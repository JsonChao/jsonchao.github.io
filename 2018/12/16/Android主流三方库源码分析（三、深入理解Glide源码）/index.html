<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android主流三方库源码分析," />





  <link rel="alternate" href="/rss2.xml" title="Deep into Android" type="application/atom+xml" />






<meta name="description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看Android主流三方库源码分析（一、深入理解OKHttp源码）和Android主流三方库源码分析（二、深入理解Retrofit源码）">
<meta name="keywords" content="Android主流三方库源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Android主流三方库源码分析（三、深入理解Glide源码）">
<meta property="og:url" content="http://yoursite.com/2018/12/16/Android主流三方库源码分析（三、深入理解Glide源码）/index.html">
<meta property="og:site_name" content="Deep into Android">
<meta property="og:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看Android主流三方库源码分析（一、深入理解OKHttp源码）和Android主流三方库源码分析（二、深入理解Retrofit源码）">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Glide%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_with%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_load%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png">
<meta property="og:updated_time" content="2019-03-06T13:28:47.725Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android主流三方库源码分析（三、深入理解Glide源码）">
<meta name="twitter:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看Android主流三方库源码分析（一、深入理解OKHttp源码）和Android主流三方库源码分析（二、深入理解Retrofit源码）">
<meta name="twitter:image" content="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Glide%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '2JGM8QNUKR',
      apiKey: 'ad3d08277d479825f7ef759beadbce0d',
      indexName: 'dicovery',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/12/16/Android主流三方库源码分析（三、深入理解Glide源码）/"/>





  <title>Android主流三方库源码分析（三、深入理解Glide源码） | Deep into Android</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deep into Android</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/16/Android主流三方库源码分析（三、深入理解Glide源码）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JsonChao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep into Android">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android主流三方库源码分析（三、深入理解Glide源码）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-12-16T20:19:00+08:00">
                2018-12-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓主流三方库源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">安卓主流三方库源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/12/16/Android主流三方库源码分析（三、深入理解Glide源码）/" class="leancloud_visitors" data-flag-title="Android主流三方库源码分析（三、深入理解Glide源码）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>。本篇，我们将会来深入地分析下目前Android使用最广泛的图片加载框架框架Glide的源码加载流程。</p>
<h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><p>Glide最基本的使用流程就是下面这行代码，其它所有扩展的额外功能都是以其建造者链式调用的基础上增加的。</p>
<pre><code>GlideApp.with(context).load(url).into(iv);
</code></pre><p>其中的GlideApp是注解处理器自动生成的，要使用GlideApp，必须先配置应用的AppGlideModule模块，里面可以为空配置，也可以根据实际情况添加指定配置。</p>
<pre><code>@GlideModule
public class MyAppGlideModule extends AppGlideModule {

    @Override
    public void applyOptions(Context context, GlideBuilder builder) {
        // 实际使用中根据情况可以添加如下配置
        &lt;!--builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));--&gt;
        &lt;!--int memoryCacheSizeBytes = 1024 * 1024 * 20;--&gt;
        &lt;!--builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));--&gt;
        &lt;!--int bitmapPoolSizeBytes = 1024 * 1024 * 30;--&gt;
        &lt;!--builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));--&gt;
        &lt;!--int diskCacheSizeBytes = 1024 * 1024 * 100;--&gt;
        &lt;!--builder.setDiskCache(new InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));--&gt;
    }
}
</code></pre><p>接下来，本文将针对Glide的最新源码版本V4.8.0对Glide加载网络图片的流程进行详细地分析与讲解，力争做到让读者朋友们知其然也知其所以然。</p>
<h3 id="二、GlideApp-with-context-源码详解"><a href="#二、GlideApp-with-context-源码详解" class="headerlink" title="二、GlideApp.with(context)源码详解"></a>二、GlideApp.with(context)源码详解</h3><p>首先，用<strong>艽野尘梦</strong>绘制的这份Glide框架图让我们对Glide的总体框架有一个初步的了解。</p>
<p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Glide%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg" alt="image"></p>
<p>从GlideApp.with这行代码开始，内部主线执行流程如下。</p>
<h4 id="1、GlideApp-with"><a href="#1、GlideApp-with" class="headerlink" title="1、GlideApp#with"></a>1、GlideApp#with</h4><pre><code>return (GlideRequests) Glide.with(context);
</code></pre><h4 id="2、Glide-with"><a href="#2、Glide-with" class="headerlink" title="2、Glide#with"></a>2、Glide#with</h4><pre><code>return getRetriever(context).get(context);

return Glide.get(context).getRequestManagerRetriever();

// 外部使用了双重检锁的同步方式确保同一时刻只执一次Glide的初始化
checkAndInitializeGlide(context);

initializeGlide(context);

// 最终执行到Glide的另一个重载方法
initializeGlide(context, new GlideBuilder());

@SuppressWarnings(&quot;deprecation&quot;)
  private static void initializeGlide(@NonNull Context   context, @NonNull GlideBuilder builder) {
    Context applicationContext =     context.getApplicationContext();
    // 1、获取前面应用中带注解的GlideModule
    GeneratedAppGlideModule annotationGeneratedModule =     getAnnotationGeneratedGlideModules();
    // 2、如果GlideModule为空或者可配置manifest里面的标志为true，则获取manifest里面
    // 配置的GlideModule模块（manifestModules）。
    List&lt;com.bumptech.glide.module.GlideModule&gt;     manifestModules = Collections.emptyList();
    if (annotationGeneratedModule == null ||     annotationGeneratedModule.isManifestParsingEnabled(    )) {
      manifestModules = new   ManifestParser(applicationContext).parse();
    }

    ...

    RequestManagerRetriever.RequestManagerFactory     factory =
        annotationGeneratedModule != null
            ? annotationGeneratedModule.getRequestManag    erFactory() : null;
    builder.setRequestManagerFactory(factory);
    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {
      module.applyOptions(applicationContext, builder);
    }
    if (annotationGeneratedModule != null) {
      annotationGeneratedModule.applyOptions(applicatio  nContext, builder);
    }
    // 3、初始化各种配置信息
    Glide glide = builder.build(applicationContext);
    // 4、把manifestModules以及annotationGeneratedModule里面的配置信息放到builder
    // 里面（applyOptions）替换glide默认组件（registerComponents）
    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {
      module.registerComponents(applicationContext,   glide, glide.registry);
    }
    if (annotationGeneratedModule != null) {
      annotationGeneratedModule.registerComponents(appl  icationContext, glide, glide.registry);
    }
    applicationContext.registerComponentCallbacks(glide    );
    Glide.glide = glide;
}
</code></pre><h4 id="3、GlideBuilder-build"><a href="#3、GlideBuilder-build" class="headerlink" title="3、GlideBuilder#build"></a>3、GlideBuilder#build</h4><pre><code>@NonNull
  Glide build(@NonNull Context context) {
    // 创建请求图片线程池sourceExecutor
    if (sourceExecutor == null) {
      sourceExecutor =   GlideExecutor.newSourceExecutor();
    }

    // 创建硬盘缓存线程池diskCacheExecutor
    if (diskCacheExecutor == null) {
      diskCacheExecutor =   GlideExecutor.newDiskCacheExecutor();
    }

    // 创建动画线程池animationExecutor
    if (animationExecutor == null) {
      animationExecutor =   GlideExecutor.newAnimationExecutor();
    }

    if (memorySizeCalculator == null) {
      memorySizeCalculator = new   MemorySizeCalculator.Builder(context).build();
    }

    if (connectivityMonitorFactory == null) {
      connectivityMonitorFactory = new   DefaultConnectivityMonitorFactory();
    }

    if (bitmapPool == null) {
      // 依据设备的屏幕密度和尺寸设置各种pool的size
      int size =   memorySizeCalculator.getBitmapPoolSize();
      if (size &gt; 0) {
        // 创建图片线程池LruBitmapPool，缓存所有被释放的bitmap
        // 缓存策略在API大于19时，为SizeConfigStrategy，小于为AttributeStrategy。
        // 其中SizeConfigStrategy是以bitmap的size和config为key，value为bitmap的HashMap
        bitmapPool = new LruBitmapPool(size);
      } else {
        bitmapPool = new BitmapPoolAdapter();
      }
    }

    // 创建对象数组缓存池LruArrayPool，默认4M
    if (arrayPool == null) {
      arrayPool = new   LruArrayPool(memorySizeCalculator.getArrayPoolSiz  eInBytes());
    }

    // 创建LruResourceCache，内存缓存
    if (memoryCache == null) {
      memoryCache = new   LruResourceCache(memorySizeCalculator.getMemoryCa  cheSize());
    }

    if (diskCacheFactory == null) {
      diskCacheFactory = new   InternalCacheDiskCacheFactory(context);
    }

    // 创建任务和资源管理引擎（线程池，内存缓存和硬盘缓存对象）
    if (engine == null) {
      engine =
          new Engine(
              memoryCache,
              diskCacheFactory,
              diskCacheExecutor,
              sourceExecutor,
              GlideExecutor.newUnlimitedSourceExecutor(  ),
              GlideExecutor.newAnimationExecutor(),
              isActiveResourceRetentionAllowed);
    }

    RequestManagerRetriever requestManagerRetriever =
    new RequestManagerRetriever(requestManagerFactory);

    return new Glide(
        context,
        engine,
        memoryCache,
        bitmapPool,
        arrayPool,
        requestManagerRetriever,
        connectivityMonitorFactory,
        logLevel,
        defaultRequestOptions.lock(),
        defaultTransitionOptions);
}
</code></pre><h4 id="4、Glide-Glide构造方法"><a href="#4、Glide-Glide构造方法" class="headerlink" title="4、Glide#Glide构造方法"></a>4、Glide#Glide构造方法</h4><pre><code>Glide(...) {
    ...
    // 注册管理任务执行对象的类(Registry)
    // Registry是一个工厂，而其中所有注册的对象都是一个工厂员工，当任务分发时，
    // 根据当前任务的性质，分发给相应员工进行处理
    registry = new Registry();

    ...

    // 这里大概有60余次的append或register员工组件（解析器、编解码器、工厂类、转码类等等组件）
    registry
    .append(ByteBuffer.class, new ByteBufferEncoder())
    .append(InputStream.class, new StreamEncoder(arrayPool))

    // 根据给定子类产出对应类型的target（BitmapImageViewTarget / DrawableImageViewTarget)
    ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();

    glideContext =
        new GlideContext(
            context,
            arrayPool,
            registry,
            imageViewTargetFactory,
            defaultRequestOptions,
            defaultTransitionOptions,
            engine,
            logLevel);
}
</code></pre><h4 id="5、RequestManagerRetriever-get"><a href="#5、RequestManagerRetriever-get" class="headerlink" title="5、RequestManagerRetriever#get"></a>5、RequestManagerRetriever#get</h4><pre><code>@NonNull
public RequestManager get(@NonNull Context context) {
  if (context == null) {
    throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);
  } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {
    // 如果当前线程是主线程且context不是Application走相应的get重载方法
    if (context instanceof FragmentActivity) {
      return get((FragmentActivity) context);
    } else if (context instanceof Activity) {
      return get((Activity) context);
    } else if (context instanceof ContextWrapper) {
      return get(((ContextWrapper) context).getBaseContext());
    }
  }

  // 否则直接将请求与ApplicationLifecycle关联
  return getApplicationManager(context);
}
</code></pre><p>这里总结一下，对于当前传入的context是application或当前线程是子线程时，请求的生命周期和ApplicationLifecycle关联，否则，context是FragmentActivity或Fragment时，在当前组件添加一个SupportFragment（SupportRequestManagerFragment），context是Activity时，在当前组件添加一个Fragment(RequestManagerFragment)。</p>
<h4 id="6、GlideApp-with小结"><a href="#6、GlideApp-with小结" class="headerlink" title="6、GlideApp#with小结"></a>6、GlideApp#with小结</h4><h5 id="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"><a href="#1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，" class="headerlink" title="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"></a>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，</h5><h5 id="2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。"><a href="#2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。" class="headerlink" title="2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。"></a>2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。</h5><h5 id="这里我们再回顾一下with方法的执行流程。"><a href="#这里我们再回顾一下with方法的执行流程。" class="headerlink" title="这里我们再回顾一下with方法的执行流程。"></a>这里我们再回顾一下with方法的执行流程。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_with%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<h3 id="三、load-url-源码详解"><a href="#三、load-url-源码详解" class="headerlink" title="三、load(url)源码详解"></a>三、load(url)源码详解</h3><h4 id="1、GlideRequest-RequestManager-load"><a href="#1、GlideRequest-RequestManager-load" class="headerlink" title="1、GlideRequest(RequestManager)#load"></a>1、GlideRequest(RequestManager)#load</h4><pre><code>return (GlideRequest&lt;Drawable&gt;) super.load(string);

return asDrawable().load(string);

// 1、asDrawable部分
return (GlideRequest&lt;Drawable&gt;) super.asDrawable();

return as(Drawable.class);

// 最终返回了一个GlideRequest（RequestManager的子类）
return new GlideRequest&lt;&gt;(glide, this, resourceClass, context);

// 2、load部分
return (GlideRequest&lt;TranscodeType&gt;) super.load(string);

return loadGeneric(string);

@NonNull
private RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) {
    // model则为设置的url
    this.model = model;
    // 记录url已设置
    isModelSet = true;
    return this;
}
</code></pre><p>可以看到，load这部分的源码很简单，就是给GlideRequest（RequestManager）设置了要请求的mode（url），并记录了url已设置的状态。</p>
<h5 id="这里，我们再看看load方法的执行流程。"><a href="#这里，我们再看看load方法的执行流程。" class="headerlink" title="这里，我们再看看load方法的执行流程。"></a>这里，我们再看看load方法的执行流程。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_load%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<h3 id="四、into-iv-源码详解"><a href="#四、into-iv-源码详解" class="headerlink" title="四、into(iv)源码详解"></a>四、into(iv)源码详解</h3><p>前方预警，真正复杂的地方开始了。</p>
<h4 id="1、RequestBuilder-into"><a href="#1、RequestBuilder-into" class="headerlink" title="1、RequestBuilder.into"></a>1、RequestBuilder.into</h4><pre><code> @NonNull
public ViewTarget&lt;ImageView, TranscodeType&gt;   into(@NonNull ImageView view) {
  Util.assertMainThread();
  Preconditions.checkNotNull(view);

  RequestOptions requestOptions =     this.requestOptions;
  if (!requestOptions.isTransformationSet()
      &amp;&amp; requestOptions.isTransformationAllowed()
      &amp;&amp; view.getScaleType() != null) {
    // Clone in this method so that if we use this   RequestBuilder to load into a View and then
    // into a different target, we don&apos;t retain the   transformation applied based on the previous
    // View&apos;s scale type.
    switch (view.getScaleType()) {
      // 这个RequestOptions里保存了要设置的scaleType，Glide自身封装了CenterCrop、CenterInside、
      // FitCenter、CenterInside四种规格。
      case CENTER_CROP:
        requestOptions =   requestOptions.clone().optionalCenterCrop();
        break;
      case CENTER_INSIDE:
        requestOptions =   requestOptions.clone().optionalCenterInside()  ;
        break;
      case FIT_CENTER:
      case FIT_START:
      case FIT_END:
        requestOptions =   requestOptions.clone().optionalFitCenter();
        break;
      case FIT_XY:
        requestOptions =   requestOptions.clone().optionalCenterInside()  ;
        break;
      case CENTER:
      case MATRIX:
      default:
        // Do nothing.
    }
  }

  // 注意，这个transcodeClass是指的drawable或bitmap
  return into(
      glideContext.buildImageViewTarget(view,     transcodeClass),
      /*targetListener=*/ null,
      requestOptions);
}
</code></pre><h4 id="2、GlideContext-buildImageViewTarget"><a href="#2、GlideContext-buildImageViewTarget" class="headerlink" title="2、GlideContext#buildImageViewTarget"></a>2、GlideContext#buildImageViewTarget</h4><pre><code>return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
</code></pre><h4 id="3、ImageViewTargetFactory-buildTarget"><a href="#3、ImageViewTargetFactory-buildTarget" class="headerlink" title="3、ImageViewTargetFactory#buildTarget"></a>3、ImageViewTargetFactory#buildTarget</h4><pre><code>@NonNull
@SuppressWarnings(&quot;unchecked&quot;)
public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt;   buildTarget(@NonNull ImageView view,
    @NonNull Class&lt;Z&gt; clazz) {
  // 返回展示Bimtap/Drawable资源的目标对象
  if (Bitmap.class.equals(clazz)) {
    return (ViewTarget&lt;ImageView, Z&gt;) new   BitmapImageViewTarget(view);
  } else if (Drawable.class.isAssignableFrom(clazz))     {
    return (ViewTarget&lt;ImageView, Z&gt;) new   DrawableImageViewTarget(view);
  } else {
    throw new IllegalArgumentException(
        &quot;Unhandled class: &quot; + clazz + &quot;, try   .as*(Class).transcode(ResourceTranscoder)&quot;);
  }
}
</code></pre><p>可以看到，Glide内部只维护了两种target，一种是BitmapImageViewTarget，另一种则是DrawableImageViewTarget，接下来继续深入。</p>
<h4 id="4、RequestBuilder-into"><a href="#4、RequestBuilder-into" class="headerlink" title="4、RequestBuilder#into"></a>4、RequestBuilder#into</h4><pre><code>private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(
      @NonNull Y target,
      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,
      @NonNull RequestOptions options) {
    Util.assertMainThread();
    Preconditions.checkNotNull(target);
    if (!isModelSet) {
      throw new IllegalArgumentException(&quot;You must call   #load() before calling #into()&quot;);
    }

    options = options.autoClone();
    // 分析1.建立请求
    Request request = buildRequest(target,     targetListener, options);

    Request previous = target.getRequest();
    if (request.isEquivalentTo(previous)
        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousReques    t(options, previous)) {
      request.recycle();
      // If the request is completed, beginning again   will ensure the result is re-delivered,
      // triggering RequestListeners and Targets. If   the request is failed, beginning again will
      // restart the request, giving it another chance   to complete. If the request is already
      // running, we can let it continue running   without interruption.
      if (!Preconditions.checkNotNull(previous).isRunni  ng()) {
        // Use the previous request rather than the new     one to allow for optimizations like skipping
        // setting placeholders, tracking and     un-tracking Targets, and obtaining View     dimensions
        // that are done in the individual Request.
        previous.begin();
      }
      return target;
    }

    requestManager.clear(target);
    target.setRequest(request);
    // 分析2.真正追踪请求的地方
    requestManager.track(target, request);

    return target;
}

// 分析1
private Request buildRequest(
      Target&lt;TranscodeType&gt; target,
      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,
      RequestOptions requestOptions) {
    return buildRequestRecursive(
        target,
        targetListener,
        /*parentCoordinator=*/ null,
        transitionOptions,
        requestOptions.getPriority(),
        requestOptions.getOverrideWidth(),
        requestOptions.getOverrideHeight(),
        requestOptions);
}

// 分析1
private Request buildRequestRecursive(
      Target&lt;TranscodeType&gt; target,
      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,
      @Nullable RequestCoordinator parentCoordinator,
      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,
      Priority priority,
      int overrideWidth,
      int overrideHeight,
      RequestOptions requestOptions) {

    // Build the ErrorRequestCoordinator first if     necessary so we can update parentCoordinator.
    ErrorRequestCoordinator errorRequestCoordinator =     null;
    if (errorBuilder != null) {
      // 创建errorRequestCoordinator（异常处理对象）
      errorRequestCoordinator = new   ErrorRequestCoordinator(parentCoordinator);
      parentCoordinator = errorRequestCoordinator;
    }

    // 递归建立缩略图请求
    Request mainRequest =
        buildThumbnailRequestRecursive(
            target,
            targetListener,
            parentCoordinator,
            transitionOptions,
            priority,
            overrideWidth,
            overrideHeight,
            requestOptions);

    if (errorRequestCoordinator == null) {
      return mainRequest;
    }

    ...

    Request errorRequest =     errorBuilder.buildRequestRecursive(
        target,
        targetListener,
        errorRequestCoordinator,
        errorBuilder.transitionOptions,
        errorBuilder.requestOptions.getPriority(),
        errorOverrideWidth,
        errorOverrideHeight,
        errorBuilder.requestOptions);
    errorRequestCoordinator.setRequests(mainRequest,     errorRequest);
    return errorRequestCoordinator;
}

// 分析1
private Request buildThumbnailRequestRecursive(
      Target&lt;TranscodeType&gt; target,
      RequestListener&lt;TranscodeType&gt; targetListener,
      @Nullable RequestCoordinator parentCoordinator,
      TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions,
      Priority priority,
      int overrideWidth,
      int overrideHeight,
      RequestOptions requestOptions) {
    if (thumbnailBuilder != null) {
      // Recursive case: contains a potentially recursive thumbnail request builder.

      ...

      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
      // 获取一个正常请求对象
      Request fullRequest =
          obtainRequest(
              target,
              targetListener,
              requestOptions,
              coordinator,
              transitionOptions,
              priority,
              overrideWidth,
              overrideHeight);
      isThumbnailBuilt = true;
      // Recursively generate thumbnail requests.
      // 使用递归的方式建立一个缩略图请求对象
      Request thumbRequest =
          thumbnailBuilder.buildRequestRecursive(
              target,
              targetListener,
              coordinator,
              thumbTransitionOptions,
              thumbPriority,
              thumbOverrideWidth,
              thumbOverrideHeight,
              thumbnailBuilder.requestOptions);
      isThumbnailBuilt = false;
      // coordinator（ThumbnailRequestCoordinator）是作为两者的协调者，
      // 能够同时加载缩略图和正常的图的请求
      coordinator.setRequests(fullRequest, thumbRequest);
      return coordinator;
    } else if (thumbSizeMultiplier != null) {
      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.
      // 当设置了缩略的比例thumbSizeMultiplier(0 ~  1)时，
      // 不需要递归建立缩略图请求
      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);
      Request fullRequest =
          obtainRequest(
              target,
              targetListener,
              requestOptions,
              coordinator,
              transitionOptions,
              priority,
              overrideWidth,
              overrideHeight);
      RequestOptions thumbnailOptions = requestOptions.clone()
          .sizeMultiplier(thumbSizeMultiplier);

      Request thumbnailRequest =
          obtainRequest(
              target,
              targetListener,
              thumbnailOptions,
              coordinator,
              transitionOptions,
              getThumbnailPriority(priority),
              overrideWidth,
              overrideHeight);

      coordinator.setRequests(fullRequest, thumbnailRequest);
      return coordinator;
    } else {
      // Base case: no thumbnail.
      // 没有缩略图请求时，直接获取一个正常图请求
      return obtainRequest(
          target,
          targetListener,
          requestOptions,
          parentCoordinator,
          transitionOptions,
          priority,
          overrideWidth,
          overrideHeight);
    }
}

private Request obtainRequest(
      Target&lt;TranscodeType&gt; target,
      RequestListener&lt;TranscodeType&gt; targetListener,
      RequestOptions requestOptions,
      RequestCoordinator requestCoordinator,
      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,
      Priority priority,
      int overrideWidth,
      int overrideHeight) {
    // 最终实际返回的是一个SingleRequest对象（将制定的资源加载进对应的Target
    return SingleRequest.obtain(
        context,
        glideContext,
        model,
        transcodeClass,
        requestOptions,
        overrideWidth,
        overrideHeight,
        priority,
        target,
        targetListener,
        requestListeners,
        requestCoordinator,
        glideContext.getEngine(),
        transitionOptions.getTransitionFactory());
}
</code></pre><p>从上源码分析可知，我们在分析1处的buildRequest()方法里建立了请求，且最多可同时进行缩略图和正常图的请求，最后，调用了requestManager.track(target, request)方法，接着看看track里面做了什么。</p>
<h4 id="5、RequestManager-track"><a href="#5、RequestManager-track" class="headerlink" title="5、RequestManager#track"></a>5、RequestManager#track</h4><pre><code>// 分析2
void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) {
    // 加入一个target目标集合(Set)
    targetTracker.track(target);

    requestTracker.runRequest(request);
}
</code></pre><h4 id="6、RequestTracker-runRequest"><a href="#6、RequestTracker-runRequest" class="headerlink" title="6、RequestTracker#runRequest"></a>6、RequestTracker#runRequest</h4><pre><code>/**
* Starts tracking the given request.
*/
// 分析2
public void runRequest(@NonNull Request request) {
    requests.add(request);
    if (!isPaused) {
      // 如果不是暂停状态则开始请求
      request.begin();
    } else {
      request.clear();
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, &quot;Paused, delaying request&quot;);
      }
      // 否则清空请求，加入延迟请求队列（为了对这些请求维持一个强引用，使用了ArrayList实现）
      pendingRequests.add(request);
    }
}
</code></pre><h4 id="7、SingleRequest-begin"><a href="#7、SingleRequest-begin" class="headerlink" title="7、SingleRequest#begin"></a>7、SingleRequest#begin</h4><pre><code>// 分析2
@Override
public void begin() {

  ...

  if (model == null) {

    ...
    // model（url）为空，回调加载失败
    onLoadFailed(new GlideException(&quot;Received null   model&quot;), logLevel);
    return;
  }

  if (status == Status.RUNNING) {
    throw new IllegalArgumentException(&quot;Cannot   restart a running request&quot;);
  }


  if (status == Status.COMPLETE) {
    onResourceReady(resource,   DataSource.MEMORY_CACHE);
    return;
  }

  status = Status.WAITING_FOR_SIZE;
  if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
    // 当使用override() API为图片指定了一个固定的宽高时直接执行onSizeReady，
    // 最终的核心处理位于onSizeReady
    onSizeReady(overrideWidth, overrideHeight);
  } else {
    // 根据imageView的宽高算出图片的宽高，最终也会走到onSizeReady
    target.getSize(this);
  }

  if ((status == Status.RUNNING || status ==     Status.WAITING_FOR_SIZE)
      &amp;&amp; canNotifyStatusChanged()) {
    // 预先加载设置的缩略图
    target.onLoadStarted(getPlaceholderDrawable());
  }
  if (IS_VERBOSE_LOGGABLE) {
    logV(&quot;finished run method in &quot; +   LogTime.getElapsedMillis(startTime));
  }
}
</code></pre><p>从requestManager.track(target, request)开始，最终会执行到SingleRequest#begin()方法的onSizeReady，可以猜到（因为后面只做了预加载缩略图的处理），真正的请求就是从这里开始的，咱们进去一探究竟~</p>
<h4 id="8、SingleRequest-onSizeReady"><a href="#8、SingleRequest-onSizeReady" class="headerlink" title="8、SingleRequest#onSizeReady"></a>8、SingleRequest#onSizeReady</h4><pre><code>// 分析2
@Override
public void onSizeReady(int width, int height) {
  stateVerifier.throwIfRecycled();

  ...

  status = Status.RUNNING;

  float sizeMultiplier =     requestOptions.getSizeMultiplier();
  this.width = maybeApplySizeMultiplier(width,     sizeMultiplier);
  this.height = maybeApplySizeMultiplier(height,     sizeMultiplier);

  ...

  // 根据给定的配置进行加载，engine是一个负责加载、管理活跃和缓存资源的引擎类
  loadStatus = engine.load(
      glideContext,
      model,
      requestOptions.getSignature(),
      this.width,
      this.height,
      requestOptions.getResourceClass(),
      transcodeClass,
      priority,
      requestOptions.getDiskCacheStrategy(),
      requestOptions.getTransformations(),
      requestOptions.isTransformationRequired(),
      requestOptions.isScaleOnlyOrNoTransform(),
      requestOptions.getOptions(),
      requestOptions.isMemoryCacheable(),
      requestOptions.getUseUnlimitedSourceGeneratorsP    ool(),
      requestOptions.getUseAnimationPool(),
      requestOptions.getOnlyRetrieveFromCache(),
      this);

  ...
}
</code></pre><p>终于看到Engine类了，感觉距离成功不远了，继续~</p>
<h4 id="9、Engine-load"><a href="#9、Engine-load" class="headerlink" title="9、Engine#load"></a>9、Engine#load</h4><pre><code>public &lt;R&gt; LoadStatus load(
    GlideContext glideContext,
    Object model,
    Key signature,
    int width,
    int height,
    Class&lt;?&gt; resourceClass,
    Class&lt;R&gt; transcodeClass,
    Priority priority,
    DiskCacheStrategy diskCacheStrategy,
    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,
    boolean isTransformationRequired,
    boolean isScaleOnlyOrNoTransform,
    Options options,
    boolean isMemoryCacheable,
    boolean useUnlimitedSourceExecutorPool,
    boolean useAnimationPool,
    boolean onlyRetrieveFromCache,
    ResourceCallback cb) {

  ...

  // 先从弱引用中查找，如果有的话回调onResourceReady并直接返回
  EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);
  if (active != null) {
    cb.onResourceReady(active,   DataSource.MEMORY_CACHE);
    if (VERBOSE_IS_LOGGABLE) {
      logWithTimeAndKey(&quot;Loaded resource from active     resources&quot;, startTime, key);
    }
    return null;
  }

  // 没有再从内存中查找,有的话会取出并放到ActiveResources（内部维护的弱引用缓存map）里面
  EngineResource&lt;?&gt; cached = loadFromCache(key,     isMemoryCacheable);
  if (cached != null) {
    cb.onResourceReady(cached,   DataSource.MEMORY_CACHE);
    if (VERBOSE_IS_LOGGABLE) {
      logWithTimeAndKey(&quot;Loaded resource from cache&quot;,     startTime, key);
    }
    return null;
  }

  EngineJob&lt;?&gt; current = jobs.get(key,     onlyRetrieveFromCache);
  if (current != null) {
    current.addCallback(cb);
    if (VERBOSE_IS_LOGGABLE) {
      logWithTimeAndKey(&quot;Added to existing load&quot;,     startTime, key);
    }
    return new LoadStatus(cb, current);
  }

  // 如果内存中没有，则创建engineJob（decodejob的回调类，管理下载过程以及状态）
  EngineJob&lt;R&gt; engineJob =
      engineJobFactory.build(
          key,
          isMemoryCacheable,
          useUnlimitedSourceExecutorPool,
          useAnimationPool,
          onlyRetrieveFromCache);

  // 创建解析工作对象
  DecodeJob&lt;R&gt; decodeJob =
      decodeJobFactory.build(
          glideContext,
          model,
          key,
          signature,
          width,
          height,
          resourceClass,
          transcodeClass,
          priority,
          diskCacheStrategy,
          transformations,
          isTransformationRequired,
          isScaleOnlyOrNoTransform,
          onlyRetrieveFromCache,
          options,
          engineJob);

  // 放在Jobs内部维护的HashMap中
  jobs.put(key, engineJob);

  // 关注点8 后面分析会用到
  // 注册ResourceCallback接口
  engineJob.addCallback(cb);
  // 内部开启线程去请求
  engineJob.start(decodeJob);

  if (VERBOSE_IS_LOGGABLE) {
    logWithTimeAndKey(&quot;Started new load&quot;, startTime,   key);
  }
  return new LoadStatus(cb, engineJob);
}

public void start(DecodeJob&lt;R&gt; decodeJob) {
    this.decodeJob = decodeJob;
    // willDecodeFromCache方法内部根据不同的阶段stage，如果是RESOURCE_CACHE/DATA_CACHE则返回true，使用diskCacheExecutor，否则调用getActiveSourceExecutor，内部会根据相应的条件返回sourceUnlimitedExecutor/animationExecutor/sourceExecutor
    GlideExecutor executor =   
    decodeJob.willDecodeFromCache()
        ? diskCacheExecutor
        : getActiveSourceExecutor();
    executor.execute(decodeJob);
}
</code></pre><p>可以看到，最终Engine(引擎)类内部会执行到自身的start方法，它会根据不同的配置采用不同的线程池使用diskCacheExecutor/sourceUnlimitedExecutor/animationExecutor/sourceExecutor来执行最终的解码任务decodeJob。</p>
<h4 id="10、DecodeJob-run"><a href="#10、DecodeJob-run" class="headerlink" title="10、DecodeJob#run"></a>10、DecodeJob#run</h4><pre><code>runWrapped();

private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        // 关注点1
        currentGenerator = getNextGenerator();
        // 关注点2 内部会调用相应Generator的startNext()
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        // 关注点3 将获取的数据解码成对应的资源
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException(&quot;Unrecognized     run reason: &quot; + runReason);
    }
}

// 关注点1，完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext()
private DataFetcherGenerator getNextGenerator() {
    switch (stage) {
      case RESOURCE_CACHE:
        return new ResourceCacheGenerator(decodeHelper, this);
      case DATA_CACHE:
        return new DataCacheGenerator(decodeHelper, this);
      case SOURCE:
        return new SourceGenerator(decodeHelper, this);
      case FINISHED:
        return null;
      default:
        throw new IllegalStateException(&quot;Unrecognized     stage: &quot; + stage);
    }
}
</code></pre><h4 id="11、SourceGenerator-startNext"><a href="#11、SourceGenerator-startNext" class="headerlink" title="11、SourceGenerator#startNext"></a>11、SourceGenerator#startNext</h4><pre><code>// 关注点2
@Override
public boolean startNext() {
  // dataToCache数据不为空的话缓存到硬盘（第一执行该方法是不会调用的）
  if (dataToCache != null) {
    Object data = dataToCache;
    dataToCache = null;
    cacheData(data);
  }

  if (sourceCacheGenerator != null &amp;&amp;     sourceCacheGenerator.startNext()) {
    return true;
  }
  sourceCacheGenerator = null;

  loadData = null;
  boolean started = false;
  while (!started &amp;&amp; hasNextModelLoader()) {
    // 关注点4 getLoadData()方法内部会在modelLoaders里面找到ModelLoder对象
    // （每个Generator对应一个ModelLoader），
    // 并使用modelLoader.buildLoadData方法返回一个loadData列表
    loadData =   helper.getLoadData().get(loadDataListIndex++);
    if (loadData != null
        &amp;&amp; (helper.getDiskCacheStrategy().isDataCache  able(loadData.fetcher.getDataSource())
        || helper.hasLoadPath(loadData.fetcher.getDat  aClass()))) {
      started = true;
      // 关注点6 通过loadData对象的fetcher对象（有关注点3的分析可知其实现类为HttpUrlFetcher）的
      // loadData方法来获取图片数据
      loadData.fetcher.loadData(helper.getPriority(),     this);
    }
  }
  return started;
}
</code></pre><h4 id="12、DecodeHelper-getLoadData"><a href="#12、DecodeHelper-getLoadData" class="headerlink" title="12、DecodeHelper#getLoadData"></a>12、DecodeHelper#getLoadData</h4><pre><code>List&lt;LoadData&lt;?&gt;&gt; getLoadData() {
    if (!isLoadDataSet) {
      isLoadDataSet = true;
      loadData.clear();
      List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders =   glideContext.getRegistry().getModelLoaders(model)  ;
      //noinspection ForLoopReplaceableByForEach to   improve perf
      for (int i = 0, size = modelLoaders.size(); i &lt;   size; i++) {
        ModelLoader&lt;Object, ?&gt; modelLoader =     modelLoaders.get(i);
        // 注意：这里最终是通过HttpGlideUrlLoader的buildLoadData获取到实际的loadData对象
        LoadData&lt;?&gt; current =
            modelLoader.buildLoadData(model, width,     height, options);
        if (current != null) {
          loadData.add(current);
        }
      }
    }
    return loadData;
}
</code></pre><h4 id="13、HttpGlideUrlLoader-buildLoadData"><a href="#13、HttpGlideUrlLoader-buildLoadData" class="headerlink" title="13、HttpGlideUrlLoader#buildLoadData"></a>13、HttpGlideUrlLoader#buildLoadData</h4><pre><code>@Override
public LoadData&lt;InputStream&gt; buildLoadData(@NonNull   GlideUrl model, int width, int height,
    @NonNull Options options) {
  // GlideUrls memoize parsed URLs so caching them     saves a few object instantiations and time
  // spent parsing urls.
  GlideUrl url = model;
  if (modelCache != null) {
    url = modelCache.get(model, 0, 0);
    if (url == null) {
      // 关注点5
      modelCache.put(model, 0, 0, model);
      url = model;
    }
  }
  int timeout = options.get(TIMEOUT);
  // 注意，这里创建了一个DataFetcher的实现类HttpUrlFetcher
  return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url,     timeout));
}

// 关注点5
public void put(A model, int width, int height, B value) {
    ModelKey&lt;A&gt; key = ModelKey.get(model, width,     height);
    // 最终是通过LruCache来缓存对应的值，key是一个ModelKey对象（由model、width、height三个属性组成）
    cache.put(key, value);
}
</code></pre><p>从这里的分析，我们明白了HttpUrlFetcher实际上就是最终的请求执行者，而且，我们知道了Glide会使用LruCache来对解析后的url来进行缓存，以便后续可以省去解析url的时间。</p>
<h4 id="14、HttpUrlFetcher-loadData"><a href="#14、HttpUrlFetcher-loadData" class="headerlink" title="14、HttpUrlFetcher#loadData"></a>14、HttpUrlFetcher#loadData</h4><pre><code>@Override
public void loadData(@NonNull Priority priority,
    @NonNull DataCallback&lt;? super InputStream&gt;   callback) {
  long startTime = LogTime.getLogTime();
  try {
    // 关注点6
    // loadDataWithRedirects内部是通过HttpURLConnection网络请求数据
    InputStream result =   loadDataWithRedirects(glideUrl.toURL(), 0, null,   glideUrl.getHeaders());
    // 请求成功回调onDataReady()
    callback.onDataReady(result);
  } catch (IOException e) {
    if (Log.isLoggable(TAG, Log.DEBUG)) {
      Log.d(TAG, &quot;Failed to load data for url&quot;, e);
    }
    callback.onLoadFailed(e);
  } finally {
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
      Log.v(TAG, &quot;Finished http url fetcher fetch in     &quot; + LogTime.getElapsedMillis(startTime));
    }
  }
}

private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
  Map&lt;String, String&gt; headers) throws IOException {

    ...

    urlConnection.connect();
    // Set the stream so that it&apos;s closed in cleanup to avoid resource leaks. See #2352.
    stream = urlConnection.getInputStream();
    if (isCancelled) {
      return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    // 只要是2xx形式的状态码则判断为成功
    if (isHttpOk(statusCode)) {
      // 从urlConnection中获取资源流
      return getStreamForSuccessfulRequest(urlConnection);
    } else if (isHttpRedirect(statusCode)) {

      ...

      // 重定向请求
      return loadDataWithRedirects(redirectUrl, redirects + 1, url,   headers);
    } else if (statusCode == INVALID_STATUS_CODE) {
      throw new HttpException(statusCode);
    } else {
      throw new HttpException(urlConnection.getResponseMessage(),   statusCode);
    }
}

private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)
  throws IOException {
    if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {
      int contentLength = urlConnection.getContentLength();
      stream = ContentLengthInputStream.obtain(urlConnection.getInputStr  eam(), contentLength);
    } else {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, &quot;Got non empty content encoding: &quot; +     urlConnection.getContentEncoding());
      }
      stream = urlConnection.getInputStream();
    }
    return stream;
}
</code></pre><p>在HttpUrlFetcher#loadData方法的loadDataWithRedirects里面，Glide通过原生的HttpURLConnection进行请求后，并调用getStreamForSuccessfulRequest()方法获取到了最终的图片流。</p>
<h4 id="15、DecodeJob-run"><a href="#15、DecodeJob-run" class="headerlink" title="15、DecodeJob#run"></a>15、DecodeJob#run</h4><p>在我们通过HtttpUrlFetcher的loadData()方法请求得到对应的流之后，我们还必须对流进行处理得到最终我们想要的资源。这里我们回到第10步DecodeJob#run方法的关注点3处，这行代码将会对流进行解码。</p>
<pre><code>decodeFromRetrievedData();
</code></pre><p>接下来，继续看看他内部的处理。</p>
<pre><code>private void decodeFromRetrievedData() {
    if (Log.isLoggable(TAG, Log.VERBOSE)) {
      logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,
          &quot;data: &quot; + currentData
              + &quot;, cache key: &quot; + currentSourceKey
              + &quot;, fetcher: &quot; + currentFetcher);
    }
    Resource&lt;R&gt; resource = null;
    try {
      //  核心代码 
      // 从数据中解码得到资源
      resource = decodeFromData(currentFetcher, currentData,   currentDataSource);
    } catch (GlideException e) {
      e.setLoggingDetails(currentAttemptingKey, currentDataSource);
      throwables.add(e);
    }
    if (resource != null) {
      // 关注点8 
      // 编码和发布最终得到的Resource&lt;Bitmap&gt;对象
      notifyEncodeAndRelease(resource, currentDataSource);
    } else {
      runGenerators();
    }
}

 private &lt;Data&gt; Resource&lt;R&gt; decodeFromData(DataFetcher&lt;?&gt; fetcher, Data data,
  DataSource dataSource) throws GlideException {
    try {
      if (data == null) {
        return null;
      }
      long startTime = LogTime.getLogTime();
      // 核心代码
      // 进一步包装了解码方法
      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        logWithTimeAndKey(&quot;Decoded result &quot; + result, startTime);
      }
      return result;
    } finally {
      fetcher.cleanup();
    }
}

@SuppressWarnings(&quot;unchecked&quot;)
private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource)
  throws GlideException {
    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());
    // 核心代码
    // 将解码任务分发给LoadPath
    return runLoadPath(data, dataSource, path);
}

private &lt;Data, ResourceType&gt; Resource&lt;R&gt; runLoadPath(Data data, DataSource dataSource,
  LoadPath&lt;Data, ResourceType, R&gt; path) throws GlideException {
    Options options = getOptionsWithHardwareConfig(dataSource);
    // 将数据进一步包装
    DataRewinder&lt;Data&gt; rewinder =     glideContext.getRegistry().getRewinder(data);
    try {
      // ResourceType in DecodeCallback below is required for   compilation to work with gradle.
      // 核心代码
      // 将解码任务分发给LoadPath
      return path.load(
          rewinder, options, width, height, new   DecodeCallback&lt;ResourceType&gt;(dataSource));
    } finally {
      rewinder.cleanup();
    }
}
</code></pre><h4 id="16、LoadPath-load"><a href="#16、LoadPath-load" class="headerlink" title="16、LoadPath#load"></a>16、LoadPath#load</h4><pre><code>public Resource&lt;Transcode&gt; load(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, int width,
  int height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback) throws GlideException {
List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());
try {
  // 核心代码
  return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);
} finally {
  listPool.release(throwables);
}
</code></pre><p>  }</p>
<pre><code>private Resource&lt;Transcode&gt; loadWithExceptionList(DataRewinder&lt;Data&gt; rewinder,
      @NonNull Options options,
      int width, int height, DecodePath.DecodeCallback&lt;ResourceType&gt;   decodeCallback,
      List&lt;Throwable&gt; exceptions) throws GlideException {
    Resource&lt;Transcode&gt; result = null;
    //noinspection ForLoopReplaceableByForEach to improve perf
    for (int i = 0, size = decodePaths.size(); i &lt; size; i++) {
      DecodePath&lt;Data, ResourceType, Transcode&gt; path =   decodePaths.get(i);
      try {
        // 核心代码
        // 将解码任务又进一步分发给DecodePath的decode方法去解码
        result = path.decode(rewinder, width, height, options,     decodeCallback);
      } catch (GlideException e) {
        exceptions.add(e);
      }
      if (result != null) {
        break;
      }
    }

    if (result == null) {
      throw new GlideException(failureMessage, new   ArrayList&lt;&gt;(exceptions));
    }

    return result;
}
</code></pre><h4 id="17、DecodePath-decode"><a href="#17、DecodePath-decode" class="headerlink" title="17、DecodePath#decode"></a>17、DecodePath#decode</h4><pre><code>public Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder,     int width, int height,
      @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)   throws GlideException {
    // 核心代码
    // 继续调用DecodePath的decodeResource方法去解析出数据
    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width,     height, options);
    Resource&lt;ResourceType&gt; transformed =     callback.onResourceDecoded(decoded);
    return transcoder.transcode(transformed, options);
}

@NonNull
private Resource&lt;ResourceType&gt; decodeResource(DataRewinder&lt;DataType&gt;   rewinder, int width,
    int height, @NonNull Options options) throws GlideException {
  List&lt;Throwable&gt; exceptions =     Preconditions.checkNotNull(listPool.acquire());
  try {
    // 核心代码
    return decodeResourceWithList(rewinder, width, height, options,   exceptions);
  } finally {
    listPool.release(exceptions);
  }
}

@NonNull
private Resource&lt;ResourceType&gt;   decodeResourceWithList(DataRewinder&lt;DataType&gt; rewinder, int width,
    int height, @NonNull Options options, List&lt;Throwable&gt; exceptions)   throws GlideException {
  Resource&lt;ResourceType&gt; result = null;
  //noinspection ForLoopReplaceableByForEach to improve perf
  for (int i = 0, size = decoders.size(); i &lt; size; i++) {
    ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);
    try {
      DataType data = rewinder.rewindAndGet();
      if (decoder.handles(data, options)) {
        // 获取包装的数据
        data = rewinder.rewindAndGet();
        // 核心代码 
        // 根据DataType和ResourceType的类型分发给不同的解码器Decoder
        result = decoder.decode(data, width, height, options);
      }
    } catch (IOException | RuntimeException | OutOfMemoryError e) {
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, &quot;Failed to decode data for &quot; + decoder, e);
      }
      exceptions.add(e);
    }

    if (result != null) {
      break;
    }
  }

  if (result == null) {
    throw new GlideException(failureMessage, new   ArrayList&lt;&gt;(exceptions));
  }
  return result;
}
</code></pre><p>可以看到，经过一连串的嵌套调用，最终执行到了decoder.decode()这行代码，decode是一个ResourceDecoder<datatype, resourcetype="">接口（资源解码器），根据不同的DataType和ResourceType它会有不同的实现类，这里的实现类是ByteBufferBitmapDecoder，接下来让我们来看看这个解码器内部的解码流程。</datatype,></p>
<h4 id="18、ByteBufferBitmapDecoder-decode"><a href="#18、ByteBufferBitmapDecoder-decode" class="headerlink" title="18、ByteBufferBitmapDecoder#decode"></a>18、ByteBufferBitmapDecoder#decode</h4><pre><code>/**
 * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link    java.nio.ByteBuffer ByteBuffers}.
 */
public class ByteBufferBitmapDecoder implements     ResourceDecoder&lt;ByteBuffer, Bitmap&gt; {

  ...

  @Override
  public Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, int width,   int height,
      @NonNull Options options)
      throws IOException {
    InputStream is = ByteBufferUtil.toStream(source);
    // 核心代码
    return downsampler.decode(is, width, height, options);
  }
}
</code></pre><p>可以看到，最终是使用了一个downsampler，它是一个压缩器，主要是对流进行解码，压缩，圆角等处理。</p>
<h4 id="19、DownSampler-decode"><a href="#19、DownSampler-decode" class="headerlink" title="19、DownSampler#decode"></a>19、DownSampler#decode</h4><pre><code>public Resource&lt;Bitmap&gt; decode(InputStream is, int outWidth, int outHeight,
  Options options) throws IOException {
    return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);
}

 @SuppressWarnings({&quot;resource&quot;, &quot;deprecation&quot;})
public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight,
      Options options, DecodeCallbacks callbacks) throws IOException {
    Preconditions.checkArgument(is.markSupported(), &quot;You must provide an     InputStream that supports&quot;
        + &quot; mark()&quot;);

    ...

    try {
      // 核心代码
      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,
          downsampleStrategy, decodeFormat, isHardwareConfigAllowed,   requestedWidth,
          requestedHeight, fixBitmapToRequestedDimensions, callbacks);
      // 关注点7   
      // 解码得到Bitmap对象后，包装成BitmapResource对象返回，
      // 通过内部的get方法得到Resource&lt;Bitmap&gt;对象
      return BitmapResource.obtain(result, bitmapPool);
    } finally {
      releaseOptions(bitmapFactoryOptions);
      byteArrayPool.put(bytesForOptions);
    }
}

private Bitmap decodeFromWrappedStreams(InputStream is,
      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,
      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,
      int requestedHeight, boolean fixBitmapToRequestedDimensions,
      DecodeCallbacks callbacks) throws IOException {

    // 省去计算压缩比例等一系列非核心逻辑
    ...

    // 核心代码
    Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);
    callbacks.onDecodeComplete(bitmapPool, downsampled);

    ...

    // Bimtap旋转处理
    ...

    return rotated;
}

private static Bitmap decodeStream(InputStream is,     BitmapFactory.Options options,
      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws   IOException {

    ...

    TransformationUtils.getBitmapDrawableLock().lock();
    try {
      // 核心代码
      result = BitmapFactory.decodeStream(is, null, options);
    } catch (IllegalArgumentException e) {
      ...
    } finally {
      TransformationUtils.getBitmapDrawableLock().unlock();
    }

    if (options.inJustDecodeBounds) {
      is.reset();
    }
    return result;
}
</code></pre><p>从以上源码流程我们知道，最后是在DownSampler的decodeStream()方法中使用了BitmapFactory.decodeStream()来得到Bitmap对象。然后，我们来分析下图片时如何显示的，我们回到步骤19的DownSampler#decode方法，看到关注点7，这里是将Bitmap包装成BitmapResource对象返回，通过内部的get方法可以得到Resource<bitmap>对象，再回到步骤15的DecodeJob#run方法，这是使用了notifyEncodeAndRelease()方法对Resource<bitmap>对象进行了发布。</bitmap></bitmap></p>
<h4 id="20、DecodeJob-notifyEncodeAndRelease"><a href="#20、DecodeJob-notifyEncodeAndRelease" class="headerlink" title="20、DecodeJob#notifyEncodeAndRelease"></a>20、DecodeJob#notifyEncodeAndRelease</h4><pre><code>private void notifyEncodeAndRelease(Resource&lt;R&gt; resource, DataSource     dataSource) {

    ...

    notifyComplete(result, dataSource);

    ...

}

private void notifyComplete(Resource&lt;R&gt; resource, DataSource     dataSource) {
    setNotifiedOrThrow();
    callback.onResourceReady(resource, dataSource);
}
</code></pre><p>从以上EngineJob的源码可知，它实现了DecodeJob.CallBack<r>这个接口。</r></p>
<pre><code>class EngineJob&lt;R&gt; implements DecodeJob.Callback&lt;R&gt;,
    Poolable {
    ...
}
</code></pre><h4 id="21、EngineJob-onResourceReady"><a href="#21、EngineJob-onResourceReady" class="headerlink" title="21、EngineJob#onResourceReady"></a>21、EngineJob#onResourceReady</h4><pre><code>@Override
public void onResourceReady(Resource&lt;R&gt; resource, DataSource   dataSource) {
  this.resource = resource;
  this.dataSource = dataSource;
  MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();
}

private static class MainThreadCallback implements Handler.Callback{

    ...

    @Override
    public boolean handleMessage(Message message) {
      EngineJob&lt;?&gt; job = (EngineJob&lt;?&gt;) message.obj;
      switch (message.what) {
        case MSG_COMPLETE:
          // 核心代码
          job.handleResultOnMainThread();
          break;
        ...
      }
      return true;
    }
}
</code></pre><p>从以上源码可知，通过主线程Handler对象进行切换线程，然后在主线程调用了handleResultOnMainThread这个方法。</p>
<pre><code>@Synthetic
void handleResultOnMainThread() {
  ...

  //noinspection ForLoopReplaceableByForEach to improve perf
  for (int i = 0, size = cbs.size(); i &lt; size; i++) {
    ResourceCallback cb = cbs.get(i);
    if (!isInIgnoredCallbacks(cb)) {
      engineResource.acquire();
      cb.onResourceReady(engineResource, dataSource);
    }
  }

  ...
}
</code></pre><p>这里又通过一个循环调用了所有ResourceCallback的方法，让我们回到步骤9处Engine#load方法的关注点8这行代码，这里对ResourceCallback进行了注册，在步骤8出SingleRequest#onSizeReady方法里的engine.load中，我们看到最后一个参数，传入的是this，可以明白，engineJob.addCallback(cb)这里的cb的实现类就是SingleRequest。接下来，让我们看看SingleRequest的onResourceReady方法。</p>
<h4 id="22、SingleRequest-onResourceReady"><a href="#22、SingleRequest-onResourceReady" class="headerlink" title="22、SingleRequest#onResourceReady"></a>22、SingleRequest#onResourceReady</h4><pre><code>/**
 * A callback method that should never be invoked directly.
 */
@SuppressWarnings(&quot;unchecked&quot;)
@Override
public void onResourceReady(Resource&lt;?&gt; resource, DataSource   dataSource) {
  ...

  // 从Resource&lt;Bitmap&gt;中得到Bitmap对象
  Object received = resource.get();

  ...

  onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);
}

private void onResourceReady(Resource&lt;R&gt; resource, R resultDataSource dataSource) {

    ...

    try {
      ...

      if (!anyListenerHandledUpdatingTarget) {
        Transition&lt;? super R&gt; animation =
            animationFactory.build(dataSource, isFirstResource);
        // 核心代码
        target.onResourceReady(result, animation);
      }
    } finally {
      isCallingCallbacks = false;
    }

    notifyLoadSuccess();
}
</code></pre><p>在SingleRequest#onResourceReady方法中又调用了target.onResourceReady(result, animation)方法，这里的target其实就是我们在into方法中建立的那个BitmapImageViewTarget，看到ImageViewTarget类，我们并没有发现onResourceReady方法，但是我们从它的子类ImageViewTarget中发现了onResourceReady方法，从这里我们继续往下看。</p>
<h4 id="23、ImageViewTarget-onResourceReady"><a href="#23、ImageViewTarget-onResourceReady" class="headerlink" title="23、ImageViewTarget#onResourceReady"></a>23、ImageViewTarget#onResourceReady</h4><pre><code>public abstract class ImageViewTarget&lt;Z&gt; extends ViewTarget&lt;ImageView, Z&gt;
implements Transition.ViewAdapter {

    ...

    @Override
    public void onResourceReady(@NonNull Z resource, @Nullable       Transition&lt;? super Z&gt; transition) {
      if (transition == null || !transition.transition(resource, this))   {
        // 核心代码
        setResourceInternal(resource);
      } else {
        maybeUpdateAnimatable(resource);
      }
    }

    ...

    private void setResourceInternal(@Nullable Z resource) {
        // Order matters here. Set the resource first to make sure that the         Drawable has a valid and
        // non-null Callback before starting it.
        // 核心代码
        setResource(resource);
        maybeUpdateAnimatable(resource);
    }

    // 核心代码
    protected abstract void setResource(@Nullable Z resource);
}
</code></pre><p>这里我们在回到BitmapImageViewTarget的setResource方法中，我们终于看到Bitmap被设置到了当前的imageView上了。</p>
<pre><code>public class BitmapImageViewTarget extends ImageViewTarget&lt;Bitmap&gt; {

    ...


    @Override
    protected void setResource(Bitmap resource) {
      view.setImageBitmap(resource);
    }
}
</code></pre><p>到这里，我们的分析就结束了，从以上的分析可知，Glide将大部分的逻辑处理都放在了最后一个into方法中，里面经过了20多个分析步骤才将请求图片流、解码出图片，到最终设置到对应的imageView上。</p>
<h5 id="最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。"><a href="#最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。" class="headerlink" title="最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。"></a>最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>到此，Glide整个的加载流程分析就结束了，可以看到，Glide最核心的逻辑都聚集在into()方法中，它里面的设计精巧而复杂，这部分的源码分析非常耗时，但是，如果你真真正正地去一步步去深入其中，你也许在Android进阶之路上将会有顿悟的感觉。目前，Android主流三方库源码分析系列已经对网络库（OkHttp、Retrofit）和图片加载库（Glide）进行了详细的源码分析，接下来，将会对数据库框架GreenDao的核心源码进行深入的分析，敬请期待~</p>
<h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr>
<p>1、Glide V4.8.0源码</p>
<p>2、<a href="https://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="external">从源码的角度理解Glide的执行流程</a></p>
<p>3、<a href="https://zhuanlan.zhihu.com/p/37297719" target="_blank" rel="external">glide源码分析</a></p>
<h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="JsonChao Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android主流三方库源码分析/" rel="tag"># Android主流三方库源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/09/Android主流三方库源码分析（二、深入理解Retrofit源码）/" rel="next" title="Android主流三方库源码分析（二、深入理解Retrofit源码）">
                <i class="fa fa-chevron-left"></i> Android主流三方库源码分析（二、深入理解Retrofit源码）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/22/Android主流三方库源码分析（四、深入理解GreenDao源码）/" rel="prev" title="Android主流三方库源码分析（四、深入理解GreenDao源码）">
                Android主流三方库源码分析（四、深入理解GreenDao源码） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="JsonChao" />
            
              <p class="site-author-name" itemprop="name">JsonChao</p>
              <p class="site-description motion-element" itemprop="description">Persist + Plan = Growing</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JsonChao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://mail.google.com/mail/u/0/#inbox" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" title="JueJin">
                      
                        <i class="fa fa-fw fa-globe"></i>JueJin</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Manito Link
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wanandroid.com/" title="WanAndroid" target="_blank">WanAndroid</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://hencoder.com/" title="HenCoder" target="_blank">HenCoder</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://stormzhang.com/" title="stromzhang" target="_blank">stromzhang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.hensen.site/" title="Hensen" target="_blank">Hensen</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://liuwangshu.cn/" title="刘望舒" target="_blank">刘望舒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhuanlan.zhihu.com/baron/" title="张磊" target="_blank">张磊</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kymjs.com/" title="张涛" target="_blank">张涛</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.piasy.com/" title="Piasy" target="_blank">Piasy</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.lmj.wiki/" title="ANLY" target="_blank">ANLY</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://glanwang.com/" title="Glan" target="_blank">Glan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://huangjunbin.com/" title="黄俊彬" target="_blank">黄俊彬</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://droidyue.com/" title="技术小黑屋" target="_blank">技术小黑屋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://gityuan.com/" title="gityuan" target="_blank">gityuan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.gcssloop.com/#blog" title="gcsslop" target="_blank">gcsslop</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><span class="nav-number">1.0.1.</span> <span class="nav-text">成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一、基本使用流程"><span class="nav-number">1.1.</span> <span class="nav-text">一、基本使用流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、GlideApp-with-context-源码详解"><span class="nav-number">1.2.</span> <span class="nav-text">二、GlideApp.with(context)源码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、GlideApp-with"><span class="nav-number">1.2.1.</span> <span class="nav-text">1、GlideApp#with</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、Glide-with"><span class="nav-number">1.2.2.</span> <span class="nav-text">2、Glide#with</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、GlideBuilder-build"><span class="nav-number">1.2.3.</span> <span class="nav-text">3、GlideBuilder#build</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、Glide-Glide构造方法"><span class="nav-number">1.2.4.</span> <span class="nav-text">4、Glide#Glide构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、RequestManagerRetriever-get"><span class="nav-number">1.2.5.</span> <span class="nav-text">5、RequestManagerRetriever#get</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、GlideApp-with小结"><span class="nav-number">1.2.6.</span> <span class="nav-text">6、GlideApp#with小结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#这里我们再回顾一下with方法的执行流程。"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">这里我们再回顾一下with方法的执行流程。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、load-url-源码详解"><span class="nav-number">1.3.</span> <span class="nav-text">三、load(url)源码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、GlideRequest-RequestManager-load"><span class="nav-number">1.3.1.</span> <span class="nav-text">1、GlideRequest(RequestManager)#load</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#这里，我们再看看load方法的执行流程。"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">这里，我们再看看load方法的执行流程。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、into-iv-源码详解"><span class="nav-number">1.4.</span> <span class="nav-text">四、into(iv)源码详解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、RequestBuilder-into"><span class="nav-number">1.4.1.</span> <span class="nav-text">1、RequestBuilder.into</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、GlideContext-buildImageViewTarget"><span class="nav-number">1.4.2.</span> <span class="nav-text">2、GlideContext#buildImageViewTarget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、ImageViewTargetFactory-buildTarget"><span class="nav-number">1.4.3.</span> <span class="nav-text">3、ImageViewTargetFactory#buildTarget</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、RequestBuilder-into"><span class="nav-number">1.4.4.</span> <span class="nav-text">4、RequestBuilder#into</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5、RequestManager-track"><span class="nav-number">1.4.5.</span> <span class="nav-text">5、RequestManager#track</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6、RequestTracker-runRequest"><span class="nav-number">1.4.6.</span> <span class="nav-text">6、RequestTracker#runRequest</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7、SingleRequest-begin"><span class="nav-number">1.4.7.</span> <span class="nav-text">7、SingleRequest#begin</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8、SingleRequest-onSizeReady"><span class="nav-number">1.4.8.</span> <span class="nav-text">8、SingleRequest#onSizeReady</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9、Engine-load"><span class="nav-number">1.4.9.</span> <span class="nav-text">9、Engine#load</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10、DecodeJob-run"><span class="nav-number">1.4.10.</span> <span class="nav-text">10、DecodeJob#run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11、SourceGenerator-startNext"><span class="nav-number">1.4.11.</span> <span class="nav-text">11、SourceGenerator#startNext</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12、DecodeHelper-getLoadData"><span class="nav-number">1.4.12.</span> <span class="nav-text">12、DecodeHelper#getLoadData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13、HttpGlideUrlLoader-buildLoadData"><span class="nav-number">1.4.13.</span> <span class="nav-text">13、HttpGlideUrlLoader#buildLoadData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14、HttpUrlFetcher-loadData"><span class="nav-number">1.4.14.</span> <span class="nav-text">14、HttpUrlFetcher#loadData</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15、DecodeJob-run"><span class="nav-number">1.4.15.</span> <span class="nav-text">15、DecodeJob#run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16、LoadPath-load"><span class="nav-number">1.4.16.</span> <span class="nav-text">16、LoadPath#load</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17、DecodePath-decode"><span class="nav-number">1.4.17.</span> <span class="nav-text">17、DecodePath#decode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18、ByteBufferBitmapDecoder-decode"><span class="nav-number">1.4.18.</span> <span class="nav-text">18、ByteBufferBitmapDecoder#decode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19、DownSampler-decode"><span class="nav-number">1.4.19.</span> <span class="nav-text">19、DownSampler#decode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20、DecodeJob-notifyEncodeAndRelease"><span class="nav-number">1.4.20.</span> <span class="nav-text">20、DecodeJob#notifyEncodeAndRelease</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21、EngineJob-onResourceReady"><span class="nav-number">1.4.21.</span> <span class="nav-text">21、EngineJob#onResourceReady</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22、SingleRequest-onResourceReady"><span class="nav-number">1.4.22.</span> <span class="nav-text">22、SingleRequest#onResourceReady</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23、ImageViewTarget-onResourceReady"><span class="nav-number">1.4.23.</span> <span class="nav-text">23、ImageViewTarget#onResourceReady</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。"><span class="nav-number">1.4.23.1.</span> <span class="nav-text">最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、总结"><span class="nav-number">1.5.</span> <span class="nav-text">五、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#参考链接："><span class="nav-number">1.5.0.1.</span> <span class="nav-text">参考链接：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><span class="nav-number">1.5.1.</span> <span class="nav-text">很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。"><span class="nav-number">1.5.2.</span> <span class="nav-text">希望我们能成为朋友，在 Github、掘金上一起分享知识。</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JsonChao</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>







        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  
    

    
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2155025"></script>
      <!-- UY END -->
    
  





  










   
   
     
   
   
  
     
</div>
<!-- City版安装代码已完成 -->
   
 

   
     
   
  
       <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
       <script type="text/javascript">
          (function(d, s) {
              var j, e = d.getElementsByTagName(s)[0];
              if (typeof LivereTower === 'function') { return; }
              j = d.createElement(s);
              j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
              j.async = true;
              e.parentNode.insertBefore(j, e);
          })(document, 'script');
       </script>
       <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
       <!-- UY END -->
   
 
  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("2wtHdVd6zid7kU6YQKIqsHU5-gzGzoHsz", "eLibBRhSAsSoX1JbTMJH6ka3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
