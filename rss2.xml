<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Mon, 28 Jan 2019 14:50:12 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android主流三方库源码分析（九、深入理解EventBus源码）</title>
      <link>http://yoursite.com/2019/01/28/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3EventBus%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/28/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3EventBus%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 27 Jan 2019 16:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>不知不觉，Android主流三方库源码分析系列已经来到最后关头了。这一次，笔者将会对Android中的事件总线框架EventBus源码进行详细地解析，一起来和大家揭开它背后的面纱。</p><h3 id="一、简单示例"><a href="#一、简单示例" class="headerlink" title="一、简单示例"></a>一、简单示例</h3><h4 id="1、首先，定义要传递的事件实体"><a href="#1、首先，定义要传递的事件实体" class="headerlink" title="1、首先，定义要传递的事件实体"></a>1、首先，定义要传递的事件实体</h4><pre><code>public class CollectEvent { ... }</code></pre><h4 id="2、准备订阅者：声明并注解你的订阅方法"><a href="#2、准备订阅者：声明并注解你的订阅方法" class="headerlink" title="2、准备订阅者：声明并注解你的订阅方法"></a>2、准备订阅者：声明并注解你的订阅方法</h4><pre><code>@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(CollectEvent event) {    LogHelper.d(&quot;OK&quot;);}</code></pre><h4 id="3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"><a href="#3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者" class="headerlink" title="3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"></a>3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者</h4><pre><code>@Overridepublic void onStart() {    super.onStart();    EventBus.getDefault().register(this);}@Overridepublic void onStop() {    super.onStop();    EventBus.getDefault().unregister(this);}</code></pre><h4 id="4、发送事件"><a href="#4、发送事件" class="headerlink" title="4、发送事件"></a>4、发送事件</h4><pre><code>EventBus.getDefault().post(new CollectEvent());</code></pre><p>在正式讲解之前，笔者觉得需要对一些基础性的概念进行详细的讲解。众所周知，EventBus没出现之前，那时候的开发者一般是使用Android四大组件中的广播进行组件间的消息传递，那么我们<strong>为什么要使用事件总线机制来替代广播</strong>呢？主要是因为：</p><ul><li>广播：耗时、容易被捕获（不安全）。</li><li>事件总线：更节省资源、更高效，能将信息传递给原生以外的各种对象。</li></ul><p>那么，话又说回来了，<strong>事件总线又是什么呢？</strong></p><p>如下图所示，事件总线机制通过记录对象、使用观察者模式来通知对象各种事件。（当然，你也可以发送基本数据类型如 int，String 等作为一个事件）</p><p><img src="https://upload-images.jianshu.io/upload_images/2276275-c20610cdd44f4c5f.png?imageMogr2/auto-orient/" alt="image"></p><p>对于<strong>事件总线EventBus</strong>而言，它的<strong>优缺点</strong>又是如何？这里简单总结下：</p><ul><li>优点：开销小，代码更优雅、简洁，解耦发送者和接收者，可动态设置事件处理线程和优先级。</li><li>缺点：每个事件必须自定义一个事件类，增加了维护成本。</li></ul><p>EventBus是基于观察者模式扩展而来的，我们先了解一下观察者模式是什么？</p><p>观察者模式又可称为<strong>发布 - 订阅模式</strong>，它定义了对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。</p><p>观察者模式有以下角色：</p><ul><li>抽象被观察者：将所有已注册的观察者对象保存在一个集合中。</li><li>具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。</li><li>抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。</li><li>具体被观察者：实现抽象观察者的更新接口。</li></ul><p>这里笔者给出一个简单的示例来让大家更深一步理解观察者模式的思想：</p><p>1、首先，创建抽象观察者</p><pre><code>public interface observer {    public void update(String message);}</code></pre><p>2、接着，创建具体观察者</p><pre><code>public class WeXinUser implements observer {    private String name;    public WeXinUser(String name) {        this.name = name;    }    @Override    public void update(String message) {        ...    }}</code></pre><p>3、然后，创建抽象被观察者</p><pre><code>public interface observable {    public void addWeXinUser(WeXinUser weXinUser);    public void removeWeXinUser(WeXinUser weXinUser);    public void notify(String message);}</code></pre><p>4、最后，创建具体被观察者</p><pre><code>public class Subscription implements observable {    private List&lt;WeXinUser&gt; mUserList = new ArrayList();    @Override    public void addWeXinUser(WeXinUser weXinUser) {        mUserList.add(weXinUser);    }    @Override    public void removeWeXinUser(WeXinUser weXinUser) {        mUserList.remove(weXinUser);    }    @Override    public void notify(String message) {        for(WeXinUser weXinUser : mUserList) {            weXinUser.update(message);        }    }}</code></pre><p>在具体使用时，我们便可以这样使用，如下所示：</p><pre><code>Subscription subscription = new Subscription();WeXinUser hongYang = new WeXinUser(&quot;HongYang&quot;);WeXinUser rengYuGang = new WeXinUser(&quot;RengYuGang&quot;);WeXinUser liuWangShu = new WeXinUser(&quot;LiuWangShu&quot;);subscription.addWeiXinUser(hongYang);subscription.addWeiXinUser(rengYuGang);subscription.addWeiXinUser(liuWangShu);subscription.notify(&quot;New article coming&quot;);</code></pre><p>在这里，hongYang、rengYuGang、liuWangShu等大神都订阅了我的微信公众号，每当我的公众号发表文章时（subscription.notify())，他们就会接收到最新的文章信息（weXinUser.update()）。（ps：当然，这一切都是YY，事实是，我并没有微信公众号-0v0-）</p><p>当然，EventBus的观察者模式和一般的观察者模式不同，它使用了扩展的观察者模式对事件进行订阅和分发，其实这里的扩展就是指的使用了EventBus来作为中介者，抽离了许多职责，如下是它的官方原理图：</p><p><img src="https://raw.githubusercontent.com/greenrobot/EventBus/master/EventBus-Publish-Subscribe.png" alt="image"></p><p>在得知了EventBus的原理之后，我们注意到，每次我们在register之后，都必须进行一次unregister，这是为什么呢？</p><ul><li>因为register是强引用，它会让对象无法得到内存回收，导致内存泄露。所以必须在unregister方法中释放对象所占的内存。</li></ul><p>有些同学可能之前使用的是EventBus2.x的版本，那么它又与EventBus3.x的版本有哪些区别呢？</p><ul><li>1、EventBus2.x使用的是运行时注解，它采用了反射的方式对整个注册的类的所有方法进行扫描来完成注册，因而会对性能有一定影响。</li><li>2、EventBus3.x使用的是编译时注解，Java文件会编译成.class文件，再对class文件进行打包等一系列处理。在编译成.class文件时，EventBus会使用EventBusAnnotationProcessor注解处理器读取@Subscribe()注解并解析、处理其中的信息，然后生成Java类来保存所有订阅者的订阅信息。这样就创建出了对文件或类的索引关系，并将其编入到apk中。</li><li>3、从EventBus3.0开始使用了对象池缓存减少了创建对象的开销。</li></ul><p>除了EventBus，其实现在比较流行的事件总线还有RxBus，那么，它与EventBus相比又如何呢？</p><ul><li>1、RxJava的Observable有onError、onComplete等状态回调。</li><li>2、Rxjava使用组合而非嵌套的方式，避免了回调地狱。</li><li>3、Rxjava的线程调度设计的更加优秀，更简单易用。</li><li>4、Rxjava可使用多种操作符来进行链式调用来实现复杂的逻辑。</li><li>5、Rxjava的信息效率高于EventBus2.x，低于EventBus3.x。</li></ul><p>在了解了EventBus和RxBus的区别之后，那么，对待新项目的事件总线选型时，我们该如何考量？</p><p>很简单，如果项目中使用了RxJava，则使用RxBus，否则使用EventBus3.x。</p><p>接下来将按以下顺序来进行EventBus的源码分析：</p><ul><li>1、订阅者：EventBus.getDefault().register(this)；</li><li>2、发布者：EventBus.getDefault().post(new CollectEvent())；</li><li>3、订阅者：EventBus.getDefault().unregister(this)。</li></ul><p>下面，我们正式开始~</p><h3 id="二、EventBus-getDefault-register-this"><a href="#二、EventBus-getDefault-register-this" class="headerlink" title="二、EventBus.getDefault().register(this)"></a>二、EventBus.getDefault().register(this)</h3><p>首先，我们从获取EventBus实例的方法getDefault()开始分析：</p><pre><code>public static EventBus getDefault() {    if (defaultInstance == null) {        synchronized (EventBus.class) {            if (defaultInstance == null) {                defaultInstance = new EventBus();            }        }    }    return defaultInstance;}</code></pre><p>在getDefault()中使用了双重校验并加锁的单例模式来创建EventBus实例。</p><p>接着，我们看到EventBus的默认构造方法中做了什么:</p><pre><code>private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();public EventBus() {    this(DEFAULT_BUILDER);}</code></pre><p>在EventBus的默认构造方法中又调用了它的另一个有参构造方法，将一个类型为EventBusBuilder的DEFAULT_BUILDER对象传递进去了。这里的EventBusBuilder很明显是一个EventBus的建造器，以便于EventBus能够添加自定义的参数和安装一个自定义的默认EventBus实例。</p><p>我们在看一下EventBusBuilder的构造方法：</p><pre><code>public class EventBusBuilder {    ...    EventBusBuilder() {    }    ...}</code></pre><p>EventBusBuilder的构造方法中什么也没有做，那我么继续查看EventBus的这个有参构造方法：</p><pre><code>private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;EventBus(EventBusBuilder builder) {    ...    // 1    subscriptionsByEventType = new HashMap&lt;&gt;();    // 2    typesBySubscriber = new HashMap&lt;&gt;();    // 3    stickyEvents = new ConcurrentHashMap&lt;&gt;();    // 4    mainThreadSupport = builder.getMainThreadSupport();    mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;    backgroundPoster = new BackgroundPoster(this);    asyncPoster = new AsyncPoster(this);    ...    // 5    subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,            builder.strictMethodVerification, builder.ignoreGeneratedIndex);    // 从builder取中一些列订阅相关信息进行赋值    ...    // 6    executorService = builder.executorService;}</code></pre><p>在注释1处，创建了一个subscriptionsByEventType对象，可以看到它是一个Map对象，并且其key为 Event 类型，value为 Subscription链表。这里的Subscription是一个订阅信息对象，它里面保存了两个重要的字段，一个是类型为 Object 的 subscriber，该字段即为注册的对象（在 Android 中时通常是 Activity对象）；另一个是 类型为SubscriberMethod 的 subscriberMethod，它就是被@Subscribe注解的那个订阅方法，里面保存了一个重要的字段eventType，它是 Class&lt;?&gt; 类型的，代表了 Event 的类型。在注释2处，新建了一个类型为 Map 的typesBySubscriber对象，它的key为subscriber对象，value为subscriber对象中所有的 Event 类型链表，日常使用中仅用于判断某个对象是否注册过。在注释3处又新建了一个类型为Map的对象，它是专用于粘性事件处理的一个字段，key为事件的Class对象，value为当前的事件。可能有的同学不了解sticky event，这里解释下：</p><ul><li>我们都知道普通事件是先注册，然后发送事件才能收到；而粘性事件，在发送事件之后再订阅该事件也能收到。并且，粘性事件会保存在内存中，每次进入都会去内存中查找获取最新的粘性事件，除非你手动解除注册。</li></ul><p>在注释4处，新建了三个不同类型的事件发送器，这里总结下：</p><ul><li>mainThreadPoster：主线程事件发送器，通过它的mainThreadPoster.enqueue(subscription, event)方法可以将订阅信息和对应的事件进行入队，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。</li><li>backgroundPoster：后台事件发送器，通过它的enqueue() 将方法加入到后台的一个队列，最后通过线程池去执行，注意，它在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。</li><li>asyncPoster：实现逻辑类似于backgroundPoster，不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，asyncPoster则是异步运行的，可以同时接收多个任务。</li></ul><p>我们在回到注释5这行代码，这里新建了一个subscriberMethodFinder对象，这是从EventBus中抽离出的订阅方法查询的一个对象，在优秀的源码中，我们经常能看到组合优于继承的这种实现思想。在注释6处，从builder中取出了一个默认的线程池对象，它由Executors的newCachedThreadPool()方法创建，它是一个有则用、无则创建、无数量上限的线程池。</p><p>分析完这些核心的字段之后，后面的讲解就比较轻松了，接着我们查看EventBus的regist()方法：</p><pre><code>public void register(Object subscriber) {    Class&lt;?&gt; subscriberClass = subscriber.getClass();    // 1    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);    synchronized (this) {        for (SubscriberMethod subscriberMethod : subscriberMethods) {            // 2            subscribe(subscriber, subscriberMethod);        }    }}</code></pre><p>在注释1处，根据当前注册类获取 subscriberMethods这个订阅方法列表 。在注释2处，使用了增强for循环令subsciber对象 对 subscriberMethods 中每个 SubscriberMethod 进行订阅。</p><p>接着我们查看SubscriberMethodFinder的findSubscriberMethods()方法：</p><pre><code>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {    // 1    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);    if (subscriberMethods != null) {        return subscriberMethods;    }    // 2    if (ignoreGeneratedIndex) {        subscriberMethods = findUsingReflection(subscriberClass);    } else {        subscriberMethods = findUsingInfo(subscriberClass);    }    if (subscriberMethods.isEmpty()) {        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);    } else {        METHOD_CACHE.put(subscriberClass, subscriberMethods);        return subscriberMethods;    }}</code></pre><p>在注释1处，如果缓存中有subscriberClass对象对应 的订阅方法列表，则直接返回。注释2处，先详细说说这个ignoreGeneratedIndex字段， 它用来判断是否使用生成的 APT 代码去优化寻找接收事件的过程，如果开启了的话，那么将会通过 subscriberInfoIndexes 来快速得到接收事件方法的相关信息。如果我们没有在项目中接入 EventBus 的 APT，那么可以将 ignoreGeneratedIndex 字段设为 false 以提高性能。这里ignoreGeneratedIndex 默认为false，所以会执行findUsingInfo()方法，后面生成 subscriberMethods 成功的话会加入到缓存中，失败的话会 抛出异常。</p><p>接着我们查看SubscriberMethodFinder的findUsingInfo()方法：</p><pre><code>private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) {    // 1    FindState findState = prepareFindState();    findState.initForSubscriber(subscriberClass);    // 2    while (findState.clazz != null) {        findState.subscriberInfo = getSubscriberInfo(findState);        if (findState.subscriberInfo != null) {            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();            for (SubscriberMethod subscriberMethod: array) {                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {                    findState.subscriberMethods.add(subscriberMethod);                }            }        } else {             // 3             findUsingReflectionInSingleClass(findState);        }        findState.moveToSuperclass();    }    // 4    return getMethodsAndRelease(findState);}</code></pre><p>在注释1处，调用了SubscriberMethodFinder的prepareFindState()方法创建了一个新的 FindState 类，我们来看看这个方法：</p><pre><code>private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];private FindState prepareFindState() {    // 1    synchronized(FIND_STATE_POOL) {        for (int i = 0; i &lt; POOL_SIZE; i++) {            FindState state = FIND_STATE_POOL[i];            if (state != null) {                FIND_STATE_POOL[i] = null;                return state;            }        }    }    // 2    return new FindState();}</code></pre><p>在注释1处，会先从 FIND_STATE_POOL 即 FindState 池中取出可用的 FindState（这里的POOL_SIZE为4），如果没有的话，则通过注释2处的代码直接新建 一个新的 FindState 对象。</p><p>接着我们来分析下FindState这个类：</p><pre><code>static class FindState {    ....    void initForSubscriber(Class&lt;?&gt; subscriberClass) {        this.subscriberClass = clazz = subscriberClass;        skipSuperClasses = false;        subscriberInfo = null;    }    ...}</code></pre><p>它是 SubscriberMethodFinder 的内部类，这个方法主要做一个初始化、回收对象等工作。</p><p>我们接着回到SubscriberMethodFinder的注释2处的SubscriberMethodFinder()方法：</p><pre><code>private SubscriberInfo getSubscriberInfo(FindState findState) {    if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) {        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();        if (findState.clazz == superclassInfo.getSubscriberClass()) {            return superclassInfo;        }    }    if (subscriberInfoIndexes != null) {        for (SubscriberInfoIndex index: subscriberInfoIndexes) {            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);            if (info != null) {                return info;            }        }    }    return null;}</code></pre><p>在前面初始化的时候，findState的subscriberInfo和subscriberInfoIndexes 这两个字段为空，所以这里直接返回 null。</p><p>接着我们查看注释3处的findUsingReflectionInSingleClass()方法：</p><pre><code>private void findUsingReflectionInSingleClass(FindState findState) {    Method[] methods;    try {        // This is faster than getMethods, especially when subscribers are fat classes like Activities        methods = findState.clazz.getDeclaredMethods();    } catch (Throwable th) {        methods = findState.clazz.getMethods();        findState.skipSuperClasses = true;    }    for (Method method: methods) {        int modifiers = method.getModifiers();        if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {            Class&lt;?&gt; [] parameterTypes = method.getParameterTypes();            if (parameterTypes.length == 1) {                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);                if (subscribeAnnotation != null) {                    // 重点                    Class&lt;?&gt; eventType = parameterTypes[0];                    if (findState.checkAdd(method, eventType)) {                        ThreadMode threadMode = subscribeAnnotation.threadMode();                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(),  subscribeAnnotation.sticky()));                    }                }            } else if (strictMethodVerification &amp;&amp;     method.isAnnotationPresent(Subscribe.class)) {            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();            throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);            }        } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();            throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);        }    }}</code></pre><p>这个方法很长，大概做的事情是：</p><ul><li>1、通过反射的方式获取订阅者类中的所有声明方法，然后在这些方法里面寻找以 @Subscribe作为注解的方法进行处理。</li><li>2、在经过经过一轮检查，看看 findState.subscriberMethods是否存在，如果没有，将方法名，threadMode，优先级，是否为 sticky 方法等信息封装到 SubscriberMethod 对象中，最后添加到 subscriberMethods 列表中。</li></ul><p>最后，我们继续查看注释4处的getMethodsAndRelease()方法：</p><pre><code>private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) {    // 1    List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);    // 2    findState.recycle();    // 3    synchronized(FIND_STATE_POOL) {        for (int i = 0; i &lt; POOL_SIZE; i++) {            if (FIND_STATE_POOL[i] == null) {                FIND_STATE_POOL[i] = findState;                break;            }        }    }    // 4    return subscriberMethods;}</code></pre><p>在这里，首先在注释1处，从findState中取出了保存的subscriberMethods。在注释2处，将findState里的保存的所有对象进行回收。在注释3处，把findState存储在 FindState 池中方便下一次使用，以提高性能。最后，在注释4处，返回subscriberMethods。接着，在EventBus的 register() 方法的最后会调用 subscribe 方法：</p><pre><code>public void register(Object subscriber) {    Class&lt;?&gt; subscriberClass = subscriber.getClass();    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);    synchronized (this) {        for (SubscriberMethod subscriberMethod : subscriberMethods) {            subscribe(subscriber, subscriberMethod);        }    }}</code></pre><p>我们继续看看这个subscribe()方法做的事情：</p><pre><code>private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {    Class&lt;?&gt; eventType = subscriberMethod.eventType;    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);    // 1    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);    if (subscriptions == null) {        subscriptions = new CopyOnWriteArrayList &lt;&gt; ();        subscriptionsByEventType.put(eventType, subscriptions);    } else {        if (subscriptions.contains(newSubscription)) {            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType);        }    }    int size = subscriptions.size();    // 2    for (int i = 0; i &lt;= size; i++) {        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {            subscriptions.add(i, newSubscription);            break;        }    }    // 3    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);    if (subscribedEvents == null) {        subscribedEvents = new ArrayList&lt;&gt;();        typesBySubscriber.put(subscriber, subscribedEvents);    }    subscribedEvents.add(eventType);    // 4    if (subscriberMethod.sticky) {        if (eventInheritance) {            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {                Class&lt;?&gt; candidateEventType = entry.getKey();                if(eventType.isAssignableFrom(candidateEventType)) {                Object stickyEvent = entry.getValue();                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);                }            }        } else {            Object stickyEvent = stickyEvents.get(eventType);            checkPostStickyEventToSubscription(newSubscription, stickyEvent);        }    }}</code></pre><p>首先，在注释1处，会根据 subscriberMethod的eventType，在 subscriptionsByEventType 去查找一个 CopyOnWriteArrayList ，如果没有则创建一个新的 CopyOnWriteArrayList，然后将这个 CopyOnWriteArrayList 放入 subscriptionsByEventType 中。在注释2处，添加 newSubscription对象，它是一个 Subscription 类，里面包含着 subscriber 和 subscriberMethod 等信息，并且这里有一个优先级的判断，说明它是按照优先级添加的。优先级越高，会插到在当前 List 靠前面的位置。在注释3处，对typesBySubscriber 进行添加，这主要是在EventBus的isRegister()方法中去使用的，目的是用来判断这个 Subscriber对象 是否已被注册过。最后，在注释4处，会判断是否是 sticky事件。如果是sticky事件的话，会调用 checkPostStickyEventToSubscription() 方法。</p><p>我们接着查看这个checkPostStickyEventToSubscription()方法：</p><pre><code>private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {    if (stickyEvent != null) {        postToSubscription(newSubscription, stickyEvent, isMainThread());    }}</code></pre><p>可以看到最终是调用了postToSubscription()这个方法来进行粘性事件的发送，对于粘性事件的处理，我们最后再分析，接下来我们看看事件是如何post的。</p><h3 id="三、EventBus-getDefault-post-new-CollectEvent"><a href="#三、EventBus-getDefault-post-new-CollectEvent" class="headerlink" title="三、EventBus.getDefault().post(new CollectEvent())"></a>三、EventBus.getDefault().post(new CollectEvent())</h3><pre><code>public void post(Object event) {    // 1    PostingThreadState postingState = currentPostingThreadState.get();    List &lt;Object&gt; eventQueue = postingState.eventQueue;    eventQueue.add(event);    // 2    if (!postingState.isPosting) {        postingState.isMainThread = isMainThread();        postingState.isPosting = true;        if (postingState.canceled) {            throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);        }        try {            while (!eventQueue.isEmpty()) {                postSingleEvent(eventQueue.remove(0), postingState);            }        } finally {            postingState.isPosting = false;            postingState.isMainThread = false;        }    }}</code></pre><p>注释1处，这里的currentPostingThreadState 是一个 ThreadLocal 类型的对象，里面存储了 PostingThreadState，而 PostingThreadState 中包含了一个 eventQueue 和其他一些标志位，相关的源码如下：</p><pre><code>private final ThreadLocal &lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal &lt;PostingThreadState&gt; () {@Overrideprotected PostingThreadState initialValue() {    return new PostingThreadState();}};final static class PostingThreadState {    final List &lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();    boolean isPosting;    boolean isMainThread;    Subscription subscription;    Object event;    boolean canceled;}</code></pre><p>接着把传入的 event，保存到了当前线程中的一个变量 PostingThreadState 的 eventQueue 中。在注释2处，最后调用了 postSingleEvent() 方法，我们继续查看这个方法：</p><pre><code>private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {    Class&lt;?&gt; eventClass = event.getClass();    boolean subscriptionFound = false;    // 1    if (eventInheritance) {        // 2        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);        int countTypes = eventTypes.size();        for (int h = 0; h &lt; countTypes; h++) {            Class&lt;?&gt; clazz = eventTypes.get(h);            subscriptionFound |=            // 3            postSingleEventForEventType(event, postingState, clazz);        }    } else {        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);    }    if (!subscriptionFound) {        ...    }}</code></pre><p>首先，在注释1处，首先取出 Event 的 class 类型，接着会对 eventInheritance 标志位 判断，它默认为true，如果设为 true 的话，它会在发射事件的时候判断是否需要发射父类事件，设为 false，能够提高一些性能。接着，在注释2处，会调用lookupAllEventTypes() 方法，它的作用就是取出 Event 及其父类和接口的 class 列表，当然重复取的话会影响性能，所以它也做了一个 eventTypesCache 的缓存，这样就不用重复调用 getSuperclass() 方法。最后，在注释3处会调用postSingleEventForEventType()方法，我们看下这个方法：</p><pre><code>private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class &lt;?&gt; eventClass) {    CopyOnWriteArrayList &lt;Subscription&gt; subscriptions;    synchronized(this) {        subscriptions = subscriptionsByEventType.get(eventClass);    }    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {        for (Subscription subscription: subscriptions) {            postingState.event = event;            postingState.subscription = subscription;            boolean aborted = false;            try {                postToSubscription(subscription, event, postingState.isMainThread);                aborted = postingState.canceled;            } finally {                postingState.event = null;                postingState.subscription = null;                postingState.canceled = false;            }            if (aborted) {                break;            }        }        return true;    }    return false;}</code></pre><p>可以看到，这里直接根据 Event 类型从 subscriptionsByEventType 中取出对应的 subscriptions对象，最后调用了 postToSubscription() 方法。</p><p>这个时候我们在看看这个postToSubscription()方法：</p><pre><code>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {    switch (subscription.subscriberMethod.threadMode) {        case POSTING:            invokeSubscriber(subscription, event);            break;        case MAIN:            if (isMainThread) {                invokeSubscriber(subscription, event);            } else {                mainThreadPoster.enqueue(subscription, event);            }            break;        case MAIN_ORDERED:            if (mainThreadPoster != null) {                mainThreadPoster.enqueue(subscription, event);            } else {                invokeSubscriber(subscription, event);            }            break;        case BACKGROUND:            if (isMainThread) {                backgroundPoster.enqueue(subscription, event);            } else {                invokeSubscriber(subscription, event);            }            break;        case ASYNC:            asyncPoster.enqueue(subscription, event);            break;        default:            throw new IllegalStateException(&quot;Unknow thread mode: &quot; + subscription.subscriberMethod.threadMode);    }}</code></pre><p>从上面可以看出，这里通过threadMode 来判断在哪个线程中去执行方法：</p><ul><li>1、POSTING：执行 invokeSubscriber() 方法，内部直接采用反射调用。</li><li>2、MAIN：首先去判断当前是否在 UI 线程，如果是的话则直接反射调用，否则调用mainThreadPoster的enqueue()方法，即把当前的方法加入到队列之中，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。</li><li>3、MAIN_ORDERED：与MAIN类型，不过是确保是顺序执行的。</li><li>4、BACKGROUND：判断当前是否在 UI 线程，如果不是的话直接反射调用，是的话通过backgroundPoster的enqueue()方法 将方法加入到后台的一个队列，最后通过线程池去执行。注意，backgroundPoster在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。</li><li>5、ASYNC：逻辑实现类似于BACKGROUND，将任务加入到后台的一个队列，最终由Eventbus 中的一个线程池去调用，这里的线程池与 BACKGROUND 逻辑中的线程池用的是同一个，即使用Executors的newCachedThreadPool()方法创建的线程池，它是一个有则用、无则创建、无数量上限的线程池。不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，这里asyncPoster则是异步运行的，可以同时接收多个任务。</li></ul><p>分析完EventBus的post()方法值，我们接着看看它的unregister()。</p><h3 id="四、EventBus-getDefault-unregister-this"><a href="#四、EventBus-getDefault-unregister-this" class="headerlink" title="四、EventBus.getDefault().unregister(this)"></a>四、EventBus.getDefault().unregister(this)</h3><p>它的核心源码如下所示：</p><pre><code>public synchronized void unregister(Object subscriber) {    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);    if (subscribedTypes != null) {        for (Class&lt;?&gt; eventType : subscribedTypes) {            //1            unsubscribeByEventType(subscriber, eventType);        }        // 2        typesBySubscriber.remove(subscriber);    }}</code></pre><p>首先，在注释1处，unsubscribeByEventType() 方法中对 subscriptionsByEventType 移除了该 subscriber 的所有订阅信息。最后，在注释2处，移除了注册对象和其对应的所有 Event 事件链表。</p><p>最后，我们在来分析下EventBus中对粘性事件的处理。</p><h3 id="五、EventBus-getDefault-postSticky-new-CollectEvent"><a href="#五、EventBus-getDefault-postSticky-new-CollectEvent" class="headerlink" title="五、EventBus.getDefault.postSticky(new CollectEvent())"></a>五、EventBus.getDefault.postSticky(new CollectEvent())</h3><p>如果想要发射 sticky 事件需要通过 EventBus的postSticky() 方法，内部源码如下所示：</p><pre><code>public void postSticky(Object event) {    synchronized (stickyEvents) {        // 1        stickyEvents.put(event.getClass(), event);    }    // 2    post(event);}</code></pre><p>在注释1处，先将该事件放入 stickyEvents 中，接着在注释2处使用post()发送事件。前面我们在分析register()方法的最后部分时，其中有关粘性事件的源码如下：</p><pre><code>if (subscriberMethod.sticky) {    Object stickyEvent = stickyEvents.get(eventType);    if (stickyEvent != null) {        postToSubscription(newSubscription, stickyEvent, isMainThread());    }}</code></pre><p>可以看到，在这里会判断当前事件是否是 sticky 事件，如果 是，则从 stickyEvents 中拿出该事件并执行 postToSubscription() 方法。</p><p>至此，EventBus源码分析完毕。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>EventBus 的源码在Android主流三方库源码分析系列中可以说是除了ButterKnife之外，算是比较简单的了。但是，它其中的一些思想和设计是值得借鉴的。比如它使用 FindState 复用池来复用 FindState 对象，在各处使用了 synchronized 关键字进行代码块同步的一些优化操作。其中上面分析了这个多，EventBus最核心的逻辑就是利用了 subscriptionsByEventType 这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行。至此，Android主流三方库源码分析系列到此完结~</p><pre><code>结束即开始，未来的路还有很长。</code></pre><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、EventBus V3.1.1 源码</p><p>2、Android进阶之光</p><p>3、Android组件化架构</p><p>3、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243033&amp;idx=1&amp;sn=28709941e6f8821c6f5dd3fa047b1393&amp;chksm=88638eb6bf1407a034ba2184cac9e31c24f43e3ac395b1b23b18243f64220c244f2edc7dc22a&amp;scene=38#wechat_redirect" target="_blank" rel="external">EventBus设计之禅</a></p><p>4、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242621&amp;idx=1&amp;sn=cc9c31aba5ff33b20fb9fecc3b0404b2&amp;chksm=88638f52bf14064453fc09e6e53798ac5a1299d84df490b15764f9a85292732879eb4a1c0665&amp;scene=38#wechat_redirect" target="_blank" rel="external">从源码入手来学习EventBus 3事件总线机制</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/28/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3EventBus%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（八、深入理解Dagger2源码）</title>
      <link>http://yoursite.com/2019/01/20/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Dagger2%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/20/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Dagger2%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 20 Jan 2019 15:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>上一篇，笔者详细地分析了Android中的依赖注入框架ButterKnife，使用它帮助我们解决了重复编写findViewById和setOnclickListener的繁琐。众所周知，当项目越来越大时，类之间的调用层次会越来越深，并且有些类是Activity/Fragment，有些是单例，而且它们的生命周期也不是一致的，所以创建这些对象时要处理的各个对象的依赖关系和生命周期时的任务会很繁重，因此，为了解决这个问题Dagger2应运而生。相比ButterKnife的轻量级使用，Dagger2会显得更重量级和锋利一些，它能够掌控全局，对项目中几乎所有的依赖进行集成管理。如果有对Binder架构体系比较了解的朋友应该知道，其中的服务大管家ServiceManager负责所有的服务（引导服务、核心服务、其它服务）的管理，而Dagger2其实就是将项目中的依赖进行了集成管理。下面，笔者来跟大家一起探索Dagger2的内部实现机制，看看它是如何进行依赖管理的。</p><p>Dagger2其实同RxJava一样，是一种多平台通用的库。由于Dagger2的通用写法比较繁琐，因此，Google推出了适用于Android平台的Dagger.Android用法。本文，将基于Dagger.Android的源码对Dagger2内部的实现机制进行探索。</p><h3 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h3><p>鉴于Dagger有一定的上手成本，这里首先带大家复习一下本篇源码分析可能会涉及到的相关基础知识点，以降低阅读难度。</p><h4 id="1、-Inject"><a href="#1、-Inject" class="headerlink" title="1、@Inject"></a>1、@Inject</h4><p>告诉dagger这个字段或类需要依赖注入，然后在需要依赖的地方使用这个注解，dagger会自动生成这个构造器的实例。</p><h5 id="获取所需依赖："><a href="#获取所需依赖：" class="headerlink" title="获取所需依赖："></a>获取所需依赖：</h5><ul><li>全局变量注入</li><li>方法注入</li></ul><h5 id="提供所需实例："><a href="#提供所需实例：" class="headerlink" title="提供所需实例："></a>提供所需实例：</h5><ul><li>构造器注入（如果有多个构造函数，只能注解一个，否则编译报错）</li></ul><h4 id="2、-Module"><a href="#2、-Module" class="headerlink" title="2、@Module"></a>2、@Module</h4><p>类注解，表示此类的方法是提供依赖的，它告诉dagger在哪可以找到依赖。用于不能用@Inject提供依赖的地方，如第三方库提供的类，基本数据类型等不能修改源码的情况。</p><p>注意：<strong>Dagger2会优先在@Module注解的类上查找依赖，没有的情况才会去查询类的@Inject构造方法</strong></p><h4 id="3、-Singleton"><a href="#3、-Singleton" class="headerlink" title="3、@Singleton"></a>3、@Singleton</h4><p>声明这是一个单例，在确保只有一个Component并且不再重新build()之后，对象只会被初始化一次，之后的每次都会被注入相同的对象，它就是一个内置的作用域。</p><p>对于@Singleton，大家可能会产生一些误解，这里详细阐述下：</p><ul><li>Singleton容易给人造成一种误解就是用Singleton注解后在整个Java代码中都是单例，但实际上他和Scope一样，只是在同一个Component是单例。也就是说，如果重新调用了component的build（）方法，即使使用了Singleton注解了，但仍然获取的是不同的对象。</li><li>它表明了@Singleton注解只是声明了这是一个单例，为的只是提高代码可读性，其实真正控制对象生命周期的还是Component。同理，自定义的@ActivityScope 、@ApplicationScope也仅仅是一个声明的作用，<strong>真正控制对象生命周期的还是Component</strong>。</li></ul><h4 id="4、-Providers"><a href="#4、-Providers" class="headerlink" title="4、@Providers"></a>4、@Providers</h4><p>只在@Module中使用，用于提供构造好的实例。一般与@Singleton搭配，用单例方法的形式对外提供依赖,是一种替代@Inject注解构造方法的方式。</p><p>注意：</p><ul><li>使用了@Providers的方法应使用provide作为前缀，使用了@Module的类应使用Module作为后缀。</li><li><strong>如果@Providers方法或@Inject构造方法有参数，要保证它能够被dagger获取到</strong>，比如通过其它@Providers方法或者@Inject注解构造器的形式得到。</li></ul><h4 id="5、-Component"><a href="#5、-Component" class="headerlink" title="5、@Component"></a>5、@Component</h4><p>@Component作为Dagger2的容器总管，它拥有着@Inject与@Module的所有依赖。同时，它也是一枚注射器，用于获取所需依赖和提供所需依赖的桥梁。这里的桥梁即指@Inject和@Module（或@Inject构造方法）之间的桥梁。定义时需要列出响应的Module组成，此外，还可以使用dependencies继承父Component。</p><h5 id="Component与Module的区别："><a href="#Component与Module的区别：" class="headerlink" title="Component与Module的区别："></a>Component与Module的区别：</h5><p>Component既是注射器也是一个容器总管，而module则是作为容器总管Component的子容器，实质是一个用于提供依赖的模块。</p><h4 id="6、-Scope"><a href="#6、-Scope" class="headerlink" title="6、@Scope"></a>6、@Scope</h4><p>注解作用域，通过自定义注解<strong>限定对象作用范围，增强可读性</strong>。</p><p>@Scope有两种常用的使用场景：</p><ul><li>模拟Singleton代表全局单例，与Component生命周期关联。</li><li>模拟局部单例，如登录到退出登录期间。 </li></ul><h4 id="7、-Qualifier"><a href="#7、-Qualifier" class="headerlink" title="7、@Qualifier"></a>7、@Qualifier</h4><p>限定符，利用它定义注解类以用于区分类的不同实例。例如：2个方法返回不同的Person对象，比如说小明和小华，为了区分，使用@Qualifier定义的注解类。</p><h4 id="8、dependencies"><a href="#8、dependencies" class="headerlink" title="8、dependencies"></a>8、dependencies</h4><p>使用它表示ChildComponent依赖于FatherComponent，如下所示：</p><pre><code>@Component(modules = ChildModule.class, dependencies = FatherComponent.class)public interface ChildComponent {    ...}</code></pre><h4 id="9、-SubComponent"><a href="#9、-SubComponent" class="headerlink" title="9、@SubComponent"></a>9、@SubComponent</h4><p>表示是一个子@Component，它能将应用的不同部分封装起来，用来替代@Dependencies。</p><p>回顾完Dagger2的基础知识，下面我们要启动发动机了。。。</p><h3 id="一、简单示例（取自AwesomeWanAndroid）"><a href="#一、简单示例（取自AwesomeWanAndroid）" class="headerlink" title="一、简单示例（取自AwesomeWanAndroid）"></a>一、简单示例（取自<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">AwesomeWanAndroid</a>）</h3><h4 id="1、首先，创建一个BaseActivityComponent的Subcomponent："><a href="#1、首先，创建一个BaseActivityComponent的Subcomponent：" class="headerlink" title="1、首先，创建一个BaseActivityComponent的Subcomponent："></a>1、首先，创建一个BaseActivityComponent的Subcomponent：</h4><pre><code>@Subcomponent(modules = {AndroidInjectionModule.class})public interface BaseActivityComponent extends AndroidInjector&lt;BaseActivity&gt; {    @Subcomponent.Builder    abstract class BaseBuilder extends AndroidInjector.Builder&lt;BaseActivity&gt;{    }}</code></pre><p>这里必须要注解成@Subcomponent.Builder表示是顶级@Subcomponent的内部类。AndroidInjector.Builder的泛型指定了BaseActivity，即表示每一个继承于BaseActivity的Activity都继承于同一个子组件（BaseActivityComponent）。</p><h4 id="2、然后，创建一个将会导入Subcomponent的公有Module。"><a href="#2、然后，创建一个将会导入Subcomponent的公有Module。" class="headerlink" title="2、然后，创建一个将会导入Subcomponent的公有Module。"></a>2、然后，创建一个将会导入Subcomponent的公有Module。</h4><pre><code>// 1@Module(subcomponents = {BaseActivityComponent.class})public abstract class AbstractAllActivityModule {    @ContributesAndroidInjector(modules = MainActivityModule.class)    abstract MainActivity contributesMainActivityInjector();    @ContributesAndroidInjector(modules = SplashActivityModule.class)    abstract SplashActivity contributesSplashActivityInjector();    // 一系列的对应Activity的contributesxxxActivityInjector    ...}</code></pre><p>在注释1处用subcomponents来表示开放全部依赖给AbstractAllActivityModule，使用Subcomponent的重要原因是它将应用的不同部分封装起来了。@AppComponent负责维护共享的数据和对象，而不同处则由各自的@Subcomponent维护。</p><h4 id="3、接着，配置项目的Application。"><a href="#3、接着，配置项目的Application。" class="headerlink" title="3、接着，配置项目的Application。"></a>3、接着，配置项目的Application。</h4><pre><code>public class WanAndroidApp extends Application implements HasActivityInjector {    // 3    @Inject    DispatchingAndroidInjector&lt;Activity&gt; mAndroidInjector;    private static volatile AppComponent appComponent;    @Override    public void onCreate() {        super.onCreate();        ...        // 1        appComponent = DaggerAppComponent.builder()            .build();        // 2        appComponent.inject(this);        ...    }    ...    // 4    @Override    public AndroidInjector&lt;Activity&gt; activityInjector() {        return mAndroidInjector;    }}</code></pre><p>首先，在注释1处，使用AppModule模块和httpModule模块构建出AppComponent的实现类DaggerAppComponent。这里看一下AppComponent的配置代码：</p><pre><code>@Singleton@Component(modules = {AndroidInjectionModule.class,        AndroidSupportInjectionModule.class,        AbstractAllActivityModule.class,        AbstractAllFragmentModule.class,        AbstractAllDialogFragmentModule.class}    )public interface AppComponent {    /**     * 注入WanAndroidApp实例     *     * @param wanAndroidApp WanAndroidApp     */    void inject(WanAndroidApp wanAndroidApp);    ...}</code></pre><p>可以看到，AppComponent依赖了AndroidInjectionModule模块，它包含了一些基础配置的绑定设置，如activityInjectorFactories、fragmentInjectorFactories等等，而AndroidSupportInjectionModule模块显然就是多了一个supportFragmentInjectorFactories的绑定设置，activityInjectorFactories的内容如所示：</p><pre><code>@Beta@Modulepublic abstract class AndroidInjectionModule {    @Multibinds    abstract Map&lt;Class&lt;? extends Activity&gt;, AndroidInjector.Factory&lt;? extends Activity&gt;&gt;        activityInjectorFactories();    @Multibinds    abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt;        fragmentInjectorFactories();    ...}</code></pre><p>接着，下面依赖的AbstractAllActivityModule、<br>AbstractAllFragmentModule、AbstractAllDialogFragmentModule则是为项目的所有Activity、Fragment、DialogFragment提供的统一基类抽象Module，这里看下AbstractAllActivityModule的配置：</p><pre><code>@Module(subcomponents = {BaseActivityComponent.class})public abstract class AbstractAllActivityModule {    @ContributesAndroidInjector(modules = MainActivityModule.class)    abstract MainActivity contributesMainActivityInjector();    @ContributesAndroidInjector(modules = SplashActivityModule.class)    abstract SplashActivity contributesSplashActivityInjector();    ...}</code></pre><p>可以看到，项目下的所有xxxActiviity都有对应的contributesxxxActivityInjector()方法提供实例注入。并且，注意到AbstractAllActivityModule这个模块依赖的<br>subcomponents为BaseActivityComponent，前面说过了，每一个继承于BaseActivity的Activity都继承于BaseActivityComponent这一个subcomponents。同理，AbstractAllFragmentModule与AbstractAllDialogFragmentModule也是类似的实现模式，如下所示：</p><pre><code>// 1@Module(c = BaseFragmentComponent.class)public abstract class AbstractAllFragmentModule {    @ContributesAndroidInjector(modules = CollectFragmentModule.class)    abstract CollectFragment contributesCollectFragmentInject();    @ContributesAndroidInjector(modules = KnowledgeFragmentModule.class)    abstract KnowledgeHierarchyFragment contributesKnowledgeHierarchyFragmentInject();    ...}// 2@Module(subcomponents = BaseDialogFragmentComponent.class)public abstract class AbstractAllDialogFragmentModule {    @ContributesAndroidInjector(modules = SearchDialogFragmentModule.class)    abstract SearchDialogFragment contributesSearchDialogFragmentInject();    @ContributesAndroidInjector(modules = UsageDialogFragmentModule.class)    abstract UsageDialogFragment contributesUsageDialogFragmentInject();}</code></pre><p>注意到注释1和注释2处的代码，AbstractAllFragmentModule和AbstractAllDialogFragmentModule的subcomponents为BaseFragmentComponent、BaseDialogFragmentComponent，很显然，同AbstractAllActivityModule的子组件BaseActivityComponent一样，它们都是作为一个通用的子组件。</p><p>然后，回到我们配置项目下的Application下面的注释2处的代码，在这里使用了第一步Dagger为我们构建的DaggerAppComponent对象将当期的Application实例注入了进去，交给了Dagger这个依赖大管家去管理。最终，Dagger2内部创建的mAndroidInjector对象会在注释3处的地方进行实例赋值。在注释4处，实现HasActivityInjector接口，重写activityInjector()方法，将我们上面得到的mAndroidInjector对象返回。这里的mAndroidInjector是一个类型为DispatchingAndroidInjector<activity>的对象，可以这样理解它：它能够执行Android框架下的核心成员如Activity、Fragment的成员注入，在我们项目下的Application中将DispatchingAndroidInjector的泛型指定为Activity就说明它承担起了所有Activity成员依赖的注入。那么，如何指定某一个Activity能被纳入DispatchingAndroidInjector这个所有Activity的依赖总管的口袋中呢？接着看使用步骤4。</activity></p><h4 id="4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。"><a href="#4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。" class="headerlink" title="4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。"></a>4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。</h4><p>很简单，只需在目标Activity的onCreate()方法前的super.onCreate(savedInstanceState)前配置一行代码 AndroidInjection.inject(this)，如下所示：</p><pre><code>public abstract class BaseActivity&lt;T extends AbstractPresenter&gt; extends AbstractSimpleActivity implements    AbstractView {    ...    @Inject    protected T mPresenter;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        AndroidInjection.inject(this);        super.onCreate(savedInstanceState);    }    ...}</code></pre><p>这里使用了@Inject表明了需要注入mPresenter实例，然后，我们需要在具体的Presenter类的构造方法上使用@Inject提供基于当前构造方法的mPresenter实例，如下所示：</p><pre><code>public class MainPresenter extends BasePresenter&lt;MainContract.View&gt; implements MainContract.Presenter {    ...    @Inject    MainPresenter(DataManager dataManager) {        super(dataManager);        this.mDataManager = dataManager;    }    ...}</code></pre><p>从上面的使用流程中，可以总结出三个核心部分：</p><ul><li><p>1、appComponent = DaggerAppComponent.builder().build()这句代码如何构建出DaggerAPPComponent的？</p></li><li><p>2、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？</p></li><li><p>3、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？</p></li></ul><p>下面，让我们来逐个一一地来探索其中的奥妙吧~</p><h3 id="二、DaggerAppComponent-builder-build-是如何构建出DaggerAPPComponent的？"><a href="#二、DaggerAppComponent-builder-build-是如何构建出DaggerAPPComponent的？" class="headerlink" title="二、DaggerAppComponent.builder().build()是如何构建出DaggerAPPComponent的？"></a>二、DaggerAppComponent.builder().build()是如何构建出DaggerAPPComponent的？</h3><p>首先，我们看到DaggerAppComponent的builder()方法：</p><pre><code>public static Builder builder() {    return new Builder();}</code></pre><p>里面直接返回了一个新建的Builder静态内部类对象，看看它的构造方法中做了什么：</p><pre><code>public static final class Builder {    private Builder() {}    ...}</code></pre><p>看来，Builder的默认构造方法什么也没有做，那么，真正的实现肯定在Builder对象的build()方法中，接着看到build()方法。</p><pre><code>public static final class Builder {    ...    public AppComponent build() {         return new DaggerAppComponent(this);    }    ...}</code></pre><p>在Builder的build()方法中直接返回了新建的DaggerAppComponent对象。下面，看看DaggerAppComponent的构造方法:</p><pre><code>private DaggerAppComponent(Builder builder) {    initialize(builder);}</code></pre><p>在DaggerAppComponent的构造方法中调用了initialize方法，顾名思义，它就是真正初始化项目全局依赖配置的地方了，下面，来看看它内部的实现：</p><pre><code>private void initialize(final Builder builder) {    // 1    this.mainActivitySubcomponentBuilderProvider =        new Provider&lt;            AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent                .Builder&gt;() {        @Override        public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent                .Builder            get() {                // 2                return new MainActivitySubcomponentBuilder();            }        };    // 一系列xxxActivitySubcomponentBuilderProvider的创建赋值代码块    ...}</code></pre><p>在注释1处，新建了一个mainActivit的子组件构造器实例提供者Provider。在注释2处，使用匿名内部类的方式重写了该Provider的get()方法，返回一个新创建好的MainActivitySubcomponentBuilder对象。很显然，它就是负责创建管理MAinActivity中所需依赖的Subcomponent建造者。接下来我们重点来分析下MainActivitySubcomponentBuilder这个类的作用。</p><pre><code>// 1private final class MainActivitySubcomponentBuilder  extends AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent      .Builder {    private MainActivity seedInstance;    @Override    public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent        build() {      if (seedInstance == null) {        throw new IllegalStateException(MainActivity.class.getCanonicalName() + &quot; must be set&quot;);      }      // 2      return new MainActivitySubcomponentImpl(this);    }    @Override    public void seedInstance(MainActivity arg0) {      // 3      this.seedInstance = Preconditions.checkNotNull(arg0);    }}</code></pre><p>首先，在注释1处，MainActivitySubcomponentBuilder继承了AbstractAllActivityModule_ContributesMainActivityInjector内部的子组件MainActivitySubcomponent的内部的子组件建造者类Builder，如下所示：</p><pre><code>@Subcomponent(modules = MainActivityModule.class)public interface MainActivitySubcomponent extends AndroidInjector&lt;MainActivity&gt; {    @Subcomponent.Builder    abstract class Builder extends    AndroidInjector.Builder&lt;MainActivity&gt; {}}</code></pre><p>可以看到，这个子组件建造者Builder又继承了AndroidInjector的抽象内部类Builder<mainactivity>，那么，这个AndroidInjector到底是什么呢？</mainactivity></p><p>顾名思义，AndroidInjector是一个Android注射器，它<strong>为每一个具体的子类型，即核心Android类型Activity和Fragment执行成员注入。</strong></p><p>接下来我们便来分析下AndroidInjector的内部实现，源码如下所示：</p><pre><code>public interface AndroidInjector&lt;T&gt; {    void inject(T instance);    // 1    interface Factory&lt;T&gt; {        AndroidInjector&lt;T&gt; create(T instance);    }    // 2    abstract class Builder&lt;T&gt; implements AndroidInjector.Factory&lt;T&gt; {        @Override        public final AndroidInjector&lt;T&gt; create(T instance) {            seedInstance(instance);            return build();        }        @BindsInstance        public abstract void seedInstance(T instance);        public abstract AndroidInjector&lt;T&gt; build();    }}</code></pre><p>在注释1处，使用了抽象工厂模式，用来创建一个具体的Activity或Fragment类型的AndroidInjector实例。注释2处，Builder<t>实现了AndroidInjector.Factory<t>，它是一种Subcomponent.Builder的通用实现模式，在重写的create()方法中，进行了实例保存seedInstance()和具体Android核心类型的构建。</t></t></p><p>接着，我们回到MainActivitySubcomponentBuilder类，可以看到，它实现了AndroidInjector.Builder的seedInstance()和build()方法。在注释3处首先播种了MainActivity的实例，然后<br>在注释2处新建了一个MainActivitySubcomponentImpl对象返回。我们看看MainActivitySubcomponentImpl这个类是如何将mPresenter依赖注入的，相关源码如下：</p><pre><code>private final class MainActivitySubcomponentImpl    implements AbstractAllActivityModule_ContributesMainActivityInjector    .MainActivitySubcomponent {    private MainPresenter getMainPresenter() {        // 2        return MainPresenter_Factory.newMainPresenter(        DaggerAppComponent.this.provideDataManagerProvider.get());    }    @Override    public void inject(MainActivity arg0) {        // 1        injectMainActivity(arg0);    }    private MainActivity injectMainActivity(MainActivity instance) {        // 3        BaseActivity_MembersInjector        .injectMPresenter(instance, getMainPresenter());        return instance;    }</code></pre><p>在注释1处，MainActivitySubcomponentImpl实现了AndroidInjector接口的inject()方法，在injectMainActivity()首先调用getMainPresenter()方法从MainPresenter_Factory工厂类中新建了一个MainPresenter对象。我们看看MainPresenter的newMainPresenter()方法：</p><pre><code>public static MainPresenter newMainPresenter(DataManager dataManager) {    return new MainPresenter(dataManager);}</code></pre><p>这里直接新建了一个MainPresenter。然后我们回到MainActivitySubcomponentImpl类的注释3处，继续调用了BaseActivity_MembersInjector的injectMPresenter()方法，顾名思义，可以猜到，它BaseActivity的成员注射器，继续看看injectMPresenter()内部：</p><pre><code>public static &lt;T extends AbstractPresenter&gt; void injectMPresenter(  BaseActivity&lt;T&gt; instance, T mPresenter) {    instance.mPresenter = mPresenter;}</code></pre><p>可以看到，这里直接将需要的mPresenter实例赋值给了BaseActivity的mPresenter，当然，这里其实是指的BaseActivity的子类MAinActivity，其它的xxxActivity的依赖管理机制都是如此。</p><h3 id="三、appComponent-inject-this-是如何将mAndroidInjector实例赋值给当前的Application的？"><a href="#三、appComponent-inject-this-是如何将mAndroidInjector实例赋值给当前的Application的？" class="headerlink" title="三、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？"></a>三、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？</h3><p>我们继续查看appComponent的inject()方法：</p><pre><code>@Overridepublic void inject(WanAndroidApp wanAndroidApp) {  injectWanAndroidApp(wanAndroidApp);}</code></pre><p>在inject()方法里调用了injectWanAndroidApp()，继续查看injectWanAndroidApp()方法：</p><pre><code>private WanAndroidApp injectWanAndroidApp(WanAndroidApp instance) {    WanAndroidApp_MembersInjector.injectMAndroidInjector(        instance,        getDispatchingAndroidInjectorOfActivity());    return instance;}</code></pre><p>首先，执行getDispatchingAndroidInjectorOfActivity()方法得到了一个Activity类型的DispatchingAndroidInjector对象，继续查看getDispatchingAndroidInjectorOfActivity()方法：</p><pre><code>private DispatchingAndroidInjector&lt;Activity&gt; getDispatchingAndroidInjectorOfActivity() {    return DispatchingAndroidInjector_Factory.newDispatchingAndroidInjector(    getMapOfClassOfAndProviderOfFactoryOf());}</code></pre><p>在getDispatchingAndroidInjectorOfActivity()方法里面，首先调用了getMapOfClassOfAndProviderOfFactoryOf()方法，我们看到这个方法：</p><pre><code>private Map&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;  getMapOfClassOfAndProviderOfFactoryOf() {    return MapBuilder        .&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;        newMapBuilder(8)        .put(MainActivity.class, (Provider) mainActivitySubcomponentBuilderProvider)        .put(SplashActivity.class, (Provider) splashActivitySubcomponentBuilderProvider)        .put(ArticleDetailActivity.class,            (Provider) articleDetailActivitySubcomponentBuilderProvider)        .put(KnowledgeHierarchyDetailActivity.class,            (Provider) knowledgeHierarchyDetailActivitySubcomponentBuilderProvider)        .put(LoginActivity.class, (Provider) loginActivitySubcomponentBuilderProvider)        .put(RegisterActivity.class, (Provider) registerActivitySubcomponentBuilderProvider)        .put(AboutUsActivity.class, (Provider) aboutUsActivitySubcomponentBuilderProvider)        .put(SearchListActivity.class, (Provider) searchListActivitySubcomponentBuilderProvider)        .build();}</code></pre><p>可以看到，这里新建了一个建造者模式实现的MapBuilder，并且同时制定了固定容量为8，将项目下使用了AndroidInjection.inject(mActivity)方法的8个Activity对应的xxxActivitySubcomponentBuilderProvider保存起来。</p><p>我们再回到getDispatchingAndroidInjectorOfActivity()方法，这里将上面得到的Map容器传入了DispatchingAndroidInjector_Factory的newDispatchingAndroidInjector()方法中，这里应该就是新建DispatchingAndroidInjector的地方了。我们点进去看看：</p><pre><code>public static &lt;T&gt; DispatchingAndroidInjector&lt;T&gt; newDispatchingAndroidInjector(  Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt; injectorFactories) {    return new DispatchingAndroidInjector&lt;T&gt;(injectorFactories);}</code></pre><p>在这里，果然新建了一个DispatchingAndroidInjector对象。继续看看DispatchingAndroidInjector的构造方法：</p><pre><code>@InjectDispatchingAndroidInjector(  Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt; injectorFactories) {    this.injectorFactories = injectorFactories;}</code></pre><p>这里仅仅是将传进来的Map容器保存起来了。</p><p>我们再回到WanAndroidApp_MembersInjector的injectMAndroidInjector()方法，将上面得到的DispatchingAndroidInjector实例传入，继续查看injectMAndroidInjector()这个方法：</p><pre><code>public static void injectMAndroidInjector(  WanAndroidApp instance, DispatchingAndroidInjector&lt;Activity&gt; mAndroidInjector) {    instance.mAndroidInjector = mAndroidInjector;}</code></pre><p>可以看到，这里直接将新建好的DispatchingAndroidInjector实例赋值给了WanAndroidApp的mAndroidInjector。</p><h3 id="四、在目标Activity下的AndroidInjection-inject-this-这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？"><a href="#四、在目标Activity下的AndroidInjection-inject-this-这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？" class="headerlink" title="四、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？"></a>四、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？</h3><p>首先，我们看到AndroidInjection.inject(this)这个方法：</p><pre><code>public static void inject(Activity activity) {    checkNotNull(activity, &quot;activity&quot;);    // 1    Application application = activity.getApplication();    if (!(application instanceof HasActivityInjector)) {    throw new RuntimeException(        String.format(            &quot;%s does not implement %s&quot;,            application.getClass().getCanonicalName(),             HasActivityInjector.class.getCanonicalName()));    }    // 2    AndroidInjector&lt;Activity&gt; activityInjector =        ((HasActivityInjector) application).activityInjector();    checkNotNull(activityInjector, &quot;%s.activityInjector() returned null&quot;, application.getClass());    // 3    activityInjector.inject(activity);</code></pre><p>  }</p><p>在注释1处，会先判断当前的application是否实现了HasActivityInjector这个接口，如果没有，则抛出RuntimeException。如果有，会继续在注释2处调用application的activityInjector()方法得到DispatchingAndroidInjector实例。最后，在注释3处，会将当前的activity实例传入activityInjector的inject()方法中。我们继续查看inject()方法：</p><pre><code>@Overridepublic void inject(T instance) {    boolean wasInjected = maybeInject(instance);    if (!wasInjected) {        throw new IllegalArgumentException(errorMessageSuggestions(instance));    }}</code></pre><p>DispatchingAndroidInjector的inject()方法，它的作用就是给传入的instance实例执行成员注入。具体在这个案例中，其实就是负责将创建好的Presenter实例赋值给BaseActivity对象<br>的mPresenter全局变量。在inject()方法中，又调用了maybeInject()方法，我们继续查看它：</p><pre><code>@CanIgnoreReturnValuepublic boolean maybeInject(T instance) {    // 1    Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt; factoryProvider =    injectorFactories.get(instance.getClass());    if (factoryProvider == null) {    return false;    }    @SuppressWarnings(&quot;unchecked&quot;)    // 2    AndroidInjector.Factory&lt;T&gt; factory = (AndroidInjector.Factory&lt;T&gt;) factoryProvider.get();    try {        // 3        AndroidInjector&lt;T&gt; injector =            checkNotNull(                factory.create(instance), &quot;%s.create(I) should not return null.&quot;, factory.getClass());        // 4        injector.inject(instance);        return true;    } catch (ClassCastException e) {        ...    }}</code></pre><p>在注释1处，我们从injectorFactories（前面得到的Map容器）中根据当前Activity实例拿到了factoryProvider对象，这里我们具体一点，看到MAinActivity对应的factoryProvider，也就是我们研究的第一个问题中的mainActivitySubcomponentBuilderProvider：</p><pre><code>private void initialize(final Builder builder) {    this.mainActivitySubcomponentBuilderProvider =        new Provider&lt;            AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent            .Builder&gt;() {        @Override        public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent                .Builder            get() {                return new MainActivitySubcomponentBuilder();            }        };    ...}</code></pre><p>在maybeInject()方法的注释2处，调用了mainActivitySubcomponentBuilderProvider的get()方法得到了一个新建的MainActivitySubcomponentBuilder对象。在注释3处执行了它的create方法，create()方法的具体实现在AndroidInjector的内部类Builder中：</p><pre><code>abstract class Builder&lt;T&gt; implements AndroidInjector.Factory&lt;T&gt; {    @Override    public final AndroidInjector&lt;T&gt; create(T instance) {        seedInstance(instance);        return build();    }</code></pre><p>看到这里，我相信看过第一个问题的同学已经明白是后面是怎么回事了。在create()方法中，我们首先MainActivitySubcomponentBuilder的seedInstance()将MAinActivity实例注入，然后再调用它的build()方法新建了一个MainActivitySubcomponentImpl实例返回。</p><p>最后，在注释4处，执行了MainActivitySubcomponentImpl的injecty()方法：</p><pre><code>private final class MainActivitySubcomponentImpl    implements AbstractAllActivityModule_ContributesMainActivityInjector    .MainActivitySubcomponent {    private MainPresenter getMainPresenter() {        // 2        return MainPresenter_Factory.newMainPresenter(        DaggerAppComponent.this.provideDataManagerProvider.get());    }    @Override    public void inject(MainActivity arg0) {        // 1        injectMainActivity(arg0);    }    private MainActivity injectMainActivity(MainActivity instance) {        // 3        BaseActivity_MembersInjector        .injectMPresenter(instance, getMainPresenter());        return instance;    }</code></pre><p>这里的逻辑已经在问题一的最后部分详细讲解了，最后，会在注释3处调用BaseActivity_MembersInjector的injectMPresenter()方法：</p><pre><code>public static &lt;T extends AbstractPresenter&gt; void injectMPresenter(  BaseActivity&lt;T&gt; instance, T mPresenter) {    instance.mPresenter = mPresenter;}</code></pre><p>这样，就将mPresenter对象赋值给了当前Activity对象的mPresenter全局变量中了。至此，Dagger.Android核心源码分析完毕，你是否有所收获呢？</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>相比于ButterKnife，Dagger是一个<strong>锋利的全局依赖注入管理框架</strong>，它主要用来管理对象的依赖关系和生命周期，当项目越来越大时，类之间的调用层次会越来越深，并且有些类是Activity或Fragment，有些是单例，而且它们的生命周期不一致，所以创建所需对象时需要处理的各个对象的依赖关系和生命周期时的任务会很繁重。因此，使用Dagger会大大减轻这方面的工作量。虽然它的学习成本比较高，而且需要写一定的模板类，但是，<strong>对于越大的项目来说，Dagger越值得被需要</strong>。下一篇，便是Android主流三方库源码分析系列的终结篇了，笔者将会对Android中的事件总线框架EventBus源码进行深入的分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Dagger V2.1.5 源码</p><p>2、Android进阶之光</p><p>3、<a href="https://blog.csdn.net/mq2553299/article/details/77725912" target="_blank" rel="external">告别Dagger2模板代码：DaggerAndroid原理解析</a></p><p>4、<a href="https://www.jianshu.com/p/7ee1a1100fab" target="_blank" rel="external">Android Dagger2 从零单排</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/20/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Dagger2%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（七、深入理解ButterKnife源码）</title>
      <link>http://yoursite.com/2019/01/13/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ButterKnife%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/13/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ButterKnife%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 13 Jan 2019 14:57:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>不知不觉，笔者已经对Android主流三方库中的网络框架OkHttp、Retrofit，图片加载框架Glide、数据库框架GreenDao、响应式编程框架RxJava、内存泄露框架LeakCanary进行了详细的分析，如果有朋友对这些开源框架的内部实现机制感兴趣的话，可以在笔者的个人主页选择相应的文章阅读。这篇，我将会对Android中的依赖注入框架ButterKnife的源码实现机制进行详细地讲解。</p><h4 id="一、简单示例"><a href="#一、简单示例" class="headerlink" title="一、简单示例"></a>一、简单示例</h4><p>首先，我们先来看一下ButterKnife的基本使用（取自<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>），如下所示：</p><pre><code>public class CollectFragment extends BaseRootFragment&lt;CollectPresenter&gt; implements CollectContract.View {    @BindView(R.id.normal_view)    SmartRefreshLayout mRefreshLayout;    @BindView(R.id.collect_recycler_view)    RecyclerView mRecyclerView;    @BindView(R.id.collect_floating_action_btn)    FloatingActionButton mFloatingActionButton;    @Nullable    @Override    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {        View view = inflater.inflate(getLayoutId(), container, false);        unBinder = ButterKnife.bind(this, view);        initView();        return view;    }    @OnClick({R.id.collect_floating_action_btn})    void onClick(View view) {        switch (view.getId()) {            case R.id.collect_floating_action_btn:                mRecyclerView.smoothScrollToPosition(0);                break;            default:                break;        }    }    @Override    public void onDestroyView() {        super.onDestroyView();        if (unBinder != null &amp;&amp; unBinder != Unbinder.EMPTY) {            unBinder.unbind();            unBinder = null;        }    }</code></pre><p>可以看到，我们使用了@BindView()替代了findViewById()方法，然后使用了@OnClick替代了setOnClickListener()方法。ButterKnife的初期版本是通过使用注解+反射这样的运行时解析的方式实现上述功能的，后面，为了改善性能，便使用了<strong>注解+APT编译时解析技术并从中生成配套模板代码的方式</strong>来实现。</p><p>在开始分析之前，可能有同学对APT不是很了解，我这里普及一下，APT是Annotation Processing Tool的缩写，即注解处理工具。它的使用步骤一般是这样的：</p><ul><li>首先声明的注解的生命周期为CLASS，即@Retention(CLASS)。</li><li>然后通过继承AbstractProcessor自定义一个注解处理器。</li><li>在编译的时候，编译器会扫描所有带有你要处理的注解的类，最后再调用AbstractProcessor的process方法，对注解进行处理。</li></ul><p>下面，我们正式来解剖一下ButterKnife的心脏。</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h4 id="2-1-模板代码解析"><a href="#2-1-模板代码解析" class="headerlink" title="2.1 模板代码解析"></a>2.1 模板代码解析</h4><p>首先，在我们编写好上述的示例代码之后，调用 gradle build 命令，在app/build/generated/source/apt下将可以找到APT为我们生产的配套模板代码CollectFragment_ViewBinding，如下所示：</p><pre><code>public class CollectFragment_ViewBinding implements Unbinder {    private CollectFragment target;    private View view2131230812;    @UiThread    public CollectFragment_ViewBinding(final CollectFragment target, View source) {      this.target = target;      View view;      // 1      target.mRefreshLayout = Utils.findRequiredViewAsType(source, R.id.normal_view, &quot;field &apos;mRefreshLayout&apos;&quot;, SmartRefreshLayout.class);      target.mRecyclerView = Utils.findRequiredViewAsType(source, R.id.collect_recycler_view, &quot;field &apos;mRecyclerView&apos;&quot;, RecyclerView.class);      view = Utils.findRequiredView(source, R.id.collect_floating_action_btn, &quot;field &apos;mFloatingActionButton&apos; and method &apos;onClick&apos;&quot;);      target.mFloatingActionButton = Utils.castView(view, R.id.collect_floating_action_btn, &quot;field &apos;mFloatingActionButton&apos;&quot;, FloatingActionButton.class);      view2131230812 = view;      // 2      view.setOnClickListener(new DebouncingOnClickListener() {        @Override        public void doClick(View p0) {          target.onClick(p0);        }      });    }    @Override    @CallSuper    public void unbind() {      CollectFragment target = this.target;      if (target == null) throw newIllegalStateException(&quot;Bindings already     cleared.&quot;);      this.target = null;      target.mRefreshLayout = null;      target.mRecyclerView = null;      target.mFloatingActionButton = null;      view2131230812.setOnClickListener(null);      view2131230812 = null;    }}</code></pre><p>生成的配套模板CollectFragment_ViewBinding中，在注释1处，使用了ButterKnife内部的工具类Utils的findRequiredViewAsType()方法来寻找控件。在注释2处，使用了view的setOnClickListener()方法来添加了一个去抖动的DebouncingOnClickListener，这样便可以防止重复点击，在重写的doClick()方法内部，直接调用了CollectFragment的onClick方法。最后，我们在深入看下Utils的findRequiredViewAsType()方法内部的实现。</p><pre><code>public static &lt;T&gt; T findRequiredViewAsType(View source, @IdRes int id, String who,  Class&lt;T&gt; cls) {    // 1    View view = findRequiredView(source, id, who);    // 2    return castView(view, id, who, cls);}public static View findRequiredView(View source, @IdRes int id, String who) {    View view = source.findViewById(id);    if (view != null) {        return view;    }    ...}public static &lt;T&gt; T castView(View view, @IdRes int id, String who, Class&lt;T&gt; cls) {    try {        return cls.cast(view);    } catch (ClassCastException e) {        ...    }}</code></pre><p>在注释1处，最终也是通过View的findViewById()方法找到相应的控件，在注释2处，通过相应Class对象的cast方法强转成对应的控件类型。</p><h4 id="2-2-ButterKnife-是怎样实现代码注入的"><a href="#2-2-ButterKnife-是怎样实现代码注入的" class="headerlink" title="2.2 ButterKnife 是怎样实现代码注入的"></a>2.2 ButterKnife 是怎样实现代码注入的</h4><p>接下来，为了使用这套模板代码，我们必须调用ButterKnife的bind()方法实现代码注入，即自动帮我们执行重复繁琐的findViewById和setOnClicklistener操作。下面我们来分析下bind()方法是如何实现注入的。</p><pre><code>@NonNull @UiThreadpublic static Unbinder bind(@NonNull Object target, @NonNull View source) {    return createBinding(target, source);}</code></pre><p>在bind()方法中调用了createBinding()，</p><pre><code>@NonNull @UiThreadpublic static Unbinder bind(@NonNull Object target, @NonNull View source) {    Class&lt;?&gt; targetClass = target.getClass();    // 1    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);    if (constructor == null) {        return Unbinder.EMPTY;    }    try {        // 2        return constructor.newInstance(target, source);    // 3    } catch (IllegalAccessException e) {    ...}</code></pre><p>首先，在注释1处，通过 findBindingConstructorForClass() 方法从 Class 中查找 constructor，这里constructor即上文生成的CollectFragment_ViewBinding类。然后，在注释2处，利用反射来新建 constructor 对象。最后，如果新建 constructor 对象失败，则会在注释3后面捕获一系列对应的异常进行自定义异常抛出处理。</p><p>下面，我们来详细分析下<br>findBindingConstructorForClass() 方法的实现逻辑。</p><pre><code>@VisibleForTestingstatic final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();@Nullable @CheckResult @UiThreadprivate static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) {    // 1    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);    if (bindingCtor != null || BINDINGS.containsKey(cls)) {        return bindingCtor;    }    // 2    String clsName = cls.getName();    if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)    || clsName.startsWith(&quot;androidx.&quot;)) {        return null;    }    try {        // 3        Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);        bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);    } catch (ClassNotFoundException e) {        // 4        bindingCtor = findBindingConstructorForClass(cls.getSuperclass());    } catch (NoSuchMethodException e) {        throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);    }    // 5    BINDINGS.put(cls, bindingCtor);    return bindingCtor;}</code></pre><p>这里，我把多余的log代码删除并把代码格式优化了一下，可以看到，findBindingConstructorForClass() 这个方法中的逻辑瞬间清晰不少，这里建议以后大家自己在分析源码的时候可以进行这样的优化重整，会带来不少好处。</p><p>重新看到 findBindingConstructorForClass() 方法，在注释1处，我们首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，这里的BINDINGS是一个LinkedHashMap对象，它保存了上述两者的映射关系。在注释2处，如果是 android，androidx，java 原生的文件，不进行处理。在注释3处，先通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象，再通过自身的getConstructor()方法获得相应的构造对象。如果在步骤3中加载不出对应的模板类对象，则会在注释4处使用类似递归的方法重新执行findBindingConstructorForClass()方法。最后，如果找到了bindingCtor模板构造对象，则将它保存在BINDINGS这个LinkedHashMap对象中。</p><p><strong>这里总结一下findBindingConstructorForClass()方法的处理：</strong></p><ul><li>1、<strong>首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，获取不到，则继续执行下面的操作</strong>。</li><li>2、<strong>如果不是android，androidx，java 原生的文件，再进行后面的处理</strong>。</li><li>3、<strong>通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象，再通过自身的getConstructor()方法获得相应的构造对象，如果获取不到，会抛出异常，在异常的处理中，我们会从当前 class 文件的父类中再去查找。如果找到了，最后会将bindingCtor对象缓存进在BINDINGS对象中</strong>。</li></ul><h4 id="2-3-ButterKnife是如何在编译时生成代码的？"><a href="#2-3-ButterKnife是如何在编译时生成代码的？" class="headerlink" title="2.3 ButterKnife是如何在编译时生成代码的？"></a>2.3 ButterKnife是如何在编译时生成代码的？</h4><p>在编译的时候，ButterKnife会通过自定义的注解处理器ButterKnifeProcessor的process方法，对编译器扫描到的要处理的类中的注解进行处理，然后通过javapoet这个库来动态生成绑定事件或者控件的模板代码，最后在运行的时候，直接调用bind方法完成绑定即可。</p><p>首先，我们先来分析下ButterKnifeProcessor的重写的入口方法init()。</p><pre><code>@Override public synchronized void init(ProcessingEnvironment env) {    super.init(env);    String sdk = env.getOptions().get(OPTION_SDK_INT);    if (sdk != null) {        try {            this.sdk = Integer.parseInt(sdk);        } catch (NumberFormatException e) {           ...        }    }    typeUtils = env.getTypeUtils();    filer = env.getFiler();    ...}</code></pre><p>可以看到，ProcessingEnviroment对象提供了两大工具类 typeUtils和filer。typeUtils的作用是用来处理TypeMirror，而Filer则是用来创建生成辅助文件。</p><p>接着我们再来看看被重写的getSupportedAnnotationTypes()方法，这个方法的作用主要是用于指定ButterknifeProcessor注册了哪些注解的。</p><pre><code>@Override public Set&lt;String&gt; getSupportedAnnotationTypes() {    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();    for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) {    types.add(annotation.getCanonicalName());    }    return types;}</code></pre><p>这里面首先创建了一个LinkedHashSet对象，然后将getSupportedAnnotations()方法返回的支持注解集合进行遍历一一添加到types中返回。</p><p>接着我们看下getSupportedAnnotations()方法，</p><pre><code>private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() {    Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;();    annotations.add(BindAnim.class);    annotations.add(BindArray.class);    annotations.add(BindBitmap.class);    annotations.add(BindBool.class);    annotations.add(BindColor.class);    annotations.add(BindDimen.class);    annotations.add(BindDrawable.class);    annotations.add(BindFloat.class);    annotations.add(BindFont.class);    annotations.add(BindInt.class);    annotations.add(BindString.class);    annotations.add(BindView.class);    annotations.add(BindViews.class);    annotations.addAll(LISTENERS);    return annotations;}</code></pre><p>可以看到，这里注册了一系列的Bindxxx注解类和监听列表LISTENERS，接着看一下LISTENERS中包含的监听方法：</p><pre><code>private static final List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(    OnCheckedChanged.class,     OnClick.class,     OnEditorAction.class,     OnFocusChange.class,     OnItemClick.class,     OnItemLongClick.class,     OnItemSelected.class,     OnLongClick.class,     OnPageChange.class,     OnTextChanged.class,     OnTouch.class );</code></pre><p>最后，我们来分析下整个ButterKnifeProcessor中最关键的方法process()。</p><pre><code>@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {    // 1    Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);    for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {        TypeElement typeElement = entry.getKey();        BindingSet binding = entry.getValue();        // 2        JavaFile javaFile = binding.brewJava(sdk, debuggable);        try {            javaFile.writeTo(filer);        } catch (IOException e) {           ...        }    }    return false;}</code></pre><p>首先，在注释1处通过findAndParseTargets()方法，知名见义，它应该就是找到并解析注解目标的关键方法了，继续看看它内部的处理：</p><pre><code>private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) {    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;();    Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;();    // 1、一系列处理每一个@Bindxxx元素的for循环代码块    ...    // Process each @BindView element.    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {        try {        // 2        parseBindView(element, builderMap, erasedTargetNames);        } catch (Exception e) {            logParsingError(element, BindView.class, e);        }    }    // Process each @BindViews element.    ...    // Process each annotation that corresponds to a listener.    for (Class&lt;? extends Annotation&gt; listener : LISTENERS) {        findAndParseListener(env, listener, builderMap, erasedTargetNames);    }    // 2    Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =        new ArrayDeque&lt;&gt;(builderMap.entrySet());    Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;();    while (!entries.isEmpty()) {        Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();        TypeElement type = entry.getKey();        BindingSet.Builder builder = entry.getValue();        TypeElement parentType = findParentType(type, erasedTargetNames);        if (parentType == null) {            bindingMap.put(type, builder.build());        } else {            BindingSet parentBinding = bindingMap.get(parentType);            if (parentBinding != null) {                builder.setParent(parentBinding);                bindingMap.put(type, builder.build());            } else {            entries.addLast(entry);            }        }    }    return bindingMap;}</code></pre><p>findAndParseTargets()方法的代码非常多，我这里尽可能做了精简。首先，在注释1处，<strong>扫描并处理所有具有@Bindxxx注解和符合LISTENERS监听方法集合的代码，然后在每一个@Bindxxx对应的for循环代码中的parseBindxxx()或findAndParseListener()方法中将解析出的信息放入builderMap</strong>这个LinkedHashMap对象中，其中builderMap是一个key为TypeElement，value为BindingSet.Builder的映射集合，这个 BindSet 是指<strong>的一个类型请求的所有绑定的集合</strong>。在注释3处，首先使用上面的builderMap对象去构建了一个entries对象，它是一个双向队列，能实现两端存取的操作。接着，又新建了一个key为TypeElement，value为BindingSet的LinkedHashMap对象，最后使用了一个while循环从entries的第一个元素开始，这里会判断当前元素类型是否有父类，如果没有，直接构建builder放入bindingMap中，如果有，则将parentBinding添加到BindingSet.Builder这个建造者对象中，然后创建BindingSet再添加到bindingMap中。</p><p>接着，我们分析下注释2处parseBindView是如何对每一个@BindView注解的元素进行处理。</p><pre><code>private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,  Set&lt;TypeElement&gt; erasedTargetNames) {    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();    // 1、首先验证生成的常见代码限制    ...    // 2、验证目标类型是否继承自View。    ...    // 3    int id = element.getAnnotation(BindView.class).value();    BindingSet.Builder builder = builderMap.get(enclosingElement);    Id resourceId = elementToId(element, BindView.class, id);    if (builder != null) {        String existingBindingName = builder.findExistingBindingName(resourceId);        if (existingBindingName != null) {            ...            return;        }    } else {        // 4        builder = getOrCreateBindingBuilder(builderMap, enclosingElement);    }    String name = simpleName.toString();    TypeName type = TypeName.get(elementType);    boolean required = isFieldRequired(element);    // 5    builder.addField(resourceId, new     FieldViewBinding(name, type, required));    // Add the type-erased version to the valid binding targets set.    erasedTargetNames.add(enclosingElement);}</code></pre><p>首先，在注释1、2处均是一些验证处理操作，如果不符合则会return。然后，我们看到注释3处，这里获取了BindView要绑定的View的id，然后先从builderMap中获取BindingSet.Builder对象，如果存在，直接return。如果不存在，则会在注释4处的<br>getOrCreateBindingBuilder()方法生成一个。我们看一下getOrCreateBindingBuilder()方法:</p><pre><code>private BindingSet.Builder getOrCreateBindingBuilder(  Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, TypeElement enclosingElement) {    BindingSet.Builder builder = builderMap.get(enclosingElement);    if (builder == null) {        builder = BindingSet.newBuilder(enclosingElement);        builderMap.put(enclosingElement, builder);    }    return builder;}</code></pre><p>可以看到，如果再次从buildMap中获取BindingSet.Builder对象，如果没有则直接调用BindingSet的newBuilder()方法新建一个BindingSet.Builder对象保存在builderMap中然后将新建的builder对象返回。</p><p>回到parseBindView()方法的注释5处，这里根据view的信息生成一个FieldViewBinding，最后添加到上边生成的builder对象中。</p><p>最后回到我们的process()方法中，现在所有的绑定的集合数据都放在了bindingMap对象中，这里使用for循环取出每一个BindingSet对象，调用它的brewJava()方法，看看它内部的处理：</p><pre><code>JavaFile brewJava(int sdk, boolean debuggable) {    TypeSpec bindingConfiguration = createType(sdk, debuggable);    return JavaFile.builder(bindingClassName.packageName(), bindingConfiguration)    .addFileComment(&quot;Generated code from Butter Knife. Do not modify!&quot;)    .build();}private TypeSpec createType(int sdk, boolean debuggable) {    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())    .addModifiers(PUBLIC);    if (isFinal) {        result.addModifiers(FINAL);    }    if (parentBinding != null) {        result.superclass(parentBinding.bindingClassName);    } else {        result.addSuperinterface(UNBINDER);    }    if (hasTargetField()) {        result.addField(targetTypeName, &quot;target&quot;, PRIVATE);    }    if (isView) {        result.addMethod(createBindingConstructorForView());    } else if (isActivity) {        result.addMethod(createBindingConstructorForActivity());    } else if (isDialog) {        result.addMethod(createBindingConstructorForDialog());    }    if (!constructorNeedsView()) {        // Add a delegating constructor with a target type + view signature for reflective use.        result.addMethod(createBindingViewDelegateConstructor());    }    result.addMethod(createBindingConstructor(sdk, debuggable));    if (hasViewBindings() || parentBinding == null) {        result.addMethod(createBindingUnbindMethod(result));    }    return result.build();}</code></pre><p>在createType()方法里面使用了java中的<a href="https://github.com/square/javapoet" target="_blank" rel="external">javapoet</a>技术生成了一个bindingConfiguration对象，很显然，它里面保存了所有的绑定配置信息。然后，通过javapoet的builder构造器将上面得到的bindingConfiguration对象构建生成一个JavaFile对象，最终，通过javaFile.writeTo(filer)生成了java源文件。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>从上面的源码分析来看，ButterKnife的执行流程总体可以分为两步：</p><ul><li>1、在编译的时候扫描注解，并通过自定义的ButterKnifeProcessor做相应的处理解析得到bindingMap对象，最后调用 javapoet 库生成 java模板 代码。</li><li>2、当我们调用 ButterKnife的bind() 方法的时候，它会根据类的全限定类型，找到相应的模板代码，并在其中完成 findViewById 和 setOnClick ，setOnLongClick 等操作。</li></ul><p>到此，ButterKnife的源码分析就结束了。接下来，笔者会对Android中的依赖注入框架Dagger2的源码实现流程进行详细的讲解，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、ButterKnife V10.0.0 源码</p><p>2、Android进阶之光</p><p>3、<a href="https://www.jianshu.com/p/0f3f4f7ca505" target="_blank" rel="external">ButterKnife源码分析</a></p><p>4、<a href="https://blog.csdn.net/gdutxiaoxu/article/details/71512754" target="_blank" rel="external">butterknife 源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/13/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ButterKnife%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（六、深入理解Leakcanary源码）</title>
      <link>http://yoursite.com/2019/01/06/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Leakcanary%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/06/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Leakcanary%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 06 Jan 2019 10:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>在Android主流三方库源码分析系列的前几篇文章中，笔者已经对网络、图片、数据库、响应式编程中最热门的第三方开源框架进行了较为深入地讲解，如果有朋友对这四块感兴趣的话，可以去了解下。本篇，我将会对Android中的内存泄露检测框架Leakcanary的源码流程进行详细地讲解。</p><h3 id="一、原理概述"><a href="#一、原理概述" class="headerlink" title="一、原理概述"></a>一、原理概述</h3><p>首先，笔者仔细查看了Leakcanary官方的github仓库，最重要的便是对<strong>Leakcanary是如何起作用的</strong>（即原理）这一问题进行了阐述，我自己把它翻译成了易于理解的文字，主要分为如下7个步骤：</p><ul><li>1、RefWatcher.watch()创建了一个KeyedWeakReference用于去观察对象。</li><li>2、然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触发GC。</li><li>3、如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中的.hprof文件里。</li><li>4、HeapAnalyzerService被开启在一个独立的进程中，并且HeapAnalyzer使用了HAHA开源库解析了指定时刻的堆栈快照文件heap dump。</li><li>5、从heap dump中，HeapAnalyzer根据一个独特的引用key找到了KeyedWeakReference，并且定位了泄露的引用。</li><li>6、HeapAnalyzer为了确定是否有泄露，计算了到GC Roots的最短强引用路径，然后建立了导致泄露的链式引用。</li><li>7、这个结果被传回到app进程中的DisplayLeakService，然后一个泄露通知便展现出来了。</li></ul><p>官方的原理简单来解释就是这样的：<strong>在一个Activity执行完onDestroy()之后，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有没有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。</strong></p><h3 id="二、简单示例"><a href="#二、简单示例" class="headerlink" title="二、简单示例"></a>二、简单示例</h3><p>下面这段是Leakcanary官方仓库的示例代码：</p><p>首先在你项目app下的build.gradle中配置:</p><pre><code>dependencies {  debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.6.2&apos;  releaseImplementation   &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.6.2&apos;  // 可选，如果你使用支持库的fragments的话  debugImplementation   &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.2&apos;}</code></pre><p>然后在你的Application中配置:</p><pre><code>public class WanAndroidApp extends Application {    private RefWatcher refWatcher;    public static RefWatcher getRefWatcher(Context context) {        WanAndroidApp application = (WanAndroidApp)     context.getApplicationContext();        return application.refWatcher;    }    @Override public void onCreate() {      super.onCreate();      if (LeakCanary.isInAnalyzerProcess(this)) {        // 1        return;      }      // 2      refWatcher = LeakCanary.install(this);    }}</code></pre><p>在注释1处，会首先判断当前进程是否是Leakcanary专门用于分析heap内存的而创建的那个进程，即HeapAnalyzerService所在的进程，如果是的话，则不进行Application中的初始化功能。如果是当前应用所处的主进程的话，则会执行注释2处的LeakCanary.install(this)进行LeakCanary的安装。只需这样简单的几行代码，我们就可以在应用中检测是否产生了内存泄露了。当然，这样使用只会检测Activity是否发生内存泄漏，如果要检测Fragment在执行完onDestroy()之后是否发生内存泄露的话，则需要在Fragment的onDestroy()方法中加上如下两行代码去监视当前的Fragment：</p><pre><code>RefWatcher refWatcher = WanAndroidApp.getRefWatcher(_mActivity);refWatcher.watch(this);</code></pre><p>上面的RefWatcher其实就是一个引用观察者对象，是用于监测当前实例对象的引用状态的。从以上的分析可以了解到，核心代码就是LeakCanary.install(this)这行代码，接下来，就从这里出发将LeakCanary一步一步进行拆解。</p><h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><h4 id="1、LeakCanary-install"><a href="#1、LeakCanary-install" class="headerlink" title="1、LeakCanary#install()"></a>1、LeakCanary#install()</h4><pre><code>public static @NonNull RefWatcher install(@NonNull Application application) {  return refWatcher(application).listenerServiceClass(DisplayLeakService.class)      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())      .buildAndInstall();}</code></pre><p>在install()方法中的处理，可以分解为如下四步：</p><ul><li>1、refWatcher(application)</li><li>2、链式调用listenerServiceClass(DisplayLeakService.class)</li><li>3、链式调用excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</li><li>4、链式调用uildAndInstall()</li></ul><p>首先，我们来看下第一步，这里调用了LeakCanary类的refWatcher方法，如下所示：</p><pre><code>public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {  return new AndroidRefWatcherBuilder(context);}</code></pre><p>然后新建了一个AndroidRefWatcherBuilder对象，再看看AndroidRefWatcherBuilder这个类。</p><h4 id="2、AndroidRefWatcherBuilder"><a href="#2、AndroidRefWatcherBuilder" class="headerlink" title="2、AndroidRefWatcherBuilder"></a>2、AndroidRefWatcherBuilder</h4><pre><code>/** A {@link RefWatcherBuilder} with appropriate Android defaults. */public final class AndroidRefWatcherBuilder extends     RefWatcherBuilder&lt;AndroidRefWatcherBuilder&gt; {...    AndroidRefWatcherBuilder(@NonNull Context context) {        this.context = context.getApplicationContext();    }...}</code></pre><p>在AndroidRefWatcherBuilder的构造方法中仅仅是将外部传入的applicationContext对象保存起来了。AndroidRefWatcherBuilder是一个适配Android平台的引用观察者构造器对象，它继承了RefWatcherBuilder，RefWatcherBuilder是一个负责建立引用观察者RefWatcher实例的基类构造器。继续看看RefWatcherBuilder这个类。</p><h4 id="3、RefWatcherBuilder"><a href="#3、RefWatcherBuilder" class="headerlink" title="3、RefWatcherBuilder"></a>3、RefWatcherBuilder</h4><pre><code>public class RefWatcherBuilder&lt;T extends RefWatcherBuilder&lt;T&gt;&gt; {    ...    public RefWatcherBuilder() {        heapDumpBuilder = new HeapDump.Builder();    }    ...}</code></pre><p>在RefWatcher的基类构造器RefWatcherBuilder的构造方法中新建了一个HeapDump的构造器对象。其中HeapDump就是一个保存heap dump信息的数据结构。</p><p>接着来分析下install()方法中的链式调用的listenerServiceClass(DisplayLeakService.class)这部分逻辑。</p><h4 id="4、AndroidRefWatcherBuilder-listenerServiceClass"><a href="#4、AndroidRefWatcherBuilder-listenerServiceClass" class="headerlink" title="4、AndroidRefWatcherBuilder#listenerServiceClass()"></a>4、AndroidRefWatcherBuilder#listenerServiceClass()</h4><pre><code>public @NonNull AndroidRefWatcherBuilder listenerServiceClass(  @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {    return heapDumpListener(new ServiceHeapDumpListener(context,     listenerServiceClass));}</code></pre><p>在这里，传入了一个DisplayLeakService的Class对象，它的作用是展示泄露分析的结果日志，然后会展示一个用于跳转到显示泄露界面DisplayLeakActivity的通知。在listenerServiceClass()这个方法中新建了一个ServiceHeapDumpListener对象，看看它内部的操作。</p><h4 id="5、ServiceHeapDumpListener"><a href="#5、ServiceHeapDumpListener" class="headerlink" title="5、ServiceHeapDumpListener"></a>5、ServiceHeapDumpListener</h4><pre><code>public final class ServiceHeapDumpListener implements HeapDump.Listener {    ...    public ServiceHeapDumpListener(@NonNull final Context context,        @NonNull final Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {      this.listenerServiceClass = checkNotNull(listenerServiceClass, &quot;listenerServiceClass&quot;);      this.context = checkNotNull(context, &quot;context&quot;).getApplicationContext();    }    ...}</code></pre><p>可以看到这里仅仅是在ServiceHeapDumpListener中保存了DisplayLeakService的Class对象和application对象。它的作用就是接收一个heap dump去分析。</p><p>然后我们继续看install()方法链式调用.excludedRefs(AndroidExcludedRefs.createAppDefaults().build())的这部分代码。先看AndroidExcludedRefs.createAppDefaults()。</p><h4 id="6、AndroidExcludedRefs-createAppDefaults"><a href="#6、AndroidExcludedRefs-createAppDefaults" class="headerlink" title="6、AndroidExcludedRefs#createAppDefaults()"></a>6、AndroidExcludedRefs#createAppDefaults()</h4><pre><code>public enum AndroidExcludedRefs {    ...    public static @NonNull ExcludedRefs.Builder createAppDefaults() {      return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));    }    public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet&lt;AndroidExcludedRefs&gt; refs) {      ExcludedRefs.Builder excluded = ExcludedRefs.builder();      for (AndroidExcludedRefs ref : refs) {        if (ref.applies) {          ref.add(excluded);          ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());        }      }      return excluded;    }    ...}</code></pre><p>先来说下AndroidExcludedRefs这个类，它是一个enum类，它声明了Android SDK和厂商定制的SDK中存在的内存泄露的case，根据AndroidExcludedRefs这个类的类名就可看出这些case都会被Leakcanary的监测过滤掉。目前这个版本是有46种这样的case被包含在内，后续可能会一直增加。然后EnumSet.allOf(AndroidExcludedRefs.class)这个方法将会返回一个包含AndroidExcludedRefs元素类型的EnumSet。Enum是一个抽象类，在这里具体的实现类是通用正规型的RegularEnumSet，如果Enum里面的元素个数大于64，则会使用存储大数据量的JumboEnumSet。最后，在createBuilder这个方法里面构建了一个排除引用的建造器excluded，将各式各样的case分门别类地保存起来再返回出去。</p><p>最后，我们看到链式调用的最后一步buildAndInstall()。</p><h4 id="7、AndroidRefWatcherBuilder-buildAndInstall"><a href="#7、AndroidRefWatcherBuilder-buildAndInstall" class="headerlink" title="7、AndroidRefWatcherBuilder#buildAndInstall()"></a>7、AndroidRefWatcherBuilder#buildAndInstall()</h4><pre><code>private boolean watchActivities = true;private boolean watchFragments = true;public @NonNull RefWatcher buildAndInstall() {    // 1    if (LeakCanaryInternals.installedRefWatcher != null) {      throw new UnsupportedOperationException(&quot;buildAndInstall() should only be called once.&quot;);    }    // 2    RefWatcher refWatcher = build();    if (refWatcher != DISABLED) {      // 3      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);      if (watchActivities) {        // 4        ActivityRefWatcher.install(context, refWatcher);      }      if (watchFragments) {        // 5        FragmentRefWatcher.Helper.install(context, refWatcher);      }    }    // 6    LeakCanaryInternals.installedRefWatcher = refWatcher;    return refWatcher;}</code></pre><p>首先，在注释1处，会判断LeakCanaryInternals.installedRefWatcher是否已经被赋值，如果被赋值了，则会抛出异常，警告<br>buildAndInstall()这个方法应该仅仅只调用一次，在此方法结束时，即在注释6处，该LeakCanaryInternals.installedRefWatcher才会被赋值。再来看注释2处，调用了AndroidRefWatcherBuilder其基类RefWatcherBuilder的build()方法，我们它是如何建造的。</p><h4 id="8、RefWatcherBuilder-build"><a href="#8、RefWatcherBuilder-build" class="headerlink" title="8、RefWatcherBuilder#build()"></a>8、RefWatcherBuilder#build()</h4><pre><code>public final RefWatcher build() {    if (isDisabled()) {      return RefWatcher.DISABLED;    }    if (heapDumpBuilder.excludedRefs == null) {      heapDumpBuilder.excludedRefs(defaultExcludedRefs());    }    HeapDump.Listener heapDumpListener = this.heapDumpListener;    if (heapDumpListener == null) {      heapDumpListener = defaultHeapDumpListener();    }    DebuggerControl debuggerControl = this.debuggerControl;    if (debuggerControl == null) {      debuggerControl = defaultDebuggerControl();    }    HeapDumper heapDumper = this.heapDumper;    if (heapDumper == null) {      heapDumper = defaultHeapDumper();    }    WatchExecutor watchExecutor = this.watchExecutor;    if (watchExecutor == null) {      watchExecutor = defaultWatchExecutor();    }    GcTrigger gcTrigger = this.gcTrigger;    if (gcTrigger == null) {      gcTrigger = defaultGcTrigger();    }    if (heapDumpBuilder.reachabilityInspectorClasses == null) {      heapDumpBuilder.reachabilityInspectorClasses(defa  ultReachabilityInspectorClasses());    }    return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,        heapDumpBuilder);}</code></pre><p>可以看到，RefWatcherBuilder包含了7个组成部分</p><ul><li><p>1、excludedRefs : 记录可以被忽略的泄漏路径。</p></li><li><p>2、heapDumpListener : 转储堆信息到hprof文件，并在解析完 hprof 文件后进行回调，最后通知 DisplayLeakService 弹出泄漏提醒。</p></li><li><p>3、debuggerControl : 判断是否处于调试模式，调试模式中不会进行内存泄漏检测。为什么呢？因为<strong>在调试过程中可能会保留上一个引用从而导致错误信息上报</strong>。</p></li><li><p>4、heapDumper : 堆信息转储者，dump 内存泄漏处的 heap 信息到 hprof 文件</p></li><li><p>5、watchExecutor : 线程控制器，在 onDestroy() 之后并且主线程空闲时执行内存泄漏检测</p></li><li><p>6、gcTrigger : 用于 GC，watchExecutor 首次检测到可能的内存泄漏，会主动进行 GC，GC 之后会再检测一次，仍然泄漏的判定为内存泄漏，最后根据heapDump信息生成相应的泄漏引用链。</p></li><li><p>7、reachabilityInspectorClasses : 用于要进行可达性检测的类列表。</p></li></ul><p>最后，会使用建造者模式将这些组成部分构建成一个新的RefWatcher并将其返回。</p><p>我们继续看回到AndroidRefWatcherBuilder的注释3处的 LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true)这行代码。</p><h4 id="9、LeakCanaryInternals-setEnabledAsync"><a href="#9、LeakCanaryInternals-setEnabledAsync" class="headerlink" title="9、LeakCanaryInternals#setEnabledAsync()"></a>9、LeakCanaryInternals#setEnabledAsync()</h4><pre><code>public static void setEnabledAsync(Context context, final Class&lt;?&gt; componentClass,final boolean enabled) {  final Context appContext = context.getApplicationContext();  AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {    @Override public void run() {      setEnabledBlocking(appContext, componentClass, enabled);    }  });}</code></pre><p>在这里使用了AsyncTask内部自带的THREAD_POOL_EXECUTOR线程池进行阻塞式地显示DisplayLeakActivity。</p><p>然后我们再继续看AndroidRefWatcherBuilder的注释4处的代码。</p><h4 id="10、ActivityRefWatcher-install"><a href="#10、ActivityRefWatcher-install" class="headerlink" title="10、ActivityRefWatcher#install()"></a>10、ActivityRefWatcher#install()</h4><pre><code>public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {    Application application = (Application) context.getApplicationContext();    // 1    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);    // 2    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);}</code></pre><p>可以看到，在注释1处创建一个自己的activityRefWatcher实例，并在注释2处调用了application的registerActivityLifecycleCallbacks()方法，这样就能够监听activity对应的生命周期事件了。继续看看activityRefWatcher.lifecycleCallbacks里面的操作。</p><pre><code>private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =    new ActivityLifecycleCallbacksAdapter() {      @Override public void onActivityDestroyed(Activity activity) {          refWatcher.watch(activity);      }};public abstract class ActivityLifecycleCallbacksAdapterimplements Application.ActivityLifecycleCallbacks {}</code></pre><p>很明显，实现并重写了Application的ActivityLifecycleCallbacks的onActivityDestroyed()方法，这样便能在所有Activity执行完onDestroyed()方法之后调用 refWatcher.watch(activity)这行代码进行内存泄漏的检测了。</p><p>我们再看会注释5处的FragmentRefWatcher.Helper.install(context, refWatcher)这行代码，</p><h4 id="11、FragmentRefWatcher-Helper-install"><a href="#11、FragmentRefWatcher-Helper-install" class="headerlink" title="11、FragmentRefWatcher.Helper#install()"></a>11、FragmentRefWatcher.Helper#install()</h4><pre><code>public interface FragmentRefWatcher {    void watchFragments(Activity activity);    final class Helper {      private static final String SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME =          &quot;com.squareup.leakcanary.internal.SupportFragmentRefWatcher&quot;;      public static void install(Context context, RefWatcher refWatcher) {        List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = new ArrayList&lt;&gt;();        // 1        if (SDK_INT &gt;= O) {          fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher));        }        // 2        try {          Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);          Constructor&lt;?&gt; constructor =              fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);          FragmentRefWatcher supportFragmentRefWatcher   =              (FragmentRefWatcher) constructor.newInstance(refWatcher);          fragmentRefWatchers.add(supportFragmentRefWatcher);        } catch (Exception ignored) {        }        if (fragmentRefWatchers.size() == 0) {          return;        }        Helper helper = new Helper(fragmentRefWatchers);        // 3        Application application = (Application) context.getApplicationContext();        application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);      }    ...}</code></pre><p>这里面的逻辑很简单，首先在注释1处将Android标准的Fragment的RefWatcher类，即AndroidOFragmentRefWatcher添加到新创建的fragmentRefWatchers中。在注释2处使用反射将leakcanary-support-fragment包下面的SupportFragmentRefWatcher添加进来，如果你在app的build.gradle下没有添加下面这行引用的话，则会拿不到此类，即LeakCanary只会兼顾监测Activity和标准Fragment这两种情况。</p><pre><code>debugImplementation   &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.2&apos;</code></pre><p>继续看到注释3处helper.activityLifecycleCallbacks里面的代码。</p><pre><code>private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =    new ActivityLifecycleCallbacksAdapter() {      @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {        for (FragmentRefWatcher watcher : fragmentRefWatchers) {            watcher.watchFragments(activity);        }    }};</code></pre><p>可以看到，在Activity执行完onActivityCreated()方法之后，会调用指定watcher的watchFragments()方法，注意，这里的watcher可能有两种，但不管是哪一种，都会使用当前传入的activity获取到对应的FragmentManager/SupportFragmentManager对象，调用它的registerFragmentLifecycleCallbacks()方法，在对应的onDestroyView()和onDestoryed()方法执行完后，分别使用refWatcher.watch(view)和refWatcher.watch(fragment)进行内存泄漏的检测，代码如下所示。</p><pre><code>@Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {    View view = fragment.getView();    if (view != null) {        refWatcher.watch(view);    }}@Overridepublic void onFragmentDestroyed(FragmentManagerfm, Fragment fragment) {    refWatcher.watch(fragment);}</code></pre><p>注意，下面到真正关键的地方了，接下来分析refWatcher.watch()这行代码。</p><h4 id="12、RefWatcher-watch"><a href="#12、RefWatcher-watch" class="headerlink" title="12、RefWatcher#watch()"></a>12、RefWatcher#watch()</h4><pre><code>public void watch(Object watchedReference, String referenceName) {    if (this == DISABLED) {      return;    }    checkNotNull(watchedReference, &quot;watchedReference&quot;);    checkNotNull(referenceName, &quot;referenceName&quot;);    final long watchStartNanoTime = System.nanoTime();    // 1    String key = UUID.randomUUID().toString();    // 2    retainedKeys.add(key);    // 3    final KeyedWeakReference reference =        new KeyedWeakReference(watchedReference, key, referenceName, queue);    // 4    ensureGoneAsync(watchStartNanoTime, reference);}</code></pre><p>注意到在注释1处使用随机的UUID保证了每个检测对象对应的<br>key 的唯一性。在注释2处将生成的key添加到类型为CopyOnWriteArraySet的Set集合中。在注释3处新建了一个自定义的弱引用KeyedWeakReference，看看它内部的实现。</p><h4 id="13、KeyedWeakReference"><a href="#13、KeyedWeakReference" class="headerlink" title="13、KeyedWeakReference"></a>13、KeyedWeakReference</h4><pre><code>final class KeyedWeakReference extends WeakReference&lt;Object&gt; {    public final String key;    public final String name;    KeyedWeakReference(Object referent, String key, String name,        ReferenceQueue&lt;Object&gt; referenceQueue) {      // 1      super(checkNotNull(referent, &quot;referent&quot;), checkNotNull(referenceQueue, &quot;referenceQueue&quot;));      this.key = checkNotNull(key, &quot;key&quot;);      this.name = checkNotNull(name, &quot;name&quot;);    }}</code></pre><p>可以看到，在KeyedWeakReference内部，使用了key和name标识了一个被检测的WeakReference对象。在注释1处，将弱引用和引用队列 ReferenceQueue 关联起来，如果弱引用referent持有的对象被GC回收，JVM就会把这个弱引用加入到与之关联的引用队列referenceQueue中。即 KeyedWeakReference 持有的 Activity 对象如果被GC回收，该对象就会加入到引用队列 referenceQueue 中。</p><p>接着我们回到RefWatcher.watch()里注释4处的ensureGoneAsync()方法。</p><h4 id="14、RefWatcher-ensureGoneAsync"><a href="#14、RefWatcher-ensureGoneAsync" class="headerlink" title="14、RefWatcher#ensureGoneAsync()"></a>14、RefWatcher#ensureGoneAsync()</h4><pre><code>private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {    // 1    watchExecutor.execute(new Retryable() {        @Override public Retryable.Result run() {            // 2            return ensureGone(reference watchStartNanoTime);        }    });}</code></pre><p>在ensureGoneAsync()方法中，在注释1处使用 watchExecutor 执行了注释2处的 ensureGone 方法，watchExecutor 是 AndroidWatchExecutor 的实例。</p><p>下面看看watchExecutor内部的逻辑。</p><h4 id="15、AndroidWatchExecutor"><a href="#15、AndroidWatchExecutor" class="headerlink" title="15、AndroidWatchExecutor"></a>15、AndroidWatchExecutor</h4><pre><code>public final class AndroidWatchExecutor implements WatchExecutor {    ...    public AndroidWatchExecutor(long initialDelayMillis)     {      mainHandler = new Handler(Looper.getMainLooper());      HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);      handlerThread.start();      // 1      backgroundHandler = new Handler(handlerThread.getLooper());      this.initialDelayMillis = initialDelayMillis;      maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;    }    @Override public void execute(@NonNull Retryable retryable) {      // 2      if (Looper.getMainLooper().getThread() == Thread.currentThread()) {        waitForIdle(retryable, 0);      } else {        postWaitForIdle(retryable, 0);      }    }    ...}</code></pre><p>在注释1处AndroidWatchExecutor的构造方法中，注意到这里使用HandlerThread的looper新建了一个backgroundHandler，后面会用到。在注释2处，会判断当前线程是否是主线程，如果是，则直接调用waitForIdle()方法，如果不是，则调用postWaitForIdle()，来看看这个方法。</p><pre><code>private void postWaitForIdle(final Retryable retryable, final int failedAttempts) {  mainHandler.post(new Runnable() {    @Override public void run() {      waitForIdle(retryable, failedAttempts);    }  });}</code></pre><p>很清晰，这里使用了在构造方法中用主线程looper构造的mainHandler进行post，那么waitForIdle()最终也会在主线程执行。接着看看waitForIdle()的实现。</p><pre><code>private void waitForIdle(final Retryable retryable,     final int failedAttempts) {  Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {    @Override public boolean queueIdle() {      postToBackgroundWithDelay(retryable, failedAttempts);      return false;    }  });}</code></pre><p>这里MessageQueue.IdleHandler()回调方法的作用是当 looper 空闲的时候，会回调 queueIdle 方法，然后执行内部的postToBackgroundWithDelay()方法。接下来看看它的实现。</p><pre><code>private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {  long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts),     maxBackoffFactor);  // 1  long delayMillis = initialDelayMillis * exponentialBackoffFactor;  // 2  backgroundHandler.postDelayed(new Runnable() {    @Override public void run() {      // 3      Retryable.Result result = retryable.run();      // 4      if (result == RETRY) {        postWaitForIdle(retryable, failedAttempts +   1);      }    }  }, delayMillis);}</code></pre><p>先看到注释4处，可以明白，postToBackgroundWithDelay()是一个递归方法，如果result 一直等于RETRY的话，则会一直执行postWaitForIdle()方法。在回到注释1处，这里initialDelayMillis 的默认值是 5s，因此delayMillis就是5s。在注释2处，使用了在构造方法中用HandlerThread的looper新建的backgroundHandler进行异步延时执行retryable的run()方法。这个run()方法里执行的就是RefWatcher的ensureGoneAsync()方法中注释2处的ensureGone()这行代码，继续看它内部的逻辑。</p><h4 id="16、RefWatcher-ensureGone"><a href="#16、RefWatcher-ensureGone" class="headerlink" title="16、RefWatcher#ensureGone()"></a>16、RefWatcher#ensureGone()</h4><pre><code>Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {    long gcStartNanoTime = System.nanoTime();    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime -     watchStartNanoTime);    // 1    removeWeaklyReachableReferences();    // 2    if (debuggerControl.isDebuggerAttached()) {      // The debugger can create false leaks.      return RETRY;    }    // 3    if (gone(reference)) {      return DONE;    }    // 4    gcTrigger.runGc();    removeWeaklyReachableReferences();    // 5    if (!gone(reference)) {      long startDumpHeap = System.nanoTime();      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);      File heapDumpFile = heapDumper.dumpHeap();      if (heapDumpFile == RETRY_LATER) {        // Could not dump the heap.        return RETRY;      }      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)          .referenceName(reference.name)          .watchDurationMs(watchDurationMs)          .gcDurationMs(gcDurationMs)          .heapDumpDurationMs(heapDumpDurationMs)          .build();      heapdumpListener.analyze(heapDump);    }    return DONE;}</code></pre><p>在注释1处，执行了removeWeaklyReachableReferences()这个方法，接下来分析下它的含义。</p><pre><code>private void removeWeaklyReachableReferences() {    KeyedWeakReference ref;    while ((ref = (KeyedWeakReference) queue.poll()) != null) {        retainedKeys.remove(ref.key);    }}</code></pre><p>这里使用了while循环遍历 ReferenceQueue ，并从 retainedKeys中移除对应的Reference。</p><p>再看到注释2处，当Android设备处于debug状态时，会直接返回RETRY进行延时重试检测的操作。在注释3处，我们看看gone(reference)这个方法的逻辑。</p><pre><code>private boolean gone(KeyedWeakReference reference) {    return !retainedKeys.contains(reference.key);}</code></pre><p>这里会判断 retainedKeys 集合中是否还含有 reference，若没有，证明已经被回收了，若含有，可能已经发生内存泄露（或Gc还没有执行回收）。前面的分析中我们知道了 reference 被回收的时候，会被加进 referenceQueue 里面，然后我们会调用removeWeaklyReachableReferences()遍历 referenceQueue 移除掉 retainedKeys 里面的 refrence。</p><p>接着我们看到注释4处，执行了gcTrigger的runGc()方法进行垃圾回收，然后使用了removeWeaklyReachableReferences()方法移除已经被回收的引用。这里我们在深入地分析下runGc()的实现。</p><pre><code>GcTrigger DEFAULT = new GcTrigger() {    @Override public void runGc() {      // Code taken from AOSP FinalizationTest:      // https://android.googlesource.com/platform/libc  ore/+/master/support/src/test/java/libcore/      // java/lang/ref/FinalizationTester.java      // System.gc() does not garbage collect every   time. Runtime.gc() is      // more likely to perform a gc.      Runtime.getRuntime().gc();      enqueueReferences();      System.runFinalization();    }    private void enqueueReferences() {      // Hack. We don&apos;t have a programmatic way to wait   for the reference queue daemon to move      // references to the appropriate queues.      try {        Thread.sleep(100);      } catch (InterruptedException e) {        throw new AssertionError();      }    }};</code></pre><p>这里并没有使用System.gc()方法进行回收，因为system.gc()并不会每次都执行。而是从AOSP中拷贝一段GC回收的代码，从而相比System.gc()更能够保证进行垃圾回收的工作。</p><p>最后我们分析下注释5处的代码处理。首先会判断activity 如果还没有被回收，则证明发生内存泄露，进行if判断里面的操作。在里面先调用堆信息转储者heapDumper的dumpHeap()生成相应的 hprof 文件。这里的heapDumper是一个HeapDumper接口，具体的实现是AndroidHeapDumper。我们分析下AndroidHeapDumper的dumpHeap()方法是如何生成hprof文件的。</p><pre><code>public File dumpHeap() {    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();    if (heapDumpFile == RETRY_LATER) {        return RETRY_LATER;    }    ...    try {      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());      ...      return heapDumpFile;    } catch (Exception e) {      ...      // Abort heap dump      return RETRY_LATER;    }}</code></pre><p>这里的核心操作就是调用了<br>Android SDK的API Debug.dumpHprofData() 来生成 hprof 文件。</p><p>如果这个文件等于RETRY_LATER则表示生成失败，直接返回RETRY进行延时重试检测的操作。如果不等于的话，则表示生成成功，最后会执行heapdumpListener的analyze()对新创建的HeapDump对象进行泄漏分析。由前面对AndroidRefWatcherBuilder的listenerServiceClass()的分析可知，heapdumpListener的实现<br>就是ServiceHeapDumpListener，接着看到ServiceHeapDumpListener的analyze方法。</p><h4 id="17、ServiceHeapDumpListener-analyze"><a href="#17、ServiceHeapDumpListener-analyze" class="headerlink" title="17、ServiceHeapDumpListener#analyze()"></a>17、ServiceHeapDumpListener#analyze()</h4><pre><code>@Override public void analyze(@NonNull HeapDump heapDump) {    checkNotNull(heapDump, &quot;heapDump&quot;);    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);}</code></pre><p>可以看到，这里执行了HeapAnalyzerService的runAnalysis()方法，为了避免减慢app进程或占用内存，这里将HeapAnalyzerService设置在了一个独立的进程中。接着继续分析runAnalysis()方法里面的处理。</p><pre><code>public final class HeapAnalyzerService extends ForegroundServiceimplements AnalyzerProgressListener {    ...    public static void runAnalysis(Context context, HeapDump heapDump,    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {        ...        ContextCompat.startForegroundService(context, intent);    }    ...    @Override protected void onHandleIntentInForeground(@Nullable Intent intent) {        ...        // 1        HeapAnalyzer heapAnalyzer =            new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);        // 2        AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,        heapDump.computeRetainedHeapSize);        // 3        AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);    }        ...}</code></pre><p>这里的HeapAnalyzerService实质是一个类型为IntentService的ForegroundService，执行startForegroundService()之后，会回调onHandleIntentInForeground()方法。注释1处，首先会新建一个HeapAnalyzer对象，顾名思义，它就是根据RefWatcher生成的heap dumps信息来分析被怀疑的泄漏是否是真的。在注释2处，然后会调用它的checkForLeak()方法去使用haha库解析 hprof文件，如下所示：</p><pre><code>public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,  @NonNull String referenceKey,  boolean computeRetainedSize) {    ...    try {    listener.onProgressUpdate(READING_HEAP_DUMP_FILE);    // 1    HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);    // 2    HprofParser parser = new HprofParser(buffer);    listener.onProgressUpdate(PARSING_HEAP_DUMP);    Snapshot snapshot = parser.parse();    listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);    // 3    deduplicateGcRoots(snapshot);    listener.onProgressUpdate(FINDING_LEAKING_REF);    // 4    Instance leakingRef = findLeakingReference(referenceKey, snapshot);    // 5    if (leakingRef == null) {        return noLeak(since(analysisStartNanoTime));    }    // 6    return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);    } catch (Throwable e) {    return failure(e, since(analysisStartNanoTime));    }}</code></pre><p>在注释1处，会新建一个内存映射缓存文件buffer。在注释2处，会使用buffer新建一个HprofParser解析器去解析出对应的引用内存快照文件snapshot。在注释3处，为了减少在Android 6.0版本中重复GCRoots带来的内存压力的影响，使用deduplicateGcRoots()删除了gcRoots中重复的根对象RootObj。在注释4处，调用了findLeakingReference()方法将传入的referenceKey和snapshot对象里面所有类实例的字段值对应的keyCandidate进行比较，如果没有相等的，则表示没有发生内存泄漏，直接调用注释5处的代码返回一个没有泄漏的分析结果AnalysisResult对象。如果找到了相等的，则表示发生了内存泄漏，执行注释6处的代码findLeakTrace()方法返回一个有泄漏分析结果的AnalysisResult对象。</p><p>最后，我们来分析下HeapAnalyzerService中注释3处的AbstractAnalysisResultService.sendResultToListener()方法，很明显，这里AbstractAnalysisResultService的实现类就是我们刚开始分析的用于展示泄漏路径信息得DisplayLeakService对象。在里面直接创建一个由PendingIntent构建的泄漏通知用于供用户点击去展示详细的泄漏界面DisplayLeakActivity。核心代码如下所示：</p><pre><code>public class DisplayLeakService extends AbstractAnalysisResultService {    @Override    protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {        ...        boolean resultSaved = false;        boolean shouldSaveResult = result.leakFound || result.failure != null;        if (shouldSaveResult) {            heapDump = renameHeapdump(heapDump);            // 1            resultSaved = saveResult(heapDump, result);        }        if (!shouldSaveResult) {            ...            showNotification(null, contentTitle, contentText);        } else if (resultSaved) {            ...            // 2            PendingIntent pendingIntent =                DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);            ...            showNotification(pendingIntent, contentTitle, contentText);        } else {             onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));        }    ...}@Override protected final void onAnalysisResultFailure(String failureMessage) {    super.onAnalysisResultFailure(failureMessage);    String failureTitle = getString(R.string.leak_canary_result_failure_title);    showNotification(null, failureTitle, failureMessage);}</code></pre><p>可以看到，只要当分析的堆信息文件保存成功之后，即在注释1处返回的resultSaved为true时，才会执行注释2处的逻辑，即创建一个供用户点击跳转到DisplayLeakActivity的延时通知。最后给出一张源码流程图用于回顾：</p><p><img src="https://ww1.sinaimg.cn/large/006dXScfly1fj22w7flt4j30z00mrtc0.jpg" alt="image"></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>性能优化一直是Android中的进阶和深入的方向之一，而内存泄漏一直是性能优化中比较重要的一部分，Android Studio自身提供了MAT等工具去分析内存泄漏，但是分析起来比较耗时，因而才诞生了LeakCanary，它的使用非常简单，但是经过对它的深入分析之后，才发现，<strong>简单的API后面往往藏着许多复杂的逻辑处理</strong>。接下来，下篇笔者将会为大家带来Android中的第三方依赖注入框架ButterKnife的源码分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、LeakCanary V1.6.2 源码</p><p>2、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243402&amp;idx=1&amp;sn=e7632788e8e147320b26a1b006cabf4c&amp;chksm=88637025bf14f933dcf90fbd1d7f9090e3802dd37759cac014ac1ed73c455fb9b5d9953bb89f&amp;scene=38#wechat_redirect" target="_blank" rel="external">一步步拆解 LeakCanary</a></p><p>3、<a href="https://allenwu.itscoder.com/leakcanary-source" target="_blank" rel="external">深入理解 Android 之 LeakCanary 源码解析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/06/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Leakcanary%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（五、深入理解RxJava源码）</title>
      <link>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Tue, 01 Jan 2019 15:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>到目前为止笔者分析了Android中最热门的网络底层和封装框架：<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>，Android中使用最广泛的图片加载框架Glide的加载流程：<a href="https://jsonchao.github.io/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>以及Android中性能最好的数据库框架<a href="https://jsonchao.github.io/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（四、深入理解GreenDao源码）</a>。本篇，我将会对近几年比较热门的函数式编程框架RxJava的源码进行详细的分析。</p><h3 id="一、RxJava到底是什么？"><a href="#一、RxJava到底是什么？" class="headerlink" title="一、RxJava到底是什么？"></a>一、RxJava到底是什么？</h3><p>RxJava是基于Java虚拟机上的响应式扩展库，它通过<strong>使用可观察的序列将异步和基于事件的程序组合起来</strong>。<br>与此同时，它<strong>扩展了观察者模式来支持数据/事件序列</strong>，并且添加了操作符，这些<strong>操作符允许你声明性地组合序列</strong>，同时抽象出要关注的问题：比如低级线程、同步、线程安全和并发数据结构等。</p><p>从RxJava的官方定义来看，我们如果要想真正地理解RxJava，就必须对它以下两个部分进行深入的分析：</p><ul><li>1、<strong>订阅流程</strong>。</li><li>2、<strong>线程切换</strong>。</li></ul><p>当然，RxJava操作符的源码也是很不错的学习资源，特别是FlatMap、Zip等操作符的源码，有很多可以借鉴的地方，但是它们内部的实现比较复杂，限于篇幅，本文只讲解RxJava的订阅流程和线程切换原理。接下来，笔者一一对以上RxJava的两个关键部分来进行详细地讲解。</p><h3 id="二、RxJava的订阅流程"><a href="#二、RxJava的订阅流程" class="headerlink" title="二、RxJava的订阅流程"></a>二、RxJava的订阅流程</h3><p>首先给出RxJava消息订阅的例子：</p><pre><code>Observable.create(newObservableOnSubscribe&lt;String&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }}).subscribe(new Observer&lt;String&gt;() {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;onSubscribe&quot;);    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;onNext : &quot; + s);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;onError : &quot; + e.toString());    }    @Override    public void onComplete() {        Log.d(TAG, &quot;onComplete&quot;);    }});</code></pre><p>可以看到，这里首先创建了一个被观察者，然后创建一个观察者订阅了这个被观察者，因此下面分两个部分对RxJava的订阅流程进行分析：</p><ul><li>1、<strong>创建被观察者过程</strong>。</li><li>2、<strong>订阅过程；</strong>。</li></ul><h4 id="1、创建被观察者过程"><a href="#1、创建被观察者过程" class="headerlink" title="1、创建被观察者过程"></a>1、创建被观察者过程</h4><p>首先，上面使用了Observable类的create()方法创建了一个被观察者，看看里面做了什么。</p><h5 id="1-1、Observable-create"><a href="#1-1、Observable-create" class="headerlink" title="1.1、Observable#create()"></a>1.1、Observable#create()</h5><pre><code>// 省略一些检测性的注解public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) {    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));}</code></pre><p>在Observable的create()里面实际上是创建了一个新的ObservableCreate对象，同时，把我们定义好的ObservableOnSubscribe对象传入了ObservableCreate对象中，最后调用了RxJavaPlugins.onAssembly()方法。接下来看看这个ObservableCreate是干什么的。</p><h5 id="1-2、ObservableCreate"><a href="#1-2、ObservableCreate" class="headerlink" title="1.2、ObservableCreate"></a>1.2、ObservableCreate</h5><pre><code>public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; {    final ObservableOnSubscribe&lt;T&gt; source;    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {        this.source = source;    }    ...}</code></pre><p>这里仅仅是把ObservableOnSubscribe这个对象保存在ObservableCreate中了。然后看看RxJavaPlugins.onAssembly()这个方法的处理。</p><h5 id="1-3、RxJavaPlugins-onAssembly"><a href="#1-3、RxJavaPlugins-onAssembly" class="headerlink" title="1.3、RxJavaPlugins#onAssembly()"></a>1.3、RxJavaPlugins#onAssembly()</h5><pre><code>public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) {    // 应用hook函数的一些处理，一般用到不到    ...    return source;}</code></pre><p>最终仅仅是把我们的ObservableCreate给返回了。</p><h5 id="1-4、创建被观察者过程小结"><a href="#1-4、创建被观察者过程小结" class="headerlink" title="1.4、创建被观察者过程小结"></a>1.4、创建被观察者过程小结</h5><p>从以上分析可知，Observable.create()方法仅仅是<strong>先将我们自定义的ObservableOnSubscribe对象重新包装成了一个ObservableCreate对象</strong>。</p><h4 id="2、订阅过程"><a href="#2、订阅过程" class="headerlink" title="2、订阅过程"></a>2、订阅过程</h4><p>接着，看看Observable.subscribe()的订阅过程是如何实现的。</p><h5 id="2-1、Observable-subscribe"><a href="#2-1、Observable-subscribe" class="headerlink" title="2.1、Observable#subscribe()"></a>2.1、Observable#subscribe()</h5><pre><code>public final void subscribe(Observer&lt;? super T&gt; observer) {    ...    // 1    observer = RxJavaPlugins.onSubscribe(this,observer);    ...    // 2    subscribeActual(observer);    ...}</code></pre><p>在Observable的subscribe()方法内部首先调用了RxJavaPlugins的onSubscribe()方法。</p><h5 id="2-2、RxJavaPlugins-onSubscribe"><a href="#2-2、RxJavaPlugins-onSubscribe" class="headerlink" title="2.2、RxJavaPlugins#onSubscribe()"></a>2.2、RxJavaPlugins#onSubscribe()</h5><pre><code>public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) {    // 应用hook函数的一些处理，一般用到不到    ...    return observer;}</code></pre><p>除去hook应用的逻辑，这里仅仅是将observer返回了。接着来分析下subscribeActual()方法，</p><h5 id="2-3、Observable-subscribeActual"><a href="#2-3、Observable-subscribeActual" class="headerlink" title="2.3、Observable#subscribeActual()"></a>2.3、Observable#subscribeActual()</h5><pre><code>protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);</code></pre><p>这是一个抽象的方法，很明显，它对应的具体实现类就是我们在第一步创建的ObservableCreate类，接下来看到ObservableCreate的subscribeActual()方法。</p><h5 id="2-4、ObservableCreate-subscribeActual"><a href="#2-4、ObservableCreate-subscribeActual" class="headerlink" title="2.4、ObservableCreate#subscribeActual()"></a>2.4、ObservableCreate#subscribeActual()</h5><pre><code>@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) {    // 1    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);    // 2    observer.onSubscribe(parent);    try {        // 3        source.subscribe(parent);    } catch (Throwable ex) {        Exceptions.throwIfFatal(ex);        parent.onError(ex);    }}</code></pre><p>在注释1处，首先新创建了一个CreateEmitter对象，同时传入了我们自定义的observer对象进去。</p><h5 id="2-4-1、CreateEmitter"><a href="#2-4-1、CreateEmitter" class="headerlink" title="2.4.1、CreateEmitter"></a>2.4.1、CreateEmitter</h5><pre><code>static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable {    ...    final Observer&lt;? super T&gt; observer;    CreateEmitter(Observer&lt;? super T&gt; observer) {        this.observer = observer;    }    ...}</code></pre><p>从上面可以看出，<strong>CreateEmitter通过继承了Java并发包中的原子引用类AtomicReference<disposable>保证了事件流切断状态Dispose的一致性</disposable></strong>（这里不理解的话，看到后面讲解Dispose的时候就明白了），并<strong>实现了ObservableEmitter接口和Disposable接口</strong>，接着我们分析下注释2处的observer.onSubscribe(parent)，这个onSubscribe回调的含义其实就是<strong>告诉观察者已经成功订阅了被观察者</strong>。再看到注释3处的source.subscribe(parent)这行代码，这里的source其实是ObservableOnSubscribe对象，我们看到ObservableOnSubscribe的subscribe()方法。</p><h5 id="2-4-2、ObservableOnSubscribe-subscribe"><a href="#2-4-2、ObservableOnSubscribe-subscribe" class="headerlink" title="2.4.2、ObservableOnSubscribe#subscribe()"></a>2.4.2、ObservableOnSubscribe#subscribe()</h5><pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {    @Override    public voidsubscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }});</code></pre><p>这里面使用到了ObservableEmitter的onNext()方法将事件流发送出去，最后调用了onComplete()方法完成了订阅过程。ObservableEmitter是一个抽象类，实现类就是我们传入的CreateEmitter对象，接下来我们看看CreateEmitter的onNext()方法和onComplete()方法的处理。</p><h5 id="2-4-3、CreateEmitter-onNext-amp-amp-CreateEmitter-onComplete"><a href="#2-4-3、CreateEmitter-onNext-amp-amp-CreateEmitter-onComplete" class="headerlink" title="2.4.3、CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()"></a>2.4.3、CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()</h5><pre><code>static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable {...@Overridepublic void onNext(T t) {    ...    if (!isDisposed()) {        //调用观察者的onNext()        observer.onNext(t);    }}@Overridepublic void onComplete() {    if (!isDisposed()) {        try {            observer.onComplete();        } finally {            dispose();        }    }}...}</code></pre><p>在CreateEmitter的onNext和onComplete方法中首先都要经过一个<strong>isDisposed</strong>的判断，作用就是看<strong>当前的事件流是否被切断（废弃）掉了</strong>，默认是不切断的，如果想要切断，可以调用Disposable的dispose()方法将此状态设置为切断（废弃）状态。我们继续看看这个isDisposed内部的处理。</p><h5 id="2-4-4、ObservableEmitter-isDisposed"><a href="#2-4-4、ObservableEmitter-isDisposed" class="headerlink" title="2.4.4、ObservableEmitter#isDisposed()"></a>2.4.4、ObservableEmitter#isDisposed()</h5><pre><code>@Overridepublic boolean isDisposed() {    return DisposableHelper.isDisposed(get());}</code></pre><p>注意到这里通过get()方法首先从ObservableEmitter的AtomicReference<disposable>中拿到了保存的Disposable状态。然后交给了DisposableHelper进行判断处理。接下来看看DisposableHelper的处理。</disposable></p><h5 id="2-4-5、DisposableHelper-isDisposed-amp-amp-DisposableHelper-set"><a href="#2-4-5、DisposableHelper-isDisposed-amp-amp-DisposableHelper-set" class="headerlink" title="2.4.5、DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()"></a>2.4.5、DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()</h5><pre><code>public enum DisposableHelper implements Disposable {    DISPOSED;    public static boolean isDisposed(Disposable d) {        // 1        return d == DISPOSED;    }    public static boolean set(AtomicReference&lt;Disposable&gt; field, Disposable d) {        for (;;) {            Disposable current = field.get();            if (current == DISPOSED) {                if (d != null) {                    d.dispose();                }                return false;            }            // 2            if (field.compareAndSet(current, d)) {                if (current != null) {                    current.dispose();                }                return true;            }        }    }    ...    public static boolean dispose(AtomicReference&lt;Disposable&gt; field) {        Disposable current = field.get();        Disposable d = DISPOSED;        if (current != d) {            // ...            current = field.getAndSet(d);            if (current != d) {                if (current != null) {                    current.dispose();                }                return true;            }        }        return false;    }    ...}</code></pre><p>DisposableHelper是一个枚举类，内部只有一个值即DISPOSED, 从上面的分析可知它就是用来<strong>标记事件流被切断（废弃）状态的</strong>。先看到注释2和注释3处的代码<strong>field.compareAndSet(current, d)和field.getAndSet(d)</strong>，这里使用了<strong>原子引用AtomicReference<disposable>内部包装的CAS方法处理了标志Disposable的并发读写问题</disposable></strong>，最后看到注释3处，将我们传入的CreateEmitter这个原子引用类保存的Dispable状态和DisposableHelper内部的DISPOSED进行比较，如果相等，就证明数据流被切断了。为了更进一步理解Disposed的作用，再来看看CreateEmitter中剩余的关键方法。</p><h5 id="2-4-6、CreateEmitter"><a href="#2-4-6、CreateEmitter" class="headerlink" title="2.4.6、CreateEmitter"></a>2.4.6、CreateEmitter</h5><pre><code>@Overridepublic void onNext(T t) {    ...    // 1    if (!isDisposed()) {        observer.onNext(t);    }}@Overridepublic void onError(Throwable t) {    if (!tryOnError(t)) {        // 2        RxJavaPlugins.onError(t);    }}@Overridepublic boolean tryOnError(Throwable t) {    ...    // 3    if (!isDisposed()) {        try {            observer.onError(t);        } finally {            // 4            dispose();        }        return true;    }    return false;}@Overridepublic void onComplete() {    // 5    if (!isDisposed()) {        try {            observer.onComplete();        } finally {            // 6            dispose();        }    }}</code></pre><p>在注释1、3、5处，onNext()和onError()、onComplete()方法首先都会判断事件流是否被切断的处理，如果事件流此时被切断了，那么onNext()和onComplete()则会退出方法体，不做处理，<strong>onError()则会执行到RxJavaPlugins.onError(t)这句代码，内部会直接抛出异常，导致崩溃</strong>。如果事件流没有被切断，那么在onError()和onComplete()内部最终会调用到注释4、6处的这句dispose()代码，将事件流进行切断，由此可知，<strong>onError()和onComplete()只能调用一个，如果先执行的是onComplete()，再调用onError()的话就会导致异常崩溃</strong>。</p><h3 id="三、RxJava的线程切换"><a href="#三、RxJava的线程切换" class="headerlink" title="三、RxJava的线程切换"></a>三、RxJava的线程切换</h3><p>首先给出RxJava线程切换的例子：</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {    @Override    public voidsubscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }})     .subscribeOn(Schedulers.io())    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Observer&lt;String&gt;() {        @Override        public void onSubscribe(Disposable d) {            Log.d(TAG, &quot;onSubscribe&quot;);        }        @Override        public void onNext(String s) {            Log.d(TAG, &quot;onNext : &quot; + s);        }        @Override        public void onError(Throwable e) {            Log.d(TAG, &quot;onError : &quot; +e.toString());        }        @Override        public void onComplete() {            Log.d(TAG, &quot;onComplete&quot;);        }});</code></pre><p>可以看到，RxJava的线程切换主要分为subscribeOn()和observeOn()方法，首先，来分析下subscribeOn()方法。</p><h4 id="1、subscribeOn-Schedulers-io"><a href="#1、subscribeOn-Schedulers-io" class="headerlink" title="1、subscribeOn(Schedulers.io())"></a>1、subscribeOn(Schedulers.io())</h4><p>在Schedulers.io()方法中，我们需要先传入一个Scheduler调度类，这里是传入了一个调度到io子线程的调度类，我们看看这个Schedulers.io()方法内部是怎么构造这个调度器的。</p><h4 id="2、Schedulers-io"><a href="#2、Schedulers-io" class="headerlink" title="2、Schedulers#io()"></a>2、Schedulers#io()</h4><pre><code>static final Scheduler IO;...public static Scheduler io() {    // 1    return RxJavaPlugins.onIoScheduler(IO);}static {    ...    // 2    IO = RxJavaPlugins.initIoScheduler(new IOTask());}static final class IOTask implements Callable&lt;Scheduler&gt; {    @Override    public Scheduler call() throws Exception {        // 3        return IoHolder.DEFAULT;    }}static final class IoHolder {    // 4    static final Scheduler DEFAULT = new IoScheduler();}</code></pre><p>Schedulers这个类的代码很多，这里我只拿出有关Schedulers。io这个方法涉及的逻辑代码进行讲解。首先，在注释1处，同前面分析的订阅流程的处理一样，只是一个处理hook的逻辑，最终返回的还是传入的这个IO对象。再看到注释2处，在Schedulers的静态代码块中将IO对象进行了初始化，其实质就是新建了一个IOTask的静态内部类，在IOTask的call方法中，也就是注释3处，可以了解到使用了静态内部类的方式把创建的IOScheduler对象给返回出去了。绕了这么大圈子，<strong>Schedulers.io方法其实质就是返回了一个IOScheduler对象</strong>。</p><h4 id="3、Observable-subscribeOn"><a href="#3、Observable-subscribeOn" class="headerlink" title="3、Observable#subscribeOn()"></a>3、Observable#subscribeOn()</h4><pre><code>  public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {    ...    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));}</code></pre><p>在subscribeOn()方法里面，又将ObservableCreate包装成了一个ObservableSubscribeOn对象。我们关注到ObservableSubscribeOn类。</p><h4 id="4、ObservableSubscribeOn"><a href="#4、ObservableSubscribeOn" class="headerlink" title="4、ObservableSubscribeOn"></a>4、ObservableSubscribeOn</h4><pre><code>public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; {    final Scheduler scheduler;    public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) {        // 1        super(source);        this.scheduler = scheduler;    }    @Override    public void subscribeActual(final Observer&lt;? super T&gt; observer) {        // 2        final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer);        // 3        observer.onSubscribe(parent);        // 4        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));    }...}</code></pre><p>首先，在注释1处，将传进来的source和scheduler保存起来。接着，等到实际订阅的时候，就会执行到这个subscribeActual方法，在注释2处，将我们自定义的Observer包装成了一个SubscribeOnObserver对象。在注释3处，通知观察者订阅了被观察者。在注释4处，内部先创建了一个SubscribeTask对象，来看看它的实现。</p><h4 id="5、ObservableSubscribeOn-SubscribeTask"><a href="#5、ObservableSubscribeOn-SubscribeTask" class="headerlink" title="5、ObservableSubscribeOn#SubscribeTask"></a>5、ObservableSubscribeOn#SubscribeTask</h4><pre><code>final class SubscribeTask implements Runnable {    private final SubscribeOnObserver&lt;T&gt; parent;    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {        this.parent = parent;    }    @Override    public void run() {        source.subscribe(parent);    }}</code></pre><p>SubscribeTask是ObservableSubscribeOn的内部类，它实质上就是一个任务类，在它的run方法中会执行到source.subscribe(parent)的订阅方法，<strong>这个source其实就是我们在ObservableSubscribeOn构造方法中传进来的ObservableCreate对象</strong>。接下来看看scheduler.scheduleDirect()内部的处理。</p><h4 id="6、Scheduler-scheduleDirect"><a href="#6、Scheduler-scheduleDirect" class="headerlink" title="6、Scheduler#scheduleDirect()"></a>6、Scheduler#scheduleDirect()</h4><pre><code>public Disposable scheduleDirect(@NonNull Runnable run) {    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);}public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {    // 1    final Worker w = createWorker();    // 2    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    // 3    DisposeTask task = new DisposeTask(decoratedRun, w);    // 4    w.schedule(task, delay, unit);    return task;}</code></pre><p>这里最后会执行到上面这个scheduleDirect()重载方法。首先，在注释1处，会调用createWorker()方法创建一个工作者对象Worker，它是一个抽象类，这里的实现类就是IoScheduler，下面，我们看看IoScheduler类的createWorker()方法。</p><h4 id="6-1、IOScheduler-createWorker"><a href="#6-1、IOScheduler-createWorker" class="headerlink" title="6.1、IOScheduler#createWorker()"></a>6.1、IOScheduler#createWorker()</h4><pre><code>final AtomicReference&lt;CachedWorkerPool&gt; pool;...public IoScheduler(ThreadFactory threadFactory) {    this.threadFactory = threadFactory;    this.pool = new AtomicReference&lt;CachedWorkerPool&gt;(NONE);    start();}...@Overridepublic Worker createWorker() {    // 1    return new EventLoopWorker(pool.get());}static final class EventLoopWorker extends Scheduler.Worker {    ...    EventLoopWorker(CachedWorkerPool pool) {        this.pool = pool;        this.tasks = new CompositeDisposable();        // 2        this.threadWorker = pool.get();    }}</code></pre><p>首先，在注释1处调用了pool.get()这个方法，pool是一个CachedWorkerPool类型的原子引用对象，它的作用就是<strong>用于缓存工作者对象Worker的</strong>。然后，将得到的CachedWorkerPool传入新创建的EventLoopWorker对象中。重点关注一下注释2处，这里讲CachedWorkerPool缓存的threadWorker对象保存起来了。</p><p>下面，我们继续分析3.6处代码段的注释2处的代码，这里又是一个关于hook的封装处理，最终还是返回的当前的Runnable对象。在注释3处新建了一个切断任务DisposeTask将decoratedRun和w包装了起来。最后在注释4处调用了工作者的schedule()方法。下面我们来分析下它内部的处理。</p><h4 id="6-2、IoScheduler-schedule"><a href="#6-2、IoScheduler-schedule" class="headerlink" title="6.2、IoScheduler#schedule()"></a>6.2、IoScheduler#schedule()</h4><pre><code>@Overridepublic Disposable schedule(@NonNull Runnableaction, long delayTime, @NonNull TimeUnit unit){    ...    return threadWorker.scheduleActual(action,delayTime, unit, tasks);}</code></pre><p>内部调用了threadWorker的scheduleActual()方法，实际上是调用到了父类NewThreadWorker的scheduleActual()方法，我们继续看看NewThreadWorker的scheduleActual()方法中做的事情。</p><h4 id="6-2-1、NewThreadWorker-scheduleActual"><a href="#6-2-1、NewThreadWorker-scheduleActual" class="headerlink" title="6.2.1、NewThreadWorker#scheduleActual()"></a>6.2.1、NewThreadWorker#scheduleActual()</h4><pre><code>public NewThreadWorker(ThreadFactory threadFactory) {    executor = SchedulerPoolFactory.create(threadFactory);}@NonNullpublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    // 1    ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);    if (parent != null) {        if (!parent.add(sr)) {            return sr;        }    }    Future&lt;?&gt; f;    try {        // 2        if (delayTime &lt;= 0) {            // 3            f = executor.submit((Callable&lt;Object&gt;)sr);        } else {            // 4            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);        }        sr.setFuture(f);    } catch (RejectedExecutionException ex) {        if (parent != null) {            parent.remove(sr);        }        RxJavaPlugins.onError(ex);    }    return sr;}</code></pre><p>在NewThreadWorker的scheduleActual()方法的内部，在注释1处首先会新建一个ScheduledRunnable对象，将Runnable对象和parent包装起来了，<strong>这里parent是一个DisposableContainer对象，它实际的实现类是CompositeDisposable类，即一个保存所有事件流是否被切断状态的容器，它内部的实现是使用了RxJava自己定义的一个简单的OpenHashSet类ji进行存储</strong>。最后注释2处，判断是否设置了延迟时间，如果设置了，则调用线程池的submit()方法立即进行线程切换，否则，调用schedule()方法进行延时执行线程切换。</p><h4 id="7、为什么多次执行subscribeOn-，只有第一次有效？"><a href="#7、为什么多次执行subscribeOn-，只有第一次有效？" class="headerlink" title="7、为什么多次执行subscribeOn()，只有第一次有效？"></a>7、为什么多次执行subscribeOn()，只有第一次有效？</h4><p>从上面的分析，我们可以很容易了解到<strong>被观察者被订阅时是从最外面的一层（ObservableSubscribeOn）通知到里面的一层（ObservableOnSubscribe）</strong>，当连续执行了到多次subscribeOn()的时候，其实就是先执行倒数第一次的subscribeOn()方法，直到最后一次执行的subscribeOn()方法肯定会覆盖前面的线程切换。</p><h4 id="8、observeOn-AndroidSchedulers-mainThread"><a href="#8、observeOn-AndroidSchedulers-mainThread" class="headerlink" title="8、observeOn(AndroidSchedulers.mainThread())"></a>8、observeOn(AndroidSchedulers.mainThread())</h4><pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler) {    return observeOn(scheduler, false, bufferSize());}public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {    ....    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));}</code></pre><p>可以看到，observeOn()方法内部最终也是返回了一个ObservableObserveOn对象，我们直接来看看ObservableObserveOn的subscribeActual()方法。</p><h4 id="9、ObservableObserveOn-subscribeActual"><a href="#9、ObservableObserveOn-subscribeActual" class="headerlink" title="9、ObservableObserveOn#subscribeActual()"></a>9、ObservableObserveOn#subscribeActual()</h4><pre><code>@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) {    // 1    if (scheduler instanceof TrampolineScheduler) {        // 2        source.subscribe(observer);    } else {        // 3        Scheduler.Worker w = scheduler.createWorker();        // 4        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));    }}</code></pre><p>首先，在注释1处，判断指定的调度器是不是TrampolineScheduler，这是一个不进行线程切换，立即执行当前代码的调度器，。如果是，则会直接调用调用ObservableSubscribeOn的subscribe()方法，如果不是，则会在注释3处创建一个工作者对象。然后在注释4处创建一个新的ObserveOnObserver将SubscribeOnobserver对象包装起来，并传入ObservableSubscribeOn的subscribe()方法进行订阅。接下来看看ObserveOnObserver类的重点方法。</p><h4 id="10、ObserveOnObserver"><a href="#10、ObserveOnObserver" class="headerlink" title="10、ObserveOnObserver"></a>10、ObserveOnObserver</h4><pre><code>@Overridepublic void onNext(T t) {    ...    if (sourceMode != QueueDisposable.ASYNC) {        // 1        queue.offer(t);    }    schedule();}@Overridepublic void onError(Throwable t) {    ...    schedule();}@Overridepublic void onComplete() {    ...    schedule();}</code></pre><p>去除非主线逻辑的代码，在ObserveOnObserver的onNext()和onError()、onComplete()方法中最后都会调用到schedule()方法。接着看schedule()方法，其中onNext()还会把消息存放到队列中。</p><h4 id="11、ObserveOnObserver-schedule"><a href="#11、ObserveOnObserver-schedule" class="headerlink" title="11、ObserveOnObserver#schedule()"></a>11、ObserveOnObserver#schedule()</h4><pre><code>void schedule() {    if (getAndIncrement() == 0) {        worker.schedule(this);    }}</code></pre><p>这里使用了worker进行调度ObserveOnObserver这个实现了Runnable的任务。worker就是在AndroidSchedulers.mainThread()中创建的，内部其实就是<strong>使用Handler进行线程切换的</strong>，此处不再赘述了。接着看ObserveOnObserver的run()方法。</p><h4 id="12、ObserveOnObserver-run"><a href="#12、ObserveOnObserver-run" class="headerlink" title="12、ObserveOnObserver#run()"></a>12、ObserveOnObserver#run()</h4><pre><code>@Overridepublic void run() {    // 1    if (outputFused) {        drainFused();    } else {        // 2        drainNormal();    }}</code></pre><p>在注释1处会先判断outputFused这个标志位，它表示事件流是否被融化掉，默认是false，所以，最后会执行到drainNormal()方法。接着看看drainNormal()方法内部的处理。</p><h4 id="13、ObserveOnObserver-drainNormal"><a href="#13、ObserveOnObserver-drainNormal" class="headerlink" title="13、ObserveOnObserver#drainNormal()"></a>13、ObserveOnObserver#drainNormal()</h4><pre><code>void drainNormal() {    int missed = 1;    final SimpleQueue&lt;T&gt; q = queue;    // 1    final Observer&lt;? super T&gt; a = downstream;    ...    // 2    v = q.poll();    ...    // 3    a.onNext(v);    ...}</code></pre><p>在注释1处，这里的downstream实际上是从外面传进来的SubscribeOnObserver对象。在注释2处将队列中的消息取出来，接着在注释3处调用了SubscribeOnObserver的onNext方法。<strong>最终，会从我们包装类的最外层一直调用到最里面的我们自定义的Observer中的onNext()方法，所以，在observeOn()方法下面的链式代码都会执行到它所指定的线程中，噢，原来如此</strong>。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>其实笔者使用了RxJava也已经有一年多的时间了，但是一直没有去深入去了解过它的内部实现原理，如今细细品尝，的确是酣畅淋漓。从一开始的OkHttp到现如今的RxJava源码分析，到此为止，Android主流三方库源码分析系列文章已经发布了五篇了，我们的征途已经过半，接下来，我将会对Android中的内存泄露框架LeakCanary源码进行深入地讲解，尽请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、RxJava V2.2.5 源码</p><p>2、Android 进阶之光</p><p>3、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492749&amp;idx=1&amp;sn=a4d2e79afd8257b57c6efa57cbff4404&amp;chksm=8eec86f2b99b0fe46f61f324e032af335fbe02c7db1ef4eca60abb4bc99b4d216da7ba32dc88&amp;scene=38#wechat_redirect" target="_blank" rel="external">详解 RxJava 的消息订阅和线程切换原理</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
