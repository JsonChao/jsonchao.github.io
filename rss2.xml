<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Fri, 19 Oct 2018 12:19:53 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android触摸事件传递机制</title>
      <link>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</link>
      <guid>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</guid>
      <pubDate>Wed, 17 Oct 2018 14:38:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><h3 id="一、了解Activity的构成"><a href="#一、了解Activity的构成" class="headerlink" title="一、了解Activity的构成"></a>一、了解Activity的构成</h3><p>一个Activity包含了一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根View，而这个DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平时所写的就是展示在ContentView中的，下图表示Activity的构成。</p><p><img src="https://upload-images.jianshu.io/upload_images/1417629-c87a3dd5ed19ee9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="二、触摸事件的类型"><a href="#二、触摸事件的类型" class="headerlink" title="二、触摸事件的类型"></a>二、触摸事件的类型</h3><p>触摸事件对应的是MotionEvent类，事件的类型主要有如下三种：</p><ul><li>ACTION_DOWN</li><li>ACTION_MOVE(移动的距离超过一定的阈值会被判定为ACTION_MOVE操作)</li><li>ACTION_UP</li></ul><h3 id="三、事件传递的三个阶段"><a href="#三、事件传递的三个阶段" class="headerlink" title="三、事件传递的三个阶段"></a>三、事件传递的三个阶段</h3><ul><li>分发（dispatchTouchEvent）：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件。</li><li>拦截（onInterceptTouchEvent）：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。<br>如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　</li></ul><pre><code>1.如果该View(ViewGroup)存在子View且点击到了该子View, 则不拦截, 继续分发给子View 处理, 此时相当于return false。2.如果该View(ViewGroup)没有子View或者有子View但是没有点击中子View(此时ViewGroup相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。</code></pre><ul><li>消费（onTouchEvent）：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：</li></ul><pre><code>1.如果该View是clickable或者longclickable的,则会返回true, 表示消费了该事件, 与返回true一样;2.如果该View不是clickable或者longclickable的,则会返回false, 表示不消费该事件,将会向上传递,与返回false一样.</code></pre><p>注意：在Android系统中，拥有事件传递处理能力的类有以下三种。</p><ul><li>Activity：拥有分发和消费两个方法。</li><li>ViewGroup：拥有分发、拦截和消费三个方法。</li><li>View：拥有分发、消费两个方法。</li></ul><h3 id="四、Activity对点击事件的分发过程"><a href="#四、Activity对点击事件的分发过程" class="headerlink" title="四、Activity对点击事件的分发过程"></a>四、Activity对点击事件的分发过程</h3><p>我们对触摸屏进行操作时，Linux就会收到相应的硬件中断，然后将中断加工成原始的输入事件并写入相应的设备节点中。而我们的Android 输入系统所做的事情概括起来说就是监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。<br>当点击事件产生后，事件会传递给当前的Activity，由Activity中的PhoneWindow完成，PhoneWindow再把事件处理工作交给DecorView，之后再有DecorView将事件处理工作交给ViewGroup。源码流程如下所示：</p><h5 id="1-Activity-dispatchTouchEvent"><a href="#1-Activity-dispatchTouchEvent" class="headerlink" title="1.Activity#dispatchTouchEvent"></a>1.Activity#dispatchTouchEvent</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {    if (ev.getAction() == MotionEvent.ACTION_DOWN) {        onUserInteraction();    }    // 由Activity所附属的Window分发，返回true，事件循环结束    if (getWindow().superDispatchTouchEvent(ev)) {        return true;    }    // 返回false意味着事件没人处理，所有View的onTouchEvent都    // 返回了false，那么Activity的onTouchEvent就会被调用    return onTouchEvent(ev);}</code></pre><h5 id="2-抽象类Window-superDispatchTouchEvent"><a href="#2-抽象类Window-superDispatchTouchEvent" class="headerlink" title="2.抽象类Window#superDispatchTouchEvent"></a>2.抽象类Window#superDispatchTouchEvent</h5><pre><code>public abstract boolean superDispatchTouchEvent(MotionEvent event);</code></pre><h5 id="3-唯一实现类PhoneWindow-superDispatchTouchEvent"><a href="#3-唯一实现类PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3.唯一实现类PhoneWindow#superDispatchTouchEvent"></a>3.唯一实现类PhoneWindow#superDispatchTouchEvent</h5><pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {    return mDecor.superDispatchTouchEvent(event);}</code></pre><h3 id="五、View的事件分发机制"><a href="#五、View的事件分发机制" class="headerlink" title="五、View的事件分发机制"></a>五、View的事件分发机制</h3><p>事件分发到ViewGroup的dispatchTouchEvent方法，如果它的onInterceptTouchEvent返回true，则由自己处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。如果它的onInterceptTouchEvent返回false，则交给点击事件链上的子View处理，如此循环，完成分发。ViewGroup#dispatchTouchEvent关键源码如下所示：</p><h5 id="1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作"><a href="#1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作" class="headerlink" title="1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作"></a>1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作</h5><pre><code>// Handle an initial down.if (actionMasked === MotionEvent.ACTION_DOWN) {    // Throw away all previous state when starting a new touch gesture.    // The framework may have dropped the up or cancel event for the    // previous gesture due to an app switch, ANR, or some other stae change.    cancelAndClearTouchTarget(ev);    // 在此方法中会重置FLAG_DISALLOW_INTERCEPT    resetTouchState();}</code></pre><h5 id="2-处理当前View是否拦截点击事件"><a href="#2-处理当前View是否拦截点击事件" class="headerlink" title="2.处理当前View是否拦截点击事件"></a>2.处理当前View是否拦截点击事件</h5><pre><code>final boolean interception；// 当事件由ViewGorup的子元素成功处理时，mFirstTouchTarget会被赋值// 并指向子元素，反之，被ViewGroup拦截时，mFirstTouchTarget则为null。if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {    // 在子View中通过requestDisallowInterceptTouchEvent方法来设置    // FLAG_DISALLOW_INTERCEPT,此时ViewGroup将无法拦截除ACTION_DOWN以外的其他事件     final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;    if (!disallowintercept) {        intercepted = onInterceptTouchEvent(ev);        //re store action in case it was changed        ev.setAction(action);    } else {        intercepted = false;    } else {        // There are no touch targets and this action is not an initial down so this         // view group continues to intercept touches（ACTION_MOVE、ACTION_UP.eg).        intercepted = true;    }}</code></pre><h5 id="3-dispatchTouchEvent-方法剩余的部分源码"><a href="#3-dispatchTouchEvent-方法剩余的部分源码" class="headerlink" title="3.dispatchTouchEvent()方法剩余的部分源码"></a>3.dispatchTouchEvent()方法剩余的部分源码</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {    ...    final View[] children = mChildren;    // 遍历ViewGroup的子元素，如果子元素能够接受到点击事件，则交给子元素处理。    for (int i = childrenCount - 1;i &gt;= 0;i--) {        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);        if (childWithAccessibilityFocus != null) {            if (childWithAccessibilityFocus != child) {                continue;            }            childWithAccessibilityFocus = null;            i = childrenCount - 1;            }            // 判断触摸点的位置是否在子View的范围内或者子View是否在播放动画，有一项            // 不符合则开始遍历下一个子View。            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {                ev.setTargetAccessibilityFocus(false);                continue;            }            newTouchTarget == getTouchTarget(child);            if (newTouchTarget != null) {                newTouchTarget.pointerIdBits |= idBitsToAssign;                break;            }            resetCancelNextUpFlag(child);            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {                mLastTouchDownTime = ev.getDownTime();                if (preorderedList != null) {                    for (int j = 0;j &lt; childrenCOunt;j++) {                        if (children[childIndex] == mChildren[j]) {                            mLastTouchDownIndex = j;                            break;                        }                    }                } else {                    mLastTouchDownIndex = childIndex;                }                mLastTouchDownX == ev.getX();                mLastTouchDownY = ev.getY();                newTouchTarget = addTouchTarget(child, idBitsToAssign);                alreadyDispatchedToNewTouchTarget == true;                break            }            ev.setTargetAccessibilityFocus(false);        }    ...}</code></pre><h5 id="4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"><a href="#4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑" class="headerlink" title="4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"></a>4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑</h5><pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event,boolean cancel,View child,int desiredPointerIdBits) {    final int oldAction = event.getAction();    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {        event.setAction(MotionEvent.ACTION_CANCEL);        // 有子View，则调用子View的dispatchTouchEvent(event)方法，如果没有子View，        // 则调用super.dispatchTouchEvent(event)方法。        if (child == null) {            handled == super..dispatchTouchEvent(event);        } else {            handled = child.dispatchTouchEvent(event);        }        event.setAction(oldAction);        return handled;    }    ...}</code></pre><h5 id="5-事件传递到View的dispatchTouchEvent"><a href="#5-事件传递到View的dispatchTouchEvent" class="headerlink" title="5.事件传递到View的dispatchTouchEvent()"></a>5.事件传递到View的dispatchTouchEvent()</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent event) {    ...    boolean result = false;    if (onFilterTouchEventForSecurity(event)) {        ListenerInfo li = mListenerInfo;        // onTouch方法优先级要高于onTouchEvent(event)方法        if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {            result = true;        }        if (!result &amp;&amp; onTouchEvent(event)) {            result == true;        }    }    ...    return result;}</code></pre><h5 id="6-事件传递到View的onTouchEvent"><a href="#6-事件传递到View的onTouchEvent" class="headerlink" title="6.事件传递到View的onTouchEvent()"></a>6.事件传递到View的onTouchEvent()</h5><pre><code>public boolean onTouchEvent(MotionEvent event) {    ...    final int action = event.getAction();    // 只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会    // 返回true消耗这个事件。    if ((viewFlags &amp; CLICKABLE) == CLICKABLE || （viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {        switch(action) {            case MotionEvent.ACTION_UP:                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;                if ((mPrivatFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {                    boolean focusTaken = false;                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {                        removeLongPressCallback();                        if (!focusTaken) {                            if (mPerformClick == null) {                                mPerformClick = new PerformClick();                            }                            if (!post(mPerformClick)) {                                performClick();                            }                        }                    }                }                ...            }            return true;    }    return true;}</code></pre><h5 id="7-在ACTION-UP事件中会调用performCLick-方法"><a href="#7-在ACTION-UP事件中会调用performCLick-方法" class="headerlink" title="7.在ACTION_UP事件中会调用performCLick()方法"></a>7.在ACTION_UP事件中会调用performCLick()方法</h5><pre><code>public boolean performClick() {    final boolean result;    final Listenerinfo li = mListenerInfo;    // 如果View设置了点击事件，onClick方法就会执行。    if (li != null &amp;&amp; li.mOnClickListener !== null) {        playSoundEffect(SoundEffectConstants.CLICK);        li.mOnClickListener.onClick(this);        result = true;    } else {        result = false;    }    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);    return result;}</code></pre><p>由以上源码分析可得出View完整的点击事件传递流程如下图所示。</p><p><img src="https://camo.githubusercontent.com/e1e469bffad8a95732db704cc161384f8e3c7f0e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323931313033382d35333439643665626233323337326461" alt="image"></p><h3 id="六、总结：点击事件分发的传递规则"><a href="#六、总结：点击事件分发的传递规则" class="headerlink" title="六、总结：点击事件分发的传递规则"></a>六、总结：点击事件分发的传递规则</h3><p>由事件分发的源码分析可知点击事件分发的3个重要方法的关系，用伪代码表示为：</p><pre><code>public boolean diapatchTouchEvent(MotionEvent ev) {    boolean consume = false;    if (onInterceptTouchEvent(ev)) {        consume = onTouchEvent(ev);    } else {        consume = child.dispatchTouchEvent(ev);    }    return consume;}</code></pre><p>一些重要的结论：</p><p>1.事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。</p><p>2.正常情况下，一个时间序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。特例：通过将重写View的onTouchEvent返回false可强行将事件转交给其他View处理。</p><p>3.如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</p><p>4.ViewGroup默认不拦截任何事件（返回false）。</p><p>5.View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。</p><p>6.View的enable属性不影响onTouchEvent的默认返回值。</p><p>7.通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p><p>最终完整的事件分发流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png" alt="image"></p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android开发艺术探索</p><p>2、Android进阶之光</p><p>3、Android高级进阶</p><p>4、<a href="http://gityuan.com/2015/09/19/android-touch/" target="_blank" rel="external">Gityuan Android事件分发机制</a></p><p>5、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492294&amp;idx=1&amp;sn=1645fa7730dbb1c627bd374e917cd557&amp;chksm=8eec80b9b99b09af1938836b2f19afc60b46c284050b9f17ceb5018867cd86df1c6a40fe56eb&amp;scene=38#wechat_redirect" target="_blank" rel="external">通俗理解Android的事件分发机制</a></p><p>6、<a href="http://www.jianshu.com/p/38015afcdb58" target="_blank" rel="external">Android事件分发机制详解：史上最全面、最易懂</a></p><p>7、<a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247486486&amp;idx=1&amp;sn=7acc1c9dd8c600ad0ec2db7d32f82f1f&amp;chksm=97f6b2a2a0813bb425cf8bf329bf0e856d3769ac8e21ed5a9a6cb7c57b1097c41f94afe4202d&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android开发之漫漫长途 Ⅵ——图解Android事件分发机制（深入底层源码）</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python入门篇</title>
      <link>http://yoursite.com/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/</link>
      <guid>http://yoursite.com/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/</guid>
      <pubDate>Thu, 26 Jul 2018 14:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>随着人工智能和AI行业的兴起，Python已经成为程序员不得不学的一门编程语言了，本系列文章主要是涉及使用Python入门方面的知识。</p><h3 id="初识Python"><a href="#初识Python" class="headerlink" title="初识Python"></a>初识Python</h3><pre><code>what：python是什么？    它是一门跨平台的高级编程语言，相对其它高级语言（如：C、Java）    来说，它封装的功能更完善，能用更少的代码实现同样的功能。    python的作用？    Python的用处很多，它主要使用的领域有：    1.前后端开发    2.工具脚本开发    3.爬虫    4.人工智能    优点：简洁、易懂、用更少的代码实现功能模块。    缺点：    1.程序运行速度很慢，因为python是解释性语言，计算机每执行一行    python代码就会把它翻译成自身能识别的机器码，而其它语言，如    C语言，则会在运行前就会被编译成计算机能识别的机器码。    2.python不能够加密，发布就是将源码发布出去，这正是解释性语言    的缺陷，而编译型语言则不会，如C语言，它是将编译后得到的二进制    码发布出去。why：为什么要使用python？    因为它的优点——简洁、易懂、能用更少的代码实现功能模块，特别适合做一些脚本工具。how：如何使用它？    请往下看。。。</code></pre><h4 id="安装Python开发工具（Windows系统）"><a href="#安装Python开发工具（Windows系统）" class="headerlink" title="安装Python开发工具（Windows系统）"></a>安装Python开发工具（Windows系统）</h4><pre><code>python有两个版本（2.x，3.x），只演示新版本的安装。打开python网站，选择安装Install-&gt;windows-&gt;最新relese 64bit即可，可选框全选即可。官网安装的python环境用的是CPython解释器（包含python代码的文档称为.py,解释器就是用来执行python代码的）。解释器有很多种，CPython是主流。</code></pre><h4 id="先用起来？"><a href="#先用起来？" class="headerlink" title="先用起来？"></a>先用起来？</h4><pre><code>启动方式？1.打开命令行模式，输入python进入python交互模式。输入exit()回到命令行模式。2.直接点击python终端，进入python交互模式。输入exit()退出命令行模式。注意：python交互模式的代码是输入一行，输出一行，它只适合初学者用来调试代码时使用，正常开发都是编写*.py文件，使用python *.py运行*.py文件，这样就会一次性执行python源代码。（文件名只能是英文字母、数字、下划线的组合）。</code></pre><h5 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h5><pre><code>输出：使用print()，可以“”，‘’的形式输出单个字符串，也可输出多个字符串如print(&quot;hello&quot;,&quot;I&quot;,&quot;am&quot;,&quot;jsonchao&quot;),输出时，号相当于一个空格。输入：使用input()，括号内可以写入输入的提示信息，如：name = print(&quot;please enter your name:&quot;)print(&quot;hello&quot;, name)其中name为字符串变量。</code></pre><h4 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h4><pre><code>python、C、JAVA都是高级语言，它们不同于自然语言，它们需要通过解释器或编译期将符合自身语法规则的语言转换为计算机能够执行的机器码。约定俗成的规则：1.#后面为注释；2.语句后面加：号结尾时，缩进的语句变为代码块；缩进一般为4个空格=tab键；3.不同于java，复制粘贴时，缩进的格式可能复制不过来，需要重起缩进格式；4.python程序是大小写敏感的。</code></pre><h5 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h5><pre><code>1.r&quot;&quot;表示字符串里面的内容默认不转义。2.&apos;&apos;&apos;hello    I am    jsonchao&apos;&apos;&apos;为避免加入多个\n的写法。3.布尔值：True、False首字母为大写，and、or、not为运算符。4.None为python中一个特殊的空值。5.变量a = 10    a = &quot;10&quot;，说明python是一门变量可以动态赋值为不同类型的语言，    称为动态语言，而java的变量，则一开始则指定了类型，如：    int a = 10；所以java是一门静态语言。6.用大写字母规范地表示常量，虽然它的值还是可以动态改变。。。7.除法：/，//（地板除，值取整）得到的都是浮点数结果，%（取余，结果为整数）。8.python的整数没有大小限制，浮点数没有大小限制，但是超过一定值会表示为inf（无限大）。</code></pre><h5 id="字符编码和字符串"><a href="#字符编码和字符串" class="headerlink" title="字符编码和字符串"></a>字符编码和字符串</h5><pre><code>字符编码：最初的ASCLL编码为1个字节表示一个字符，由于不同国家有不同的编码，为了解决文本显示不同语言乱码的问题，国际统一了Unicode编码，一般为2个字节表示一个字符（生僻的中文为4个字节表示一个字符），为了节省Unicode在保存数据和传输数据时字符占用过多字节的问题，后面在储存和传输时会将Unicode转换为UTF-8编码，文本显示时又会转变回Unicode编码。最常用的编码为utf-8。Python的字符串：在最新的Python3中，字符是Unicode编码的，因此，它能适配多语言。1.ord()获取字符的整数表示，chr()获取整数对应的字符。2.如果需要将字符串在进行网络传输或者存储到磁盘，就必须将其转换成bytes（字节）。3.b&apos;&apos;或b&quot;&quot;表示里面的为字节，使用encode()将字符串编码为字节，decode()将字节编码为字符串，括号内为指定的编译码格式，\x后面指定为不能被ASCLL识别的字符。b&apos;23\x3d3j&apos;.decode(&apos;utf-8&apos;,errors=&apos;ignore&apos;),以此格式指定忽略错误。4.len()表示计算出字符串的长度。5.使用%d、%s、%f、%x来格式化字符串，形式为：&quot;emm..., is %s.&quot; % (jsonchao)&quot;emm...，$%d，is %s.&quot; % (10000000， jsonchao)还可以使用%0d表示0x，%.2f表示3.14这样的形式。用%%表示%字符串。还有另一种格式化字符串的方式，使用.format()，如：&apos;haha,i&apos;m {0} year\’s old, {1:.1f}%percent power&apos;.format(24, 30.555)注意，30.5会四舍五入为30.6。6.&apos;haha&apos;.replace(&apos;h&apos;, &apos;d&apos;)替换指定字符。</code></pre><h5 id="List和Tuple"><a href="#List和Tuple" class="headerlink" title="List和Tuple"></a>List和Tuple</h5><pre><code>List：MyList = [10,&apos;haha&apos;，[20, &apos;lala&apos;]]，可存储不同类型数据，元素还可以是List。MyList[-1], MyList[-2]表示取出倒数第一，二个值。MyList.append(20)，结尾添加值。MyList.insert(1, ‘haha’)，下标为1处添加值。MyList.pop()，弹出最后一个值。MyList.pop(0)，弹出第一个值。MyList[2][1],二维取值。MyList.sort()从小到大进行排序。Tuple:是不可变的，定义为：MyTuple = (20, &apos;haha&apos;)当Tuple中只表示一个元素时，必须使用MyTuple = (20,)来消除来Python以为是括号()+值的歧义。记住不变，是指Tuple的每一个元素的指向不变，并不是指向的元素内容不变。（相当于Java中指向元素的地址，C语言的指针）为什么需要元组？1.旧式字符串格式化中参数要用元组；2.在字典中当作键值；3.数据库的返回值……区别：即为可变与不可变。</code></pre><h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><pre><code>if:后面会执行接下来缩进的两行代码。1.elif为else if的缩写。2.if还有如下写法：if 20:    print(&apos;nice&apos;)只要if后的内容是非0，非空List，一切非空内容即为Ture。elif 20 &lt;= bmi &lt; 25不同于java，java为bmi &gt;= 20 &amp;&amp;bmi &lt; 25。**为java平方符合^。</code></pre><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><pre><code>names = [&apos;tianshen&apos;, &apos;jsonchao&apos;, &apos;zhanshen&apos;]for x in names：    print(&quot;Hello, &quot; + x + &quot;!&quot;)whilebreakcontinuebreak和continue尽量少用，易造成程序逻辑混乱。</code></pre><h5 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h5><pre><code>dict称为字典，编写形式如下：d = {&apos;hello&apos; : 1, &apos;haha&apos; : 2, &apos;emem&apos; : 3}判断是否有对应的key：&apos;hello&apos; in d,有则True，无则False。d.get(&apos;hello&apos;)获取key对应的值。没有则返回none，python交互命令环境下不显示结果。d.pop(key)删除指定key和对应的值。dict和List的区别：dict的查找和插入速度极快，不会随着元素的增多而变慢。dict占用的内存较多。空间换时间。记住,dict中的key必须是不可变元素。key + Hash算法计算出值的内存地址。  s = set([1,2,3,3,4])s{1,2,3,4}set：创建一个set，需要传入一个List进入。add(key)remove(key)set相当于一个无序和不重复元素的集合。可以使用&amp;和|来进行交并集计算。注意：创建空集合的时候只能用set来创建，因为在Python中{}创建的是一个空的字典：s = {}type(s)dict区别：唯一区别是set没有存储对应的value整数的内存地址是不可变的    对一些简单的数值，为了提高效率，python会重用对象内存：x = 2y = 2x is yTruepython的一些数据值被视为False的有：False0None空字符串、空列表、空集合、空字典</code></pre><h4 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h4><pre><code>对应于元组（tuple）与列表（list）的关系，对于集合（set），Python提供了一种叫做不可变集合（frozen set）的数据结构。使用 frozenset 来进行创建：s = frozenset([1, 2, 3, &apos;a&apos;, 1])sfrozenset({1, 2, 3, &apos;a&apos;})与集合不同的是，不可变集合一旦创建就不可以改变。不可变集合的一个主要应用是用来作为字典的键。</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>Python中的函数类似于数学中的函数。</code></pre><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p><a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">Python中内置的函数</a></p><pre><code>例如：计算类函数：abs(x)，max(...)。数据类型转换函数：int()，str(), bool(), float()。函数名复制给变量，该变量指向了该函数的地址。因而，具有函数的功能。a = absa(-10)输出10。</code></pre><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><pre><code>def myAbs(x)：    if x &gt;= 0：        return x    else：         return -x以def为前缀 + 函数名 + (参数...), return返回函数返回值，没有return则返回None， return = return None。空函数：使用pass构造空函数def test:    pass也可以：if a &gt; 0:    pass</code></pre><h5 id="参数类型检查"><a href="#参数类型检查" class="headerlink" title="参数类型检查"></a>参数类型检查</h5><pre><code>使用isinstance检测参数类型：def myAbs(x):    if not isinstance (x, (int, float)):        raise TypeError(&quot;bad opread error&quot;)    if x &gt;= 0:        return x    else:        return -x</code></pre><h5 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h5><pre><code>当一个函数返回值有多个时，返回的是一个tuple，如(20, 30)。</code></pre><h5 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h5><pre><code>位置参数：test(x)、test(x, y)x、y的参数定义即为位置参数。默认参数：def test(x , age = 3, city = &apos;shenzhen&apos;)，其中age和city为默认参数。1.传入test(0)即为传入test(0, 3, &apos;shenzhen&apos;)。2.传入test(0, 25)即为传入test(0, 25, &apos;shenzhen&apos;)。3.传入test(0, city = &apos;guangzhou&apos;)即为传入&apos;guangzhou&apos;，注意，当参数位置不对应时，需要指明参数类型，即city。4.默认参数必须指向不变对象，使用test(city = none)替代test(city = [])，写入if(city = none):    city = []即可。额外的：为什么要设计str、none这样的不可变对象?可以避免在多线程中对象改变而造成的的错误，因此，尽量用不可变对象替代可变对象。可变参数：def test(*nums)1.可变参数在函数调用时自动组装成一个Tuple。2.nums可以是0个或多个数据。3.nums可以是一个List或者Tuple，此时*nums表示将List或者Tuple中的元素转化成可变参数传递进去。（内容拷贝）关键字参数：def test(**nums)1.关键字参数在函数调用时自动组装成一个dict。2.nums可以是0个或多个数据。3.nums可以是一个dict，此时**nums表示将dict中的元素转化为关键字参数传递进去。（内容拷贝）命名关键字参数：def test(a, *, b, c)，*，后面的为命名关键字参数。1.当函数中存在可变参数*x时，*x的作用等效于*，即此时，b、c也为命名关键字参数。2.调用含有关键字参数的函数时，应该使用key = value的形式，如本例：test(a, b = 1, c = &apos;haha&apos;)。3.当函数中指定了缺省值时，如def test(a, *x, b = 1, c)，此时，使用函数时可不填b参数。参数组合：5种参数的组合顺序为：位置参数、默认参数、可变参数、命名关键字参数、关键字参数。任意参数组合的函数都能给函数传入function(*x, **y)的组合传值形式。注意：参数组合过多会影响语义，尽量避免使用多参数组合。使用*args和**kw是习惯写法，建议遵循。</code></pre><h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><pre><code>1.优点：逻辑简单清晰，缺点：调用过深会导致栈溢出。2.可使用尾递归(返回自身本身)优化的方式避免栈溢出。3.大多数编程语言(包括Python)的编译器或解释器都没有针对尾递归进行优化。</code></pre><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><pre><code>代码越少，效率越高。</code></pre><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><pre><code>nums = list(range(100))切片：nums[0:2] == nums[:2]表示取下标为0到2(不包括2)的数据。倒数切片：nums[-2:0] == nums[-2:]表示取下标为-2到0(不包括0)的数据。nums[:10:2]前10个数，每2个取一个。nums[::5]所有数，每5个取一个。nums[::-1]取倒数。nums[:]输出该list。注意：nums指向的数据类型是什么，nums[...]取出来的数据类型就是什么。</code></pre><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><pre><code>for i in nums不管是否有下标，只要能迭代，就能使用迭代器。对于dict，迭代的是key，迭代value：for i in nums.values()迭代key、value for i in nums.items()1.通过collections的Iterable来判读是否能迭代：from collections import Iterableisinstance(&apos;abcd&apos;, Iterable)2.使用内置的enumerate将list变成索引-元素对：for i, j in enumerate([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]):    print(i, j)</code></pre><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><pre><code>[i * i for i in range(1, 10)][i * i for i in range(1, 10) if i % 2 == 0][i * j for i in range(1, 10) for j in range(1, 10)][i * j for i in range(1, 10) if i % 2 == 0 for j in range(1, 10) if j % 2 == 0]注意：&apos;a&apos; + 1，不同于java，python计算会出错。此外，列表生成式还可以生成集合和字典：{i ** 2 for i in range(1, 10)}{i : i ** 2 for i in range(1, 10)}可以使用sum()得到生成式的和：total = sum([i ** 2 for i in range(1, 10)])但是这样python为它生成了一个列表，并且由于没有变量指向它，它会被放在垃圾回收器中，因此，此时使用产生式列表替代它：total = sum(i ** 2 for i in range(1, 10))</code></pre><h6 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h6><pre><code>g = (x * x for x in range(10))for i in g一边循环，一边计算的机制称为生成器。获取返回值，必须捕获StopIterable异常。返回值就在包含在StopIterable的value中。except StopIterable as e：    print(e.value)    break普通函数和generate函数的区别普通函数调用直接返回结果，generate函数调用返回generate对象。def fib(max):n, a, b = 0, 0, 1while n &lt; max:    yield b    a, b = b, a + b    n = n + 1return &apos;done&apos;函数中使用yield关键字，每次调用next()时，遇到yield语句就返回，再次执行next()时，又继续从上次的位置往下执行。</code></pre><h5 id="迭代器对象"><a href="#迭代器对象" class="headerlink" title="迭代器对象"></a>迭代器对象</h5><pre><code>直接作用于for循环的数据类型有以下几种：1.集合类型：list、tuple、dict、set、str等等。2.generate类型：generate对象和generate函数。这些可直接作用于for循环的对象称为Iterable对象。1.可直接作用于next()函数的数据类型称为Iterator对象。所有的生成器都是Iterator，而list、dict、str则不是。why：Iterator至少需满足2个条件：    1.长度不能够被提前知道。    2.可以表示无限大的数据。2.可通过iter()函数来获得一个Iterator对象。3.python的for循环的本质就是不断调用next()函数来实现的。</code></pre><h3 id="函数式编程语言"><a href="#函数式编程语言" class="headerlink" title="函数式编程语言"></a>函数式编程语言</h3><pre><code>抽象程度很高的编程范式。只要输入确定，输出就确定，就是纯函数式编程语言。否则，则不是(当有变量存在函数中)。特点：允许将函数作为参数传入另一个函数，也可以返回一个函数。</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><h5 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h5><pre><code>x = absx(-10)10说明变量指向函数</code></pre><h5 id="函数名指向变量"><a href="#函数名指向变量" class="headerlink" title="函数名指向变量"></a>函数名指向变量</h5><pre><code>abs是函数名，同时它也是一个变量，它指向一个计算绝对值的函数。</code></pre><h5 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h5><pre><code>既然变量可以作为参数传入到函数中，那么因为函数名指向变量得缘故，所以函数中可以传入函数，传入函数作为变量的函数称为高阶函数。</code></pre><h5 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h5><pre><code>def f(x):    return x * xy = map(f, [1, 3, 5])list(y)[1, 9, 25]map函数传入2个参数，第一个参数是函数，第二个是Iterable对象，map将传入的结果依次作用到Iterable对象的每一个元素，最后返回一个Iterator(map)对象。此外，map函数还可以作用于多个参数：def f(x, y):    return x * yy = map(f, [2, 3], (2, 4))from functools import reducedef f(x, y):    return x + yreduce(f, [1, 2, 3, 4]) == f(f(f(1, 2), 3), 4)reduce函数传入2个参数，第一个参数是函数，第二个是Iterable对象，reduce将每次取2个元素使用函数计算，得出的结果继续和下个元素传入函数做计算，依次类推。</code></pre><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><pre><code>def is_odd(x):    return x % 2 == 1list(filter(is_odd, [1, 2, 3, 4]))[1, 3]过滤序列，同map/reduce一样，传入2个参数，第一个参数是函数，第二个是Iterable对象，对Iterable对象的每一个元素作用函数，返回True则保留，否则不保留。</code></pre><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><pre><code>sorted([&apos;Hello&apos;, &apos;JsonChao&apos;, &apos;quchao&apos;], key = str.lower, reverse = True)对字符串排序是按首字母的ASCLL码对应的值大小来进行。key给要排序的元素作用同一个函数，reverse = True为反转排序结果。用sorted排序的关键在于实现一个映射函数。</code></pre><h4 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h4><h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><pre><code>def sum(*nums):    def add():        ax = 0        for n in nums:            ax = ax + i        return ax    return add其中，add是返回函数，输出add为函数本身，add()为函数返回值。注意：x1 = sum(1, 3, 5)    x2 = sum(1, 3, 5)    x1 == x2    输出False。</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code>注意：返回闭包时应牢记不要引用循环变量和后面会发生改变的变量。如要使用，在内部再创建一个函数，用该函数的参数绑定循环变量的值。</code></pre><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><pre><code>使用lambda实现匿名内部类，形如：: 前面的为参数，lambda x, y : x * y无参则为lambda: x * x</code></pre><h4 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h4><h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a><strong>name</strong>属性</h5><pre><code>当我们想让当前.py文件既可以当成一个模块，又可以当成作为一个脚本使用时，可以写成如下：test()是该脚本中的方法。只有.py被当做脚本执行时，__name__的值才会是__main__。if __name__ == ‘__main__’:    test()</code></pre><h5 id="导入模块或模块中的变量"><a href="#导入模块或模块中的变量" class="headerlink" title="导入模块或模块中的变量"></a>导入模块或模块中的变量</h5><pre><code>import os 导入模块from ex2 import PI导入ex2模块中的变量PIfrom ex2 import *导入所有变量</code></pre><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><pre><code>__init__文件存在文件夹中则表明这是一个包。</code></pre><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><pre><code>try:    ...catch ValueError as exc：    exc.message捕捉单个异常try:    ...catch (ValueError, ZeroDivisionError):    ...try:    ...catch ValueError:    ...catch ZeroDivisionError：    ...捕捉多个异常try:    ...catch Expection：    ...捕捉所有异常raise ValueError(&quot;Value error&quot;)使用raise来抛出异常try:    ... ##有异常的代码块finally:    ...finally会在try后执行，抛出异常前执行。try:    ...catch Expection:    ...finally:    ...如果异常被捕获了，finally则会最后执行。</code></pre><h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><pre><code>使用 warnings.warn(msg, RuntimeWarning)抛出警告，在调用抛出警告的方法前加上warnings.filterwarnings(action = &apos;ignore&apos;, category = RuntimeWarning)可过滤指定的警告。</code></pre><h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><pre><code>%%writefile test.txt...写入文件f = open(&quot;test.txt&quot;)f = file(&quot;test.txt&quot;)打开文件f.read()读入文件夹中的所有内容。f.readLines()行读入文件，返回一个列表，格式为:[..../n..../n...]f.close()文件读写完毕，关闭文件。f = open(&apos;test.txt&apos;, &apos;w&apos;)f.write(&apos;hello, python, I come in~&apos;)f.close()print open(&apos;test.txt&apos;).read()使用open函数的写入模式来写文件,如果文件不存在，则创建该文件写入，如果之前已经存在该文件，则会把之前写入的内容覆盖。将&apos;w&apos;改为&apos;a&apos;，即使用追加模式加入新的内容到文件中。将&apos;w&apos;改为&apos;w+&apos;即可使用读写模式，使用f.read()即可读出文件内容。注意：二进制文件的写入，读取格式为&apos;wb&apos;,&apos;rb&apos;。</code></pre><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一文全面了解Android单元测试</title>
      <link>http://yoursite.com/2018/07/09/%E4%B8%80%E6%96%87%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <guid>http://yoursite.com/2018/07/09/%E4%B8%80%E6%96%87%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <pubDate>Mon, 09 Jul 2018 15:06:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p><a href="https://github.com/JsonChao/Awesome-WanAndroid/tree/master/app/src/test/java/json/chao/com/wanandroid" target="_blank" rel="external">==》完整项目单元测试学习案例</a></p><p>众所周知，一个好的项目需要不断地打造，而一些有效的测试则是加速这一过程的利器。本篇博文将带你了解并逐步深入Android单元测试。</p><h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><hr><p>单元测试就是针对类中的某一个方法进行验证是否正确的过程，单元就是指<strong>独立的粒子</strong>，在Android和Java中大都是指方法。</p><h3 id="为什么要进行单元测试？"><a href="#为什么要进行单元测试？" class="headerlink" title="为什么要进行单元测试？"></a>为什么要进行单元测试？</h3><hr><p>使用单元测试可以提高开发效率，当项目随着迭代越来越大时，每一次编译、运行、打包、调试需要耗费的时间会随之上升，因此，使用单元测试可以不需这一步骤就可以对单个方法进行功能或逻辑测试。<br>同时，为了能测试每一个细分功能模块，需要将其相关代码抽成相应的方法封装起来，这也在一定程度上改善了代码的设计。因为是单个方法的测试，所以能更快地定位到bug。</p><p>单元测试case需要对这段业务逻辑进行验证。在验证的过程中，开发人员可以<strong>深度了解业务流程</strong>，同时新人来了看一下项目单元测试就知道<strong>哪个逻辑跑了多少函数，需要注意哪些边界</strong>——是的，单元测试做的好和文档一样<strong>具备业务指导能力。</strong></p><h3 id="Android测试的分类"><a href="#Android测试的分类" class="headerlink" title="Android测试的分类"></a>Android测试的分类</h3><hr><p>Android测试主要分为三个方面：</p><pre><code>单元测试（Junit4、Mockito、PowerMockito、Robolectric）UI测试（Espresso、UI Automator）压力测试（Monkey）</code></pre><h3 id="一、单元测试之基础Junit4"><a href="#一、单元测试之基础Junit4" class="headerlink" title="一、单元测试之基础Junit4"></a>一、单元测试之基础Junit4</h3><hr><h4 id="什么是Junit4？"><a href="#什么是Junit4？" class="headerlink" title="什么是Junit4？"></a>什么是Junit4？</h4><hr><p>Junit4是事实上的Java标准测试库，并且它是JUnit框架有史以来的最大改进，其主要目标便是利用Java5的Annotation特性简化测试用例的编写。</p><h4 id="开始使用Junit4进行单元测试"><a href="#开始使用Junit4进行单元测试" class="headerlink" title="开始使用Junit4进行单元测试"></a>开始使用Junit4进行单元测试</h4><hr><h5 id="1-Android-Studio已经自动集成了Junit4测试框架，如下"><a href="#1-Android-Studio已经自动集成了Junit4测试框架，如下" class="headerlink" title="1.Android Studio已经自动集成了Junit4测试框架，如下"></a>1.Android Studio已经自动集成了Junit4测试框架，如下</h5><pre><code>dependencies {    ...    testImplementation &apos;junit:junit:4.12&apos;}</code></pre><h5 id="2-Junit4框架使用时涉及到的重要注解如下"><a href="#2-Junit4框架使用时涉及到的重要注解如下" class="headerlink" title="2.Junit4框架使用时涉及到的重要注解如下"></a>2.Junit4框架使用时涉及到的重要注解如下</h5><pre><code>@Test 指明这是一个测试方法 (@Test注解可以接受2个参数，一个是预期错误expected，一个是超时时间timeout，格式如 @Test(expected = IndexOutOfBoundsException.class), @Test（timeout = 1000)@Before 在所有测试方法之前执行@After 在所有测试方法之后执行@BeforeClass 在该类的所有测试方法和@Before方法之前执行 （修饰的方法必须是静态的）@AfterClass 在该类的所有测试方法和@After方法之后执行（修饰的方法必须是静态的）@Ignore 忽略此单元测试</code></pre><p>此外，很多时候，因为某些原因（比如正式代码还没有实现等），我们可能想让JUnit忽略某些方法，让它在跑所有测试方法的时候不要跑这个测试方法。要达到这个目的也很简单，只需要在要被忽略的<strong>测试方法前面加上@Ignore</strong>就可以了</p><h5 id="3-主要的测试方法——断言"><a href="#3-主要的测试方法——断言" class="headerlink" title="3.主要的测试方法——断言"></a>3.主要的测试方法——断言</h5><pre><code>assertEquals(expected, actual) 判断2个值是否相等，相等则测试通过。assertEquals(expected, actual, tolerance) tolerance 偏差值</code></pre><p>注意：上面的每一个方法，都有一个重载的方法，可以加一个String类型的参数，表示如果验证失败的话，将<strong>用这个字符串作为失败的结果报告</strong>。</p><h5 id="4-自定义Junit-Rule——实现TestRule接口并重写apply方法"><a href="#4-自定义Junit-Rule——实现TestRule接口并重写apply方法" class="headerlink" title="4.自定义Junit Rule——实现TestRule接口并重写apply方法"></a>4.自定义Junit Rule——实现TestRule接口并重写apply方法</h5><pre><code>public class JsonChaoRule implements TestRule {    @Override    public Statement apply(final Statement base, final Description description) {        Statement repeatStatement =  new Statement() {            @Override            public void evaluate() throws Throwable {                    //测试前的初始化工作                    //执行测试方法                    base.evaluate();                    //测试后的释放资源等工作            }        };        return repeatStatement;    }}</code></pre><p>然后在想要的测试类中使用@Rule注解声明使用JsonChaoRule即可（注意<strong>被@Rule注解的变量必须是final的</strong>）：</p><pre><code>@Rulepublic final JsonChaoRule repeatRule = new JsonChaoRule();</code></pre><h5 id="5-开始上手，使用Junit4进行单元测试"><a href="#5-开始上手，使用Junit4进行单元测试" class="headerlink" title="5.开始上手，使用Junit4进行单元测试"></a>5.开始上手，使用Junit4进行单元测试</h5><pre><code>1.编写测试类。2.鼠标右键点击测试类，选择选择Go To-&gt;Test（或者使用快捷键Ctrl+Shift+T，此快捷键可以在方法和测试方法之间来回切换）在Test/java/项目测试文件夹/下自动生成测试模板。3.使用断言（assertEqual、assertEqualArrayEquals等等)进行单元测试。4.右键点击测试类，Run编写好的测试类。</code></pre><h5 id="6-使用Android-Studio自带的Gradle脚本自动化单元测试"><a href="#6-使用Android-Studio自带的Gradle脚本自动化单元测试" class="headerlink" title="6.使用Android Studio自带的Gradle脚本自动化单元测试"></a>6.使用Android Studio自带的Gradle脚本自动化单元测试</h5><p>点击Android Studio中的<strong>Gradle projects</strong>下的<strong>app/Tasks/verification/test</strong>即可同时测试module下所有的测试类（案例），并在<strong>module下的build/reports/tests/下</strong>生成对应的<strong>index.html测试报告</strong>。</p><h5 id="7-对Junit4的总结："><a href="#7-对Junit4的总结：" class="headerlink" title="7.对Junit4的总结："></a>7.对Junit4的总结：</h5><pre><code>优点：速度快，支持代码覆盖率等代码质量的检测工具，缺点：无法单独对Android UI，一些类进行操作，与原生JAVA有一些差异。</code></pre><p>可能涉及到的额外的概念：</p><p>打桩方法：使方法简单快速地返回一个有效的结果。</p><p>测试驱动开发：编写测试，实现功能使测试通过，然后不断地使用这种方式实现功能的快速迭代开发。</p><h3 id="二、单元测试之基础Mockito"><a href="#二、单元测试之基础Mockito" class="headerlink" title="二、单元测试之基础Mockito"></a>二、单元测试之基础Mockito</h3><hr><h4 id="什么是Mockito？"><a href="#什么是Mockito？" class="headerlink" title="什么是Mockito？"></a>什么是Mockito？</h4><p>Mockito 是美味的 Java 单元测试 Mock 框架，mock可以模拟各种各样的对象，从而代替真正的对象做出希望的响应。</p><h4 id="开始使用Mockito进行单元测试"><a href="#开始使用Mockito进行单元测试" class="headerlink" title="开始使用Mockito进行单元测试"></a>开始使用Mockito进行单元测试</h4><h5 id="1-在build-gradle里面添加Mcokito的依赖"><a href="#1-在build-gradle里面添加Mcokito的依赖" class="headerlink" title="1.在build.gradle里面添加Mcokito的依赖"></a>1.在build.gradle里面添加Mcokito的依赖</h5><pre><code>testImplementation &apos;org.mockito:mockito-core:2.7.1&apos;</code></pre><h5 id="2-使用mock-方法模拟对象"><a href="#2-使用mock-方法模拟对象" class="headerlink" title="2.使用mock()方法模拟对象"></a>2.使用mock()方法模拟对象</h5><pre><code>Person mPerson = mock(Person.class); </code></pre><h5 id="能量补充站（-vov-）"><a href="#能量补充站（-vov-）" class="headerlink" title="能量补充站（-vov-）"></a>能量补充站（-vov-）</h5><p>在JUnit框架下，case（带@Test注解的那个函数）也是个函数，直接调用这个函数就不是case，和case是无关的，两者并不会相互影响，可以直接调用以减少重复代码。<strong>单元测试不应该对某一个条件过度耦合</strong>，因此，需要用mock解除耦合，<strong>直接mock出网络请求得到的数据，单独验证页面对数据的响应。</strong></p><h5 id="3-验证方法的调用，指定方法的返回值，或者执行特定的动作"><a href="#3-验证方法的调用，指定方法的返回值，或者执行特定的动作" class="headerlink" title="3.验证方法的调用，指定方法的返回值，或者执行特定的动作"></a>3.验证方法的调用，指定方法的返回值，或者执行特定的动作</h5><pre><code>when(iMathUtils.sum(1, 1)).thenReturn(2); doReturn(3).when(iMathUtils).sum(1,1);   //给方法设置桩可以设置多次，只会返回最后一次设置的值doReturn(2).when(iMathUtils).sum(1,1);//验证方法调用次数//方法调用1次Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)).thenReturn(true);//方法调用3次Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)， Mockito.times(3).thenReturn(true);//verify方法用于验证“模仿对象”的互动或验证发生的某些行为verify(mPerson, atLeast(2)).getAge();//参数匹配器,用于匹配特定的参数any()contains()argThat()when(mPerson.eat(any(String.class))).thenReturn(&quot;米饭&quot;);//除了mock()外，spy()也可以模拟对象，spy与mock的//唯一区别就是默认行为不一样：spy对象的方法默认调用//真实的逻辑，mock对象的方法默认什么都不做，或直接//返回默认值//如果要保留原来对象的功能，而仅仅修改一个或几个//方法的返回值，可以采用spy方法,无参构造的类初始//化也使用spy方法Person mPerson = spy(Person.class); //检查入参的mocks是否有任何未经验证的交互verifyNoMoreInteractions(iMathUtils);</code></pre><h5 id="4-使用Mockito后的思考"><a href="#4-使用Mockito后的思考" class="headerlink" title="4.使用Mockito后的思考"></a>4.使用Mockito后的思考</h5><p>简单的测试会使整体的代码更简单，更可读、更可维护。如果你<strong>不能把测试写的很简单，那么请在测试时重构你的代码</strong>。    </p><pre><code>优点：丰富强大的方式验证“模仿对象”的互动或验证发生的某些行为缺点：Mockito框架不支持mock匿名类、final类、static方法、private方法。</code></pre><p>虽然，static方法可以使用wrapper静态类的方式实现mockito的单元测试，但是，毕竟过于繁琐，因此，PowerMockito由此而来。</p><h3 id="三、拯救Mockito于水深火热的PowerMockito"><a href="#三、拯救Mockito于水深火热的PowerMockito" class="headerlink" title="三、拯救Mockito于水深火热的PowerMockito"></a>三、拯救Mockito于水深火热的PowerMockito</h3><hr><h4 id="什么是PowerMockito？"><a href="#什么是PowerMockito？" class="headerlink" title="什么是PowerMockito？"></a>什么是PowerMockito？</h4><hr><p>PowerMockito是一个扩展了Mockito的具有更强大功能的单元测试框架，它支持mock匿名类、final类、static方法、private方法</p><h4 id="开始PowerMockito之旅"><a href="#开始PowerMockito之旅" class="headerlink" title="开始PowerMockito之旅"></a>开始PowerMockito之旅</h4><hr><h5 id="1-在build-gradle里面添加Mcokito的依赖-1"><a href="#1-在build-gradle里面添加Mcokito的依赖-1" class="headerlink" title="1.在build.gradle里面添加Mcokito的依赖"></a>1.在build.gradle里面添加Mcokito的依赖</h5><pre><code>testImplementation &apos;org.powermock:powermock-module-junit4:1.6.5&apos;testImplementation &apos;org.powermock:powermock-api-mockito:1.6.5&apos;</code></pre><h5 id="2-用PowerMockito来模拟对象"><a href="#2-用PowerMockito来模拟对象" class="headerlink" title="2.用PowerMockito来模拟对象"></a>2.用PowerMockito来模拟对象</h5><pre><code>//使用PowerMock须加注解@PrepareForTest和@RunWith(PowerMockRunner.class)（@PrepareForTest()里写的是对应方法所在的类    ，mockito支持的方法使用PowerMock的形式实现时，可以不加这两个注解）@PrepareForTest(T.class)@RunWith(PowerMockRunner.class)//mock含静态方法或字段的类    PowerMockito.mockStatic(Banana.class);//Powermock提供了一个Whitebox的class，可以方便的绕开权限限制，可以get/set private属性，实现注入。也可以调用private方法。也可以处理static的//属性/方法，根据不同需求选择不同参数的方法即可。//修改类里面静态字段的值Whitebox.setInternalState(Banana.class, &quot;COLOR&quot;, &quot;蓝色&quot;);//调用类中的真实方法PowerMockito.when(banana.getBananaInfo()).thenCallRealMethod();//验证私有方法是否被调用PowerMockito.verifyPrivate(banana, times(1)).invoke(&quot;flavor&quot;);//忽略调用私有方法PowerMockito.suppress(PowerMockito.method(Banana.class, &quot;flavor&quot;));//修改私有变量MemberModifier.field(Banana.class, &quot;fruit&quot;).set(banana, &quot;西瓜&quot;);//使用PowerMockito mock出来的对象可以直接调用final方法Banana banana = PowerMockito.mock(Banana.class);//whenNew 方法的意思是之后 new 这个对象时，返回某个被 Mock //的对象而不是让真的 new //新的对象。如果构造方法有参数，可以在withNoArguments方法中传入。PowerMockito.whenNew(Banana.class).withNoArguments().thenReturn(banana);</code></pre><h5 id="3-使用PowerMockRule来代替-RunWith-PowerMockRunner-class-的方式，需要多添加以下依赖："><a href="#3-使用PowerMockRule来代替-RunWith-PowerMockRunner-class-的方式，需要多添加以下依赖：" class="headerlink" title="3.使用PowerMockRule来代替@RunWith(PowerMockRunner.class)的方式，需要多添加以下依赖："></a>3.使用PowerMockRule来代替@RunWith(PowerMockRunner.class)的方式，需要多添加以下依赖：</h5><pre><code>testImplementation &quot;org.powermock:powermock-module-junit4-rule:1.7.4&quot;testImplementation &quot;org.powermock:powermock-classloading-xstream:1.7.4&quot;</code></pre><p>使用示例如下：</p><pre><code>@Rulepublic PowerMockRule mPowerMockRule = new PowerMockRule();</code></pre><h5 id="4-使用Parameterized来进行参数化测试："><a href="#4-使用Parameterized来进行参数化测试：" class="headerlink" title="4.使用Parameterized来进行参数化测试："></a>4.使用Parameterized来进行参数化测试：</h5><p><strong>通过注解@Parameterized.parameters提供一系列数据给构造器中的构造参数</strong>或给<strong>被注解@Parameterized.parameter注解的public全局变量</strong></p><pre><code>RunWith(Parameterized.class)public class ParameterizedTest {    private int num;    private boolean truth;    public ParameterizedTest(int num, boolean truth) {        this.num = num;        this.truth = truth;    }    //被此注解注解的方法将把返回的列表数据中的元素对应注入到测试类    //的构造函数ParameterizedTest(int num, boolean truth)中    @Parameterized.Parameters    public static Collection providerTruth() {        return Arrays.asList(new Object[][]{                {0, true},                {1, false},                {2, true},                {3, false},                {4, true},                {5, false}        });    }//    //也可不使用构造函数注入的方式，使用注解注入public变量的方式//    @Parameterized.Parameter//    public int num;//    //value = 1指定括号里的第二个Boolean值//    @Parameterized.Parameter(value = 1)//    public boolean truth;    @Test    public void printTest() {        Assert.assertEquals(truth, print(num));        System.out.println(num);    }    private boolean print(int num) {        return num % 2 == 0;    }}</code></pre><h3 id="四、能在Java单元测试里面执行Android代码的Robolectric"><a href="#四、能在Java单元测试里面执行Android代码的Robolectric" class="headerlink" title="四、能在Java单元测试里面执行Android代码的Robolectric"></a>四、能在Java单元测试里面执行Android代码的Robolectric</h3><hr><h4 id="什么是Robolectric？"><a href="#什么是Robolectric？" class="headerlink" title="什么是Robolectric？"></a>什么是Robolectric？</h4><hr><p>Robolectric通过<strong>一套能运行在JVM上的Android代码</strong>，解决了在Java单元测试中很难进行Android单元测试的痛点。</p><h4 id="进入Roboletric的领地"><a href="#进入Roboletric的领地" class="headerlink" title="进入Roboletric的领地"></a>进入Roboletric的领地</h4><hr><h5 id="1-在build-gradle里面添加Robolectric的依赖"><a href="#1-在build-gradle里面添加Robolectric的依赖" class="headerlink" title="1.在build.gradle里面添加Robolectric的依赖"></a>1.在build.gradle里面添加Robolectric的依赖</h5><pre><code>//Robolectric核心testImplementation &quot;org.robolectric:robolectric:3.8&quot;//支持support-v4testImplementation &apos;org.robolectric:shadows-support-v4:3.4-rc2&apos;//支持Multidex功能testImplementation &quot;org.robolectric:shadows-multidex:3.+&quot; </code></pre><h5 id="2-Robolectric常用用法"><a href="#2-Robolectric常用用法" class="headerlink" title="2.Robolectric常用用法"></a>2.Robolectric常用用法</h5><p>首先给指定的测试类上面进行配置</p><pre><code>@RunWith(RobolectricTestRunner.class)//目前Robolectric最高支持sdk版本为23。@Config(constants = BuildConfig.class, sdk = 23)</code></pre><p>下面是一些常用用法</p><pre><code>//当Robolectric.setupActivity()方法返回的时候，//默认会调用Activity的onCreate()、onStart()、onResume()mTestActivity = Robolectric.setupActivity(TestActivity.class);//获取TestActivity对应的影子类，从而能获取其相应的动作或行为ShadowActivity shadowActivity = Shadows.shadowOf(mTestActivity);Intent intent = shadowActivity.getNextStartedActivity();//使用ShadowToast类获取展示toast时相应的动作或行为Toast latestToast = ShadowToast.getLatestToast();Assert.assertNull(latestToast);//直接通过ShadowToast简单工厂类获取Toast中的文本Assert.assertEquals(&quot;hahaha&quot;, ShadowToast.getTextOfLatestToast());//使用ShadowAlertDialog类获取展示AlertDialog时相应的//动作或行为（暂时只支持app包下的，不支持v7。。。）latestAlertDialog = ShadowAlertDialog.getLatestAlertDialog();AlertDialog latestAlertDialog = ShadowAlertDialog.getLatestAlertDialog();Assert.assertNull(latestAlertDialog);//使用RuntimeEnvironment.application可以获取到//Application，方便我们使用。比如访问资源文件。Application application = RuntimeEnvironment.application;String appName = application.getString(R.string.app_name);Assert.assertEquals(&quot;WanAndroid&quot;, appName);//也可以直接通过ShadowApplication获取applicationShadowApplication application = ShadowApplication.getInstance();Assert.assertNotNull(application.hasReceiverForIntent(intent));</code></pre><p>自定义Shadow类</p><pre><code>@Implements(Person.class)public class ShadowPerson {    @Implementation    public String getName() {        return &quot;AndroidUT&quot;;    }}@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class,        sdk = 23,        shadows = {ShadowPerson.class})    Person person = new Person();    //实际上调用的是ShadowPerson的方法，输出JsonChao    Log.d(&quot;test&quot;, person.getName());    ShadowPerson shadowPerson = Shadow.extract(person);    //测试通过    Assert.assertEquals(&quot;JsonChao&quot;, shadowPerson.getName());}</code></pre><p>注意：<br>异步测试出现一些问题（比如改变一些编码习惯，比如回调函数不能写成匿名内部类对象，需要定义一个全局变量，并破坏其封装性，即提供一个get方法，供UT调用），解决方案<strong>使用Mockito来结合进行测试，将异步转为同步</strong>。</p><h5 id="3-Robolectric的优缺点"><a href="#3-Robolectric的优缺点" class="headerlink" title="3.Robolectric的优缺点"></a>3.Robolectric的优缺点</h5><pre><code>优点：支持大部分Android平台依赖类底层的引用与模拟。缺点：异步测试有些问题，需要结合一些框架来配合完成更多功能。</code></pre><h3 id="五、单元测试覆盖率报告生成之jacoco"><a href="#五、单元测试覆盖率报告生成之jacoco" class="headerlink" title="五、单元测试覆盖率报告生成之jacoco"></a>五、单元测试覆盖率报告生成之jacoco</h3><hr><h4 id="什么是Jacoco"><a href="#什么是Jacoco" class="headerlink" title="什么是Jacoco"></a>什么是Jacoco</h4><hr><p>Jacoco的全称为Java Code Coverage（Java代码覆盖率），可以<strong>生成java的单元测试代码覆盖率报告</strong>。</p><h4 id="加入Jacoco到你的单元测试大家族"><a href="#加入Jacoco到你的单元测试大家族" class="headerlink" title="加入Jacoco到你的单元测试大家族"></a>加入Jacoco到你的单元测试大家族</h4><hr><p>在应用Module下加入jacoco.gradle自定义脚本，app.gradle apply from它，同步，即可看到在app的Task下生成了Report目录，Report目录<br>下生成了JacocoTestReport任务。</p><pre><code>apply plugin: &apos;jacoco&apos;jacoco {    toolVersion = &quot;0.7.7.201606060606&quot; //指定jacoco的版本    reportsDir = file(&quot;$buildDir/JacocoReport&quot;) //指定jacoco生成报告的文件夹}//依赖于testDebugUnitTest任务task jacocoTestReport(type: JacocoReport, dependsOn: &apos;testDebugUnitTest&apos;) {    group = &quot;reporting&quot; //指定task的分组    reports {        xml.enabled = true //开启xml报告        html.enabled = true //开启html报告    }    def debugTree = fileTree(dir: &quot;${buildDir}/intermediates/classes/debug&quot;,            includes: [&quot;**/*Presenter.*&quot;],            excludes: [&quot;*.*&quot;])//指定类文件夹、包含类的规则及排除类的规则，            //这里我们生成所有Presenter类的测试报告    def mainSrc = &quot;${project.projectDir}/src/main/java&quot; //指定源码目录    sourceDirectories = files([mainSrc])    classDirectories = files([debugTree])    executionData = files(&quot;${buildDir}/jacoco/testDebugUnitTest.exec&quot;)//指定报告数据的路径}</code></pre><p>在Gradle构建板块<strong>Gradle.projects</strong>下的<strong>app/Task/verification</strong>下，其中<strong>testDebugUnitTest</strong>构建任务会生成单元测试结果报告，包<strong>含xml及html</strong>格式，分别对应<strong>test-results和reports</strong>文件夹；jacocoTestReport任务会生成单元测试覆盖率报告，结果存放在jacoco和JacocoReport文件夹。</p><p><img src="https://s1.ax1x.com/2018/07/09/PnEv7j.png" alt="image"></p><p>生成的JacocoReport文件夹下的index.html即对应的单元测试覆盖率报告，用浏览器打开后，可以看到覆盖情况被不同的颜色标识出来，其中<strong>绿色表示代码被单元测试覆盖到，黄色表示部分覆盖，红色则表示完全没有覆盖到</strong>。</p><h3 id="六、单元测试的流程"><a href="#六、单元测试的流程" class="headerlink" title="六、单元测试的流程"></a>六、单元测试的流程</h3><hr><p>要验证程序正确性，必然要给出所有可能的条件（极限编程），并验证其行为或结果，才算是100%覆盖条件。实际项目中，验证<strong>一般条件</strong>和<strong>边界条件</strong>就OK了。</p><p>在实际项目中，<strong>单元测试对象与页面是一对一的</strong>，并不建议跨页面，这样的单元测试耦合太大，维护困难。<br>需要写完后，看覆盖率，找出单元测试中没有覆盖到的函数分支条件等，然后继续补充单元测试case列表，并在单元测试工程代码中补上case。<br>直到规划的<strong>页面中所有逻辑的重要分支、边界条件都被覆盖</strong>，该项目的单元测试结束。</p><h5 id="建议（-ovo-）"><a href="#建议（-ovo-）" class="headerlink" title="建议（-ovo-）~"></a>建议（-ovo-）~</h5><hr><p>可以从公司项目<strong>小规模使用</strong>，形成<strong>自己的单元测试风格</strong>后，就可以跟大范围地推广了。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="http://www.wanandroid.com/blog/show/2085" target="_blank" rel="external">必知必会 | Android 测试相关的方方面面都在这儿</a></p><p>2、<a href="https://www.jianshu.com/p/03118c11c199" target="_blank" rel="external">在Android Studio中进行单元测试和UI测试</a></p><p>3、<a href="https://www.jianshu.com/p/0a8bbfe6cba2" target="_blank" rel="external">Android单元测试（一）</a></p><p>4、<a href="https://www.jianshu.com/subscriptions" target="_blank" rel="external">Android单元测试（二）</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/07/09/%E4%B8%80%E6%96%87%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>可能会改变你的话</title>
      <link>http://yoursite.com/2018/04/22/Some%20awesome%20tips/</link>
      <guid>http://yoursite.com/2018/04/22/Some%20awesome%20tips/</guid>
      <pubDate>Sun, 22 Apr 2018 13:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><pre><code>这是一篇记录平时读书遇到的一些让人觉得会改变自己的话。</code></pre><h4 id="Some-awesome-tips"><a href="#Some-awesome-tips" class="headerlink" title="Some awesome tips"></a>Some awesome tips</h4><pre><code>1.一个浪头打过来，最好的办法是迎上去了解个究竟，而不是漠视，或者干脆当事情没有发生。2.记住这个教训：别猜，去问！去查！3.隔一段时间重顾知识是记忆的关键方法。不要一次性学完一项知识就不管了，这样你无法真正的掌握。隔一段时间回顾一下，每次重复，你都会加深自己的理解，次数多了，你就会理解每个细节，成为真正的专家。4.对于一个技术通常我们需要抱有这样的疑问它是什么 一句话概括解决了什么问题 存在的意义怎样去使用它怎样解决了问题 内部的实现它的缺点是什么 多角度分析5.高效率的学习方法。理清楚概念很重要做好控制变量法多动手实践，与理论结合抓住重点，剔除干扰因素6.关于如何选择第三方库确定这个库是否是必需的这个库能否带来开发效率的提升，降低代码的维护成本这个库的学习成本如何 比如rxjava其实学习成本会相对高一些。这个库的质量如何，不要仅仅看star，更要看issue的处理情况。7.怎样练习算法题？每道算法题都先自己去实现，先写思路，然后自己去实现一遍，然后再看看答案，记住答案的思路，第二天再重新按照答案的思路实现一遍。8.&quot;另类&quot;的学习方法抄书的奥妙——那就是延缓阅读速度，不至遗漏每一个重要的细节：眼到，手到，心到，其实不仅书抄得，代码(优秀源码)也抄得。9.建议：建立逐字稿计算机网络相关的逐字稿计算机操作系统相关的逐字稿数据库相关的逐字稿设计模式相关的逐字稿数据结构与算法相关的逐字稿Java知识相关的逐字稿Kotlin知识相关的逐字稿Python知识相关的逐字稿React Native知识相关的逐字稿Flutter知识相关的逐字稿小程序知识相关的逐字稿JS知识相关的逐字稿Android知识相关的逐字稿与技术无关的逐字稿10.如何提升你的阅读能力？只字不差的反复阅读真正的获取知识，是通过阅读，深入思考与践行11.如何高效阅读一篇文章？由主题扩展为知识树尝试描述尝试记忆12.如何阅读源码？准备：Java设计模式(模板方法，单例，观察者，工厂方法，代理，策略，装饰者)，Java高级相关熟练掌握这个库先Google了解软件的整体架构设计搭建系统，把源码跑起来开始阅读：根据你对系统的理解，设计几个主要的测试案例，定义好输入，输出。(Debug一遍肯定是不行的，需要Debug很多遍)第一篇抛弃细节，抓住主要流程，第二篇，第三篇，再去看各个部分的细节。阅读的时候同时使用UML画出系统的类图。主要的测试案例明白了，丰富测试案例，考虑一些分支。这一步会非常非常地花费时间，但是你做完了，对系统的理解绝对有质的飞跃。13.想象一个来自未来的自己，他非常自信，非常成功，拥有你现在所希望的一切，他会对现在的你说些什么？他怎么说，你就怎么去做，10年之后，你就变成了他。14.重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。15.我们需要从别人身上学习。从老师、领导、同事、下属甚至对手身上学习，是快速成长的重要手段。16.多多总结，多多分享，善莫大焉。17.解答别人的问题也是个人成长的重要手段。有时候，某个问题自己本来不太懂，但是在给别人讲解的时候却豁然开朗。所以，“诲人不倦”利人惠己。18.学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。19.良好的用人方式应该如下：首选选择相信，在面临失败后，收缩信任度。查找失败的原因，提供改进意见，提升下属的能力。总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。20.学习就是不断地刻意联系，刻意练习，就是有目的的练习，先规划好，再去练习。首先给自己定一个目标，目标可以有效的引导你学习，然后使用3F练习法：1： 专注（Focus），专注在眼前的任务上，在学习过程中保持专注，可以尝试使用番茄工作法。2：反馈（Feedback），意识到自己的不足，学习完之后进行反思，思考下自己哪些方面不足，为什么不足，3： 修正（Fix），改进自己的不足。不停的练习和思考可以改变大脑结构，大脑像肌肉一样，挑战越大，影响越大，学习更高效，并且也会产生突破性。21.写一篇博客的过程，其实就是对一件事情，学习、理解、思考、转化，最终输出成一篇博客的过程。22.深入浅出SQL给出的学习法则：如何快速记忆知识？将文字转换为图片（将文字嵌入图片效果比较好)，如果能转换为令人惊奇，有趣的情景模拟，那么可以让你的大脑意识到这是重要的东西，记忆效果会更好。1.慢慢来，理解越多，需要强记得就越少。2.勤做笔记，写下你的心得笔记。3.你的大脑会需要一段时间来消化新知识，如果之后再学别的知识，会使之前的记忆效果减弱，因此，在睡前看最重要的知识。4.喝水，多喝水。5.大声说出你想要记忆的知识，如果能与别人进行一问一答则效果更佳。6.当学习知识时，达到了漫不经心或过目即忘的状态，则应该让大脑好好休息。7.用心感受，让你的大脑知道这很重要，将学习的内容尽量以情景化+惊奇+幽默的形式展示出来。8.用学到的知识解决实际的难题（真实的情景演练）。23.想要学习新技术，想要提升自己，不是看见新技术就去学，沉下心来认真钻研才行，吃透它，不再为缓解焦虑而学习。24.业务代码一样很牛逼1.使用封装和抽象可以使业务代码更具扩展性。2.多和产品交流以便更好地理解和实现业务。3.日志记录好了问题定位效率可以提升10倍。25.在工作中学习、实战提升是效果最好的，其余时间可有目的去碎片化学习一整块知识，也可以快速构建牢固的知识体系。26.做更多：工作中熟悉多个业务代码，端到端（前后端）的业务代码，自学。做更好：1.提升项目稳定性，引进单元测试和UI测试。2.重构解耦项目。3.性能优化。4.设计模式去除重复代码。做练习：1.学习2.尝试3.教学27.一项新技术的出现，应该先去了解它，看它是否对自身的技术成长有比较大的帮助，有的话按优先级加入计划表28.重复记忆时间间隔：1小时、早上/晚上、1天、3天、7天、1个月、3个月形成长期记忆~29.学习一个新的知识点的流程：what、why、how、原理/源码、优缺点~注意”先主后从“原则，多实践加深理解。</code></pre><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/22/Some%20awesome%20tips/#disqus_thread</comments>
    </item>
    
    <item>
      <title>初识人工智能</title>
      <link>http://yoursite.com/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</link>
      <guid>http://yoursite.com/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</guid>
      <pubDate>Sun, 18 Mar 2018 14:15:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><h3 id="AI-人工智能-的idea起源于20世纪50年代，在20世纪80年代时，ML-机器学习-开始变得流行起来，在大约2010年，DL-深度学习-在AI的推动下有了大的发展。下图是三者直接的关系图："><a href="#AI-人工智能-的idea起源于20世纪50年代，在20世纪80年代时，ML-机器学习-开始变得流行起来，在大约2010年，DL-深度学习-在AI的推动下有了大的发展。下图是三者直接的关系图：" class="headerlink" title="AI(人工智能)的idea起源于20世纪50年代，在20世纪80年代时，ML(机器学习)开始变得流行起来，在大约2010年，DL(深度学习)在AI的推动下有了大的发展。下图是三者直接的关系图："></a>AI(人工智能)的idea起源于20世纪50年代，在20世纪80年代时，ML(机器学习)开始变得流行起来，在大约2010年，DL(深度学习)在AI的推动下有了大的发展。下图是三者直接的关系图：</h3><p><img src="https://note.youdao.com/yws/public/resource/12ec8de4ff02f0af21b5ce1a93cbf9a9/xmlnote/A1389FE91E5D4696B23BEDBD955D115C/20679" alt="image"></p><h3 id="关于人工智能，我们所需要了解的"><a href="#关于人工智能，我们所需要了解的" class="headerlink" title="关于人工智能，我们所需要了解的"></a>关于人工智能，我们所需要了解的</h3><h5 id="what（人工智能是什么？）："><a href="#what（人工智能是什么？）：" class="headerlink" title="what（人工智能是什么？）："></a>what（人工智能是什么？）：</h5><p>人工智能（英语：Artificial Intelligence, AI）亦称机器智能，<br>是指由人制造出来的机器所表现出来的智能。通常人工智能是指通过<br>普通计算机程序的手段实现的类人智能技术。</p><h5 id="why（为什么要使用它-作用-？）："><a href="#why（为什么要使用它-作用-？）：" class="headerlink" title="why（为什么要使用它(作用)？）："></a>why（为什么要使用它(作用)？）：</h5><p>AI是一个制造智能机器的科学与工程，它的核心问题包括建构能够跟<br>人类似甚至超越的推理、知识、规划、学习、交流、感知、移动和操<br>作物体的能力等，以更好地实现某一领域的特定目标（例如搜索、逻<br>辑推演、创造力等等）。</p><h5 id="how（学习AI该从哪方面着手？）："><a href="#how（学习AI该从哪方面着手？）：" class="headerlink" title="how（学习AI该从哪方面着手？）："></a>how（学习AI该从哪方面着手？）：</h5><p>见下方。。</p><h3 id="AI的应用领域"><a href="#AI的应用领域" class="headerlink" title="AI的应用领域"></a>AI的应用领域</h3><h5 id="AI的应用领域很广泛，目前主要涉及到的领域如下："><a href="#AI的应用领域很广泛，目前主要涉及到的领域如下：" class="headerlink" title="AI的应用领域很广泛，目前主要涉及到的领域如下："></a>AI的应用领域很广泛，目前主要涉及到的领域如下：</h5><pre><code>智能控制机器人学自动化技术语言和图像理解遗传编程</code></pre><h5 id="涉及到的概念："><a href="#涉及到的概念：" class="headerlink" title="涉及到的概念："></a>涉及到的概念：</h5><h5 id="智能控制"><a href="#智能控制" class="headerlink" title="智能控制"></a>智能控制</h5><h5 id="what（它是什么？）："><a href="#what（它是什么？）：" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>智能控制是针对控制对象及其环境、控制目标和任务的不确定性<br>和复杂性而提出的一种控制技术。</p><h5 id="why（为什么要使用智能控制？）："><a href="#why（为什么要使用智能控制？）：" class="headerlink" title="why（为什么要使用智能控制？）："></a>why（为什么要使用智能控制？）：</h5><p>能够减小或消除被控对象的被控制量的控制偏差。</p><h5 id="how（有哪些人工智能控制方法？）："><a href="#how（有哪些人工智能控制方法？）：" class="headerlink" title="how（有哪些人工智能控制方法？）："></a>how（有哪些人工智能控制方法？）：</h5><p>类神经网络，模糊逻辑，机器学习，进化计算和遗传算法等等。</p><h5 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h5><h5 id="what（它是什么？）：-1"><a href="#what（它是什么？）：-1" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>是一项涵盖了机器人的设计、建造、运作、以及应用的跨领域科<br>技，就如同电脑系统之控制、感测回授、以及资讯处理。</p><h5 id="自动化技术"><a href="#自动化技术" class="headerlink" title="自动化技术"></a>自动化技术</h5><h5 id="what（它是什么？）：-2"><a href="#what（它是什么？）：-2" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>是一门综合性技术，它和控制论、信息论、系统工程、计算机技<br>术、电子学、液压气压技术、自动控制等都有着十分密切的关系，<br>而其中又以“控制理论”和“计算机技术”对自动化技术的影响最大。<br>一些过程已经被完全自动化。</p><h5 id="语言和图像理解"><a href="#语言和图像理解" class="headerlink" title="语言和图像理解"></a>语言和图像理解</h5><h5 id="what（它是什么？）：-3"><a href="#what（它是什么？）：-3" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>图像识别是对图像整体的语义内容进行类别判定，而语言识别是指<br>能够让计算机自动地识别语音中所携带信息的技术。</p><h5 id="遗传编程"><a href="#遗传编程" class="headerlink" title="遗传编程"></a>遗传编程</h5><h5 id="what（它是什么？）：-4"><a href="#what（它是什么？）：-4" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>是一种从生物演化过程得到灵感的自动化生成和选择计算机程序<br>来完成用户定义的任务的技术。</p><h5 id="AI的主要研究范畴如下："><a href="#AI的主要研究范畴如下：" class="headerlink" title="AI的主要研究范畴如下："></a>AI的主要研究范畴如下：</h5><pre><code>机器学习（Machine Learning）自然语言处理（NLP： Natural Language Processing）人工神经网络（Artificial Neural Network）数据挖掘（Data Mining）智能搜索（Intelligent Search）遗传算法</code></pre><h5 id="涉及到的概念：-1"><a href="#涉及到的概念：-1" class="headerlink" title="涉及到的概念："></a>涉及到的概念：</h5><h5 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h5><h5 id="what（他是什么？）"><a href="#what（他是什么？）" class="headerlink" title="what（他是什么？）"></a>what（他是什么？）</h5><p>机器学习可简单概括为“用数据解决问题”，即：数据 + 学习算法 =模型(映射或函数)<br>机器学习是人工智能的一个分支，近30多年已发展为一门多领域交叉<br>学科，机器学习理论主要是设计和分析一些让计算机可以自动“学习”<br>的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规<br>律对未知数据进行预测的算法。</p><h5 id="why（为什么要学习机器学习？）"><a href="#why（为什么要学习机器学习？）" class="headerlink" title="why（为什么要学习机器学习？）"></a>why（为什么要学习机器学习？）</h5><p>就是因为机器学习算法的这种可预测性，能利用规律对未知数据进行<br>预测，从而会有比较广的应用范围，现如今，机器学习已广泛应用于<br>数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、<br>医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和<br>手写识别、战略游戏和机器人等领域。</p><h5 id="how（如何开始机器学习？）"><a href="#how（如何开始机器学习？）" class="headerlink" title="how（如何开始机器学习？）"></a>how（如何开始机器学习？）</h5><p>首先，我们需要了解机器学习分为哪几种。<br>监督学习：<br>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据<br>这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以<br>说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法<br>包括回归分析和统计分类。<br>无监督学习：<br>与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法<br>有聚类。<br>半监督学习：<br>介于监督学习与无监督学习之间。<br>增强学习：<br>通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习<br>对象根据观察到的周围环境的反馈来做出判断。<br>选择了要学习的机器学习类别，具体的就是机器学习算法的学习了，此处<br>不再概述。</p><h5 id="进行机器学习的七步曲："><a href="#进行机器学习的七步曲：" class="headerlink" title="进行机器学习的七步曲："></a>进行机器学习的七步曲：</h5><pre><code>搜集数据准备数据选择模型训练模型评估模型参数微调预测</code></pre><h5 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h5><h5 id="what（它是什么？）"><a href="#what（它是什么？）" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>自然语言处理是人工智能和语言学领域的分支学科，它分为两部分，<br>自然语言生成系统和自然语言理解系统。自然语言生成系统把计算机<br>数据转化为自然语言。自然语言理解系统把自然语言转化为计算机程序<br>更易于处理的形式。</p><h5 id="why（为什么要使用自然语言处理？）"><a href="#why（为什么要使用自然语言处理？）" class="headerlink" title="why（为什么要使用自然语言处理？）"></a>why（为什么要使用自然语言处理？）</h5><p>就是为了使计算机生成和理解自然语言。</p><h5 id="how（自然语言的处理范畴？）"><a href="#how（自然语言的处理范畴？）" class="headerlink" title="how（自然语言的处理范畴？）"></a>how（自然语言的处理范畴？）</h5><p>自然语言的处理范畴比较广，主要有文本朗读、语音合成、语音识别、<br>文本分类、信息检索、信息抽取、问答系统、机器翻译、自动摘要等等。</p><h5 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h5><h5 id="what（它是什么？）-1"><a href="#what（它是什么？）-1" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>人工神经网络（英语：artificial neural network，缩写ANN），简称<br>神经网络（neural network，缩写NN）或类神经网络，在机器学习和认知<br>科学领域，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）<br>的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。</p><h5 id="why（为什么要使用人工神经网络？）"><a href="#why（为什么要使用人工神经网络？）" class="headerlink" title="why（为什么要使用人工神经网络？）"></a>why（为什么要使用人工神经网络？）</h5><p>就是因为它对于函数进行估计或近似的这种能力，现在，已经被用于解决<br>各种各样的问题，例如机器视觉和语音识别。</p><h5 id="how（如何使用人工神经网络？）"><a href="#how（如何使用人工神经网络？）" class="headerlink" title="how（如何使用人工神经网络？）"></a>how（如何使用人工神经网络？）</h5><p>具体的学习请参照本文总结。</p><h5 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h5><h5 id="what（它是什么？）-2"><a href="#what（它是什么？）-2" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>数据挖掘（英语：data mining）是一个跨学科的计算机科学分支，它是<br>用人工智能、机器学习、统计学和数据库的交叉方法在相对较大型的数据<br>集中发现模式的计算过程。</p><h5 id="why（为什么要使用数据挖掘？）"><a href="#why（为什么要使用数据挖掘？）" class="headerlink" title="why（为什么要使用数据挖掘？）"></a>why（为什么要使用数据挖掘？）</h5><p>用于从大量数据中提取模式和知识。</p><h5 id="how（如何进行数据挖掘？）"><a href="#how（如何进行数据挖掘？）" class="headerlink" title="how（如何进行数据挖掘？）"></a>how（如何进行数据挖掘？）</h5><p>数据挖掘的方法类似于机器学习，包括监督式学习、非监督式学习、半监<br>督学习、增强学习。<br>监督式学习包括：分类、估计、预测。<br>非监督式学习包括：聚类，关联规则分析。</p><h5 id="智能搜索"><a href="#智能搜索" class="headerlink" title="智能搜索"></a>智能搜索</h5><h5 id="what（它是什么？）-3"><a href="#what（它是什么？）-3" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>智能搜索其实就是一些能提高搜索策略的搜索方式。比如：深度优先搜索、<br>迭代加深搜索（ID搜索）、启发式OR图搜索算法、AND-OR图启发式搜索、<br>约束满足搜索等等。</p><h5 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h5><h5 id="what（它是什么？）-4"><a href="#what（它是什么？）-4" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>遗传算法（英语：genetic algorithm (GA)）是计算数学中用于解决最佳<br>化的搜索算法，是进化算法的一种。进化算法最初是借鉴了进化生物学中<br>的一些现象而发展起来的，这些现象包括遗传、突变、自然选择以及杂交等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于AI，目前应用范围主要集中在机器学习、深度学习(用于学习机器学习的一种技术)、NLP、图像识别与处理这几个方面，请选择适合您的分支。</p><p>如果您对深度学习有兴趣，可以从<a href="http://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="external">吴恩达的深度学习课程</a>开始。同样的，如果对机器学习有兴趣，可以从<a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="external">Google的机器学习速成课程</a>、<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">吴恩达的机器学习课程</a>、<a href="https://zhuanlan.zhihu.com/tensorflowcn" target="_blank" rel="external">Google Cloud AI Adventure 中文版教程</a>、<a href="https://zhuanlan.zhihu.com/machine-learning-book?topic=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="external">写给大家看的机器学习书</a>着手。</p><p>除此之外，这里还有一些关于AI的快速开发框架:最知名的如<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow</a>(使用数据流图形计算来扩展机器学习的框架)、<a href="https://github.com/BVLC/caffe" target="_blank" rel="external">caffe</a>(一个快速开放的深度学习框架)、<a href="https://github.com/keras-team/keras" target="_blank" rel="external">keras</a>(对人类的深度学习框架)、<br><a href="https://github.com/apache/incubator-mxnet" target="_blank" rel="external">MXNet</a>(MxNet是一个兼并效率和弹性的深度学习框架)、<a href="http://torch.ch/" target="_blank" rel="external">torch</a>(torch是一个广泛支持机器学习算法的科学计算框架)、<a href="https://github.com/Theano/Theano" target="_blank" rel="external">theano</a>(theano是一个允许你去高效地定义、优化、评估涉及多维数组的数学表达的python库)。</p><p>最热门的TensorFlow入门推荐-<a href="https://codelabs.developers.google.com/codelabs/tensorflow-for-poets/index.html#0" target="_blank" rel="external">Google的TensorFlow入门指南</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
