<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Sun, 13 Jan 2019 15:03:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android主流三方库源码分析（七、深入理解ButterKnife源码）</title>
      <link>http://yoursite.com/2019/01/13/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ButterKnife%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/13/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ButterKnife%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 13 Jan 2019 14:57:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>不知不觉，笔者已经对Android主流三方库中的网络框架OkHttp、Retrofit，图片加载框架Glide、数据库框架GreenDao、响应式编程框架RxJava、内存泄露框架LeakCanary进行了详细的分析，如果有朋友对这些开源框架的内部实现机制感兴趣的话，可以在笔者的个人主页选择相应的文章阅读。这篇，我将会对Android中的依赖注入框架ButterKnife的源码实现机制进行详细地讲解。</p><h4 id="一、简单示例"><a href="#一、简单示例" class="headerlink" title="一、简单示例"></a>一、简单示例</h4><p>首先，我们先来看一下ButterKnife的基本使用（取自<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>），如下所示：</p><pre><code>public class CollectFragment extends BaseRootFragment&lt;CollectPresenter&gt; implements CollectContract.View {    @BindView(R.id.normal_view)    SmartRefreshLayout mRefreshLayout;    @BindView(R.id.collect_recycler_view)    RecyclerView mRecyclerView;    @BindView(R.id.collect_floating_action_btn)    FloatingActionButton mFloatingActionButton;    @Nullable    @Override    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {        View view = inflater.inflate(getLayoutId(), container, false);        unBinder = ButterKnife.bind(this, view);        initView();        return view;    }    @OnClick({R.id.collect_floating_action_btn})    void onClick(View view) {        switch (view.getId()) {            case R.id.collect_floating_action_btn:                mRecyclerView.smoothScrollToPosition(0);                break;            default:                break;        }    }    @Override    public void onDestroyView() {        super.onDestroyView();        if (unBinder != null &amp;&amp; unBinder != Unbinder.EMPTY) {            unBinder.unbind();            unBinder = null;        }    }</code></pre><p>可以看到，我们使用了@BindView()替代了findViewById()方法，然后使用了@OnClick替代了setOnClickListener()方法。ButterKnife的初期版本是通过使用注解+反射这样的运行时解析的方式实现上述功能的，后面，为了改善性能，便使用了<strong>注解+APT编译时解析技术并从中生成配套模板代码的方式</strong>来实现。</p><p>在开始分析之前，可能有同学对APT不是很了解，我这里普及一下，APT是Annotation Processing Tool的缩写，即注解处理工具。它的使用步骤一般是这样的：</p><ul><li>首先声明的注解的生命周期为CLASS，即@Retention(CLASS)。</li><li>然后通过继承AbstractProcessor自定义一个注解处理器。</li><li>在编译的时候，编译器会扫描所有带有你要处理的注解的类，最后再调用AbstractProcessor的process方法，对注解进行处理。</li></ul><p>下面，我们正式来解剖一下ButterKnife的心脏。</p><h3 id="二、源码分析"><a href="#二、源码分析" class="headerlink" title="二、源码分析"></a>二、源码分析</h3><h4 id="2-1-模板代码解析"><a href="#2-1-模板代码解析" class="headerlink" title="2.1 模板代码解析"></a>2.1 模板代码解析</h4><p>首先，在我们编写好上述的示例代码之后，调用 gradle build 命令，在app/build/generated/source/apt下将可以找到APT为我们生产的配套模板代码CollectFragment_ViewBinding，如下所示：</p><pre><code>public class CollectFragment_ViewBinding implements Unbinder {    private CollectFragment target;    private View view2131230812;    @UiThread    public CollectFragment_ViewBinding(final CollectFragment target, View source) {      this.target = target;      View view;      // 1      target.mRefreshLayout = Utils.findRequiredViewAsType(source, R.id.normal_view, &quot;field &apos;mRefreshLayout&apos;&quot;, SmartRefreshLayout.class);      target.mRecyclerView = Utils.findRequiredViewAsType(source, R.id.collect_recycler_view, &quot;field &apos;mRecyclerView&apos;&quot;, RecyclerView.class);      view = Utils.findRequiredView(source, R.id.collect_floating_action_btn, &quot;field &apos;mFloatingActionButton&apos; and method &apos;onClick&apos;&quot;);      target.mFloatingActionButton = Utils.castView(view, R.id.collect_floating_action_btn, &quot;field &apos;mFloatingActionButton&apos;&quot;, FloatingActionButton.class);      view2131230812 = view;      // 2      view.setOnClickListener(new DebouncingOnClickListener() {        @Override        public void doClick(View p0) {          target.onClick(p0);        }      });    }    @Override    @CallSuper    public void unbind() {      CollectFragment target = this.target;      if (target == null) throw newIllegalStateException(&quot;Bindings already     cleared.&quot;);      this.target = null;      target.mRefreshLayout = null;      target.mRecyclerView = null;      target.mFloatingActionButton = null;      view2131230812.setOnClickListener(null);      view2131230812 = null;    }}</code></pre><p>生成的配套模板CollectFragment_ViewBinding中，在注释1处，使用了ButterKnife内部的工具类Utils的findRequiredViewAsType()方法来寻找控件。在注释2处，使用了view的setOnClickListener()方法来添加了一个去抖动的DebouncingOnClickListener，这样便可以防止重复点击，在重写的doClick()方法内部，直接调用了CollectFragment的onClick方法。最后，我们在深入看下Utils的findRequiredViewAsType()方法内部的实现。</p><pre><code>public static &lt;T&gt; T findRequiredViewAsType(View source, @IdRes int id, String who,  Class&lt;T&gt; cls) {    // 1    View view = findRequiredView(source, id, who);    // 2    return castView(view, id, who, cls);}public static View findRequiredView(View source, @IdRes int id, String who) {    View view = source.findViewById(id);    if (view != null) {        return view;    }    ...}public static &lt;T&gt; T castView(View view, @IdRes int id, String who, Class&lt;T&gt; cls) {    try {        return cls.cast(view);    } catch (ClassCastException e) {        ...    }}</code></pre><p>在注释1处，最终也是通过View的findViewById()方法找到相应的控件，在注释2处，通过相应Class对象的cast方法强转成对应的控件类型。</p><h4 id="2-2-ButterKnife-是怎样实现代码注入的"><a href="#2-2-ButterKnife-是怎样实现代码注入的" class="headerlink" title="2.2 ButterKnife 是怎样实现代码注入的"></a>2.2 ButterKnife 是怎样实现代码注入的</h4><p>接下来，为了使用这套模板代码，我们必须调用ButterKnife的bind()方法实现代码注入，即自动帮我们执行重复繁琐的findViewById和setOnClicklistener操作。下面我们来分析下bind()方法是如何实现注入的。</p><pre><code>@NonNull @UiThreadpublic static Unbinder bind(@NonNull Object target, @NonNull View source) {    return createBinding(target, source);}</code></pre><p>在bind()方法中调用了createBinding()，</p><pre><code>@NonNull @UiThreadpublic static Unbinder bind(@NonNull Object target, @NonNull View source) {    Class&lt;?&gt; targetClass = target.getClass();    // 1    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);    if (constructor == null) {        return Unbinder.EMPTY;    }    try {        // 2        return constructor.newInstance(target, source);    // 3    } catch (IllegalAccessException e) {    ...}</code></pre><p>首先，在注释1处，通过 findBindingConstructorForClass() 方法从 Class 中查找 constructor，这里constructor即上文生成的CollectFragment_ViewBinding类。然后，在注释2处，利用反射来新建 constructor 对象。最后，如果新建 constructor 对象失败，则会在注释3后面捕获一系列对应的异常进行自定义异常抛出处理。</p><p>下面，我们来详细分析下<br>findBindingConstructorForClass() 方法的实现逻辑。</p><pre><code>@VisibleForTestingstatic final Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = new LinkedHashMap&lt;&gt;();@Nullable @CheckResult @UiThreadprivate static Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) {    // 1    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);    if (bindingCtor != null || BINDINGS.containsKey(cls)) {        return bindingCtor;    }    // 2    String clsName = cls.getName();    if (clsName.startsWith(&quot;android.&quot;) || clsName.startsWith(&quot;java.&quot;)    || clsName.startsWith(&quot;androidx.&quot;)) {        return null;    }    try {        // 3        Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + &quot;_ViewBinding&quot;);        bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);    } catch (ClassNotFoundException e) {        // 4        bindingCtor = findBindingConstructorForClass(cls.getSuperclass());    } catch (NoSuchMethodException e) {        throw new RuntimeException(&quot;Unable to find binding constructor for &quot; + clsName, e);    }    // 5    BINDINGS.put(cls, bindingCtor);    return bindingCtor;}</code></pre><p>这里，我把多余的log代码删除并把代码格式优化了一下，可以看到，findBindingConstructorForClass() 这个方法中的逻辑瞬间清晰不少，这里建议以后大家自己在分析源码的时候可以进行这样的优化重整，会带来不少好处。</p><p>重新看到 findBindingConstructorForClass() 方法，在注释1处，我们首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，这里的BINDINGS是一个LinkedHashMap对象，它保存了上述两者的映射关系。在注释2处，如果是 android，androidx，java 原生的文件，不进行处理。在注释3处，先通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象，再通过自身的getConstructor()方法获得相应的构造对象。如果在步骤3中加载不出对应的模板类对象，则会在注释4处使用类似递归的方法重新执行findBindingConstructorForClass()方法。最后，如果找到了bindingCtor模板构造对象，则将它保存在BINDINGS这个LinkedHashMap对象中。</p><p><strong>这里总结一下findBindingConstructorForClass()方法的处理：</strong></p><ul><li>1、<strong>首先从缓存BINDINGS中获取CollectFragment类对象对应的模块类CollectFragment_ViewBinding的构造器对象，获取不到，则继续执行下面的操作</strong>。</li><li>2、<strong>如果不是android，androidx，java 原生的文件，再进行后面的处理</strong>。</li><li>3、<strong>通过CollectFragment类对象的类加载器加载出对应的模块类CollectFragment_ViewBinding的类对象，再通过自身的getConstructor()方法获得相应的构造对象，如果获取不到，会抛出异常，在异常的处理中，我们会从当前 class 文件的父类中再去查找。如果找到了，最后会将bindingCtor对象缓存进在BINDINGS对象中</strong>。</li></ul><h4 id="2-3-ButterKnife是如何在编译时生成代码的？"><a href="#2-3-ButterKnife是如何在编译时生成代码的？" class="headerlink" title="2.3 ButterKnife是如何在编译时生成代码的？"></a>2.3 ButterKnife是如何在编译时生成代码的？</h4><p>在编译的时候，ButterKnife会通过自定义的注解处理器ButterKnifeProcessor的process方法，对编译器扫描到的要处理的类中的注解进行处理，然后通过javapoet这个库来动态生成绑定事件或者控件的模板代码，最后在运行的时候，直接调用bind方法完成绑定即可。</p><p>首先，我们先来分析下ButterKnifeProcessor的重写的入口方法init()。</p><pre><code>@Override public synchronized void init(ProcessingEnvironment env) {    super.init(env);    String sdk = env.getOptions().get(OPTION_SDK_INT);    if (sdk != null) {        try {            this.sdk = Integer.parseInt(sdk);        } catch (NumberFormatException e) {           ...        }    }    typeUtils = env.getTypeUtils();    filer = env.getFiler();    ...}</code></pre><p>可以看到，ProcessingEnviroment对象提供了两大工具类 typeUtils和filer。typeUtils的作用是用来处理TypeMirror，而Filer则是用来创建生成辅助文件。</p><p>接着我们再来看看被重写的getSupportedAnnotationTypes()方法，这个方法的作用主要是用于指定ButterknifeProcessor注册了哪些注解的。</p><pre><code>@Override public Set&lt;String&gt; getSupportedAnnotationTypes() {    Set&lt;String&gt; types = new LinkedHashSet&lt;&gt;();    for (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) {    types.add(annotation.getCanonicalName());    }    return types;}</code></pre><p>这里面首先创建了一个LinkedHashSet对象，然后将getSupportedAnnotations()方法返回的支持注解集合进行遍历一一添加到types中返回。</p><p>接着我们看下getSupportedAnnotations()方法，</p><pre><code>private Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() {    Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = new LinkedHashSet&lt;&gt;();    annotations.add(BindAnim.class);    annotations.add(BindArray.class);    annotations.add(BindBitmap.class);    annotations.add(BindBool.class);    annotations.add(BindColor.class);    annotations.add(BindDimen.class);    annotations.add(BindDrawable.class);    annotations.add(BindFloat.class);    annotations.add(BindFont.class);    annotations.add(BindInt.class);    annotations.add(BindString.class);    annotations.add(BindView.class);    annotations.add(BindViews.class);    annotations.addAll(LISTENERS);    return annotations;}</code></pre><p>可以看到，这里注册了一系列的Bindxxx注解类和监听列表LISTENERS，接着看一下LISTENERS中包含的监听方法：</p><pre><code>private static final List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(    OnCheckedChanged.class,     OnClick.class,     OnEditorAction.class,     OnFocusChange.class,     OnItemClick.class,     OnItemLongClick.class,     OnItemSelected.class,     OnLongClick.class,     OnPageChange.class,     OnTextChanged.class,     OnTouch.class );</code></pre><p>最后，我们来分析下整个ButterKnifeProcessor中最关键的方法process()。</p><pre><code>@Override public boolean process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {    // 1    Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);    for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {        TypeElement typeElement = entry.getKey();        BindingSet binding = entry.getValue();        // 2        JavaFile javaFile = binding.brewJava(sdk, debuggable);        try {            javaFile.writeTo(filer);        } catch (IOException e) {           ...        }    }    return false;}</code></pre><p>首先，在注释1处通过findAndParseTargets()方法，知名见义，它应该就是找到并解析注解目标的关键方法了，继续看看它内部的处理：</p><pre><code>private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) {    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;();    Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;();    // 1、一系列处理每一个@Bindxxx元素的for循环代码块    ...    // Process each @BindView element.    for (Element element : env.getElementsAnnotatedWith(BindView.class)) {        try {        // 2        parseBindView(element, builderMap, erasedTargetNames);        } catch (Exception e) {            logParsingError(element, BindView.class, e);        }    }    // Process each @BindViews element.    ...    // Process each annotation that corresponds to a listener.    for (Class&lt;? extends Annotation&gt; listener : LISTENERS) {        findAndParseListener(env, listener, builderMap, erasedTargetNames);    }    // 2    Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =        new ArrayDeque&lt;&gt;(builderMap.entrySet());    Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;();    while (!entries.isEmpty()) {        Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();        TypeElement type = entry.getKey();        BindingSet.Builder builder = entry.getValue();        TypeElement parentType = findParentType(type, erasedTargetNames);        if (parentType == null) {            bindingMap.put(type, builder.build());        } else {            BindingSet parentBinding = bindingMap.get(parentType);            if (parentBinding != null) {                builder.setParent(parentBinding);                bindingMap.put(type, builder.build());            } else {            entries.addLast(entry);            }        }    }    return bindingMap;}</code></pre><p>findAndParseTargets()方法的代码非常多，我这里尽可能做了精简。首先，在注释1处，<strong>扫描并处理所有具有@Bindxxx注解和符合LISTENERS监听方法集合的代码，然后在每一个@Bindxxx对应的for循环代码中的parseBindxxx()或findAndParseListener()方法中将解析出的信息放入builderMap</strong>这个LinkedHashMap对象中，其中builderMap是一个key为TypeElement，value为BindingSet.Builder的映射集合，这个 BindSet 是指<strong>的一个类型请求的所有绑定的集合</strong>。在注释3处，首先使用上面的builderMap对象去构建了一个entries对象，它是一个双向队列，能实现两端存取的操作。接着，又新建了一个key为TypeElement，value为BindingSet的LinkedHashMap对象，最后使用了一个while循环从entries的第一个元素开始，这里会判断当前元素类型是否有父类，如果没有，直接构建builder放入bindingMap中，如果有，则将parentBinding添加到BindingSet.Builder这个建造者对象中，然后创建BindingSet再添加到bindingMap中。</p><p>接着，我们分析下注释2处parseBindView是如何对每一个@BindView注解的元素进行处理。</p><pre><code>private void parseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,  Set&lt;TypeElement&gt; erasedTargetNames) {    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();    // 1、首先验证生成的常见代码限制    ...    // 2、验证目标类型是否继承自View。    ...    // 3    int id = element.getAnnotation(BindView.class).value();    BindingSet.Builder builder = builderMap.get(enclosingElement);    Id resourceId = elementToId(element, BindView.class, id);    if (builder != null) {        String existingBindingName = builder.findExistingBindingName(resourceId);        if (existingBindingName != null) {            ...            return;        }    } else {        // 4        builder = getOrCreateBindingBuilder(builderMap, enclosingElement);    }    String name = simpleName.toString();    TypeName type = TypeName.get(elementType);    boolean required = isFieldRequired(element);    // 5    builder.addField(resourceId, new     FieldViewBinding(name, type, required));    // Add the type-erased version to the valid binding targets set.    erasedTargetNames.add(enclosingElement);}</code></pre><p>首先，在注释1、2处均是一些验证处理操作，如果不符合则会return。然后，我们看到注释3处，这里获取了BindView要绑定的View的id，然后先从builderMap中获取BindingSet.Builder对象，如果存在，直接return。如果不存在，则会在注释4处的<br>getOrCreateBindingBuilder()方法生成一个。我们看一下getOrCreateBindingBuilder()方法:</p><pre><code>private BindingSet.Builder getOrCreateBindingBuilder(  Map&lt;TypeElement, BindingSet.Builder&gt; builderMap, TypeElement enclosingElement) {    BindingSet.Builder builder = builderMap.get(enclosingElement);    if (builder == null) {        builder = BindingSet.newBuilder(enclosingElement);        builderMap.put(enclosingElement, builder);    }    return builder;}</code></pre><p>可以看到，如果再次从buildMap中获取BindingSet.Builder对象，如果没有则直接调用BindingSet的newBuilder()方法新建一个BindingSet.Builder对象保存在builderMap中然后将新建的builder对象返回。</p><p>回到parseBindView()方法的注释5处，这里根据view的信息生成一个FieldViewBinding，最后添加到上边生成的builder对象中。</p><p>最后回到我们的process()方法中，现在所有的绑定的集合数据都放在了bindingMap对象中，这里使用for循环取出每一个BindingSet对象，调用它的brewJava()方法，看看它内部的处理：</p><pre><code>JavaFile brewJava(int sdk, boolean debuggable) {    TypeSpec bindingConfiguration = createType(sdk, debuggable);    return JavaFile.builder(bindingClassName.packageName(), bindingConfiguration)    .addFileComment(&quot;Generated code from Butter Knife. Do not modify!&quot;)    .build();}private TypeSpec createType(int sdk, boolean debuggable) {    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())    .addModifiers(PUBLIC);    if (isFinal) {        result.addModifiers(FINAL);    }    if (parentBinding != null) {        result.superclass(parentBinding.bindingClassName);    } else {        result.addSuperinterface(UNBINDER);    }    if (hasTargetField()) {        result.addField(targetTypeName, &quot;target&quot;, PRIVATE);    }    if (isView) {        result.addMethod(createBindingConstructorForView());    } else if (isActivity) {        result.addMethod(createBindingConstructorForActivity());    } else if (isDialog) {        result.addMethod(createBindingConstructorForDialog());    }    if (!constructorNeedsView()) {        // Add a delegating constructor with a target type + view signature for reflective use.        result.addMethod(createBindingViewDelegateConstructor());    }    result.addMethod(createBindingConstructor(sdk, debuggable));    if (hasViewBindings() || parentBinding == null) {        result.addMethod(createBindingUnbindMethod(result));    }    return result.build();}</code></pre><p>在createType()方法里面使用了java中的<a href="https://github.com/square/javapoet" target="_blank" rel="external">javapoet</a>技术生成了一个bindingConfiguration对象，很显然，它里面保存了所有的绑定配置信息。然后，通过javapoet的builder构造器将上面得到的bindingConfiguration对象构建生成一个JavaFile对象，最终，通过javaFile.writeTo(filer)生成了java源文件。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>从上面的源码分析来看，ButterKnife的执行流程总体可以分为两步：</p><ul><li>1、在编译的时候扫描注解，并通过自定义的ButterKnifeProcessor做相应的处理解析得到bindingMap对象，最后调用 javapoet 库生成 java模板 代码。</li><li>2、当我们调用 ButterKnife的bind() 方法的时候，它会根据类的全限定类型，找到相应的模板代码，并在其中完成 findViewById 和 setOnClick ，setOnLongClick 等操作。</li></ul><p>到此，ButterKnife的源码分析就结束了。接下来，笔者会对Android中的依赖注入框架Dagger2的源码实现流程进行详细的讲解，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、ButterKnife V10.0.0 源码</p><p>2、Android进阶之光</p><p>3、<a href="https://www.jianshu.com/p/0f3f4f7ca505" target="_blank" rel="external">ButterKnife源码分析</a></p><p>4、<a href="https://blog.csdn.net/gdutxiaoxu/article/details/71512754" target="_blank" rel="external">butterknife 源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/13/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%83%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ButterKnife%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（六、深入理解Leakcanary源码）</title>
      <link>http://yoursite.com/2019/01/06/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Leakcanary%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/06/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Leakcanary%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 06 Jan 2019 10:35:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>在Android主流三方库源码分析系列的前几篇文章中，笔者已经对网络、图片、数据库、响应式编程中最热门的第三方开源框架进行了较为深入地讲解，如果有朋友对这四块感兴趣的话，可以去了解下。本篇，我将会对Android中的内存泄露检测框架Leakcanary的源码流程进行详细地讲解。</p><h3 id="一、原理概述"><a href="#一、原理概述" class="headerlink" title="一、原理概述"></a>一、原理概述</h3><p>首先，笔者仔细查看了Leakcanary官方的github仓库，最重要的便是对<strong>Leakcanary是如何起作用的</strong>（即原理）这一问题进行了阐述，我自己把它翻译成了易于理解的文字，主要分为如下7个步骤：</p><ul><li>1、RefWatcher.watch()创建了一个KeyedWeakReference用于去观察对象。</li><li>2、然后，在后台线程中，它会检测引用是否被清除了，并且是否没有触发GC。</li><li>3、如果引用仍然没有被清除，那么它将会把堆栈信息保存在文件系统中的.hprof文件里。</li><li>4、HeapAnalyzerService被开启在一个独立的进程中，并且HeapAnalyzer使用了HAHA开源库解析了指定时刻的堆栈快照文件heap dump。</li><li>5、从heap dump中，HeapAnalyzer根据一个独特的引用key找到了KeyedWeakReference，并且定位了泄露的引用。</li><li>6、HeapAnalyzer为了确定是否有泄露，计算了到GC Roots的最短强引用路径，然后建立了导致泄露的链式引用。</li><li>7、这个结果被传回到app进程中的DisplayLeakService，然后一个泄露通知便展现出来了。</li></ul><p>官方的原理简单来解释就是这样的：<strong>在一个Activity执行完onDestroy()之后，将它放入WeakReference中，然后将这个WeakReference类型的Activity对象与ReferenceQueque关联。这时再从ReferenceQueque中查看是否有没有该对象，如果没有，执行gc，再次查看，还是没有的话则判断发生内存泄露了。最后用HAHA这个开源库去分析dump之后的heap内存。</strong></p><h3 id="二、简单示例"><a href="#二、简单示例" class="headerlink" title="二、简单示例"></a>二、简单示例</h3><p>下面这段是Leakcanary官方仓库的示例代码：</p><p>首先在你项目app下的build.gradle中配置:</p><pre><code>dependencies {  debugImplementation &apos;com.squareup.leakcanary:leakcanary-android:1.6.2&apos;  releaseImplementation   &apos;com.squareup.leakcanary:leakcanary-android-no-op:1.6.2&apos;  // 可选，如果你使用支持库的fragments的话  debugImplementation   &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.2&apos;}</code></pre><p>然后在你的Application中配置:</p><pre><code>public class WanAndroidApp extends Application {    private RefWatcher refWatcher;    public static RefWatcher getRefWatcher(Context context) {        WanAndroidApp application = (WanAndroidApp)     context.getApplicationContext();        return application.refWatcher;    }    @Override public void onCreate() {      super.onCreate();      if (LeakCanary.isInAnalyzerProcess(this)) {        // 1        return;      }      // 2      refWatcher = LeakCanary.install(this);    }}</code></pre><p>在注释1处，会首先判断当前进程是否是Leakcanary专门用于分析heap内存的而创建的那个进程，即HeapAnalyzerService所在的进程，如果是的话，则不进行Application中的初始化功能。如果是当前应用所处的主进程的话，则会执行注释2处的LeakCanary.install(this)进行LeakCanary的安装。只需这样简单的几行代码，我们就可以在应用中检测是否产生了内存泄露了。当然，这样使用只会检测Activity是否发生内存泄漏，如果要检测Fragment在执行完onDestroy()之后是否发生内存泄露的话，则需要在Fragment的onDestroy()方法中加上如下两行代码去监视当前的Fragment：</p><pre><code>RefWatcher refWatcher = WanAndroidApp.getRefWatcher(_mActivity);refWatcher.watch(this);</code></pre><p>上面的RefWatcher其实就是一个引用观察者对象，是用于监测当前实例对象的引用状态的。从以上的分析可以了解到，核心代码就是LeakCanary.install(this)这行代码，接下来，就从这里出发将LeakCanary一步一步进行拆解。</p><h3 id="三、源码分析"><a href="#三、源码分析" class="headerlink" title="三、源码分析"></a>三、源码分析</h3><h4 id="1、LeakCanary-install"><a href="#1、LeakCanary-install" class="headerlink" title="1、LeakCanary#install()"></a>1、LeakCanary#install()</h4><pre><code>public static @NonNull RefWatcher install(@NonNull Application application) {  return refWatcher(application).listenerServiceClass(DisplayLeakService.class)      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())      .buildAndInstall();}</code></pre><p>在install()方法中的处理，可以分解为如下四步：</p><ul><li>1、refWatcher(application)</li><li>2、链式调用listenerServiceClass(DisplayLeakService.class)</li><li>3、链式调用excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</li><li>4、链式调用uildAndInstall()</li></ul><p>首先，我们来看下第一步，这里调用了LeakCanary类的refWatcher方法，如下所示：</p><pre><code>public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {  return new AndroidRefWatcherBuilder(context);}</code></pre><p>然后新建了一个AndroidRefWatcherBuilder对象，再看看AndroidRefWatcherBuilder这个类。</p><h4 id="2、AndroidRefWatcherBuilder"><a href="#2、AndroidRefWatcherBuilder" class="headerlink" title="2、AndroidRefWatcherBuilder"></a>2、AndroidRefWatcherBuilder</h4><pre><code>/** A {@link RefWatcherBuilder} with appropriate Android defaults. */public final class AndroidRefWatcherBuilder extends     RefWatcherBuilder&lt;AndroidRefWatcherBuilder&gt; {...    AndroidRefWatcherBuilder(@NonNull Context context) {        this.context = context.getApplicationContext();    }...}</code></pre><p>在AndroidRefWatcherBuilder的构造方法中仅仅是将外部传入的applicationContext对象保存起来了。AndroidRefWatcherBuilder是一个适配Android平台的引用观察者构造器对象，它继承了RefWatcherBuilder，RefWatcherBuilder是一个负责建立引用观察者RefWatcher实例的基类构造器。继续看看RefWatcherBuilder这个类。</p><h4 id="3、RefWatcherBuilder"><a href="#3、RefWatcherBuilder" class="headerlink" title="3、RefWatcherBuilder"></a>3、RefWatcherBuilder</h4><pre><code>public class RefWatcherBuilder&lt;T extends RefWatcherBuilder&lt;T&gt;&gt; {    ...    public RefWatcherBuilder() {        heapDumpBuilder = new HeapDump.Builder();    }    ...}</code></pre><p>在RefWatcher的基类构造器RefWatcherBuilder的构造方法中新建了一个HeapDump的构造器对象。其中HeapDump就是一个保存heap dump信息的数据结构。</p><p>接着来分析下install()方法中的链式调用的listenerServiceClass(DisplayLeakService.class)这部分逻辑。</p><h4 id="4、AndroidRefWatcherBuilder-listenerServiceClass"><a href="#4、AndroidRefWatcherBuilder-listenerServiceClass" class="headerlink" title="4、AndroidRefWatcherBuilder#listenerServiceClass()"></a>4、AndroidRefWatcherBuilder#listenerServiceClass()</h4><pre><code>public @NonNull AndroidRefWatcherBuilder listenerServiceClass(  @NonNull Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {    return heapDumpListener(new ServiceHeapDumpListener(context,     listenerServiceClass));}</code></pre><p>在这里，传入了一个DisplayLeakService的Class对象，它的作用是展示泄露分析的结果日志，然后会展示一个用于跳转到显示泄露界面DisplayLeakActivity的通知。在listenerServiceClass()这个方法中新建了一个ServiceHeapDumpListener对象，看看它内部的操作。</p><h4 id="5、ServiceHeapDumpListener"><a href="#5、ServiceHeapDumpListener" class="headerlink" title="5、ServiceHeapDumpListener"></a>5、ServiceHeapDumpListener</h4><pre><code>public final class ServiceHeapDumpListener implements HeapDump.Listener {    ...    public ServiceHeapDumpListener(@NonNull final Context context,        @NonNull final Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {      this.listenerServiceClass = checkNotNull(listenerServiceClass, &quot;listenerServiceClass&quot;);      this.context = checkNotNull(context, &quot;context&quot;).getApplicationContext();    }    ...}</code></pre><p>可以看到这里仅仅是在ServiceHeapDumpListener中保存了DisplayLeakService的Class对象和application对象。它的作用就是接收一个heap dump去分析。</p><p>然后我们继续看install()方法链式调用.excludedRefs(AndroidExcludedRefs.createAppDefaults().build())的这部分代码。先看AndroidExcludedRefs.createAppDefaults()。</p><h4 id="6、AndroidExcludedRefs-createAppDefaults"><a href="#6、AndroidExcludedRefs-createAppDefaults" class="headerlink" title="6、AndroidExcludedRefs#createAppDefaults()"></a>6、AndroidExcludedRefs#createAppDefaults()</h4><pre><code>public enum AndroidExcludedRefs {    ...    public static @NonNull ExcludedRefs.Builder createAppDefaults() {      return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));    }    public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet&lt;AndroidExcludedRefs&gt; refs) {      ExcludedRefs.Builder excluded = ExcludedRefs.builder();      for (AndroidExcludedRefs ref : refs) {        if (ref.applies) {          ref.add(excluded);          ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());        }      }      return excluded;    }    ...}</code></pre><p>先来说下AndroidExcludedRefs这个类，它是一个enum类，它声明了Android SDK和厂商定制的SDK中存在的内存泄露的case，根据AndroidExcludedRefs这个类的类名就可看出这些case都会被Leakcanary的监测过滤掉。目前这个版本是有46种这样的case被包含在内，后续可能会一直增加。然后EnumSet.allOf(AndroidExcludedRefs.class)这个方法将会返回一个包含AndroidExcludedRefs元素类型的EnumSet。Enum是一个抽象类，在这里具体的实现类是通用正规型的RegularEnumSet，如果Enum里面的元素个数大于64，则会使用存储大数据量的JumboEnumSet。最后，在createBuilder这个方法里面构建了一个排除引用的建造器excluded，将各式各样的case分门别类地保存起来再返回出去。</p><p>最后，我们看到链式调用的最后一步buildAndInstall()。</p><h4 id="7、AndroidRefWatcherBuilder-buildAndInstall"><a href="#7、AndroidRefWatcherBuilder-buildAndInstall" class="headerlink" title="7、AndroidRefWatcherBuilder#buildAndInstall()"></a>7、AndroidRefWatcherBuilder#buildAndInstall()</h4><pre><code>private boolean watchActivities = true;private boolean watchFragments = true;public @NonNull RefWatcher buildAndInstall() {    // 1    if (LeakCanaryInternals.installedRefWatcher != null) {      throw new UnsupportedOperationException(&quot;buildAndInstall() should only be called once.&quot;);    }    // 2    RefWatcher refWatcher = build();    if (refWatcher != DISABLED) {      // 3      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);      if (watchActivities) {        // 4        ActivityRefWatcher.install(context, refWatcher);      }      if (watchFragments) {        // 5        FragmentRefWatcher.Helper.install(context, refWatcher);      }    }    // 6    LeakCanaryInternals.installedRefWatcher = refWatcher;    return refWatcher;}</code></pre><p>首先，在注释1处，会判断LeakCanaryInternals.installedRefWatcher是否已经被赋值，如果被赋值了，则会抛出异常，警告<br>buildAndInstall()这个方法应该仅仅只调用一次，在此方法结束时，即在注释6处，该LeakCanaryInternals.installedRefWatcher才会被赋值。再来看注释2处，调用了AndroidRefWatcherBuilder其基类RefWatcherBuilder的build()方法，我们它是如何建造的。</p><h4 id="8、RefWatcherBuilder-build"><a href="#8、RefWatcherBuilder-build" class="headerlink" title="8、RefWatcherBuilder#build()"></a>8、RefWatcherBuilder#build()</h4><pre><code>public final RefWatcher build() {    if (isDisabled()) {      return RefWatcher.DISABLED;    }    if (heapDumpBuilder.excludedRefs == null) {      heapDumpBuilder.excludedRefs(defaultExcludedRefs());    }    HeapDump.Listener heapDumpListener = this.heapDumpListener;    if (heapDumpListener == null) {      heapDumpListener = defaultHeapDumpListener();    }    DebuggerControl debuggerControl = this.debuggerControl;    if (debuggerControl == null) {      debuggerControl = defaultDebuggerControl();    }    HeapDumper heapDumper = this.heapDumper;    if (heapDumper == null) {      heapDumper = defaultHeapDumper();    }    WatchExecutor watchExecutor = this.watchExecutor;    if (watchExecutor == null) {      watchExecutor = defaultWatchExecutor();    }    GcTrigger gcTrigger = this.gcTrigger;    if (gcTrigger == null) {      gcTrigger = defaultGcTrigger();    }    if (heapDumpBuilder.reachabilityInspectorClasses == null) {      heapDumpBuilder.reachabilityInspectorClasses(defa  ultReachabilityInspectorClasses());    }    return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,        heapDumpBuilder);}</code></pre><p>可以看到，RefWatcherBuilder包含了7个组成部分</p><ul><li><p>1、excludedRefs : 记录可以被忽略的泄漏路径。</p></li><li><p>2、heapDumpListener : 转储堆信息到hprof文件，并在解析完 hprof 文件后进行回调，最后通知 DisplayLeakService 弹出泄漏提醒。</p></li><li><p>3、debuggerControl : 判断是否处于调试模式，调试模式中不会进行内存泄漏检测。为什么呢？因为<strong>在调试过程中可能会保留上一个引用从而导致错误信息上报</strong>。</p></li><li><p>4、heapDumper : 堆信息转储者，dump 内存泄漏处的 heap 信息到 hprof 文件</p></li><li><p>5、watchExecutor : 线程控制器，在 onDestroy() 之后并且主线程空闲时执行内存泄漏检测</p></li><li><p>6、gcTrigger : 用于 GC，watchExecutor 首次检测到可能的内存泄漏，会主动进行 GC，GC 之后会再检测一次，仍然泄漏的判定为内存泄漏，最后根据heapDump信息生成相应的泄漏引用链。</p></li><li><p>7、reachabilityInspectorClasses : 用于要进行可达性检测的类列表。</p></li></ul><p>最后，会使用建造者模式将这些组成部分构建成一个新的RefWatcher并将其返回。</p><p>我们继续看回到AndroidRefWatcherBuilder的注释3处的 LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true)这行代码。</p><h4 id="9、LeakCanaryInternals-setEnabledAsync"><a href="#9、LeakCanaryInternals-setEnabledAsync" class="headerlink" title="9、LeakCanaryInternals#setEnabledAsync()"></a>9、LeakCanaryInternals#setEnabledAsync()</h4><pre><code>public static void setEnabledAsync(Context context, final Class&lt;?&gt; componentClass,final boolean enabled) {  final Context appContext = context.getApplicationContext();  AsyncTask.THREAD_POOL_EXECUTOR.execute(new Runnable() {    @Override public void run() {      setEnabledBlocking(appContext, componentClass, enabled);    }  });}</code></pre><p>在这里使用了AsyncTask内部自带的THREAD_POOL_EXECUTOR线程池进行阻塞式地显示DisplayLeakActivity。</p><p>然后我们再继续看AndroidRefWatcherBuilder的注释4处的代码。</p><h4 id="10、ActivityRefWatcher-install"><a href="#10、ActivityRefWatcher-install" class="headerlink" title="10、ActivityRefWatcher#install()"></a>10、ActivityRefWatcher#install()</h4><pre><code>public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {    Application application = (Application) context.getApplicationContext();    // 1    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);    // 2    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);}</code></pre><p>可以看到，在注释1处创建一个自己的activityRefWatcher实例，并在注释2处调用了application的registerActivityLifecycleCallbacks()方法，这样就能够监听activity对应的生命周期事件了。继续看看activityRefWatcher.lifecycleCallbacks里面的操作。</p><pre><code>private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =    new ActivityLifecycleCallbacksAdapter() {      @Override public void onActivityDestroyed(Activity activity) {          refWatcher.watch(activity);      }};public abstract class ActivityLifecycleCallbacksAdapterimplements Application.ActivityLifecycleCallbacks {}</code></pre><p>很明显，实现并重写了Application的ActivityLifecycleCallbacks的onActivityDestroyed()方法，这样便能在所有Activity执行完onDestroyed()方法之后调用 refWatcher.watch(activity)这行代码进行内存泄漏的检测了。</p><p>我们再看会注释5处的FragmentRefWatcher.Helper.install(context, refWatcher)这行代码，</p><h4 id="11、FragmentRefWatcher-Helper-install"><a href="#11、FragmentRefWatcher-Helper-install" class="headerlink" title="11、FragmentRefWatcher.Helper#install()"></a>11、FragmentRefWatcher.Helper#install()</h4><pre><code>public interface FragmentRefWatcher {    void watchFragments(Activity activity);    final class Helper {      private static final String SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME =          &quot;com.squareup.leakcanary.internal.SupportFragmentRefWatcher&quot;;      public static void install(Context context, RefWatcher refWatcher) {        List&lt;FragmentRefWatcher&gt; fragmentRefWatchers = new ArrayList&lt;&gt;();        // 1        if (SDK_INT &gt;= O) {          fragmentRefWatchers.add(new AndroidOFragmentRefWatcher(refWatcher));        }        // 2        try {          Class&lt;?&gt; fragmentRefWatcherClass = Class.forName(SUPPORT_FRAGMENT_REF_WATCHER_CLASS_NAME);          Constructor&lt;?&gt; constructor =              fragmentRefWatcherClass.getDeclaredConstructor(RefWatcher.class);          FragmentRefWatcher supportFragmentRefWatcher   =              (FragmentRefWatcher) constructor.newInstance(refWatcher);          fragmentRefWatchers.add(supportFragmentRefWatcher);        } catch (Exception ignored) {        }        if (fragmentRefWatchers.size() == 0) {          return;        }        Helper helper = new Helper(fragmentRefWatchers);        // 3        Application application = (Application) context.getApplicationContext();        application.registerActivityLifecycleCallbacks(helper.activityLifecycleCallbacks);      }    ...}</code></pre><p>这里面的逻辑很简单，首先在注释1处将Android标准的Fragment的RefWatcher类，即AndroidOFragmentRefWatcher添加到新创建的fragmentRefWatchers中。在注释2处使用反射将leakcanary-support-fragment包下面的SupportFragmentRefWatcher添加进来，如果你在app的build.gradle下没有添加下面这行引用的话，则会拿不到此类，即LeakCanary只会兼顾监测Activity和标准Fragment这两种情况。</p><pre><code>debugImplementation   &apos;com.squareup.leakcanary:leakcanary-support-fragment:1.6.2&apos;</code></pre><p>继续看到注释3处helper.activityLifecycleCallbacks里面的代码。</p><pre><code>private final Application.ActivityLifecycleCallbacks activityLifecycleCallbacks =    new ActivityLifecycleCallbacksAdapter() {      @Override public void onActivityCreated(Activity activity, Bundle savedInstanceState) {        for (FragmentRefWatcher watcher : fragmentRefWatchers) {            watcher.watchFragments(activity);        }    }};</code></pre><p>可以看到，在Activity执行完onActivityCreated()方法之后，会调用指定watcher的watchFragments()方法，注意，这里的watcher可能有两种，但不管是哪一种，都会使用当前传入的activity获取到对应的FragmentManager/SupportFragmentManager对象，调用它的registerFragmentLifecycleCallbacks()方法，在对应的onDestroyView()和onDestoryed()方法执行完后，分别使用refWatcher.watch(view)和refWatcher.watch(fragment)进行内存泄漏的检测，代码如下所示。</p><pre><code>@Override public void onFragmentViewDestroyed(FragmentManager fm, Fragment fragment) {    View view = fragment.getView();    if (view != null) {        refWatcher.watch(view);    }}@Overridepublic void onFragmentDestroyed(FragmentManagerfm, Fragment fragment) {    refWatcher.watch(fragment);}</code></pre><p>注意，下面到真正关键的地方了，接下来分析refWatcher.watch()这行代码。</p><h4 id="12、RefWatcher-watch"><a href="#12、RefWatcher-watch" class="headerlink" title="12、RefWatcher#watch()"></a>12、RefWatcher#watch()</h4><pre><code>public void watch(Object watchedReference, String referenceName) {    if (this == DISABLED) {      return;    }    checkNotNull(watchedReference, &quot;watchedReference&quot;);    checkNotNull(referenceName, &quot;referenceName&quot;);    final long watchStartNanoTime = System.nanoTime();    // 1    String key = UUID.randomUUID().toString();    // 2    retainedKeys.add(key);    // 3    final KeyedWeakReference reference =        new KeyedWeakReference(watchedReference, key, referenceName, queue);    // 4    ensureGoneAsync(watchStartNanoTime, reference);}</code></pre><p>注意到在注释1处使用随机的UUID保证了每个检测对象对应的<br>key 的唯一性。在注释2处将生成的key添加到类型为CopyOnWriteArraySet的Set集合中。在注释3处新建了一个自定义的弱引用KeyedWeakReference，看看它内部的实现。</p><h4 id="13、KeyedWeakReference"><a href="#13、KeyedWeakReference" class="headerlink" title="13、KeyedWeakReference"></a>13、KeyedWeakReference</h4><pre><code>final class KeyedWeakReference extends WeakReference&lt;Object&gt; {    public final String key;    public final String name;    KeyedWeakReference(Object referent, String key, String name,        ReferenceQueue&lt;Object&gt; referenceQueue) {      // 1      super(checkNotNull(referent, &quot;referent&quot;), checkNotNull(referenceQueue, &quot;referenceQueue&quot;));      this.key = checkNotNull(key, &quot;key&quot;);      this.name = checkNotNull(name, &quot;name&quot;);    }}</code></pre><p>可以看到，在KeyedWeakReference内部，使用了key和name标识了一个被检测的WeakReference对象。在注释1处，将弱引用和引用队列 ReferenceQueue 关联起来，如果弱引用referent持有的对象被GC回收，JVM就会把这个弱引用加入到与之关联的引用队列referenceQueue中。即 KeyedWeakReference 持有的 Activity 对象如果被GC回收，该对象就会加入到引用队列 referenceQueue 中。</p><p>接着我们回到RefWatcher.watch()里注释4处的ensureGoneAsync()方法。</p><h4 id="14、RefWatcher-ensureGoneAsync"><a href="#14、RefWatcher-ensureGoneAsync" class="headerlink" title="14、RefWatcher#ensureGoneAsync()"></a>14、RefWatcher#ensureGoneAsync()</h4><pre><code>private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {    // 1    watchExecutor.execute(new Retryable() {        @Override public Retryable.Result run() {            // 2            return ensureGone(reference watchStartNanoTime);        }    });}</code></pre><p>在ensureGoneAsync()方法中，在注释1处使用 watchExecutor 执行了注释2处的 ensureGone 方法，watchExecutor 是 AndroidWatchExecutor 的实例。</p><p>下面看看watchExecutor内部的逻辑。</p><h4 id="15、AndroidWatchExecutor"><a href="#15、AndroidWatchExecutor" class="headerlink" title="15、AndroidWatchExecutor"></a>15、AndroidWatchExecutor</h4><pre><code>public final class AndroidWatchExecutor implements WatchExecutor {    ...    public AndroidWatchExecutor(long initialDelayMillis)     {      mainHandler = new Handler(Looper.getMainLooper());      HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);      handlerThread.start();      // 1      backgroundHandler = new Handler(handlerThread.getLooper());      this.initialDelayMillis = initialDelayMillis;      maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;    }    @Override public void execute(@NonNull Retryable retryable) {      // 2      if (Looper.getMainLooper().getThread() == Thread.currentThread()) {        waitForIdle(retryable, 0);      } else {        postWaitForIdle(retryable, 0);      }    }    ...}</code></pre><p>在注释1处AndroidWatchExecutor的构造方法中，注意到这里使用HandlerThread的looper新建了一个backgroundHandler，后面会用到。在注释2处，会判断当前线程是否是主线程，如果是，则直接调用waitForIdle()方法，如果不是，则调用postWaitForIdle()，来看看这个方法。</p><pre><code>private void postWaitForIdle(final Retryable retryable, final int failedAttempts) {  mainHandler.post(new Runnable() {    @Override public void run() {      waitForIdle(retryable, failedAttempts);    }  });}</code></pre><p>很清晰，这里使用了在构造方法中用主线程looper构造的mainHandler进行post，那么waitForIdle()最终也会在主线程执行。接着看看waitForIdle()的实现。</p><pre><code>private void waitForIdle(final Retryable retryable,     final int failedAttempts) {  Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {    @Override public boolean queueIdle() {      postToBackgroundWithDelay(retryable, failedAttempts);      return false;    }  });}</code></pre><p>这里MessageQueue.IdleHandler()回调方法的作用是当 looper 空闲的时候，会回调 queueIdle 方法，然后执行内部的postToBackgroundWithDelay()方法。接下来看看它的实现。</p><pre><code>private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {  long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts),     maxBackoffFactor);  // 1  long delayMillis = initialDelayMillis * exponentialBackoffFactor;  // 2  backgroundHandler.postDelayed(new Runnable() {    @Override public void run() {      // 3      Retryable.Result result = retryable.run();      // 4      if (result == RETRY) {        postWaitForIdle(retryable, failedAttempts +   1);      }    }  }, delayMillis);}</code></pre><p>先看到注释4处，可以明白，postToBackgroundWithDelay()是一个递归方法，如果result 一直等于RETRY的话，则会一直执行postWaitForIdle()方法。在回到注释1处，这里initialDelayMillis 的默认值是 5s，因此delayMillis就是5s。在注释2处，使用了在构造方法中用HandlerThread的looper新建的backgroundHandler进行异步延时执行retryable的run()方法。这个run()方法里执行的就是RefWatcher的ensureGoneAsync()方法中注释2处的ensureGone()这行代码，继续看它内部的逻辑。</p><h4 id="16、RefWatcher-ensureGone"><a href="#16、RefWatcher-ensureGone" class="headerlink" title="16、RefWatcher#ensureGone()"></a>16、RefWatcher#ensureGone()</h4><pre><code>Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {    long gcStartNanoTime = System.nanoTime();    long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime -     watchStartNanoTime);    // 1    removeWeaklyReachableReferences();    // 2    if (debuggerControl.isDebuggerAttached()) {      // The debugger can create false leaks.      return RETRY;    }    // 3    if (gone(reference)) {      return DONE;    }    // 4    gcTrigger.runGc();    removeWeaklyReachableReferences();    // 5    if (!gone(reference)) {      long startDumpHeap = System.nanoTime();      long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);      File heapDumpFile = heapDumper.dumpHeap();      if (heapDumpFile == RETRY_LATER) {        // Could not dump the heap.        return RETRY;      }      long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)          .referenceName(reference.name)          .watchDurationMs(watchDurationMs)          .gcDurationMs(gcDurationMs)          .heapDumpDurationMs(heapDumpDurationMs)          .build();      heapdumpListener.analyze(heapDump);    }    return DONE;}</code></pre><p>在注释1处，执行了removeWeaklyReachableReferences()这个方法，接下来分析下它的含义。</p><pre><code>private void removeWeaklyReachableReferences() {    KeyedWeakReference ref;    while ((ref = (KeyedWeakReference) queue.poll()) != null) {        retainedKeys.remove(ref.key);    }}</code></pre><p>这里使用了while循环遍历 ReferenceQueue ，并从 retainedKeys中移除对应的Reference。</p><p>再看到注释2处，当Android设备处于debug状态时，会直接返回RETRY进行延时重试检测的操作。在注释3处，我们看看gone(reference)这个方法的逻辑。</p><pre><code>private boolean gone(KeyedWeakReference reference) {    return !retainedKeys.contains(reference.key);}</code></pre><p>这里会判断 retainedKeys 集合中是否还含有 reference，若没有，证明已经被回收了，若含有，可能已经发生内存泄露（或Gc还没有执行回收）。前面的分析中我们知道了 reference 被回收的时候，会被加进 referenceQueue 里面，然后我们会调用removeWeaklyReachableReferences()遍历 referenceQueue 移除掉 retainedKeys 里面的 refrence。</p><p>接着我们看到注释4处，执行了gcTrigger的runGc()方法进行垃圾回收，然后使用了removeWeaklyReachableReferences()方法移除已经被回收的引用。这里我们在深入地分析下runGc()的实现。</p><pre><code>GcTrigger DEFAULT = new GcTrigger() {    @Override public void runGc() {      // Code taken from AOSP FinalizationTest:      // https://android.googlesource.com/platform/libc  ore/+/master/support/src/test/java/libcore/      // java/lang/ref/FinalizationTester.java      // System.gc() does not garbage collect every   time. Runtime.gc() is      // more likely to perform a gc.      Runtime.getRuntime().gc();      enqueueReferences();      System.runFinalization();    }    private void enqueueReferences() {      // Hack. We don&apos;t have a programmatic way to wait   for the reference queue daemon to move      // references to the appropriate queues.      try {        Thread.sleep(100);      } catch (InterruptedException e) {        throw new AssertionError();      }    }};</code></pre><p>这里并没有使用System.gc()方法进行回收，因为system.gc()并不会每次都执行。而是从AOSP中拷贝一段GC回收的代码，从而相比System.gc()更能够保证进行垃圾回收的工作。</p><p>最后我们分析下注释5处的代码处理。首先会判断activity 如果还没有被回收，则证明发生内存泄露，进行if判断里面的操作。在里面先调用堆信息转储者heapDumper的dumpHeap()生成相应的 hprof 文件。这里的heapDumper是一个HeapDumper接口，具体的实现是AndroidHeapDumper。我们分析下AndroidHeapDumper的dumpHeap()方法是如何生成hprof文件的。</p><pre><code>public File dumpHeap() {    File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();    if (heapDumpFile == RETRY_LATER) {        return RETRY_LATER;    }    ...    try {      Debug.dumpHprofData(heapDumpFile.getAbsolutePath());      ...      return heapDumpFile;    } catch (Exception e) {      ...      // Abort heap dump      return RETRY_LATER;    }}</code></pre><p>这里的核心操作就是调用了<br>Android SDK的API Debug.dumpHprofData() 来生成 hprof 文件。</p><p>如果这个文件等于RETRY_LATER则表示生成失败，直接返回RETRY进行延时重试检测的操作。如果不等于的话，则表示生成成功，最后会执行heapdumpListener的analyze()对新创建的HeapDump对象进行泄漏分析。由前面对AndroidRefWatcherBuilder的listenerServiceClass()的分析可知，heapdumpListener的实现<br>就是ServiceHeapDumpListener，接着看到ServiceHeapDumpListener的analyze方法。</p><h4 id="17、ServiceHeapDumpListener-analyze"><a href="#17、ServiceHeapDumpListener-analyze" class="headerlink" title="17、ServiceHeapDumpListener#analyze()"></a>17、ServiceHeapDumpListener#analyze()</h4><pre><code>@Override public void analyze(@NonNull HeapDump heapDump) {    checkNotNull(heapDump, &quot;heapDump&quot;);    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);}</code></pre><p>可以看到，这里执行了HeapAnalyzerService的runAnalysis()方法，为了避免减慢app进程或占用内存，这里将HeapAnalyzerService设置在了一个独立的进程中。接着继续分析runAnalysis()方法里面的处理。</p><pre><code>public final class HeapAnalyzerService extends ForegroundServiceimplements AnalyzerProgressListener {    ...    public static void runAnalysis(Context context, HeapDump heapDump,    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass) {        ...        ContextCompat.startForegroundService(context, intent);    }    ...    @Override protected void onHandleIntentInForeground(@Nullable Intent intent) {        ...        // 1        HeapAnalyzer heapAnalyzer =            new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);        // 2        AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,        heapDump.computeRetainedHeapSize);        // 3        AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);    }        ...}</code></pre><p>这里的HeapAnalyzerService实质是一个类型为IntentService的ForegroundService，执行startForegroundService()之后，会回调onHandleIntentInForeground()方法。注释1处，首先会新建一个HeapAnalyzer对象，顾名思义，它就是根据RefWatcher生成的heap dumps信息来分析被怀疑的泄漏是否是真的。在注释2处，然后会调用它的checkForLeak()方法去使用haha库解析 hprof文件，如下所示：</p><pre><code>public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,  @NonNull String referenceKey,  boolean computeRetainedSize) {    ...    try {    listener.onProgressUpdate(READING_HEAP_DUMP_FILE);    // 1    HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);    // 2    HprofParser parser = new HprofParser(buffer);    listener.onProgressUpdate(PARSING_HEAP_DUMP);    Snapshot snapshot = parser.parse();    listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);    // 3    deduplicateGcRoots(snapshot);    listener.onProgressUpdate(FINDING_LEAKING_REF);    // 4    Instance leakingRef = findLeakingReference(referenceKey, snapshot);    // 5    if (leakingRef == null) {        return noLeak(since(analysisStartNanoTime));    }    // 6    return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);    } catch (Throwable e) {    return failure(e, since(analysisStartNanoTime));    }}</code></pre><p>在注释1处，会新建一个内存映射缓存文件buffer。在注释2处，会使用buffer新建一个HprofParser解析器去解析出对应的引用内存快照文件snapshot。在注释3处，为了减少在Android 6.0版本中重复GCRoots带来的内存压力的影响，使用deduplicateGcRoots()删除了gcRoots中重复的根对象RootObj。在注释4处，调用了findLeakingReference()方法将传入的referenceKey和snapshot对象里面所有类实例的字段值对应的keyCandidate进行比较，如果没有相等的，则表示没有发生内存泄漏，直接调用注释5处的代码返回一个没有泄漏的分析结果AnalysisResult对象。如果找到了相等的，则表示发生了内存泄漏，执行注释6处的代码findLeakTrace()方法返回一个有泄漏分析结果的AnalysisResult对象。</p><p>最后，我们来分析下HeapAnalyzerService中注释3处的AbstractAnalysisResultService.sendResultToListener()方法，很明显，这里AbstractAnalysisResultService的实现类就是我们刚开始分析的用于展示泄漏路径信息得DisplayLeakService对象。在里面直接创建一个由PendingIntent构建的泄漏通知用于供用户点击去展示详细的泄漏界面DisplayLeakActivity。核心代码如下所示：</p><pre><code>public class DisplayLeakService extends AbstractAnalysisResultService {    @Override    protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {        ...        boolean resultSaved = false;        boolean shouldSaveResult = result.leakFound || result.failure != null;        if (shouldSaveResult) {            heapDump = renameHeapdump(heapDump);            // 1            resultSaved = saveResult(heapDump, result);        }        if (!shouldSaveResult) {            ...            showNotification(null, contentTitle, contentText);        } else if (resultSaved) {            ...            // 2            PendingIntent pendingIntent =                DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);            ...            showNotification(pendingIntent, contentTitle, contentText);        } else {             onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));        }    ...}@Override protected final void onAnalysisResultFailure(String failureMessage) {    super.onAnalysisResultFailure(failureMessage);    String failureTitle = getString(R.string.leak_canary_result_failure_title);    showNotification(null, failureTitle, failureMessage);}</code></pre><p>可以看到，只要当分析的堆信息文件保存成功之后，即在注释1处返回的resultSaved为true时，才会执行注释2处的逻辑，即创建一个供用户点击跳转到DisplayLeakActivity的延时通知。最后给出一张源码流程图用于回顾：</p><p><img src="https://ww1.sinaimg.cn/large/006dXScfly1fj22w7flt4j30z00mrtc0.jpg" alt="image"></p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>性能优化一直是Android中的进阶和深入的方向之一，而内存泄漏一直是性能优化中比较重要的一部分，Android Studio自身提供了MAT等工具去分析内存泄漏，但是分析起来比较耗时，因而才诞生了LeakCanary，它的使用非常简单，但是经过对它的深入分析之后，才发现，<strong>简单的API后面往往藏着许多复杂的逻辑处理</strong>。接下来，下篇笔者将会为大家带来Android中的第三方依赖注入框架ButterKnife的源码分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、LeakCanary V1.6.2 源码</p><p>2、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243402&amp;idx=1&amp;sn=e7632788e8e147320b26a1b006cabf4c&amp;chksm=88637025bf14f933dcf90fbd1d7f9090e3802dd37759cac014ac1ed73c455fb9b5d9953bb89f&amp;scene=38#wechat_redirect" target="_blank" rel="external">一步步拆解 LeakCanary</a></p><p>3、<a href="https://allenwu.itscoder.com/leakcanary-source" target="_blank" rel="external">深入理解 Android 之 LeakCanary 源码解析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/06/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AD%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Leakcanary%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（五、深入理解RxJava源码）</title>
      <link>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Tue, 01 Jan 2019 15:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>到目前为止笔者分析了Android中最热门的网络底层和封装框架：<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>，Android中使用最广泛的图片加载框架Glide的加载流程：<a href="https://jsonchao.github.io/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>以及Android中性能最好的数据库框架<a href="https://jsonchao.github.io/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（四、深入理解GreenDao源码）</a>。本篇，我将会对近几年比较热门的函数式编程框架RxJava的源码进行详细的分析。</p><h3 id="一、RxJava到底是什么？"><a href="#一、RxJava到底是什么？" class="headerlink" title="一、RxJava到底是什么？"></a>一、RxJava到底是什么？</h3><p>RxJava是基于Java虚拟机上的响应式扩展库，它通过<strong>使用可观察的序列将异步和基于事件的程序组合起来</strong>。<br>与此同时，它<strong>扩展了观察者模式来支持数据/事件序列</strong>，并且添加了操作符，这些<strong>操作符允许你声明性地组合序列</strong>，同时抽象出要关注的问题：比如低级线程、同步、线程安全和并发数据结构等。</p><p>从RxJava的官方定义来看，我们如果要想真正地理解RxJava，就必须对它以下两个部分进行深入的分析：</p><ul><li>1、<strong>订阅流程</strong>。</li><li>2、<strong>线程切换</strong>。</li></ul><p>当然，RxJava操作符的源码也是很不错的学习资源，特别是FlatMap、Zip等操作符的源码，有很多可以借鉴的地方，但是它们内部的实现比较复杂，限于篇幅，本文只讲解RxJava的订阅流程和线程切换原理。接下来，笔者一一对以上RxJava的两个关键部分来进行详细地讲解。</p><h3 id="二、RxJava的订阅流程"><a href="#二、RxJava的订阅流程" class="headerlink" title="二、RxJava的订阅流程"></a>二、RxJava的订阅流程</h3><p>首先给出RxJava消息订阅的例子：</p><pre><code>Observable.create(newObservableOnSubscribe&lt;String&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }}).subscribe(new Observer&lt;String&gt;() {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;onSubscribe&quot;);    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;onNext : &quot; + s);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;onError : &quot; + e.toString());    }    @Override    public void onComplete() {        Log.d(TAG, &quot;onComplete&quot;);    }});</code></pre><p>可以看到，这里首先创建了一个被观察者，然后创建一个观察者订阅了这个被观察者，因此下面分两个部分对RxJava的订阅流程进行分析：</p><ul><li>1、<strong>创建被观察者过程</strong>。</li><li>2、<strong>订阅过程；</strong>。</li></ul><h4 id="1、创建被观察者过程"><a href="#1、创建被观察者过程" class="headerlink" title="1、创建被观察者过程"></a>1、创建被观察者过程</h4><p>首先，上面使用了Observable类的create()方法创建了一个被观察者，看看里面做了什么。</p><h5 id="1-1、Observable-create"><a href="#1-1、Observable-create" class="headerlink" title="1.1、Observable#create()"></a>1.1、Observable#create()</h5><pre><code>// 省略一些检测性的注解public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) {    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));}</code></pre><p>在Observable的create()里面实际上是创建了一个新的ObservableCreate对象，同时，把我们定义好的ObservableOnSubscribe对象传入了ObservableCreate对象中，最后调用了RxJavaPlugins.onAssembly()方法。接下来看看这个ObservableCreate是干什么的。</p><h5 id="1-2、ObservableCreate"><a href="#1-2、ObservableCreate" class="headerlink" title="1.2、ObservableCreate"></a>1.2、ObservableCreate</h5><pre><code>public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; {    final ObservableOnSubscribe&lt;T&gt; source;    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {        this.source = source;    }    ...}</code></pre><p>这里仅仅是把ObservableOnSubscribe这个对象保存在ObservableCreate中了。然后看看RxJavaPlugins.onAssembly()这个方法的处理。</p><h5 id="1-3、RxJavaPlugins-onAssembly"><a href="#1-3、RxJavaPlugins-onAssembly" class="headerlink" title="1.3、RxJavaPlugins#onAssembly()"></a>1.3、RxJavaPlugins#onAssembly()</h5><pre><code>public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) {    // 应用hook函数的一些处理，一般用到不到    ...    return source;}</code></pre><p>最终仅仅是把我们的ObservableCreate给返回了。</p><h5 id="1-4、创建被观察者过程小结"><a href="#1-4、创建被观察者过程小结" class="headerlink" title="1.4、创建被观察者过程小结"></a>1.4、创建被观察者过程小结</h5><p>从以上分析可知，Observable.create()方法仅仅是<strong>先将我们自定义的ObservableOnSubscribe对象重新包装成了一个ObservableCreate对象</strong>。</p><h4 id="2、订阅过程"><a href="#2、订阅过程" class="headerlink" title="2、订阅过程"></a>2、订阅过程</h4><p>接着，看看Observable.subscribe()的订阅过程是如何实现的。</p><h5 id="2-1、Observable-subscribe"><a href="#2-1、Observable-subscribe" class="headerlink" title="2.1、Observable#subscribe()"></a>2.1、Observable#subscribe()</h5><pre><code>public final void subscribe(Observer&lt;? super T&gt; observer) {    ...    // 1    observer = RxJavaPlugins.onSubscribe(this,observer);    ...    // 2    subscribeActual(observer);    ...}</code></pre><p>在Observable的subscribe()方法内部首先调用了RxJavaPlugins的onSubscribe()方法。</p><h5 id="2-2、RxJavaPlugins-onSubscribe"><a href="#2-2、RxJavaPlugins-onSubscribe" class="headerlink" title="2.2、RxJavaPlugins#onSubscribe()"></a>2.2、RxJavaPlugins#onSubscribe()</h5><pre><code>public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) {    // 应用hook函数的一些处理，一般用到不到    ...    return observer;}</code></pre><p>除去hook应用的逻辑，这里仅仅是将observer返回了。接着来分析下subscribeActual()方法，</p><h5 id="2-3、Observable-subscribeActual"><a href="#2-3、Observable-subscribeActual" class="headerlink" title="2.3、Observable#subscribeActual()"></a>2.3、Observable#subscribeActual()</h5><pre><code>protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);</code></pre><p>这是一个抽象的方法，很明显，它对应的具体实现类就是我们在第一步创建的ObservableCreate类，接下来看到ObservableCreate的subscribeActual()方法。</p><h5 id="2-4、ObservableCreate-subscribeActual"><a href="#2-4、ObservableCreate-subscribeActual" class="headerlink" title="2.4、ObservableCreate#subscribeActual()"></a>2.4、ObservableCreate#subscribeActual()</h5><pre><code>@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) {    // 1    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);    // 2    observer.onSubscribe(parent);    try {        // 3        source.subscribe(parent);    } catch (Throwable ex) {        Exceptions.throwIfFatal(ex);        parent.onError(ex);    }}</code></pre><p>在注释1处，首先新创建了一个CreateEmitter对象，同时传入了我们自定义的observer对象进去。</p><h5 id="2-4-1、CreateEmitter"><a href="#2-4-1、CreateEmitter" class="headerlink" title="2.4.1、CreateEmitter"></a>2.4.1、CreateEmitter</h5><pre><code>static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable {    ...    final Observer&lt;? super T&gt; observer;    CreateEmitter(Observer&lt;? super T&gt; observer) {        this.observer = observer;    }    ...}</code></pre><p>从上面可以看出，<strong>CreateEmitter通过继承了Java并发包中的原子引用类AtomicReference<disposable>保证了事件流切断状态Dispose的一致性</disposable></strong>（这里不理解的话，看到后面讲解Dispose的时候就明白了），并<strong>实现了ObservableEmitter接口和Disposable接口</strong>，接着我们分析下注释2处的observer.onSubscribe(parent)，这个onSubscribe回调的含义其实就是<strong>告诉观察者已经成功订阅了被观察者</strong>。再看到注释3处的source.subscribe(parent)这行代码，这里的source其实是ObservableOnSubscribe对象，我们看到ObservableOnSubscribe的subscribe()方法。</p><h5 id="2-4-2、ObservableOnSubscribe-subscribe"><a href="#2-4-2、ObservableOnSubscribe-subscribe" class="headerlink" title="2.4.2、ObservableOnSubscribe#subscribe()"></a>2.4.2、ObservableOnSubscribe#subscribe()</h5><pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {    @Override    public voidsubscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }});</code></pre><p>这里面使用到了ObservableEmitter的onNext()方法将事件流发送出去，最后调用了onComplete()方法完成了订阅过程。ObservableEmitter是一个抽象类，实现类就是我们传入的CreateEmitter对象，接下来我们看看CreateEmitter的onNext()方法和onComplete()方法的处理。</p><h5 id="2-4-3、CreateEmitter-onNext-amp-amp-CreateEmitter-onComplete"><a href="#2-4-3、CreateEmitter-onNext-amp-amp-CreateEmitter-onComplete" class="headerlink" title="2.4.3、CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()"></a>2.4.3、CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()</h5><pre><code>static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable {...@Overridepublic void onNext(T t) {    ...    if (!isDisposed()) {        //调用观察者的onNext()        observer.onNext(t);    }}@Overridepublic void onComplete() {    if (!isDisposed()) {        try {            observer.onComplete();        } finally {            dispose();        }    }}...}</code></pre><p>在CreateEmitter的onNext和onComplete方法中首先都要经过一个<strong>isDisposed</strong>的判断，作用就是看<strong>当前的事件流是否被切断（废弃）掉了</strong>，默认是不切断的，如果想要切断，可以调用Disposable的dispose()方法将此状态设置为切断（废弃）状态。我们继续看看这个isDisposed内部的处理。</p><h5 id="2-4-4、ObservableEmitter-isDisposed"><a href="#2-4-4、ObservableEmitter-isDisposed" class="headerlink" title="2.4.4、ObservableEmitter#isDisposed()"></a>2.4.4、ObservableEmitter#isDisposed()</h5><pre><code>@Overridepublic boolean isDisposed() {    return DisposableHelper.isDisposed(get());}</code></pre><p>注意到这里通过get()方法首先从ObservableEmitter的AtomicReference<disposable>中拿到了保存的Disposable状态。然后交给了DisposableHelper进行判断处理。接下来看看DisposableHelper的处理。</disposable></p><h5 id="2-4-5、DisposableHelper-isDisposed-amp-amp-DisposableHelper-set"><a href="#2-4-5、DisposableHelper-isDisposed-amp-amp-DisposableHelper-set" class="headerlink" title="2.4.5、DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()"></a>2.4.5、DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()</h5><pre><code>public enum DisposableHelper implements Disposable {    DISPOSED;    public static boolean isDisposed(Disposable d) {        // 1        return d == DISPOSED;    }    public static boolean set(AtomicReference&lt;Disposable&gt; field, Disposable d) {        for (;;) {            Disposable current = field.get();            if (current == DISPOSED) {                if (d != null) {                    d.dispose();                }                return false;            }            // 2            if (field.compareAndSet(current, d)) {                if (current != null) {                    current.dispose();                }                return true;            }        }    }    ...    public static boolean dispose(AtomicReference&lt;Disposable&gt; field) {        Disposable current = field.get();        Disposable d = DISPOSED;        if (current != d) {            // ...            current = field.getAndSet(d);            if (current != d) {                if (current != null) {                    current.dispose();                }                return true;            }        }        return false;    }    ...}</code></pre><p>DisposableHelper是一个枚举类，内部只有一个值即DISPOSED, 从上面的分析可知它就是用来<strong>标记事件流被切断（废弃）状态的</strong>。先看到注释2和注释3处的代码<strong>field.compareAndSet(current, d)和field.getAndSet(d)</strong>，这里使用了<strong>原子引用AtomicReference<disposable>内部包装的CAS方法处理了标志Disposable的并发读写问题</disposable></strong>，最后看到注释3处，将我们传入的CreateEmitter这个原子引用类保存的Dispable状态和DisposableHelper内部的DISPOSED进行比较，如果相等，就证明数据流被切断了。为了更进一步理解Disposed的作用，再来看看CreateEmitter中剩余的关键方法。</p><h5 id="2-4-6、CreateEmitter"><a href="#2-4-6、CreateEmitter" class="headerlink" title="2.4.6、CreateEmitter"></a>2.4.6、CreateEmitter</h5><pre><code>@Overridepublic void onNext(T t) {    ...    // 1    if (!isDisposed()) {        observer.onNext(t);    }}@Overridepublic void onError(Throwable t) {    if (!tryOnError(t)) {        // 2        RxJavaPlugins.onError(t);    }}@Overridepublic boolean tryOnError(Throwable t) {    ...    // 3    if (!isDisposed()) {        try {            observer.onError(t);        } finally {            // 4            dispose();        }        return true;    }    return false;}@Overridepublic void onComplete() {    // 5    if (!isDisposed()) {        try {            observer.onComplete();        } finally {            // 6            dispose();        }    }}</code></pre><p>在注释1、3、5处，onNext()和onError()、onComplete()方法首先都会判断事件流是否被切断的处理，如果事件流此时被切断了，那么onNext()和onComplete()则会退出方法体，不做处理，<strong>onError()则会执行到RxJavaPlugins.onError(t)这句代码，内部会直接抛出异常，导致崩溃</strong>。如果事件流没有被切断，那么在onError()和onComplete()内部最终会调用到注释4、6处的这句dispose()代码，将事件流进行切断，由此可知，<strong>onError()和onComplete()只能调用一个，如果先执行的是onComplete()，再调用onError()的话就会导致异常崩溃</strong>。</p><h3 id="三、RxJava的线程切换"><a href="#三、RxJava的线程切换" class="headerlink" title="三、RxJava的线程切换"></a>三、RxJava的线程切换</h3><p>首先给出RxJava线程切换的例子：</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {    @Override    public voidsubscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }})     .subscribeOn(Schedulers.io())    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Observer&lt;String&gt;() {        @Override        public void onSubscribe(Disposable d) {            Log.d(TAG, &quot;onSubscribe&quot;);        }        @Override        public void onNext(String s) {            Log.d(TAG, &quot;onNext : &quot; + s);        }        @Override        public void onError(Throwable e) {            Log.d(TAG, &quot;onError : &quot; +e.toString());        }        @Override        public void onComplete() {            Log.d(TAG, &quot;onComplete&quot;);        }});</code></pre><p>可以看到，RxJava的线程切换主要分为subscribeOn()和observeOn()方法，首先，来分析下subscribeOn()方法。</p><h4 id="3-1-1、subscribeOn-Schedulers-io"><a href="#3-1-1、subscribeOn-Schedulers-io" class="headerlink" title="3.1.1、subscribeOn(Schedulers.io())"></a>3.1.1、subscribeOn(Schedulers.io())</h4><p>在Schedulers.io()方法中，我们需要先传入一个Scheduler调度类，这里是传入了一个调度到io子线程的调度类，我们看看这个Schedulers.io()方法内部是怎么构造这个调度器的。</p><h4 id="3-1-2、Schedulers-io"><a href="#3-1-2、Schedulers-io" class="headerlink" title="3.1.2、Schedulers#io()"></a>3.1.2、Schedulers#io()</h4><pre><code>static final Scheduler IO;...public static Scheduler io() {    // 1    return RxJavaPlugins.onIoScheduler(IO);}static {    ...    // 2    IO = RxJavaPlugins.initIoScheduler(new IOTask());}static final class IOTask implements Callable&lt;Scheduler&gt; {    @Override    public Scheduler call() throws Exception {        // 3        return IoHolder.DEFAULT;    }}static final class IoHolder {    // 4    static final Scheduler DEFAULT = new IoScheduler();}</code></pre><p>Schedulers这个类的代码很多，这里我只拿出有关Schedulers。io这个方法涉及的逻辑代码进行讲解。首先，在注释1处，同前面分析的订阅流程的处理一样，只是一个处理hook的逻辑，最终返回的还是传入的这个IO对象。再看到注释2处，在Schedulers的静态代码块中将IO对象进行了初始化，其实质就是新建了一个IOTask的静态内部类，在IOTask的call方法中，也就是注释3处，可以了解到使用了静态内部类的方式把创建的IOScheduler对象给返回出去了。绕了这么大圈子，<strong>Schedulers.io方法其实质就是返回了一个IOScheduler对象</strong>。</p><h4 id="3-1-3、Observable-subscribeOn"><a href="#3-1-3、Observable-subscribeOn" class="headerlink" title="3.1.3、Observable#subscribeOn()"></a>3.1.3、Observable#subscribeOn()</h4><pre><code>  public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {    ...    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));}</code></pre><p>在subscribeOn()方法里面，又将ObservableCreate包装成了一个ObservableSubscribeOn对象。我们关注到ObservableSubscribeOn类。</p><h4 id="3-1-4、ObservableSubscribeOn"><a href="#3-1-4、ObservableSubscribeOn" class="headerlink" title="3.1.4、ObservableSubscribeOn"></a>3.1.4、ObservableSubscribeOn</h4><pre><code>public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; {    final Scheduler scheduler;    public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) {        // 1        super(source);        this.scheduler = scheduler;    }    @Override    public void subscribeActual(final Observer&lt;? super T&gt; observer) {        // 2        final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer);        // 3        observer.onSubscribe(parent);        // 4        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));    }...}</code></pre><p>首先，在注释1处，将传进来的source和scheduler保存起来。接着，等到实际订阅的时候，就会执行到这个subscribeActual方法，在注释2处，将我们自定义的Observer包装成了一个SubscribeOnObserver对象。在注释3处，通知观察者订阅了被观察者。在注释4处，内部先创建了一个SubscribeTask对象，来看看它的实现。</p><h4 id="3-1-5、ObservableSubscribeOn-SubscribeTask"><a href="#3-1-5、ObservableSubscribeOn-SubscribeTask" class="headerlink" title="3.1.5、ObservableSubscribeOn#SubscribeTask"></a>3.1.5、ObservableSubscribeOn#SubscribeTask</h4><pre><code>final class SubscribeTask implements Runnable {    private final SubscribeOnObserver&lt;T&gt; parent;    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {        this.parent = parent;    }    @Override    public void run() {        source.subscribe(parent);    }}</code></pre><p>SubscribeTask是ObservableSubscribeOn的内部类，它实质上就是一个任务类，在它的run方法中会执行到source.subscribe(parent)的订阅方法，<strong>这个source其实就是我们在ObservableSubscribeOn构造方法中传进来的ObservableCreate对象</strong>。接下来看看scheduler.scheduleDirect()内部的处理。</p><h4 id="3-1-6、Scheduler-scheduleDirect"><a href="#3-1-6、Scheduler-scheduleDirect" class="headerlink" title="3.1.6、Scheduler#scheduleDirect()"></a>3.1.6、Scheduler#scheduleDirect()</h4><pre><code>public Disposable scheduleDirect(@NonNull Runnable run) {    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);}public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {    // 1    final Worker w = createWorker();    // 2    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    // 3    DisposeTask task = new DisposeTask(decoratedRun, w);    // 4    w.schedule(task, delay, unit);    return task;}</code></pre><p>这里最后会执行到上面这个scheduleDirect()重载方法。首先，在注释1处，会调用createWorker()方法创建一个工作者对象Worker，它是一个抽象类，这里的实现类就是IoScheduler，下面，我们看看IoScheduler类的createWorker()方法。</p><h4 id="3-1-6-1、IOScheduler-createWorker"><a href="#3-1-6-1、IOScheduler-createWorker" class="headerlink" title="3.1.6.1、IOScheduler#createWorker()"></a>3.1.6.1、IOScheduler#createWorker()</h4><pre><code>final AtomicReference&lt;CachedWorkerPool&gt; pool;...public IoScheduler(ThreadFactory threadFactory) {    this.threadFactory = threadFactory;    this.pool = new AtomicReference&lt;CachedWorkerPool&gt;(NONE);    start();}...@Overridepublic Worker createWorker() {    // 1    return new EventLoopWorker(pool.get());}static final class EventLoopWorker extends Scheduler.Worker {    ...    EventLoopWorker(CachedWorkerPool pool) {        this.pool = pool;        this.tasks = new CompositeDisposable();        // 2        this.threadWorker = pool.get();    }}</code></pre><p>首先，在注释1处调用了pool.get()这个方法，pool是一个CachedWorkerPool类型的原子引用对象，它的作用就是<strong>用于缓存工作者对象Worker的</strong>。然后，将得到的CachedWorkerPool传入新创建的EventLoopWorker对象中。重点关注一下注释2处，这里讲CachedWorkerPool缓存的threadWorker对象保存起来了。</p><p>下面，我们继续分析3.6处代码段的注释2处的代码，这里又是一个关于hook的封装处理，最终还是返回的当前的Runnable对象。在注释3处新建了一个切断任务DisposeTask将decoratedRun和w包装了起来。最后在注释4处调用了工作者的schedule()方法。下面我们来分析下它内部的处理。</p><h4 id="3-1-6-2、IoScheduler-schedule"><a href="#3-1-6-2、IoScheduler-schedule" class="headerlink" title="3.1.6.2、IoScheduler#schedule()"></a>3.1.6.2、IoScheduler#schedule()</h4><pre><code>@Overridepublic Disposable schedule(@NonNull Runnableaction, long delayTime, @NonNull TimeUnit unit){    ...    return threadWorker.scheduleActual(action,delayTime, unit, tasks);}</code></pre><p>内部调用了threadWorker的scheduleActual()方法，实际上是调用到了父类NewThreadWorker的scheduleActual()方法，我们继续看看NewThreadWorker的scheduleActual()方法中做的事情。</p><h4 id="3-1-6-2-1、NewThreadWorker-scheduleActual"><a href="#3-1-6-2-1、NewThreadWorker-scheduleActual" class="headerlink" title="3.1.6.2.1、NewThreadWorker#scheduleActual()"></a>3.1.6.2.1、NewThreadWorker#scheduleActual()</h4><pre><code>public NewThreadWorker(ThreadFactory threadFactory) {    executor = SchedulerPoolFactory.create(threadFactory);}@NonNullpublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    // 1    ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);    if (parent != null) {        if (!parent.add(sr)) {            return sr;        }    }    Future&lt;?&gt; f;    try {        // 2        if (delayTime &lt;= 0) {            // 3            f = executor.submit((Callable&lt;Object&gt;)sr);        } else {            // 4            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);        }        sr.setFuture(f);    } catch (RejectedExecutionException ex) {        if (parent != null) {            parent.remove(sr);        }        RxJavaPlugins.onError(ex);    }    return sr;}</code></pre><p>在NewThreadWorker的scheduleActual()方法的内部，在注释1处首先会新建一个ScheduledRunnable对象，将Runnable对象和parent包装起来了，<strong>这里parent是一个DisposableContainer对象，它实际的实现类是CompositeDisposable类，即一个保存所有事件流是否被切断状态的容器，它内部的实现是使用了RxJava自己定义的一个简单的OpenHashSet类ji进行存储</strong>。最后注释2处，判断是否设置了延迟时间，如果设置了，则调用线程池的submit()方法立即进行线程切换，否则，调用schedule()方法进行延时执行线程切换。</p><h4 id="3-1-7、为什么多次执行subscribeOn-，只有第一次有效？"><a href="#3-1-7、为什么多次执行subscribeOn-，只有第一次有效？" class="headerlink" title="3.1.7、为什么多次执行subscribeOn()，只有第一次有效？"></a>3.1.7、为什么多次执行subscribeOn()，只有第一次有效？</h4><p>从上面的分析，我们可以很容易了解到<strong>被观察者被订阅时是从最外面的一层（ObservableSubscribeOn）通知到里面的一层（ObservableOnSubscribe）</strong>，当连续执行了到多次subscribeOn()的时候，其实就是先执行倒数第一次的subscribeOn()方法，直到最后一次执行的subscribeOn()方法肯定会覆盖前面的线程切换。</p><h4 id="3-2-1、observeOn-AndroidSchedulers-mainThread"><a href="#3-2-1、observeOn-AndroidSchedulers-mainThread" class="headerlink" title="3.2.1、observeOn(AndroidSchedulers.mainThread())"></a>3.2.1、observeOn(AndroidSchedulers.mainThread())</h4><pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler) {    return observeOn(scheduler, false, bufferSize());}public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {    ....    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));}</code></pre><p>可以看到，observeOn()方法内部最终也是返回了一个ObservableObserveOn对象，我们直接来看看ObservableObserveOn的subscribeActual()方法。</p><h4 id="3-2-2、ObservableObserveOn-subscribeActual"><a href="#3-2-2、ObservableObserveOn-subscribeActual" class="headerlink" title="3.2.2、ObservableObserveOn#subscribeActual()"></a>3.2.2、ObservableObserveOn#subscribeActual()</h4><pre><code>@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) {    // 1    if (scheduler instanceof TrampolineScheduler) {        // 2        source.subscribe(observer);    } else {        // 3        Scheduler.Worker w = scheduler.createWorker();        // 4        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));    }}</code></pre><p>首先，在注释1处，判断指定的调度器是不是TrampolineScheduler，这是一个不进行线程切换，立即执行当前代码的调度器，。如果是，则会直接调用调用ObservableSubscribeOn的subscribe()方法，如果不是，则会在注释3处创建一个工作者对象。然后在注释4处创建一个新的ObserveOnObserver将SubscribeOnobserver对象包装起来，并传入ObservableSubscribeOn的subscribe()方法进行订阅。接下来看看ObserveOnObserver类的重点方法。</p><h4 id="3-2-3、ObserveOnObserver"><a href="#3-2-3、ObserveOnObserver" class="headerlink" title="3.2.3、ObserveOnObserver"></a>3.2.3、ObserveOnObserver</h4><pre><code>@Overridepublic void onNext(T t) {    ...    if (sourceMode != QueueDisposable.ASYNC) {        // 1        queue.offer(t);    }    schedule();}@Overridepublic void onError(Throwable t) {    ...    schedule();}@Overridepublic void onComplete() {    ...    schedule();}</code></pre><p>去除非主线逻辑的代码，在ObserveOnObserver的onNext()和onError()、onComplete()方法中最后都会调用到schedule()方法。接着看schedule()方法，其中onNext()还会把消息存放到队列中。</p><h4 id="3-2-4、ObserveOnObserver-schedule"><a href="#3-2-4、ObserveOnObserver-schedule" class="headerlink" title="3.2.4、ObserveOnObserver#schedule()"></a>3.2.4、ObserveOnObserver#schedule()</h4><pre><code>void schedule() {    if (getAndIncrement() == 0) {        worker.schedule(this);    }}</code></pre><p>这里使用了worker进行调度ObserveOnObserver这个实现了Runnable的任务。worker就是在AndroidSchedulers.mainThread()中创建的，内部其实就是<strong>使用Handler进行线程切换的</strong>，此处不再赘述了。接着看ObserveOnObserver的run()方法。</p><h4 id="3-2-5、ObserveOnObserver-run"><a href="#3-2-5、ObserveOnObserver-run" class="headerlink" title="3.2.5、ObserveOnObserver#run()"></a>3.2.5、ObserveOnObserver#run()</h4><pre><code>@Overridepublic void run() {    // 1    if (outputFused) {        drainFused();    } else {        // 2        drainNormal();    }}</code></pre><p>在注释1处会先判断outputFused这个标志位，它表示事件流是否被融化掉，默认是false，所以，最后会执行到drainNormal()方法。接着看看drainNormal()方法内部的处理。</p><h4 id="3-2-6、ObserveOnObserver-drainNormal"><a href="#3-2-6、ObserveOnObserver-drainNormal" class="headerlink" title="3.2.6、ObserveOnObserver#drainNormal()"></a>3.2.6、ObserveOnObserver#drainNormal()</h4><pre><code>void drainNormal() {    int missed = 1;    final SimpleQueue&lt;T&gt; q = queue;    // 1    final Observer&lt;? super T&gt; a = downstream;    ...    // 2    v = q.poll();    ...    // 3    a.onNext(v);    ...}</code></pre><p>在注释1处，这里的downstream实际上是从外面传进来的SubscribeOnObserver对象。在注释2处将队列中的消息取出来，接着在注释3处调用了SubscribeOnObserver的onNext方法。<strong>最终，会从我们包装类的最外层一直调用到最里面的我们自定义的Observer中的onNext()方法，所以，在observeOn()方法下面的链式代码都会执行到它所指定的线程中，噢，原来如此</strong>。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>其实笔者使用了RxJava也已经有一年多的时间了，但是一直没有去深入去了解过它的内部实现原理，如今细细品尝，的确是酣畅淋漓。从一开始的OkHttp到现如今的RxJava源码分析，到此为止，Android主流三方库源码分析系列文章已经发布了五篇了，我们的征途已经过半，接下来，我将会对Android中的内存泄露框架LeakCanary源码进行深入地讲解，尽请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、RxJava V2.2.5 源码</p><p>2、Android 进阶之光</p><p>3、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492749&amp;idx=1&amp;sn=a4d2e79afd8257b57c6efa57cbff4404&amp;chksm=8eec86f2b99b0fe46f61f324e032af335fbe02c7db1ef4eca60abb4bc99b4d216da7ba32dc88&amp;scene=38#wechat_redirect" target="_blank" rel="external">详解 RxJava 的消息订阅和线程切换原理</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2018年终总结</title>
      <link>http://yoursite.com/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <guid>http://yoursite.com/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sat, 29 Dec 2018 14:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>今天，已经是2018年最后一天的工作日了，回想2018学习路上的点点滴滴，有收获和喜悦，也有烦恼与焦虑，但是，总的来说，这一年，我在技术上的提升还是比较大的，因此，我感觉，我的付出是值得的，接下来，回顾一下2018年我的成长轨迹。</p><h3 id="一、回顾我的2018年"><a href="#一、回顾我的2018年" class="headerlink" title="一、回顾我的2018年"></a>一、回顾我的2018年</h3><h3 id="第一季度（1-3月）："><a href="#第一季度（1-3月）：" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、开源Awesome-WanAndroid（开源时间-2018年3月9日）"><a href="#1、开源Awesome-WanAndroid（开源时间-2018年3月9日）" class="headerlink" title="1、开源Awesome-WanAndroid（开源时间 2018年3月9日）"></a>1、开源Awesome-WanAndroid（开源时间 2018年3月9日）</h4><p><a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid项目地址</a></p><p>这是我在Github开源的第一个项目，也是第一个达到1K Star的项目。在这之前，我对开源的理解和大多数普通Android开发者的理解一样，认为它只是一个免费的仓库聚集地，其实，开源所包含的意义是巨大的，它对 <strong>整个Android社区的推动和发展</strong> ，以及与 <strong>个人的成长紧密关联</strong> ，而我自身，也 <strong>因为开源，对Android本身的热爱也更加浓厚了</strong> 。因此，希望每个人都能加入到这个大环境来，这能在某种程度上影响自身的发展。</p><p>再来说说这个项目，这个项目是基于鸿洋大神的个人网站<a href="http://www.wanandroid.com/" target="_blank" rel="external">WanAndroid</a>进行开发的Android客户端。它是一款会让您觉得很nice的<strong>技术学习APP</strong>，所用技术基本涵盖了<strong>当前Android开发中常用的主流技术框架</strong>，阅读内容主要面向想在Android开发领域成为专家的朋友们，有兴趣的朋友可以点击上面的链接进行查看。</p><h3 id="第二季度（4-6月）："><a href="#第二季度（4-6月）：" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、开源Awesome-Android-Notebook（开源时间-2018年5月1日）"><a href="#1、开源Awesome-Android-Notebook（开源时间-2018年5月1日）" class="headerlink" title="1、开源Awesome-Android-Notebook（开源时间 2018年5月1日）"></a>1、开源Awesome-Android-Notebook（开源时间 2018年5月1日）</h4><p><a href="https://github.com/JsonChao/Awesome-Android-Notebook" target="_blank" rel="external">Awesome-Android-Notebook项目地址</a></p><p>这个项目的发起还得从我的第一个开源项目<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>说起，在开源了这个项目之后，我收到了很多朋友的鼓励，但同时，因为自身技术实力的薄弱，对很多项目本身所用技术和Android的理解层次不够使我产生了一个将自己打造成为一个优秀Android开发的念头，由此，<a href="https://github.com/JsonChao/Awesome-Android-Notebook" target="_blank" rel="external">Awesome-Android-Notebook</a>诞生了，它是一份通往优秀Android开发的完备的计划，有兴趣的朋友可以参考下。</p><h4 id="2、计算机网络系统学习"><a href="#2、计算机网络系统学习" class="headerlink" title="2、计算机网络系统学习"></a>2、计算机网络系统学习</h4><p>主要基于《计算机网络：自顶向下方法》一书对计算机网络OSI中的五层架构模型相关知识进行了较为深入的学习与理解。</p><h4 id="3、系统学习Android单元测试"><a href="#3、系统学习Android单元测试" class="headerlink" title="3、系统学习Android单元测试"></a>3、系统学习Android单元测试</h4><p>基于<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a><br>项目对Android单元测试的相关技术进行了系统学习，有兴趣的可以查看该项目的test测试目录进行学习。</p><h3 id="第三季度（7-9月）："><a href="#第三季度（7-9月）：" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、开源Awesome-Android-Interview项目（开源时间-2018年7月29日）"><a href="#1、开源Awesome-Android-Interview项目（开源时间-2018年7月29日）" class="headerlink" title="1、开源Awesome-Android-Interview项目（开源时间 2018年7月29日）"></a>1、开源Awesome-Android-Interview项目（开源时间 2018年7月29日）</h4><p><a href="https://github.com/JsonChao/Awesome-Android-Interview" target="_blank" rel="external">Awesome-Android-Interview项目地址</a></p><p>随着Android技术发展的成熟，Kotlin、大前端技术RN、Flutter、小程序等一下子就进入了我们的视野内，同时，Android自身的技术栈也正在不断扩展，比如前段时间Google推出的Jetpack。因此，Android开发者们越来越焦虑，越来越迷茫，每个人的<strong>时间和精力是有限的</strong>，我们到底该学什么才能有效地提高自身的竞争力呢?其实，首先我们应该优先深入学习工作中用到的技术，其次，关注这2年来<strong>Android最新的面试题所涉及的知识点</strong>，根据<strong>自身的实际情况有选择地进行针对性的学习和提升</strong>。只有这样，自身才不会被所谓的 <strong>互联网寒冬</strong> 吓倒。</p><h4 id="2、Python基础-amp-amp-数据分析基础学习"><a href="#2、Python基础-amp-amp-数据分析基础学习" class="headerlink" title="2、Python基础 &amp;&amp; 数据分析基础学习"></a>2、Python基础 &amp;&amp; 数据分析基础学习</h4><p>这一块主要是基于公司的后台算法项目为目的对Python基础知识和数据分析相关基础进行了学习。</p><h3 id="第四季度（10-12月）："><a href="#第四季度（10-12月）：" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、Android核心知识点学习"><a href="#1、Android核心知识点学习" class="headerlink" title="1、Android核心知识点学习"></a>1、Android核心知识点学习</h4><p>基于 <strong>《Android开发艺术探索》</strong> 、 <strong>《Android开发进阶》</strong> 对Android应用开发涉及的核心知识点进行了系统的学习 &amp; 复习 &amp; 理解，并对其中的重难点知识进行了博客输出：</p><ul><li><a href="https://jsonchao.github.io/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Android触摸事件传递机制</a></li><li><a href="https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Android View的绘制流程</a></li><li>Android中的消息机制Handler</li><li>Android中的线程和线程池</li><li>…</li></ul><h4 id="2、开源Awesome-Third-Library-Source-Analysis项目（开源时间-2018年12月18日）"><a href="#2、开源Awesome-Third-Library-Source-Analysis项目（开源时间-2018年12月18日）" class="headerlink" title="2、开源Awesome-Third-Library-Source-Analysis项目（开源时间 2018年12月18日）"></a>2、开源Awesome-Third-Library-Source-Analysis项目（开源时间 2018年12月18日）</h4><p><a href="https://github.com/JsonChao/Awesome-Third-Library-Source-Analysis" target="_blank" rel="external">Awesome-Third-Library-Source-Analysis项目地址</a></p><p>众所周知，优秀源码的阅读与理解是最能提升自身功力的途径，如果想要成为一名优秀的Android工程师，那么Android优秀三方库源码的分析和理解则是必备技能。因此，为了将知识成体系地聚合起来，笔者创建了Awesome-Third-Library-Source-Analysis这个项目，为的就是让每一个Android工程师能够从以下七方面全方位地提升自己：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Android_hot_third_source_analysis.png" alt="image"></p><p>这个项目目前已进行进行到第四步——响应式编程，最近几天就会输出RxJava的源码分析文章，此前，已经对Android中的网络、图片加载、数据库热门框架源码进行了分析，感兴趣的可以<a href="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Android_hot_third_source_analysis.png" target="_blank" rel="external">点此查看</a>，目前，估计在2019年1月底此系列将会完结，后续会马上推出Android核心源码的分析系列，敬请期待。</p><h4 id="3、C-C-核心基础知识复习"><a href="#3、C-C-核心基础知识复习" class="headerlink" title="3、C/C++核心基础知识复习"></a>3、C/C++核心基础知识复习</h4><p>要想深入研究Android源码，C/C++基础则是必备之一，因此，我重新捡起了C/C++，下面是C/C++的核心知识速记笔记:</p><ul><li><a href="https://github.com/JsonChao/Awesome-Android-Notebook/blob/master/notes/C%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md" target="_blank" rel="external">C核心速记笔记</a></li><li><a href="https://github.com/JsonChao/Awesome-Android-Notebook/blob/master/notes/C%2B%2B%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md" target="_blank" rel="external">C++核心速记笔记</a></li></ul><p>接下来，下面对我的2019年做了<strong>最核心的学习计划</strong>，所以会尽可能地去完成好它。</p><h3 id="二、初始化我的2019年"><a href="#二、初始化我的2019年" class="headerlink" title="二、初始化我的2019年"></a>二、初始化我的2019年</h3><h3 id="第一季度（1-3月）：-1"><a href="#第一季度（1-3月）：-1" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、Android主流开源库源码分析系列博客"><a href="#1、Android主流开源库源码分析系列博客" class="headerlink" title="1、Android主流开源库源码分析系列博客"></a>1、Android主流开源库源码分析系列博客</h4><p>Android高级开发者必须了解的核心开源库源码：</p><ul><li>内存泄露：LeakCanary</li><li>依赖注入：ButterKnife、Dagger2</li><li>事件总线：EventBus</li></ul><h4 id="2、Android核心源码"><a href="#2、Android核心源码" class="headerlink" title="2、Android核心源码"></a>2、Android核心源码</h4><p>与Android应用开发紧密相关的Framework核心源码：</p><ul><li>Context家族</li><li>AMS</li><li>WMS</li><li>PMS</li><li>JNI原理</li></ul><h4 id="3、Android插件化知识相关"><a href="#3、Android插件化知识相关" class="headerlink" title="3、Android插件化知识相关"></a>3、Android插件化知识相关</h4><p>学习和理解插件化知识能将FrameWork核心源码的相关知识融会贯通：</p><ul><li>JVM核心知识</li><li>Davilk/ART核心知识</li><li>类加载</li><li>热修复</li><li>插件化（基于VirtualAPK）</li></ul><h4 id="4、组件化"><a href="#4、组件化" class="headerlink" title="4、组件化"></a>4、组件化</h4><p>结合公司新版项目系统学习组件化架构的设计与理念。</p><h4 id="5、算法"><a href="#5、算法" class="headerlink" title="5、算法"></a>5、算法</h4><p>LetteCode 每日一题 ==&gt; 思考&amp;练习&amp;记录，基于以下学习课程：</p><ul><li><a href="https://coding.imooc.com/learn/list/207.html" target="_blank" rel="external">玩转数据结构 从入门到进阶</a></li><li><a href="https://coding.imooc.com/learn/list/71.html" target="_blank" rel="external">学习算法思想，修炼编程内功</a></li><li><a href="https://coding.imooc.com/learn/list/82.html" target="_blank" rel="external">玩转算法面试，从真题到思维全面提升算法思维</a></li></ul><h3 id="第二季度（4-6月）：-1"><a href="#第二季度（4-6月）：-1" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、Android源码设计模式"><a href="#1、Android源码设计模式" class="headerlink" title="1、Android源码设计模式"></a>1、Android源码设计模式</h4><p>主要基于 <strong>Android源码</strong> 和 <strong>《Android源码设计模式解析与实战》</strong> 一书进一步加深对Android FrameWork层的的理解与思考。</p><h4 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录，基于以下学习课程：</p><ul><li>极客时间之《数据结构和算法之美》</li></ul><h3 id="第三季度（7-9月）：-1"><a href="#第三季度（7-9月）：-1" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、深入理解Android热修复"><a href="#1、深入理解Android热修复" class="headerlink" title="1、深入理解Android热修复"></a>1、深入理解Android热修复</h4><p>主要基于 <strong>现有的热修复技术</strong> 和 <strong>《深入探索Android热修复技术原理》</strong> 一书进一步加深对Android热修复技术的的理解与思考解。</p><h4 id="2、深入理解Android插件化"><a href="#2、深入理解Android插件化" class="headerlink" title="2、深入理解Android插件化"></a>2、深入理解Android插件化</h4><p>主要基于 <strong>现有的插件化技术</strong> 和 <strong>《Android插件化开发指南》</strong> 一书进一步加深对Android插件化技术的理解与思考。</p><h4 id="3、算法"><a href="#3、算法" class="headerlink" title="3、算法"></a>3、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录，基于以下学习课程：</p><ul><li>极客时间之《算法面试通关40讲》</li></ul><h3 id="第四季度（10-12月）：-1"><a href="#第四季度（10-12月）：-1" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、深入学习Android性能优化"><a href="#1、深入学习Android性能优化" class="headerlink" title="1、深入学习Android性能优化"></a>1、深入学习Android性能优化</h4><p>主要基于 <strong>极客时间之《Android开发高手课》</strong> 和 <strong>《Android应用性能优化最佳实践》</strong>、收藏的其它性能优化博文对Android性能优化相关知识进行全面、系统、深入地学习。</p><h4 id="2、算法-1"><a href="#2、算法-1" class="headerlink" title="2、算法"></a>2、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>如果想要成为一名优秀甚至卓越的Android工程师，就必须给自己 <strong>制定好切合自身的计划</strong> ，并 <strong>不断地刻意练习和思考</strong> ，只有这样，我们才能像锻炼肌肉一样去强化我们的大脑，最终，我们便会拥有 <strong>一通百通、快速学习的能力</strong> 。</p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（四、深入理解GreenDao源码）</title>
      <link>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sat, 22 Dec 2018 14:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>，除了热门的网络库之外，我们还分析了使用最广泛的图片加载框架Glide的加载流程，大家读完这篇源码分析会有不少提升，有兴趣可以看看<a href="https://jsonchao.github.io/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>。本篇，我们将会来对目前Android数据库框架中性能最好的GreenDao来进行较为深入地讲解。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><h4 id="1、导入GreenDao的代码生成插件和库"><a href="#1、导入GreenDao的代码生成插件和库" class="headerlink" title="1、导入GreenDao的代码生成插件和库"></a>1、导入GreenDao的代码生成插件和库</h4><pre><code>// 项目下的build.gradlebuildscript {    ...    dependencies {        classpath &apos;com.android.tools.build:gradle:2.3.0&apos;        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos;     }}// app模块下的build.gradleapply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos;...dependencies {    ...    compile &apos;org.greenrobot:greendao:3.2.0&apos; }</code></pre><h4 id="2、创建一个实体类，这里为HistoryData"><a href="#2、创建一个实体类，这里为HistoryData" class="headerlink" title="2、创建一个实体类，这里为HistoryData"></a>2、创建一个实体类，这里为HistoryData</h4><pre><code>@Entitypublic class HistoryData {    @Id(autoincrement = true)    private Long id;    private long date;    private String data;}</code></pre><h4 id="3、选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"><a href="#3、选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。" class="headerlink" title="3、选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"></a>3、选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。</h4><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/greendao_auto_generate_class.png" alt="image"></p><pre><code>@Entitypublic class HistoryData {    @Id(autoincrement = true)    private Long id;    private long date;    private String data;    @Generated(hash = 1371145256)    public HistoryData(Long id, long date, String data) {        this.id = id;        this.date = date;        this.data = data;    }    @Generated(hash = 422767273)    public HistoryData() {    }    public Long getId() {        return this.id;    }    public void setId(Long id) {        this.id = id;    }    public long getDate() {        return this.date;    }    public void setDate(long date) {        this.date = date;    }    public String getData() {        return this.data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>这里点明一下这几个类的作用：</p><ul><li>DaoMaster：所有Dao类的主人，负责整个库的运行，内部的静态抽象子类DevOpenHelper继承并重写了Android的SqliteOpenHelper。</li><li>DaoSession：作为一个会话层的角色，用于生成相应的Dao对象、Dao对象的注册，操作Dao的具体对象。</li><li>xxDao（HistoryDataDao）：生成的Dao对象，用于进行具体的数据库操作。</li></ul><h4 id="4、获取并使用相应的Dao对象进行增删改查操作"><a href="#4、获取并使用相应的Dao对象进行增删改查操作" class="headerlink" title="4、获取并使用相应的Dao对象进行增删改查操作"></a>4、获取并使用相应的Dao对象进行增删改查操作</h4><pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME);SQLiteDatabase database = devOpenHelper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(database);mDaoSession = daoMaster.newSession();HistoryDataDao historyDataDao = daoSession.getHistoryDataDao();// 省略创建historyData的代码...// 增historyDataDao.insert(historyData);// 删historyDataDao.delete(historyData);// 改historyDataDao.update(historyData);// 查List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll();</code></pre><p>本篇文章将会以上述使用流程来对GreenDao的源码进行逐步分析，最后会分析下GreenDao中一些优秀的特性，让读者朋友们对GreenDao的理解有更一步的加深。</p><h3 id="二、GreenDao使用流程分析"><a href="#二、GreenDao使用流程分析" class="headerlink" title="二、GreenDao使用流程分析"></a>二、GreenDao使用流程分析</h3><h4 id="1、创建数据库帮助类对象DaoMaster-DevOpenHelper"><a href="#1、创建数据库帮助类对象DaoMaster-DevOpenHelper" class="headerlink" title="1、创建数据库帮助类对象DaoMaster.DevOpenHelper"></a>1、创建数据库帮助类对象DaoMaster.DevOpenHelper</h4><pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME);</code></pre><p>创建GreenDao内部实现的数据库帮助类对象devOpenHelper，核心源码如下：</p><pre><code>public class DaoMaster extends AbstractDaoMaster {    ...    public static abstract class OpenHelper extends DatabaseOpenHelper {    ...         @Override        public void onCreate(Database db) {            Log.i(&quot;greenDAO&quot;, &quot;Creating tables for schema version &quot; + SCHEMA_VERSION);            createAllTables(db, false);        }    }    public static class DevOpenHelper extends OpenHelper {        ...        @Override        public void onUpgrade(Database db, int oldVersion, int newVersion) {            Log.i(&quot;greenDAO&quot;, &quot;Upgrading schema from version &quot; + oldVersion + &quot; to &quot; + newVersion + &quot; by dropping all tables&quot;);            dropAllTables(db, true);            onCreate(db);        }    }}</code></pre><p>DevOpenHelper自身实现了更新的逻辑，这里是弃置了所有的表，并且调用了OpenHelper实现的onCreate方法用于创建所有的表，其中DevOpenHelper继承于OpenHelper，而OpenHelper自身又继承于DatabaseOpenHelper，那么，这个DatabaseOpenHelper这个类的作用是什么呢？</p><pre><code>public abstract class DatabaseOpenHelper extends SQLiteOpenHelper {    ...    // 关注点1    public Database getWritableDb() {        return wrap(getWritableDatabase());    }    public Database getReadableDb() {        return wrap(getReadableDatabase());    }       protected Database wrap(SQLiteDatabase sqLiteDatabase) {        return new StandardDatabase(sqLiteDatabase);    }    ...    // 关注点2    public Database getEncryptedWritableDb(String password) {        EncryptedHelper encryptedHelper = checkEncryptedHelper();        return encryptedHelper.wrap(encryptedHelper.getWritableDatabase(password));    }    public Database getEncryptedReadableDb(String password) {        EncryptedHelper encryptedHelper = checkEncryptedHelper();        return encryptedHelper.wrap(encryptedHelper.getReadableDatabase(password));    }    ...    private class EncryptedHelper extends net.sqlcipher.database.SQLiteOpenHelper {        ...        protected Database wrap(net.sqlcipher.database.SQLiteDatabase     sqLiteDatabase) {            return new EncryptedDatabase(sqLiteDatabase);        }    }</code></pre><p>其实，DatabaseOpenHelper也是实现了SQLiteOpenHelper的一个帮助类，它内部可以获取到两种不同的数据库类型，一种是标准型的数据库==StandardDatabase==，另一种是加密型的数据库==EncryptedDatabase==，从以上源码可知，它们内部都通过wrap这样一个包装的方法，返回了对应的数据库类型，我们大致看一下StandardDatabase和EncryptedDatabase的内部实现。</p><pre><code>public class StandardDatabase implements Database {    // 这里的SQLiteDatabase是android.database.sqlite.SQLiteDatabase包下的    private final SQLiteDatabase delegate;    public StandardDatabase(SQLiteDatabase delegate) {        this.delegate = delegate;    }    @Override    public Cursor rawQuery(String sql, String[] selectionArgs) {        return delegate.rawQuery(sql, selectionArgs);    }    @Override    public void execSQL(String sql) throws SQLException {        delegate.execSQL(sql);    }    ...}public class EncryptedDatabaseStatement implements DatabaseStatement     {    // 这里的SQLiteStatement是net.sqlcipher.database.SQLiteStatement包下的    private final SQLiteStatement delegate;    public EncryptedDatabaseStatement(SQLiteStatement delegate) {        this.delegate = delegate;    }    @Override    public void execute() {        delegate.execute();    }    ...}</code></pre><p>StandardDatabase和EncryptedDatabase这两个类内部都使用了<strong>代理模式</strong>给相同的接口添加了不同的具体实现，StandardDatabase自然是使用的Android包下的SQLiteDatabase，而EncryptedDatabaseStatement为了实现加密数据库的功能，则使用了一个叫做==sqlcipher==的数据库加密三方库，如果你项目下的数据库需要保存比较重要的数据，则可以使用getEncryptedWritableDb方法来代替getdWritableDb方法对数据库进行加密，这样，我们之后的数据库操作则会以代理模式的形式间接地使用sqlcipher提供的API去操作数据库。</p><h4 id="2、创建DaoMaster对象"><a href="#2、创建DaoMaster对象" class="headerlink" title="2、创建DaoMaster对象"></a>2、创建DaoMaster对象</h4><pre><code>SQLiteDatabase database = devOpenHelper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(database);</code></pre><p>首先，DaoMaster作为所有Dao对象的主人，它内部肯定是需要一个SQLiteDatabase对象的，因此，先由DaoMaster的帮助类对象devOpenHelper的getWritableDatabase方法得到一个标准的数据库类对象database，再由此创建一个DaoMaster对象。</p><pre><code>public class DaoMaster extends AbstractDaoMaster {    ...    public DaoMaster(SQLiteDatabase db) {        this(new StandardDatabase(db));    }    public DaoMaster(Database db) {        super(db, SCHEMA_VERSION);        registerDaoClass(HistoryDataDao.class);    }    ...}</code></pre><p>在DaoMaster的构造方法中，它首先执行了super(db, SCHEMA_VERSION)方法，即它的父类AbstractDaoMaster的构造方法。</p><pre><code>public abstract class AbstractDaoMaster {    ...    public AbstractDaoMaster(Database db, int schemaVersion) {        this.db = db;        this.schemaVersion = schemaVersion;        daoConfigMap = new HashMap&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt;();    }    protected void registerDaoClass(Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt; daoClass) {        DaoConfig daoConfig = new DaoConfig(db, daoClass);        daoConfigMap.put(daoClass, daoConfig);    }    ...}</code></pre><p>在AbstractDaoMaster对象的构造方法中，除了记录当前的数据库对象db和版本schemaVersion之外，还创建了一个类型为HashMap<class<? extends="" abstractdao<?,="" ?="">&gt;, DaoConfig&gt;()的daoConfigMap对象<strong>用于保存每一个DAO对应的数据配置对象DaoConfig</strong>，Daoconfig对象存储了对应的Dao对象所必需的数据。最后，在DaoMaster的构造方法中使用了registerDaoClass(HistoryDataDao.class)方法将HistoryDataDao类对象进行了注册，实际上，就是为HistoryDataDao这个Dao对象创建了相应的DaoConfig对象并将它放入daoConfigMap对象中保存起来。</class<?></p><h4 id="3、创建DaoSession对象"><a href="#3、创建DaoSession对象" class="headerlink" title="3、创建DaoSession对象"></a>3、创建DaoSession对象</h4><pre><code>mDaoSession = daoMaster.newSession();</code></pre><p>在DaoMaster对象中使用了newSession方法新建了一个DaoSession对象。</p><pre><code>public DaoSession newSession() {    return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);}</code></pre><p>在DaoSeesion的构造方法中，又做了哪些事情呢？</p><pre><code>public class DaoSession extends AbstractDaoSession {    ...    public DaoSession(Database db, IdentityScopeType type, Map&lt;Class&lt;?     extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt;            daoConfigMap) {        super(db);        historyDataDaoConfig = daoConfigMap.get(HistoryDataDao.class).clone();        historyDataDaoConfig.initIdentityScope(type);        historyDataDao = new HistoryDataDao(historyDataDaoConfig, this);        registerDao(HistoryData.class, historyDataDao);    }    ...}</code></pre><p>首先，调用了父类AbstractDaoSession的构造方法。</p><pre><code>public class AbstractDaoSession {    ...    public AbstractDaoSession(Database db) {        this.db = db;        this.entityToDao = new HashMap&lt;Class&lt;?&gt;, AbstractDao&lt;?, ?&gt;&gt;();    }    protected &lt;T&gt; void registerDao(Class&lt;T&gt; entityClass, AbstractDao&lt;T, ?&gt; dao) {        entityToDao.put(entityClass, dao);    }    ...}</code></pre><p>在AbstractDaoSession构造方法里面<strong>创建了一个实体与Dao对象的映射集合</strong>。接下来，在DaoSession的构造方法中还做了2件事：</p><ul><li>1、创建每一个Dao对应的DaoConfig对象，这里是historyDataDaoConfig，并且根据IdentityScopeType的类型初始化创建一个相应的IdentityScope，根据type的不同，它有两种类型，分别是==IdentityScopeObject==和==IdentityScopeLong==，它的作用是根据主键缓存对应的实体数据。当主键是数字类型的时候，如long/Long、int/Integer、short/Short、byte/Byte，则使用IdentityScopeLong缓存实体数据，当主键不是数字类型的时候，则使用IdentityScopeObject缓存实体数据。</li><li>2、根据DaoSession对象和每一个Dao对应的DaoConfig对象，创建与之对应的historyDataDao对象，由于这个项目只创建了一个实体类HistoryData，因此这里只有一个Dao对象historyDataDao，然后就是注册Dao对象，其实就是将实体和对应的Dao对象放入entityToDao这个映射集合中保存起来了。</li></ul><h4 id="4、插入源码分析"><a href="#4、插入源码分析" class="headerlink" title="4、插入源码分析"></a>4、插入源码分析</h4><pre><code>HistoryDataDao historyDataDao = daoSession.getHistoryDataDao();// 增historyDataDao.insert(historyData);</code></pre><p>这里首先在会话层DaoSession中获取了我们要操作的Dao对象HistoryDataDao，然后插入了一个我们预先创建好的historyData实体对象。其中HistoryDataDao继承了AbstractDao<historydata, long=""> 。</historydata,></p><pre><code>public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; {    ...}</code></pre><p>那么，这个AbstractDao是干什么的呢？</p><pre><code>public abstract class AbstractDao&lt;T, K&gt; {    ...    public List&lt;T&gt; loadAll() {        Cursor cursor = db.rawQuery(statements.getSelectAll(), null);        return loadAllAndCloseCursor(cursor);    }    ...    public long insert(T entity) {        return executeInsert(entity, statements.getInsertStatement(),     true);    }    ...    public void delete(T entity) {        assertSinglePk();        K key = getKeyVerified(entity);        deleteByKey(key);    }    ...}</code></pre><p>看到这里，根据程序员优秀的直觉，大家应该能猜到，AbstractDao是所有Dao对象的基类，它实现了实体数据的操作如增删改查。我们接着分析insert是如何实现的，在AbstractDao的insert方法中又调用了executeInsert这个方法。在这个方法中，第二个参里的statements是一个==TableStatements==对象，它是在AbstractDao初始化构造器时从DaoConfig对象中取出来的，是一个<strong>根据指定的表格创建SQL语句的一个帮助类</strong>。使用statements.getInsertStatement()则是获取了一个插入的语句。而第三个参数则是判断是否是主键的标志。</p><pre><code>public class TableStatements {    ...    public DatabaseStatement getInsertStatement() {        if (insertStatement == null) {            String sql = SqlUtils.createSqlInsert(&quot;INSERT INTO &quot;, tablename, allColumns);            DatabaseStatement newInsertStatement = db.compileStatement(sql);            ...        }        return insertStatement;    }    ...}</code></pre><p>在TableStatements的getInsertStatement方法中，主要做了两件事：</p><ul><li>1、使用SqlUtils创建了插入的sql语句。</li><li>2、根据不同的数据库类型（标准数据库或加密数据库）将sql语句编译成当前数据库对应的语句。</li></ul><p>我们继续往下分析executeInsert的执行流程。</p><pre><code>private long executeInsert(T entity, DatabaseStatement stmt, boolean setKeyAndAttach) {    long rowId;    if (db.isDbLockedByCurrentThread()) {        rowId = insertInsideTx(entity, stmt);    } else {        db.beginTransaction();        try {            rowId = insertInsideTx(entity, stmt);            db.setTransactionSuccessful();        } finally {            db.endTransaction();        }    }    if (setKeyAndAttach) {        updateKeyAfterInsertAndAttach(entity, rowId, true);    }    return rowId;}</code></pre><p>这里首先是判断数据库是否被当前线程锁定，如果是，则直接插入数据，否则为了避免死锁，则开启一个数据库事务，再进行插入数据的操作。最后如果设置了主键，则在插入数据之后更新主键的值并将对应的实体缓存到相应的identityScope中，这一块的代码流程如下所示：</p><pre><code>protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {    if (rowId != -1) {        K key = updateKeyAfterInsert(entity, rowId);        attachEntity(key, entity, lock);    } else {       ...    }}protected final void attachEntity(K key, T entity, boolean lock) {    attachEntity(entity);    if (identityScope != null &amp;&amp; key != null) {        if (lock) {            identityScope.put(key, entity);        } else {            identityScope.putNoLock(key, entity);        }    }}</code></pre><p>接着，我们还是继续追踪主线流程，在executeInsert这个方法中调用了insertInsideTx进行数据的插入。</p><pre><code>private long insertInsideTx(T entity, DatabaseStatement stmt) {    synchronized (stmt) {        if (isStandardSQLite) {            SQLiteStatement rawStmt = (SQLiteStatement) stmt.getRawStatement();            bindValues(rawStmt, entity);            return rawStmt.executeInsert();        } else {            bindValues(stmt, entity);            return stmt.executeInsert();        }    }}</code></pre><p>为了防止并发，这里使用了悲观锁保证了数据的一致性，在AbstractDao这个类中，大量使用了这种锁保证了它的线程安全性。接着，如果当前是标准数据库，则直接获取stmt这个DatabaseStatement类对应的原始语句进行实体字段属性的绑定和最后的执行插入操作。如果是加密数据库，则直接使用当前的加密数据库所属的插入语句进行实体字段属性的绑定和执行最后的插入操作。其中bindValues这个方法对应的实现类就是我们的HistoryDataDao类。</p><pre><code>public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; {    ...    @Override    protected final void bindValues(DatabaseStatement stmt, HistoryData     entity) {        stmt.clearBindings();        Long id = entity.getId();        if (id != null) {            stmt.bindLong(1, id);        }        stmt.bindLong(2, entity.getDate());        String data = entity.getData();        if (data != null) {            stmt.bindString(3, data);        }    }    @Override    protected final void bindValues(SQLiteStatement stmt, HistoryData     entity) {        stmt.clearBindings();        Long id = entity.getId();        if (id != null) {            stmt.bindLong(1, id);        }        stmt.bindLong(2, entity.getDate());        String data = entity.getData();        if (data != null) {            stmt.bindString(3, data);        }    }    ...}</code></pre><p>可以看到，这里对HistoryData的所有字段使用对应的数据库语句进行了绑定操作。这里最后再提及一下，如果当前数据库是加密型时，则会使用最开始提及的DatabaseStatement的加密实现类EncryptedDatabaseStatement应用代理模式去使用sqlcipher这个加密型数据库的insert方法。</p><h4 id="5、查询源码分析"><a href="#5、查询源码分析" class="headerlink" title="5、查询源码分析"></a>5、查询源码分析</h4><p>经过对插入源码的分析，我相信大家对GreenDao内部的机制已经有了一些自己的理解，由于删除和更新内部的流程比较简单，且与插入源码有异曲同工之妙，这里就不在赘述了。最后我们再分析下查询的源码，查询的流程调用链较长，所以将它的核心流程源码直接给出。</p><pre><code>List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll();public List&lt;T&gt; loadAll() {    Cursor cursor = db.rawQuery(statements.getSelectAll(), null);    return loadAllAndCloseCursor(cursor);}protected List&lt;T&gt; loadAllAndCloseCursor(Cursor cursor) {    try {        return loadAllFromCursor(cursor);    } finally {        cursor.close();    }}protected List&lt;T&gt; loadAllFromCursor(Cursor cursor) {    int count = cursor.getCount();    ...    boolean useFastCursor = false;    if (cursor instanceof CrossProcessCursor) {        window = ((CrossProcessCursor) cursor).getWindow();        if (window != null) {              if (window.getNumRows() == count) {                cursor = new FastCursor(window);                useFastCursor = true;            } else {              ...            }        }    }    if (cursor.moveToFirst()) {        ...        try {            if (!useFastCursor &amp;&amp; window != null &amp;&amp; identityScope != null) {                loadAllUnlockOnWindowBounds(cursor, window, list);            } else {                do {                    list.add(loadCurrent(cursor, 0, false));                } while (cursor.moveToNext());            }        } finally {            ...        }    }    return list;}</code></pre><p>最终，loadAll方法将会调用到loadAllFromCursor这个方法，首先，如果<strong>当前的游标cursor是跨进程的cursor</strong>，并且cursor的行数没有偏差的话，则使用一个加快版的==FastCursor==对象进行游标遍历。接着，不管是执行loadAllUnlockOnWindowBounds这个方法还是直接加载当前的数据列表list.add(loadCurrent(cursor, 0, false))，最后都会调用到这行list.add(loadCurrent(cursor, 0, false))代码，很明显，loadCurrent方法就是加载数据的方法。</p><pre><code>final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {    if (identityScopeLong != null) {        ...        T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);        if (entity != null) {            return entity;        } else {            entity = readEntity(cursor, offset);            attachEntity(entity);            if (lock) {                identityScopeLong.put2(key, entity);            } else {                identityScopeLong.put2NoLock(key, entity);            }            return entity;        }    } else if (identityScope != null) {        ...        T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key);        if (entity != null) {            return entity;        } else {            entity = readEntity(cursor, offset);            attachEntity(key, entity, lock);            return entity;        }    } else {        ...        T entity = readEntity(cursor, offset);        attachEntity(entity);        return entity;    }}</code></pre><p>我们来理解下loadCurrent这个方法内部的执行策略。<strong>首先，如果有实体数据缓存identityScopeLong/identityScope，则先从缓存中取，如果缓存中没有，会使用该实体对应的Dao对象，这里的是HistoryDataDao，它在内部根据游标取出的数据新建了一个新的HistoryData实体对象返回。</strong></p><pre><code>@Overridepublic HistoryData readEntity(Cursor cursor, int offset) {    HistoryData entity = new HistoryData( //        cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id        cursor.getLong(offset + 1), // date        cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2) // data    );    return entity;}</code></pre><p><strong>最后，如果是非identityScopeLong缓存类型，即是属于identityScope的情况下，则还会在identityScope中将上面获得的数据进行缓存。如果没有实体数据缓存的话，则直接调用readEntity组装数据返回即可。</strong></p><p>注意：对于GreenDao缓存的特性，可能会出现没有拿到最新数据的bug，因此，如果遇到这种情况，可以使用DaoSession的clear方法删除缓存。</p><h3 id="三、GreenDao是如何与ReactiveX结合？"><a href="#三、GreenDao是如何与ReactiveX结合？" class="headerlink" title="三、GreenDao是如何与ReactiveX结合？"></a>三、GreenDao是如何与ReactiveX结合？</h3><p>首先，看下与rx结合的使用流程：</p><pre><code>RxDao&lt;HistoryData, Long&gt; xxDao = daoSession.getHistoryDataDao().rx();xxDao.insert(historyData)        .observerOn(AndroidSchedulers.mainThread())        .subscribe(new Action1&lt;HistoryData&gt;() {            @Override            public void call(HistoryData entity) {                // insert success            }        });</code></pre><p>在AbstractDao对象的.rx()方法中，创建了一个默认执行在io线程的rxDao对象。</p><pre><code>@Experimentalpublic RxDao&lt;T, K&gt; rx() {    if (rxDao == null) {        rxDao = new RxDao&lt;&gt;(this, Schedulers.io());    }    return rxDao;}</code></pre><p>接着分析rxDao的insert方法。</p><pre><code>@Experimentalpublic Observable&lt;T&gt; insert(final T entity) {    return wrap(new Callable&lt;T&gt;() {        @Override        public T call() throws Exception {            dao.insert(entity);            return entity;        }    });}</code></pre><p>起实质作用的就是这个wrap方法了，在这个方法里面主要是调用了RxUtils.fromCallable(callable)这个方法。</p><pre><code>@Internalclass RxBase {    ...    protected &lt;R&gt; Observable&lt;R&gt; wrap(Callable&lt;R&gt; callable) {        return wrap(RxUtils.fromCallable(callable));    }    protected &lt;R&gt; Observable&lt;R&gt; wrap(Observable&lt;R&gt; observable) {        if (scheduler != null) {            return observable.subscribeOn(scheduler);        } else {            return observable;        }    }    ...}</code></pre><p>在RxUtils的fromCallable这个方法内部，其实就是<strong>使用defer这个延迟操作符来进行被观察者事件的发送，主要目的就是为了确保Observable被订阅后才执行</strong>。最后，如果调度器scheduler存在的话，将通过外部的wrap方法将执行环境调度到io线程。</p><pre><code>@Internalclass RxUtils {    @Internal    static &lt;T&gt; Observable&lt;T&gt; fromCallable(final Callable&lt;T&gt; callable) {        return Observable.defer(new Func0&lt;Observable&lt;T&gt;&gt;() {            @Override            public Observable&lt;T&gt; call() {                T result;                try {                    result = callable.call();                } catch (Exception e) {                    return Observable.error(e);                }                return Observable.just(result);            }        });    }}</code></pre><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>在分析完GreenDao的大致源码之后，我发现，GreenDao作为最好的数据库框架之一，是有一定道理的。首先，它通过使用自身的插件配套相应的freemarker模板生成所需的静态代码，避免了反射等消耗性能的操作。其次，它内部提供了实体数据的映射缓存机制，能够进一步加快查询速度。对于不同数据库对应的SQL语句，也使用了不同的DataBaseStatement实现类结合代理模式进行了封装，屏蔽了数据库操作等繁琐的细节。最后，它使用了sqlcipher提供了加密数据库的功能，在一定程度确保了安全性，同时，结合RxJava，我们便能更简洁地实现异步的数据库操作。GreenDao源码分析到这里就真的完结了，下一篇，笔者将会对RxJava的核心源码进行细致地讲解，以此能让大家对RxJava有一个更为深入的理解。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、GreenDao V3.2.2源码</p><p>2、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492577&amp;idx=1&amp;sn=b35b0ef0f3769efa8c5d49fc5d60dd80&amp;chksm=8eec879eb99b0e8881dd83cac912192df742ad547ccd274b7fccd2995edd08b095e1fd556cfe&amp;scene=38#wechat_redirect" target="_blank" rel="external">GreenDao源码分析</a></p><p>3、<a href="http://www.voidcn.com/article/p-ksrtulcy-brp.html" target="_blank" rel="external">GreenDao源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
