<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Mon, 13 Jan 2020 15:00:04 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>深入探索Android布局优化（下）</title>
      <link>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/</link>
      <guid>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/</guid>
      <pubDate>Mon, 13 Jan 2020 14:59:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>本篇，为深入探索Android布局优化的下篇。这篇文章包含的主要内容如下所示：</p><ul><li>6、布局优化常规方案</li><li>7、布局优化的进阶方案</li><li>8、布局优化的常见问题</li></ul><p>下面，笔者将与大家一起进入进行布局优化的实操环节。</p><h3 id="六、布局优化常规方案"><a href="#六、布局优化常规方案" class="headerlink" title="六、布局优化常规方案"></a>六、布局优化常规方案</h3><p>布局优化的方法有很多，大部分主流的方案笔者已经在<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>里讲解过了。下面，我将介绍一些其它的优化方案。</p><h4 id="1、布局Inflate优化方案演进"><a href="#1、布局Inflate优化方案演进" class="headerlink" title="1、布局Inflate优化方案演进"></a>1、布局Inflate优化方案演进</h4><h5 id="1、代码动态创建View"><a href="#1、代码动态创建View" class="headerlink" title="1、代码动态创建View"></a>1、代码动态创建View</h5><p>使用Java代码动态添加控件的简单示例如下：</p><pre><code>Button button=new Button(this);        button.setBackgroundColor(Color.RED);button.setText(&quot;Hello World&quot;);ViewGroup viewGroup = (ViewGroup) LayoutInflater.from(this).inflate(R.layout.activity_main, null);viewGroup.addView(button);</code></pre><h5 id="2、替换MessageQueue来实现异步创建View"><a href="#2、替换MessageQueue来实现异步创建View" class="headerlink" title="2、替换MessageQueue来实现异步创建View"></a>2、替换MessageQueue来实现异步创建View</h5><p>在使用子线程创建视图控件的时候，我们可以把子线程Looper的MessageQueue替换成主线程的MessageQueue，在创建完需要的视图控件后记得将子线程Looper中的MessageQueue恢复为原来的。在<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>项目下的UiUtils的Ui优化工具类中，提供了相应的实现，代码如下所示：</p><pre><code> /** * 实现将子线程Looper中的MessageQueue替换为主线程中Looper的 * MessageQueue，这样就能够在子线程中异步创建UI。 * * 注意：需要在子线程中调用。 * * @param reset 是否将子线程中的MessageQueue重置为原来的，false则表示需要进行替换 * @return 替换是否成功 */public static boolean replaceLooperWithMainThreadQueue(boolean reset) {    if (CommonUtils.isMainThread()) {        return true;    } else {        // 1、获取子线程的ThreadLocal实例        ThreadLocal&lt;Looper&gt; threadLocal = ReflectUtils.reflect(Looper.class).field(&quot;sThreadLocal&quot;).get();        if (threadLocal == null) {            return false;        } else {            Looper looper = null;            if (!reset) {                Looper.prepare();                looper = Looper.myLooper();                // 2、通过调用MainLooper的getQueue方法区获取主线程Looper中的MessageQueue实例                Object queue = ReflectUtils.reflect(Looper.getMainLooper()).method(&quot;getQueue&quot;).get();                if (!(queue instanceof MessageQueue)) {                    return false;                }                // 3、将子线程中的MessageQueue字段的值设置为主线的MessageQueue实例                ReflectUtils.reflect(looper).field(&quot;mQueue&quot;, queue);            }            // 4、reset为false，表示需要将子线程Looper中的MessageQueue重置为原来的。            ReflectUtils.reflect(threadLocal).method(&quot;set&quot;, looper);            return true;        }    }}</code></pre><h5 id="3、AsynclayoutInflater异步创建View"><a href="#3、AsynclayoutInflater异步创建View" class="headerlink" title="3、AsynclayoutInflater异步创建View"></a>3、AsynclayoutInflater异步创建View</h5><p>在第三小节中，我们对Android的布局加载原理进行了深入地分析，从中我们得出了布局加载过程中的两个耗时点：</p><ul><li>1、布局文件读取慢：IO过程。</li><li>2、创建View慢：使用反射，比直接new的方式要慢3倍。布局嵌套层级越多，控件个数越多，反射的次数就会越频繁。</li></ul><p>很明显，我们无法从根本上去解决这两个问题，但是Google提供了一个从侧面解决的方案:使用AsyncLayoutInflater去异步加载对应的布局，它的特点如下：</p><ul><li>1、工作线程加载布局。</li><li>2、回调主线程。</li><li>3、节省主线程时间。</li></ul><p>接下来，我将详细地介绍AsynclayoutInflater的使用。</p><p>首先，在项目的build.gradle中进行配置：</p><pre><code>implementation &apos;com.android.support:asynclayoutinflater:28.0.0&apos;</code></pre><p>然后，在Activity中的onCreate方法中将setContentView注释：</p><pre><code>super.onCreate(savedInstanceState);// 内部分别使用了IO和反射的方式去加载布局解析器和创建对应的View// setContentView(R.layout.activity_main);</code></pre><p>接着，在super.onCreate方法前继续布局的异步加载：</p><pre><code>// 使用AsyncLayoutInflater进行布局的加载new AsyncLayoutInflater(MainActivity.this).inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() {        @Override        public void onInflateFinished(@NonNull View view, int i, @Nullable ViewGroup viewGroup) {            setContentView(view);            // findViewById、视图操作等    }});super.onCreate(savedInstanceState);</code></pre><p>接下来，我们来分析下AsyncLayoutInflater的实现原理与工作流程。</p><p>由于我们是使用new的方式创建的AsyncLayoutInflater，所以我们先来看看它的构造函数：</p><pre><code> public AsyncLayoutInflater(@NonNull Context context) {    // 1    this.mInflater = new AsyncLayoutInflater.BasicInflater(context);    // 2    this.mHandler = new Handler(this.mHandlerCallback);    // 3    this.mInflateThread = AsyncLayoutInflater.InflateThread.getInstance();}</code></pre><p>在注释1处，创建了一个BasicInflater，它内部的onCreateView并没有使用Factory做AppCompat控件兼容的处理：</p><pre><code>protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {    String[] var3 = sClassPrefixList;    int var4 = var3.length;    for(int var5 = 0; var5 &lt; var4; ++var5) {        String prefix = var3[var5];        try {            View view = this.createView(name, prefix, attrs);            if (view != null) {                return view;            }        } catch (ClassNotFoundException var8) {        }    }    return super.onCreateView(name, attrs);}</code></pre><p>由前面的分析可知，在createView方法中仅仅是做了反射创建出对应View的处理。</p><p>接着，在注释2处，创建了一个全局的Handler对象，主要是用于将异步线程创建好的View实例及其相关信息回调到主线程。</p><p>最后，在注释3处，获取了一个用于异步加载View的线程实例。</p><p>接着，我们继续跟踪AsyncLayoutInflater实例的inflate方法：</p><pre><code>@UiThreadpublic void inflate(@LayoutRes int resid, @Nullable ViewGroup parent, @NonNull AsyncLayoutInflater.OnInflateFinishedListener callback) {    if (callback == null) {        throw new NullPointerException(&quot;callback argument may not be null!&quot;);    } else {        // 1        AsyncLayoutInflater.InflateRequest request = this.mInflateThread.obtainRequest();        request.inflater = this;        request.resid = resid;        request.parent = parent;        request.callback = callback;        this.mInflateThread.enqueue(request);    }}</code></pre><p>在注释1处，这里使用InflateRequest对象将我们传进来的三个参数进行了包装，并最终将这个InflateRequest对象加入了mInflateThread线程中的一个ArrayBlockingQueue中：</p><pre><code>public void enqueue(AsyncLayoutInflater.InflateRequest request) {    try {        this.mQueue.put(request);      } catch (InterruptedException var3) {        throw new RuntimeException(&quot;Failed to enqueue async inflate request&quot;, var3);    }}</code></pre><p>并且，在InflateThread这个静态内部类的静态代码块中调用了其自身实例的start方法以启动线程：</p><pre><code>static {    sInstance.start();}public void run() {    while(true) {        this.runInner();    }}public void runInner() {    AsyncLayoutInflater.InflateRequest request;    try {        // 1        request = (AsyncLayoutInflater.InflateRequest)this.mQueue.take();    } catch (InterruptedException var4) {        Log.w(&quot;AsyncLayoutInflater&quot;, var4);        return;    }    try {        // 2        request.view = request.inflater.mInflater.inflate(request.resid, request.parent, false);    } catch (RuntimeException var3) {        Log.w(&quot;AsyncLayoutInflater&quot;, &quot;Failed to inflate resource in the background! Retrying on the UI thread&quot;, var3);    }    // 3    Message.obtain(request.inflater.mHandler, 0, request).sendToTarget();}</code></pre><p>在run方法中，使用了死循环的方式去不断地调用runInner方法，在runInner方法中，首先在注释1处从ArrayBlockingQueue队列中获取一个InflateRequest对象，然后在注释2处将异步加载好的view对象赋值给了InflateRequest对象，最后，在注释3处，将请求作为消息发送给了Handler的handleMessage：</p><pre><code>private Callback mHandlerCallback = new Callback() {    public boolean handleMessage(Message msg) {        AsyncLayoutInflater.InflateRequest request = (AsyncLayoutInflater.InflateRequest)msg.obj;        // 1        if (request.view == null) {            request.view = AsyncLayoutInflater.this.mInflater.inflate(request.resid, request.parent, false);        }        request.callback.onInflateFinished(request.view, request.resid, request.parent);        AsyncLayoutInflater.this.mInflateThread.releaseRequest(request);        return true;    }};</code></pre><p>在handleMessage方法中，当异步加载得到的view为null时，此时在注释1处还做了一个fallback处理，直接在主线程进行view的加载，以此兼容某些异常情况，最后，就调用了回调接口的onInflateFinished方法将view的相关信息返回给Activity对象。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由以上分析可知，AsyncLayoutInflater是通过侧面缓解的方式去缓解布局加载过程中的卡顿，但是它依然存在一些问题：</p><ul><li>1、不能设置LayoutInflater.Factory，通过自定义AsyncLayoutInflater的方式解决，由于它是一个final，所以需要将代码直接拷处进行修改。</li><li>2、因为是异步加载，所以需要注意在布局加载过程中不能有依赖于主线程的操作。</li></ul><p>由于AsyncLayoutInflater仅仅只能通过侧面缓解的方式去缓解布局加载的卡顿，因此，我们下面将介绍一种从根本上解决问题的方案。对于AsynclayoutInflater的改进措施，可以查看祁同伟同学封装之后的代码：</p><p><a href="https://www.jianshu.com/p/f0c0eda06ae4" target="_blank" rel="external">Android AsyncLayoutInflater 限制及改进</a></p><h5 id="4、使用X2C进行布局加载优化"><a href="#4、使用X2C进行布局加载优化" class="headerlink" title="4、使用X2C进行布局加载优化"></a>4、使用X2C进行布局加载优化</h5><p>由上分析可知，在布局加载的过程中有两个主要的耗时点，即IO操作和反射，而AsyncLayoutInflater仅仅是缓解，那么有什么方案能从根本上去解决这个问题呢？</p><h4 id="使用Java代码写布局？"><a href="#使用Java代码写布局？" class="headerlink" title="使用Java代码写布局？"></a>使用Java代码写布局？</h4><p>如果使用Java代码写布局，无疑从Xml文件进行IO操作的过程和反射获取View实例的过程都将被抹去。虽然这样从本质上解决了问题，但是也引入了一些新问题，如不便于开发，可维护性差等等。</p><p>那么，还有没有别的更好的方式呢？</p><p>答案就是X2C。</p><h4 id="X2C"><a href="#X2C" class="headerlink" title="X2C"></a>X2C</h4><p><a href="https://github.com/iReaderAndroid/X2C/blob/master/README_CN.md" target="_blank" rel="external">X2C项目地址</a></p><p>X2C框架保留了XML的优点，并解决了其IO操作和反射的性能问题。开发人员只需要正常写XML代码即可，在编译期，X2C会利用APT工具将XML代码翻译为Java代码。</p><p>接下来，我们来进行X2C的使用。</p><p>首先，在app的build.gradle文件添加如下依赖：</p><pre><code>annotationProcessor &apos;com.zhangyue.we:x2c-apt:1.1.2&apos;implementation &apos;com.zhangyue.we:x2c-lib:1.0.6&apos;</code></pre><p>然后，在对应的MainActivity类上方添加如下注解，让MainActivity知道我们使用的布局是activity_main：</p><pre><code>@Xml(layouts = &quot;activity_main&quot;)public class MainActivity extends AppCompatActivity implements OnFeedShowCallBack {</code></pre><p>接着，将onCreate方法中setContentView的原始方式改为X2C的设置方式：</p><pre><code>X2C.setContentView(MainActivity.this, R.layout.activity_main);</code></pre><p>最后，我们再Rebuild项目，会在build下的generated-&gt;source-&gt;apt-&gt;debug-&gt;com.zhangyue.we.x2c下自动生成X2C127_activity_main这个类：</p><pre><code>public class X2C127_activity_main implements IViewCreator {@Overridepublic View createView(Context context) {    return new com.zhangyue.we.x2c.layouts.X2C127_Activity_Main().createView(context);    }}</code></pre><p>在这个类中又继续调用了layout目录下的X2C127_Activity_Main实例的createView方法，如下所示：</p><pre><code>public class X2C127_Activity_Main implements IViewCreator {    @Override    public View createView(Context ctx) {        Resources res = ctx.getResources();        ConstraintLayout constraintLayout0 = new ConstraintLayout(ctx);        RecyclerView recyclerView1 = new RecyclerView(ctx);        ConstraintLayout.LayoutParams layoutParam1 = new ConstraintLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);        recyclerView1.setId(R.id.recycler_view);        recyclerView1.setLayoutParams(layoutParam1);        constraintLayout0.addView(recyclerView1);        return constraintLayout0;    }}</code></pre><p>从上可知，里面采用了new的方式创建了相应的控件，并设置了对应的信息。</p><p>接下来，我们回到X2C.setContentView(MainActivity.this, R.layout.activity_main)这个方法，看看它内部究竟做了什么处理：</p><pre><code>/** * 设置contentview，检测如果有对应的java文件，使用java文件，否则使用xml * * @param activity 上下文 * @param layoutId layout的资源id */public static void setContentView(Activity activity, int layoutId) {    if (activity == null) {        throw new IllegalArgumentException(&quot;Activity must not be null&quot;);    }    // 1    View view = getView(activity, layoutId);    if (view != null) {        activity.setContentView(view);    } else {        activity.setContentView(layoutId);    }}</code></pre><p>在注释1处，通过getView方法获取到了对应的view，我们继续跟踪进去：</p><pre><code>public static View getView(Context context, int layoutId) {    IViewCreator creator = sSparseArray.get(layoutId);    if (creator == null) {        try {            int group = generateGroupId(layoutId);            String layoutName = context.getResources().getResourceName(layoutId);            layoutName = layoutName.substring(layoutName.lastIndexOf(&quot;/&quot;) + 1);            String clzName = &quot;com.zhangyue.we.x2c.X2C&quot; + group + &quot;_&quot; + layoutName;            // 1            creator = (IViewCreator) context.getClassLoader().loadClass(clzName).newInstance();        } catch (Exception e) {            e.printStackTrace();        }        //如果creator为空，放一个默认进去，防止每次都调用反射方法耗时        if (creator == null) {            creator = new DefaultCreator();        }        sSparseArray.put(layoutId, creator);    }    // 2    return creator.createView(context);}</code></pre><p>可以看到，这里采用了一个sSparseArray集合去存储布局对应的视图创建对象creator，如果是首次创建creator的话，会在注释1处使用反射的方式去加载处对应的creator对象，然后将它放入sSparseArray集中，最后在注释2处调用了creator的createView方法去使用new的方式去创建对应的控件。</p><p>但是，X2C框架还存在一些问题：</p><ul><li>1、部分Java属性不支持。</li><li>2、失去了系统的兼容（AppCompat）</li></ul><p>对于第2个问题，我们需要修改X2C框架的源码，当发现是TextView等控件时，需要直接使用new的方式去创建一个AppCompatTextView等兼容类型的控件。于此同时，它还有如下两个小的点不支持，但是这个问题不大：</p><ul><li>merge标签 ,在编译期间无法确定xml的parent，所以无法支持。</li><li>系统style,在编译期间只能查到应用的style列表，无法查询系统style，所以只支持应用内style。</li></ul><h4 id="2、使用ConstraintLayout降低布局嵌套层级"><a href="#2、使用ConstraintLayout降低布局嵌套层级" class="headerlink" title="2、使用ConstraintLayout降低布局嵌套层级"></a>2、使用ConstraintLayout降低布局嵌套层级</h4><p>首先，对于Android视图绘制的原理，我们必须要有一定的了解，关于这块，大家可以参考下<a href="https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Android View的绘制流程</a>这篇文章。</p><p>对于视图绘制的性能瓶颈，大概有以下三点：</p><ul><li>1、测量、布局、绘制每个阶段的耗时。</li><li>2、自顶而下的遍历，当嵌套层级过多时，遍历耗时会比较明显。</li><li>3、无效的嵌套布局或不合理使用RelativeLayout可能会导致触发多次绘制。</li></ul><p>那么，如何减少布局的层级及复杂度呢？</p><p>基本上只要遵循以下两点即可：</p><ul><li>1、减少View树层级。</li><li>2、宽而浅，避免窄而深。</li></ul><p>为了提升布局的绘制速度，Google推出了ConstraintLayout，它的特点如下：</p><ul><li>1、实现几乎完全扁平化的布局。</li><li>2、构建复杂布局性能更高。</li><li>3、具有RelativeLayout和LinearLayout的特性。</li></ul><p>接下来，我们来简单使用一下ConstraintLayout来优化一下我们的布局。</p><p>首先，下面是我们的原始布局:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/ll_out&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;    android:padding=&quot;5dp&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;com.facebook.drawee.view.SimpleDraweeView            android:id=&quot;@+id/iv_news&quot;            android:layout_width=&quot;80dp&quot;            android:layout_height=&quot;80dp&quot;            android:scaleType=&quot;fitXY&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/tv_title&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:padding=&quot;10dp&quot;            android:textSize=&quot;20dp&quot; /&gt;    &lt;/LinearLayout&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;right&quot;        android:padding=&quot;3dp&quot;        android:text=&quot;来自NBA官网&quot;        android:textSize=&quot;14dp&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>可以看到,它具有三层嵌套结构,然后我们来使用ConstraintLayout来优化一下这个布局：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:id=&quot;@+id/ll_out&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;    android:padding=&quot;5dp&quot;&gt;    &lt;com.facebook.drawee.view.SimpleDraweeView        android:id=&quot;@+id/iv_news&quot;        android:layout_width=&quot;80dp&quot;        android:layout_height=&quot;80dp&quot;        android:scaleType=&quot;fitXY&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv_title&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:paddingLeft=&quot;10dp&quot;        android:textSize=&quot;20dp&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/iv_news&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;@id/iv_news&quot; /&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:padding=&quot;3dp&quot;        android:text=&quot;来自NBA官网&quot;        android:textSize=&quot;14dp&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/iv_news&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>经过ConstraintLayout之后，布局的嵌套层级变为了2级，如果布局比较复杂，比如有5，6，7层嵌套层级，使用Contraintlayout之后降低的层级会更加明显。对于其app下的一系列属性，其实都非常简单，这里就不多做介绍了。</p><p>除此之外，还有以下方式可以减少布局层级和复杂度：</p><ul><li>1、不嵌套使用RelativeLayout。</li><li>2、不在嵌套LinearLayout中使用weight。</li><li>3、使用merge标签，它能够减少一个层级，但只能用于根View。</li></ul><h4 id="3、过渡绘制优化"><a href="#3、过渡绘制优化" class="headerlink" title="3、过渡绘制优化"></a>3、过渡绘制优化</h4><p>在视图的绘制优化中，还有一个比较重要的优化点，就是避免过渡绘制，这个笔者已经在<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>一文的第四小节详细分析过了。最后这里补充一下自定义View中使用clipRect的一个实例。</p><p>首先，我们自定义了一个DroidCardsView，他可以存放多个叠加的卡片，onDraw方法的实现如下：</p><pre><code> protected void onDraw(Canvas canvas) {    super.onDraw(canvas);    // Don&apos;t draw anything until all the Asynctasks are done and all the DroidCards are ready.    if (mDroids.length &gt; 0 &amp;&amp; mDroidCards.size() == mDroids.length) {        // Loop over all the droids, except the last one.        int i;        for (i = 0; i &lt; mDroidCards.size() - 1; i++) {            mCardLeft = i * mCardSpacing;            // Draw the card. Only the parts of the card that lie within the bounds defined by            // the clipRect() get drawn.            drawDroidCard(canvas, mDroidCards.get(i), mCardLeft, 0);        }        // Draw the final card. This one doesn&apos;t get clipped.        drawDroidCard(canvas, mDroidCards.get(mDroidCards.size() - 1),                mCardLeft + mCardSpacing, 0);    }    // Invalidate the whole view. Doing this calls onDraw() if the view is visible.    invalidate();}</code></pre><p>从以上代码可知，这里是直接进行绘制的，此时显示的布局过渡绘制背景如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/pre_overdraw.jpeg" alt="image"></p><p>可以看到，图片的背景都叠加起来了，这个时候，我们需要在绘制的时候使用clipRect让系统去识别可绘制的区域，因此我们在自定义的DroidCardsView的onDraw方法去使用clipRect：</p><pre><code>protected void onDraw(Canvas canvas) {    super.onDraw(canvas);    // Don&apos;t draw anything until all the Asynctasks are done and all the DroidCards are ready.    if (mDroids.length &gt; 0 &amp;&amp; mDroidCards.size() == mDroids.length) {        // Loop over all the droids, except the last one.        int i;        for (i = 0; i &lt; mDroidCards.size() - 1; i++) {            mCardLeft = i * mCardSpacing;            // 1、clipRect方法和绘制前后成对使用canvas的save方法与restore方法。            canvas.save();            // 2、使用clipRect指定绘制区域，这里的mCardSpacing是指的相邻卡片最左边的间距，需要在动态创建DroidCardsView的时候传入。            canvas.clipRect(mCardLeft,0,mCardLeft+mCardSpacing,mDroidCards.get(i).getHeight());            // 3、Draw the card. Only the parts of the card that lie within the bounds defined by            // the clipRect() get drawn.            drawDroidCard(canvas, mDroidCards.get(i), mCardLeft, 0);            canvas.restore();        }        // Draw the final card. This one doesn&apos;t get clipped.        drawDroidCard(canvas, mDroidCards.get(mDroidCards.size() - 1),                mCardLeft + mCardSpacing, 0);    }    // Invalidate the whole view. Doing this calls onDraw() if the view is visible.    invalidate();}</code></pre><p>在注释1处，首先需要在clipRect方法和绘制前后成对使用canvas的save方法与restore方法用来对画布进行操作。接着，在注释2处，使用clipRect指定绘制区域，这里的mCardSpacing是指的相邻卡片最左边的间距，需要在动态创建DroidCardsView的时候传入。最后，在注释3处调用实际绘制卡片的方法。</p><p>使用clipRect优化过后的布局过渡绘制背景如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/after_overdraw.jpeg" alt="image"></p><p><strong>注意：</strong></p><p>我们还可以通过canvas.quickReject方法来判断是否没和某个矩形相交，以跳过非矩形区域的绘制操作。</p><p>当然，对视图的绘制优化还有其它的一些优化操作，比如：</p><ul><li>1、使用ViewStub、Merge，ViewStub是一种高效占位符，用于延迟初始化。</li><li>2、onDraw中避免创建大对象，进行耗时操作。</li><li>3、TextView的优化，比如利用它的drawableLeft属性。此外，也可以使用Android 9.0之后的 PrecomputedText，它将文件的measure与layout过程进行了异步化。但是需要注意，如果要显示的文本比较少，反而会造成不必要的Scheduling delay，建议文本字符大于200时才使用，并记得使用其兼容类PrecomputedTextCompat，它在9.0以上使用PrecomputedText进行优化，在5.0~9.0使用StaticLayout进行优化。具体调用代码如下所示：</li></ul><pre><code>Future&lt;PrecomputedTextCompat&gt; future = PrecomputedTextCompat.getTextFuture(                “text”, textView.getTextMetricsParamsCompat(), null)；textView.setTextFuture(future);</code></pre><p>到这里，笔者就将常规的布局优化讲解完了，是不是顿时感觉实力大增呢？</p><div align="center"><br><img src="http://image.diydoutu.com/12140371143798.png?imageView2/0/format/jpg/q/75" width="30%"><br></div><p>如果你此时内心已经YY到这种程度，那我只能说：</p><div align="center"><br><img src="http://image.diydoutu.com/12140564648444.gif?imageView2/0/format/gif/q/75" width="30%"><br></div><p>下面，笔者就来和大家一起来探索布局优化的进阶方案。</p><h3 id="七、布局优化的进阶方案"><a href="#七、布局优化的进阶方案" class="headerlink" title="七、布局优化的进阶方案"></a>七、布局优化的进阶方案</h3><h4 id="1、使用异步布局框架Litho"><a href="#1、使用异步布局框架Litho" class="headerlink" title="1、使用异步布局框架Litho"></a>1、使用异步布局框架Litho</h4><p>Litho是Facebook开源的一款在Android上高效建立UI的声明式框架，它具有以下特点：</p><ul><li>声明式：它使用了声明式的API来定义UI组件。</li><li>异步布局：它可以提前布局UI，而不会阻塞UI线程。</li><li>视图扁平化：它使用了Facebook开源的另一款布局引擎Yoga进行布局，以自动减少UI包含的ViewGroup数量。</li><li>细粒度的回收：可以回收文本或图形等任何组件，并可以在用户界面的任何位置重复使用。</li><li>内部不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。Litho实现了大量使用Drawable来渲染的基础组件，可以进一步使布局扁平化。</li></ul><h5 id="简单使用Litho"><a href="#简单使用Litho" class="headerlink" title="简单使用Litho"></a>简单使用Litho</h5><p>接下来，我们在项目里面来使用Litho。</p><p>1、首先，我们需要配置Litho的相关依赖，如下所示：</p><pre><code>// 项目下repositories {    jcenter()}// module下dependencies {    // ...    // Litho    implementation &apos;com.facebook.litho:litho-core:0.33.0&apos;    implementation &apos;com.facebook.litho:litho-widget:0.33.0&apos;    annotationProcessor &apos;com.facebook.litho:litho-processor:0.33.0&apos;    // SoLoader    implementation &apos;com.facebook.soloader:soloader:0.5.1&apos;    // For integration with Fresco    implementation &apos;com.facebook.litho:litho-fresco:0.33.0&apos;    // For testing    testImplementation &apos;com.facebook.litho:litho-testing:0.33.0&apos;    // Sections （options，用来声明去构建一个list）    implementation &apos;com.facebook.litho:litho-sections-core:0.33.0&apos;    implementation &apos;com.facebook.litho:litho-sections-widget:0.33.0&apos;    compileOnly &apos;com.facebook.litho:litho-sections-annotations:0.33.0&apos;    annotationProcessor &apos;com.facebook.litho:litho-sections-processor:0.33.0&apos;}</code></pre><p>2、然后，在Application下的onCreate方法中初始化SoLoader：</p><pre><code>@Overridepublic void onCreate() {    super.onCreate();    SoLoader.init(this, false);}</code></pre><p>从之前的介绍可知，我们知道Litho使用了Yoga进行布局，而Yoga包含有native依赖，在Soloader.init方法中对这些native依赖进行了加载。</p><p>3、最后，在Activity的onCreate方法中添加如下代码即可显示单个的文本视图：</p><pre><code> // 1、将Activity的Context对象保存到ComponentContext中，并同时初始化// 一个资源解析者实例ResourceResolver供其余组件使用。ComponentContext componentContext = new ComponentContext(this);// 2、Text内部使用建造者模式以实现组件属性的链式调用，下面设置的text、// TextColor等属性在Litho中被称为Prop，此概念引申字React。Text lithoText = Text.create(componentContext)        .text(&quot;Litho text&quot;)        .textSizeDip(64)        .textColor(ContextCompat.getColor(this, R.color.light_deep_red))            .build();// 3、设置一个LithoView去展示Text组件：LithoView.create内部新建了一个// LithoView实例，并用给定的Component（lithoText）进行初始化setContentView(LithoView.create(componentContext, lithoText));</code></pre><p>显示效果如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_text.png" alt="image"></p><p>在上面的示例中，我们仅仅是将Text这个子组件设置给了LithoView，后续为了实现更复杂的布局，我们需要使用带多个子组件的根组件去替换它。</p><h5 id="使用自定义Component"><a href="#使用自定义Component" class="headerlink" title="使用自定义Component"></a>使用自定义Component</h5><p>由上可知，在Litho中的视图单元叫做Component，即组件，它的设计理念来源于React组件化的思想。每个组件持有描述一个视图单元所必须的属性与状态，用于视图布局的计算工作。视图最终的绘制工作是由组件指定的绘制单元（View或Drawable）来完成的。接下来，我们使用Litho提供的自定义Component的功能，它能够让我们实现更复杂的Component，这里我们来实现一个类似ListView的列表。</p><p>首先，我们先来实现一个ListItem Component，它就如ListView的itemView一样。在下面的实战中，我们将会学习到所有的基础知识，这将会支撑你后续能实现更多更复杂的Component。</p><p>然后，在Litho中，我们需要先写一个Spec类去声明Component所对应的布局，在这里需要使用@LayoutSpec规范注解(除此之外，Litho还提供了另一种类型的组件规范：Mount Spec)。代码如下所示：</p><pre><code>@LayoutSpecpublic class ListItemSpec {    @OnCreateLayout    static Component onCreateLayout(ComponentContext context) {        // Column的作用类似于HTML中的&lt;div&gt;标签        return Column.create(context)                .paddingDip(YogaEdge.ALL, 16)                .backgroundColor(Color.WHITE)                .child(Text.create(context)                            .text(&quot;Litho Study&quot;)                            .textSizeSp(36)                         .textColor(Color.BLUE)                            .build())                .child(Text.create(context)                            .text(&quot;JsonChao&quot;)                            .textSizeSp(24)                         .textColor(Color.MAGENTA)                            .build())                .build();    }}</code></pre><p>然后，框架会使用APT技术去帮助生成对应的ListItem Component 类。最后，我们在Activity的onCreate中将上述第一个例子中的第二步改为如下：</p><pre><code> // 2、构建ListItem组件ListItem listItem = ListItem.create(componentContext).build();</code></pre><p>运行项目，显示界面如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_listitem.png" alt="image"></p><p><strong>那上述过程是如何创建与构建的呢？</strong></p><p>它看起来就像有一个LithoSpec的类名，并且在项目构建之后生成了一个与LithoSpec有着同样包名的Litho类，如下所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/litho_build_listitem.png?raw=true" alt="image"></p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/app_listitemspec.png?raw=true" alt="image"></p><p>类似于Litho这种类中的所有方法参数都会由Litho进行自动填充。此外，基于这些规格，将会有一些额外的方法由注解处理器自动生成，例如上述示例中Column或Row中的Text的TextSizeSp、backgroundColor等方法。(Row和Column分别对应着Flexox中的行和列，它们都实现了Litho中另一种特殊的组件Layout)</p><h5 id="补充：MountSpec规范"><a href="#补充：MountSpec规范" class="headerlink" title="补充：MountSpec规范"></a>补充：MountSpec规范</h5><p>MountSpec是用来生成可挂载类型组件的一种规范，它的作用是用来生成渲染具体的View或者Drawable的组件。同LayoutSpec类似，它必须使用@MountSpec注解来标注，并实现一个标注了@onCreateMountContent的方法。但是MountSpec的实现要比Layout更加地复杂，因为它拥有自己的生命周期，如下所示：</p><ul><li>@OnPrepare：准备阶段，用于进行一些初始化操作。</li><li>@OnMeasure：负责布局的计算工作。</li><li>@OnBoundsDefined：在布局计算完成之后、挂载视图之前做一些操作。</li><li>@OnCreateMountContent：如果没有可以复用的视图单元，则调用它去创建需要挂载的视图。</li><li>@OnMount：挂载视图，用于完成布局相关的设置。</li><li>@OnBind：绑定视图，用于完成数据和视图的绑定。</li><li>@OnUnBind：解绑视图，与@OnBind相对，主要用于重置视图的数据属性，避免出现数据复用的问题。</li><li>@OnUnmount：卸载视图，与@OnMount相对，主要用于重置视图的布局相关的属性，避免出现布局复用的问题。</li></ul><p>MountSpec的生命周期流转图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_mount_spec_lifecycle.png" alt="image"></p><p>在使用Litho完成了两个实例的开发之后，相信我们已经对Litho的布局方式已经有了一个感性的认知。那么，Litho到底是如何进行布局优化的呢？在布局优化中它所做的核心工作有哪些？</p><p>Litho在布局优化中所做的核心工作包括以下三点：</p><ul><li>1、异步布局化。</li><li>2、布局自动扁平化。</li><li>3、更细粒度地优化RecyclerView中组件的缓存与回收的方法。</li></ul><h5 id="1、异步布局化"><a href="#1、异步布局化" class="headerlink" title="1、异步布局化"></a>1、异步布局化</h5><p>在前文中，我们知道Android的布局加载过程通常会先后涉及到measure、layout、draw过程，并且它们都是在主线程执行的，如果方法执行过程中耗时太多，则主界面必然会产生卡顿现象。</p><p>还记得我们在前面介绍的PrecomputedText，它内部将measure与layout的过程放在了异步线程进行初始化，而Litho与PrecomputedText类似，也是将measre与layout的过程进行了异步化，核心原理就是利用CPU的闲置时间提前在异步线程中完成measure和layout的过程，仅在UI线程中完成绘制工作。</p><p><strong>那么Android为什么不自己实现异步布局呢？</strong></p><p>主要有以下两原因：</p><ul><li>1、因为View的属性是可变的，只要属性发生变化就可能导致布局变化，所以需要重新计算布局，那么提前异步去计算布局的意义就不大了。而Litho组件的属性是不可变的，因此它的布局计算结果也是不变的。</li><li>2、提前异步布局需要去提前创建好接下来用到的若干条目的视图，但是Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，这将会大大增加App进程的内存占用。对于Litho的组件来说，它只是视图属性的一个集合，仅仅负责计算布局，绘制工作由指定的绘制单元来完成。因此在Litho中，提前创建好下面要用到的多个条目的组件，是不会有性能问题的。两者的绘制原理简图如下所示：</li></ul><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_sync.png" alt="image"></p><h5 id="2、布局自动扁平化"><a href="#2、布局自动扁平化" class="headerlink" title="2、布局自动扁平化"></a>2、布局自动扁平化</h5><p>经过之前的学习，我们了解到Litho采用了一套自有的布局引擎Yoga，它会在布局的过程中去检测出不必要的布局嵌套层级，并自动去减少多余的层级以实现布局的扁平化，这可以显著减少渲染时的递归调用，加快渲染速度。例如，在实现一个图片带多个文字的布局中，我们通常会至少有两个布局层级，当然，<strong>你也可以使用TextView的drawableStart方法 + 代码动态布局使用Spannable/Html.fromHtml(用来实现多种不同规格的文字) + lineSpaceExtra/lineSpacingMultiplier（用来调整多行文本的显示间距）</strong>来将布局层级降为一层，但是这种实现方式比较繁琐，而通过使用Litho，我们可以把降低布局嵌套层级的任务全部丢给布局引擎Yoga去处理。由前面可知，Litho是使用Flexbox来创建布局的，并最终生成带有层级结构的组件树。通过使用Yoga来进行布局计算，可以使用Flexbox的相对布局变成了只有一层嵌套的绝对布局。相比于ConstraintLayout，对于实现复杂布局的时候可读性会更好一些，因为ConstraintLayout此时会有过多的约束条件，这会导致可读性变差。此外，Litho自身还提供了许多挂载Drawable的基本视图组件，相比Viwe组件使用它们可以显著减少内存占用（通常会减少80%的内存占用）。Litho实现布局自动扁平化的原理图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_plan.png" alt="image"></p><h5 id="3、更细粒度地优化RecyclerView中组件的缓存与回收的方法"><a href="#3、更细粒度地优化RecyclerView中组件的缓存与回收的方法" class="headerlink" title="3、更细粒度地优化RecyclerView中组件的缓存与回收的方法"></a>3、更细粒度地优化RecyclerView中组件的缓存与回收的方法</h5><p>使用了RecyclerView与ListView这么久，我们明白它是以viewType为粒度来对一个组件集合统一进行缓存与回收的，并且，当viewType的类型越多，其对组件集合的缓存与回收的效果就会越差。相对于RecyclerView与ListView缓存与回收的粗粒度而言，Litho实现了更细粒度的回收机制，它是以Text、image、video等单个Component为粒度来作为其基准的，具体实现原理为在item回收前，会把LithoView中挂载的各个绘制单元进行解绑拆分出来，由Litho自己的缓存池去分类回收，然后在展示前由LithoView按照组件树的样式挂载组装各个绘制单元，这样就达到了细粒度复用的目的。毫无疑问，这不仅提高了其缓存的命中率与内存的使用率，也降低了提高了其滚动刷新的频率。更细粒度复用优化内存的原图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_recycler.png" alt="image"></p><p>由上图可以看出，滑出屏幕的itemType1会被拆分成一个个的视图单元。其中LithoView容器由Recycler缓存池回收，而其他视图单元则由Litho的缓存池分类回收，例如分类为Img缓存池、Text缓存池等等。</p><p>现在，我们对Litho已经比较了解了，它似乎很完美，但是任何事物都有其弊端，在学习一个新的事物时，我们不仅仅只去使用与了解它的优势，更应该对它的缺陷与弊端了如指掌。Litho在布局的过程中，使用了类似React的单向数据流设计，并且由于Litho是使用代码进行动态布局，这大大增加了布局的复杂度，而且，代码布局是无法实时预览的，这也增加了开发调试时的难度。</p><p>综上，对于某些性能性能要求高的场景，可以先使用Litho布局的方式去替换，特别是利用好RecyclerViewCollectionComponent与sections去充分提升RecylerView的性能。</p><p>现在，我们来使用RecyclerViewCollectionComponent与sections去创建一个可滚动的列表单元。</p><p>接下来，我们需要使用SectionsAPI，它可以将列表分为多个Section，然后编写GroupSectionSpec注解类来声明每个Section需要呈现的内容及其使用的数据。下面，我们创建一个ListSectoinSpec：</p><pre><code>// 1、可以理解为一个组合Sectoin规格@GroupSectionSpecpublic class ListSectionSpec {    @OnCreateChildren    static Children onCreateChildren(final SectionContext context) {        Children.Builder builder = Children.create();        for (int i = 0; i &lt; 20; i++) {            builder.child(                   // 单组件区域用来包含一个特定的组件                    SingleComponentSection.create(context)                    .key(String.valueOf(i))                    .component(ListItem.create(context).build())        };        return builder.build();    }}</code></pre><p>然后，我们将MainActivity onCreate方法中的步骤2替换为如下代码：</p><pre><code>// 2、使用RecyclerCollectionComponent去绘制list   RecyclerCollectionComponent recyclerCollectionComponent = RecyclerCollectionComponent.create(componentContext)           // 使下拉刷新实现           .disablePTR(true)           .section(ListSection.create(new SectionContext(componentContext)).build())           .build();</code></pre><p>最终的显示效果如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/recycle_section.png" alt="image"></p><p><strong>如果我们需要显示不同UI的ListItem该怎么办呢？</strong></p><p>这个时候我们需要去自定义Component的属性，即props，它是一种不可变属性（此外还有一种可变属性称为State，但是其变化是由组件内部进行控制的，例如输入框、Checkbox等都是由组件内部去感知用户的行为，并由此更新组件的State属性），你设置的这些属性将会改变Component的行为或表现。Props是Component Spec中方法的参数，并且使用@Prop注解。</p><p>下面，我们使用props将ListItemSpec的onCreateLayout修改为可自定义组件属性的方法，如下所示：</p><pre><code>@LayoutSpecpublic class ListItemSpec {    @OnCreateLayout    static Component onCreateLayout(ComponentContext context,                                @Prop int bacColor,                                @Prop String title,                                @Prop String subTitle,                                @Prop int textSize,                                @Prop int subTextSize) {        // Column的作用类似于HTML中的&lt;div&gt;标签        return Column.create(context)                .paddingDip(YogaEdge.ALL, 16)                .backgroundColor(bacColor)                .child(Text.create(context)                            .text(title)                         .textSizeSp(textSize)                         .textColor(Color.BLUE)                            .build())                .child(Text.create(context)                            .text(subTitle)                         .textSizeSp(subTextSize)                         .textColor(Color.MAGENTA)                            .build())                .build();    }}</code></pre><p>奇妙之处就发生在我们所定义的@Prop注解与注解处理器之间，注解处理器以一种智能的方对组件构建过程中所关联的属性生成了对应的方法。</p><p>接下来，我们再修改ListSectionSpec类，如下所示：</p><pre><code>@GroupSectionSpecpublic class ListSectionSpec {    @OnCreateChildren    static Children onCreateChildren(final SectionContext context) {        Children.Builder builder = Children.create();        for (int i = 0; i &lt; 20; i++) {            builder.child(                    SingleComponentSection.create(context)                    .key(String.valueOf(i))                    .component(ListItem.create(context)                            .bacColor(i % 2 == 0 ? Color.BLUE:Color.MAGENTA)                            .title(&quot;第&quot; + i + &quot;次练习&quot;)                         .subTitle(&quot;JsonChao&quot;)                            .textSize(36)                            .subTextSize(24)                            .build())            );        }        return builder.build();    }}</code></pre><p>最终的显示效果如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_prop.png" alt="image"></p><p>除此之外，我们还可以有更多的方式去定义@Prop，如下所示：</p><pre><code>@Prop(optional = true, resType = ResType.DIMEN_OFFSET) int shadowRadius,</code></pre><p>上面定义了一个可选的Prop，传入的shadowRadius是支持dimen规格的，如px、dp、sp等等。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>使用Litho，在布局性能上有很大的提升，但是开发成本太高，因为需要自己去实现很多的组件，并且其组件需要在编译时才能生成，不能够进行实时预览，但是可以把Litho封装成Flexbox布局的底层渲染引擎，以此实现上层的动态化，具体实现原理可参见<a href="https://tech.meituan.com/2019/09/19/litho-practice-in-dynamic-program-mtflexbox.html" target="_blank" rel="external">Litho在美团动态化方案MTFlexbox中的实践</a>。</p><h4 id="2、使用Flutter实现高性能的UI布局"><a href="#2、使用Flutter实现高性能的UI布局" class="headerlink" title="2、使用Flutter实现高性能的UI布局"></a>2、使用Flutter实现高性能的UI布局</h4><p>Flutter可以说是2019最火爆的框架之一了，它是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。对于Android来说，FLutter能够创作媲美原生的高性能应用，应用使用 Dart语言进行 开发。Flutter的架构类似于Android的层级架构，每一层都建立在前一层之上，其架构图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/flutter_acrchitecture.png" alt="image"></p><p>在Framework层中，Flutter通过在 widgets 层组合基础 widgets 来构建 Material 层，而 widgets 层本身则是通过对来自 Rendering 层的低层次对象组合而来。而在Engine层，Flutter集成了Skia引擎用于进行栅格化，并且使用了Dart虚拟机。</p><h5 id="那么Flutter的图形性能为何能够媲美原生应用呢？"><a href="#那么Flutter的图形性能为何能够媲美原生应用呢？" class="headerlink" title="那么Flutter的图形性能为何能够媲美原生应用呢？"></a>那么Flutter的图形性能为何能够媲美原生应用呢？</h5><p>接下来，我们以Flutter、原生Android、其它跨平台框架如RN来做比较，它们的图形绘制调用层级图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/flutter_performance_compare.png" alt="image"></p><p>可以看到，Flutter框架的代码完全取代了Java层的框架代码，所以只要当Flutter框架中Dart代码的效率可以媲美原生框架的Java代码的时候，那么总体的Flutter App的性能就能够媲美原生的APP。而反观其它流行的跨平台框架如RN，它首先需要调用自身的Js代码，然后再去调用Java层的代码，这里比原生和Flutter的App显然多出来一个步骤，所以它的性能肯定是不及原生的APP的。此外，Flutter App不同于原生、RN，它内部是直接包含了Skia渲染引擎的，只要Flutter SDK进行升级，Skia就能够升级，这样Skia的性能改进就能够同步到Flutter框架之中。而对于Android原生和RN来说，只能等到Android系统升级才能同步Skia的性能改进。</p><h5 id="而Flutter又是如何实现高性能UI布局的呢？"><a href="#而Flutter又是如何实现高性能UI布局的呢？" class="headerlink" title="而Flutter又是如何实现高性能UI布局的呢？"></a>而Flutter又是如何实现高性能UI布局的呢？</h5><p>接下来，我们来大致了解一下Flutter的UI绘制原理，它主要是通过VSYNC信号来使UI线程和GPU线程有条不紊的周期性的去渲染界面，其绘制原理图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/flutter_ui_core.png" alt="image"></p><p>绘制步骤大致如下：</p><ul><li>1、首先 UI Runner 会执行 root isolate（可简单理解为Dart  VM的线程），它会告诉引擎层有帧要渲染，当需要渲染则会调用到Engine的ScheduleFrame()来注册VSYNC信号回调，一旦触发回调doFrame()，并当它执行完成后，便会移除回调方法，也就是说一次注册一次回调。</li><li>2、当需要再次绘制则需要重新调用到ScheduleFrame()方法，该方法的唯一重要参数regenerate_layer_tree决定在帧绘制过程是否需要重新生成layer tree，还是直接复用上一次的layer tree。</li><li>3、接着，执行的是UI线程绘制过程中最核心的WidgetsBinding的drawFrame()方法，然后会创建layer tree视图树。</li><li>4、然后 Layer Tree 会交给 GPU Task Runner 进行合成和栅格化。</li><li>5、最后，GPU Task Runner会利用Skia库结合GL或Vu’lkan将layer tree提供的信息转化为平台可执行的GPU指令。</li></ul><p>此外，Flutter 也采用了类似 Litho 的props属性不可变、Reat单向数据流的方案，用于将视图与数据分离。对于Flutter这一大前端领域的核心技术，笔者也是充满兴趣，后续会有计划对此进行深入研究，敬请期待。</p><h4 id="3、使用RenderThread-与-RenderScript"><a href="#3、使用RenderThread-与-RenderScript" class="headerlink" title="3、使用RenderThread 与 RenderScript"></a>3、使用RenderThread 与 RenderScript</h4><p>在Android 5.0之后，Android引进了RenderThread，它能够实现动画的异步渲染。但是目前支持RenderThread完全渲染的动画，只有两种，即ViewPropertyAnimator和CircularReveal（揭露动画）。对于CircularReveal使用比较简单且功能较为单一，就不多做过多的描述了。下面我简单说下ViewPropertyAnimator中如何去利用RenderThread。</p><h5 id="1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT-，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示："><a href="#1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT-，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示：" class="headerlink" title="1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT ，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示："></a>1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT ，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示：</h5><pre><code> /** * 使用反射的方式去创建对应View的ViewPropertyAnimatorRT(非hide类) */private static Object createViewPropertyAnimatorRT(View view) {    try {                   Class&lt;?&gt; animRtClazz = Class.forName(&quot;android.view.ViewPropertyAnimatorRT&quot;);        Constructor&lt;?&gt; animRtConstructor = animRtClazz.getDeclaredConstructor(View.class);        animRtConstructor.setAccessible(true);        Object animRt = animRtConstructor.newInstance(view);                    return animRt;    } catch (Exception e) {                    Log.d(TAG, &quot;创建ViewPropertyAnimatorRT出错,错误信息:&quot; + e.toString());                   return null;    }}</code></pre><h5 id="2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示："><a href="#2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示：" class="headerlink" title="2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示："></a>2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示：</h5><pre><code>private static void setViewPropertyAnimatorRT(ViewPropertyAnimator animator, Object rt) {        try {        Class&lt;?&gt; animClazz = Class.forName(&quot;android.view.ViewPropertyAnimator&quot;);        Field animRtField = animClazz.getDeclaredField(&quot;mRTBackend&quot;);        animRtField.setAccessible(true);        animRtField.set(animator, rt);    } catch (Exception e) {        Log.d(TAG, &quot;设置ViewPropertyAnimatorRT出错,错误信息:&quot; + e.toString());    }}/** * 在animator.start()即执行动画开始之前配置的方法 */public static void onStartBeforeConfig(ViewPropertyAnimator animator, View view) {    Object rt = createViewPropertyAnimatorRT(view);    setViewPropertyAnimatorRT(animator, rt);}</code></pre><h5 id="3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示："><a href="#3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示：" class="headerlink" title="3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示："></a>3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示：</h5><pre><code>ViewPropertyAnimator animator = v.animate().scaleY(2).setDuration(2000);AnimHelper.onStartBeforeConfig(animator, v);animator.start();</code></pre><p>现在，如果是做音视频或图像处理的工作，经常需要对图片进行高斯模糊、放大、锐化等操作，但是这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。而图片的变换又涉及大量的计算任务，这个时候我们可以通过RenderScript去充分利用手机的GPU计算能力，以实现高效的图片处理。</p><p>而RenderScript的工作流程需要经历如下三个步骤：</p><ul><li>1、RenderScript运行时API：提供进行运算的API。</li><li>2、反射层：相当于NDK中的JNI胶水代码，它是一些由Android编译工具自动生成的类，对我们写的RenderScript代码进行包装，以使得安卓层能够和RenderScript进行交互。</li><li>3、安卓框架：通过调用反射层来访问RenderScript运行时。</li></ul><p>由于RenderScript主要是用于音视频、图像处理等细分领域，这里笔者就不继续深入扩展了，对于NDK、音视频领域的知识，笔者在今年会有一系列学习计划，目前大纲已经定制好了，如果有兴趣的朋友，可以了解下：<a href="https://github.com/JsonChao/Awesome-Android-NDK" target="_blank" rel="external">Awesome-Android-NDK</a>。</p><h3 id="八、布局优化的常见问题"><a href="#八、布局优化的常见问题" class="headerlink" title="八、布局优化的常见问题"></a>八、布局优化的常见问题</h3><h4 id="1、你在做布局优化的过程中用到了哪些工具？"><a href="#1、你在做布局优化的过程中用到了哪些工具？" class="headerlink" title="1、你在做布局优化的过程中用到了哪些工具？"></a>1、你在做布局优化的过程中用到了哪些工具？</h4><p>我在做布局优化的过程中，用到了很多的工具，但是每一个工具都有它不同的使用场景，不同的场景应该使用不同的工具。下面我从线上和线下两个角度来进行分析。</p><p>比如说，我要统计线上的FPS，我使用的就是Choreographer这个类，它具有以下特性：</p><ul><li>1、能够获取整体的帧率。</li><li>2、能够带到线上使用。</li><li>3、它获取的帧率几乎是实时的，能够满足我们的需求。</li></ul><p>同时，在线下，如果要去优化布局加载带来的时间消耗，那就需要检测每一个布局的耗时，对此我使用的是AOP的方式，它没有侵入性，同时也不需要别的开发同学进行接入，就可以方便地获取每一个布局加载的耗时。如果还要更细粒度地去检测每一个控件的加载耗时，那么就需要使用LayoutInflaterCompat.setFactory2这个方法去进行Hook。</p><p>此外，我还使用了LayoutInspector和Systrace这两个工具，Systrace可以很方便地看到每帧的具体耗时以及这一帧在布局当中它真正做了什么。而LayoutInspector可以很方便地看到每一个界面的布局层级，帮助我们对层级进行优化。</p><h4 id="2、布局为什么会导致卡顿，你又是如何优化的？"><a href="#2、布局为什么会导致卡顿，你又是如何优化的？" class="headerlink" title="2、布局为什么会导致卡顿，你又是如何优化的？"></a>2、布局为什么会导致卡顿，你又是如何优化的？</h4><p>分析完布局的加载流程之后，我们发现有如下四点可能会导致布局卡顿：</p><ul><li>1、首先，系统会将我们的Xml文件通过<strong>IO</strong>的方式映射的方式加载到我们的内存当中，而IO的过程可能会导致卡顿。</li><li>2、其次，布局加载的过程是一个反射的过程，而反射的过程也会可能会导致卡顿。</li><li>3、同时，这个布局的层级如果比较深，那么进行布局遍历的过程就会比较耗时。</li><li>4、最后，不合理的嵌套RelativeLayout布局也会导致重绘的次数过多。</li></ul><p>对此，我们的优化方式有如下几种：</p><ul><li>1、针对布局加载Xml文件的优化，我们使用了异步Inflate的方式，即AsyncLayoutInflater。它的核心原理是在子线程中对我们的Layout进行加载，而加载完成之后会将View通过Handler发送到主线程来使用。所以不会阻塞我们的主线程，加载的时间全部是在异步线程中进行消耗的。而这仅仅是一个从侧面缓解的思路。</li><li>2、后面，我们发现了一个从根源解决上述痛点的方式，即使用X2C框架。它的一个核心原理就是在开发过程我们还是使用的XML进行编写布局，但是在编译的时候它会使用APT的方式将XML布局转换为Java的方式进行布局，通过这样的方式去写布局，它有以下优点：1、它省去了使用IO的方式去加载XML布局的耗时过程。2、它是采用Java代码直接new的方式去创建控件对象，所以它也没有反射带来的性能损耗。这样就从根本上解决了布局加载过程中带来的问题。</li><li>3、然后，我们可以使用ConstraintLayout去减少我们界面布局的嵌套层级，如果原始布局层级越深，它能减少的层级就越多。而使用它也能避免嵌套RelativeLayout布局导致的重绘次数过多。</li><li>4、最后，我们可以使用AspectJ框架（即AOP）和LayoutInflaterCompat.setFactory2的方式分别去建立线下全局的布局加载速度和控件加载速度的监控体系。</li></ul><h4 id="3、做完布局优化有哪些成果产出？"><a href="#3、做完布局优化有哪些成果产出？" class="headerlink" title="3、做完布局优化有哪些成果产出？"></a>3、做完布局优化有哪些成果产出？</h4><ul><li>1、首先，我们建立了一个体系化的监控手段，这里的体系还指的是线上加线下的一个综合方案，针对线下，我们使用AOP或者ARTHook，可以很方便地获取到每一个布局的加载耗时以及每一个控件的加载耗时。针对线上，我们通过Choreographer.getInstance().postFrameCallback的方式收集到了FPS，这样我们可以知道用户在哪些界面出现了丢帧的情况。</li><li>2、然后，对于布局监控方面，我们设立了FPS、布局加载时间、布局层级等一系列指标。</li><li>3、最后，在每一个版本上线之前，我们都会对我们的核心路径进行一次Review，确保我们的FPS、布局加载时间、布局层级等达到一个合理的状态。</li></ul><h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>对于Android的布局优化，笔者以一种自顶向下，层层递进的方式和大家一起深入地去探索了Android中如何将布局优化做到极致，其中主要涉及以下八大主题：</p><ul><li>1、绘制原理：CPU\GPU、Android图形系统的整体架构、绘制线程、刷新机制。</li><li>2、屏幕适配：OLED 屏幕和 LCD 屏幕的区别、屏幕适配方案。</li><li>3、优化工具：使用Systrace来进行布局优化、利用Layout Inspector来查看视图层级结构、采用Choreographer来获取FPS以及自动化测量 UI 渲染性能的方式（gfxinfo、SurfaceFlinger等dumpsys命令）。</li><li>4、布局加载原理：布局加载源码分析、LayoutInflater.Factory分析。</li><li>5、获取界面布局耗时：使用AOP的方式去获取界面加载的耗时、利用LayoutInflaterCompat.setFactory2去监控每一个控件加载的耗时。</li><li>6、布局优化常规方案：使用AOP的方式去获取界面加载的耗时、利用LayoutInflaterCompat.setFactory2去监控每一个控件加载的耗时。</li><li>7、布局优化的进阶方案：使用异步布局框架Litho、使用Flutter实现高性能的UI布局、使用RenderThread实现动画的异步渲染与 利用RenderScript实现高效的图片处理。</li><li>8、布局优化的常见问题。</li></ul><p>可以看到，布局优化看似是Android性能优化中最简单的专项优化项，但是笔者却花费了整整三万字的篇幅才能比较完整地将其核心知识传授给大家。因此，不要小看每一个专项优化点，深入进去，必定满载而归。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第五章 布局优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/80921" target="_blank" rel="external">极客时间之Android开发高手课 UI优化</a></p><p>3、<a href="http://mobile.zol.com.cn/680/6809348.html" target="_blank" rel="external">手机屏幕的前世今生 可能比你想的还精彩</a></p><p>4、<a href="https://www.zhihu.com/question/22263252" target="_blank" rel="external">OLED 和 LCD 什么区别？</a></p><p>5、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826034&amp;idx=1&amp;sn=5e86768d7abc1850b057941cdd003927&amp;chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&amp;scene=21#wechat_redirect" target="_blank" rel="external">Android 目前稳定高效的UI适配方案</a></p><p>6、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-smallestWidth 限定符适配方案</a></p><p>7、<a href="https://github.com/ladingwu/dimens_sw" target="_blank" rel="external">dimens_sw github</a></p><p>8、<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247484502&amp;idx=2&amp;sn=a60ea223de4171dd2022bc2c71e09351&amp;scene=21#wechat_redirect" target="_blank" rel="external">一种极低成本的Android屏幕适配方式</a></p><p>9、<a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-今日头条适配方案</a></p><p>10、<a href="https://juejin.im/post/5bce688e6fb9a05cf715d1c2#heading-0" target="_blank" rel="external">今日头条屏幕适配方案终极版正式发布!</a></p><p>11、<a href="https://www.jianshu.com/p/b492140a555f" target="_blank" rel="external">使用Systrace分析UI性能</a></p><p>12、<a href="https://gapid.dev/about/" target="_blank" rel="external">GAPID-Graphics API Debugger</a></p><p>13、<a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a></p><p>14、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 屏幕绘制机制及硬件加速</a></p><p>15、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 图形处理官方教程</a></p><p>16、<a href="https://zhuanlan.zhihu.com/p/20712354" target="_blank" rel="external">Vulkan - 高性能渲染</a></p><p>17、<a href="https://source.android.com/devices/graphics/arch-vulkan" target="_blank" rel="external">Android Vulkan Tutorial</a></p><p>18、<a href="https://developer.android.com/training/testing/performance#top_of_page" target="_blank" rel="external">Test UI performance-gfxinfo</a></p><p>19、<a href="https://www.jianshu.com/p/7477e381a7ea" target="_blank" rel="external">使用dumpsys gfxinfo 测UI性能（适用于Android6.0以后）</a></p><p>20、<a href="https://developer.android.com/reference/android/view/TextureView" target="_blank" rel="external">TextureView API</a></p><p>21、<a href="https://developer.android.com/reference/android/text/PrecomputedText" target="_blank" rel="external">PrecomputedText API</a></p><p>22、<a href="https://fblitho.com/docs/tutorial" target="_blank" rel="external">Litho Tutorial</a></p><p>23、<a href="https://tech.meituan.com/2019/03/14/litho-use-and-principle-analysis.html" target="_blank" rel="external">基本功 | Litho的使用及原理剖析</a></p><p>24、<a href="https://flutter.cn/docs/resources/technical-overview" target="_blank" rel="external">Flutter官方文档中文版</a></p><p>25、<a href="https://www.bilibili.com/video/av48772383/?spm_id_from=333.788.videocard.0" target="_blank" rel="external">[Google Flutter 团队出品] 深入了解 Flutter 的高性能图形渲染</a></p><p>26、<a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="external">Flutter渲染机制—UI线程</a></p><p>27、<a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489230&amp;idx=1&amp;sn=adc193e35903ab90a4c966059933a35a&amp;source=41#wechat_redirect" target="_blank" rel="external">RenderThread:异步渲染动画</a></p><p>28、<a href="https://developer.android.com/guide/topics/renderscript/compute" target="_blank" rel="external">RenderScript官方文档</a></p><p>29、<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">RenderScript :简单而快速的图像处理</a></p><p>30、<a href="https://www.jianshu.com/p/b72da42e1463" target="_blank" rel="external">RenderScript渲染利器</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android布局优化（上）</title>
      <link>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/</link>
      <guid>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/</guid>
      <pubDate>Mon, 13 Jan 2020 14:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>Android的绘制优化其实可以分为两个部分，即布局(UI)优化和卡顿优化，而布局优化的核心问题就是要解决因布局渲染性能不佳而导致应用卡顿的问题，所以它可以认为是卡顿优化的一个子集。对于Android开发来说，写布局可以说是一个比较简单的工作，但是如果想将写的每一个布局的渲染性能提升到比较好的程度，要付出的努力是要远远超过写布局所付出的。由于布局优化这一主题包含的内容太多，因此，笔者将它分为了上、下两篇，本篇，即为深入探索Android布局优化的上篇。本篇包含的主要内容如下所示：</p><ul><li>1、绘制原理</li><li>2、屏幕适配</li><li>3、优化工具</li><li>4、布局加载原理</li><li>5、获取界面布局耗时</li></ul><p>说到Android的布局绘制，那么我们就不得不先从布局的绘制原理开始说起。</p><h3 id="一、绘制原理"><a href="#一、绘制原理" class="headerlink" title="一、绘制原理"></a>一、绘制原理</h3><p>Android的绘制实现主要是借助CPU与GPU结合刷新机制共同完成的。</p><h4 id="1、CPU与GPU"><a href="#1、CPU与GPU" class="headerlink" title="1、CPU与GPU"></a>1、CPU与GPU</h4><ul><li>CPU负责计算显示内容，包括Measure、Layout、Record、Execute等操作。在UI绘制上的缺陷在于容易显示重复的视图组件，这样不仅带来重复的计算操作，而且会占用额外的GPU资源。</li><li>GPU负责栅格化（用于将UI元素绘制到屏幕上，即将UI组件拆分到不同的像素上显示）。</li></ul><p>这里举两个栗子来讲解一些CPU和GPU的作用：</p><ul><li>1、文字的显示首先经过CPU换算成纹理，然后再传给GPU进行渲染。</li><li>2、而图片的显示首先是经过CPU的计算，然后加载到内存当中，最后再传给GPU进行渲染。</li></ul><p>那么，软件绘制和硬件绘制有什么区别呢？我们先看看下图：</p><p><img src="https://raw.githubusercontent.com/yuegs/yuegs.github.io/master/images/android/render-process/diff-hw-soft.png" alt="image"></p><p>这里软件绘制使用的是Skia库（一款在低端设备如手机上呈现高质量的 2D 图形的 跨平台图形框架)进行绘制的，而硬件绘制本质上是使用的OpenGl ES接口去利用GPU进行绘制的。OpenGL是一种跨平台的图形API，它为2D/3D图形处理硬件指定了标准的软件接口。而OpenGL ES是用于嵌入式设备的，它是OpenGL规范的一种形式，也可称为其子集。</p><p>并且，由于OpenGl ES系统版本的限制，有很多 绘制API 都有相应的 Android API level 的限制，此外，在Android 7.0 把 OpenGL ES 升级到最新的 3.2 版本的时候，还添加了对Vulkan（一套适用于高性能 3D 图形的低开销、跨平台 API）的支持。Vulan作为下一代图形API以及OpenGL的继承者，它的优势在于大幅优化了CPU上图形驱动相关的性能。</p><h4 id="2、Android-图形系统的整体架构"><a href="#2、Android-图形系统的整体架构" class="headerlink" title="2、Android 图形系统的整体架构"></a>2、Android 图形系统的整体架构</h4><p>Android官方的架构图如下：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/graphic_arc.png" alt="image"></p><p>为了比较好的描述它们之间的作用，我们可以把应用程序图形渲染过程当作一次绘画过程，那么绘画过程中 Android 的各个图形组件的作用分别如下：</p><ul><li>画笔：Skia 或者 OpenGL。我们可以用 Skia去绘制 2D 图形，也可以用 OpenGL 去绘制 2D/3D 图形。</li><li>画纸：Surface。所有的元素都在 Surface 这张画纸上进行绘制和渲染。在 Android 中，Window 是 View 的容器，每个窗口都会关联一个 Surface。而 WindowManager 则负责管理这些窗口，并且把它们的数据传递给 SurfaceFlinger。</li><li>画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，在 Android 4.1 之前使用的是双缓冲机制，而在 Android 4.1 之后使用的是三缓冲机制。</li><li>显示：SurfaceFlinger。它将 WindowManager 提供的所有 Surface，通过硬件合成器 Hardware Composer 合成并输出到显示屏。</li></ul><p>在了解完Android图形系统的整体架构之后，我们还需要了解下Android系统的显示原理，关于这块内容可以参考我之前写的<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>的Android系统显示原理一节。</p><h4 id="3、RenderThread"><a href="#3、RenderThread" class="headerlink" title="3、RenderThread"></a>3、RenderThread</h4><p>在Android系统的显示过程中，虽然我们利用了GPU的图形高性能计算的能力，但是从计算Display到通过GPU绘制到Frame Buffer都在UI线程中完成，此时如果能让GPU在不同的线程中进行绘制渲染图形，那么绘制将会更加地流畅。</p><p>于是，在Android 5.0之后,引入了RenderNode和RenderThread的概念，它们的作用如下：</p><ul><li>RenderNode：进一步封装了Display和某些View的属性。</li><li>RenderThread：渲染线程，负责执行所有的OpenGl命令，其中的RenderNode保存有渲染帧的所有信息，能在主线程有耗时操作的前提下保证动画流畅。</li></ul><p>CPU将数据同步给GPU之后，通常不会阻塞等待RenderThread去利用GPU去渲染完视图，而是通知结束之后就返回。加入ReaderThread之后的整个显示调用流程图如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/7f/7d/7f349aefe7a081259218af30b9a9fc7d.png" alt="image"></p><p>在Android 6.0之后，其在adb shell dumpsys gxinfo命令中添加了更加详细的信息，在优化工具一节中我将详细分析下它的使用。</p><p>在Android 7.0之后，对HWUI进行了重构，它是用于2D硬件绘图并负责硬件加速的主要模块，其使用了OpenGl ES来进行GPU硬件绘图。此外，Android 7.0还支持了Vulkan，并且，Vulkan 1.1在Android 被引入。</p><h5 id="硬件加速存在哪些问题？"><a href="#硬件加速存在哪些问题？" class="headerlink" title="硬件加速存在哪些问题？"></a>硬件加速存在哪些问题？</h5><p>我们都知道，硬件加速的原理就是将CPU不擅长的图形计算转换成GPU专用指令。</p><ul><li>1、其中的OpenGl API调用和Graphic Buffer缓冲区至少会占用几MB以上的内存，<strong>内存消耗较大</strong>。</li><li>2、有些OpenGl的绘制API还没有支持，特别是比较低的Android系统版本，并且由于Android每一个版本都会对渲染模块进行一些重构，导致了在硬件加速绘制过程中会出现一些不可预知的Bug。如在Android 5.0~7.0机型上出现的libhwui.so崩溃问题，需要使用inline Hook、GOT Hook等native调试手段去进行分析定位，可能的原因是ReaderThread与UI线程的sync同步过程出现了差错，而这种情况一般都是有多个相同的视图绘制而导致的，比如View的复用、多个动画同时播放。</li></ul><h4 id="4、刷新机制"><a href="#4、刷新机制" class="headerlink" title="4、刷新机制"></a>4、刷新机制</h4><p>16ms发出VSync信号触发UI渲染，大多数的Android设备屏幕刷新频率为60HZ，如果16ms内不能完成渲染过程，则会产生掉帧现象。</p><h3 id="二、屏幕适配"><a href="#二、屏幕适配" class="headerlink" title="二、屏幕适配"></a>二、屏幕适配</h3><p>我们都知道，Android手机屏幕的差异化导致了严重的碎片化问题，并且屏幕材质也是用户比较关注的一个重要因素。</p><p>首先，我们来了解下主流Android屏幕材质，目前主要有两类：</p><ul><li>LCD（Liquid Crystal Display）：液晶显示器。</li><li>OLED（Organic Light-Emitting Diode ）:有机发光二极管。</li></ul><p>早在20世纪60年代，随着半导体集成电路的发展，美国人成功研发出了第一块液晶显示屏LCD，而现在大部分最新的高端机使用的都是OLED材质，这是因为相比于LCD屏幕，OLED屏幕在色彩、可弯曲程度、厚度和耗电等方面都有一定的优势。正因为如此，现在主流的全面屏、曲面屏与未来的柔性折叠屏，使用的几乎都是 OLED 材质。当前，好的材质，它的成本也必然会比较昂贵。</p><h4 id="1、OLED-屏幕和-LCD-屏幕的区别"><a href="#1、OLED-屏幕和-LCD-屏幕的区别" class="headerlink" title="1、OLED 屏幕和 LCD 屏幕的区别"></a>1、OLED 屏幕和 LCD 屏幕的区别</h4><p>如果要明白OLED 屏幕和LCD屏幕的区别，需要了解它们的运行原理，下面，我将分别进行讲解。</p><h5 id="屏幕的成像原理"><a href="#屏幕的成像原理" class="headerlink" title="屏幕的成像原理"></a>屏幕的成像原理</h5><p>屏幕由无数个点组成，并且，每个点由红绿蓝三个子像素组成，每个像素点通过调节红绿蓝子像素的颜色配比来显示不同的颜色，最终所有的像素点就会形成具体的画面。</p><h5 id="LCD背光源与OLED自发光"><a href="#LCD背光源与OLED自发光" class="headerlink" title="LCD背光源与OLED自发光"></a>LCD背光源与OLED自发光</h5><p>下面，我们来看下LCD和OLED的总体结构图，如下所示：</p><p><img src="https://pic4.zhimg.com/v2-5b2ed9a8a18793f9801183e327ecc364_b.jpg" alt="image"></p><p>LCD的发光原理主要在于背光层Back-light，它通常都会由大量的LED背光灯组成以用于显示白光，之后，为了显示出彩色，在其上面加了一层有颜色的薄膜，白色的背光穿透了有颜色的薄膜后就可以显示出彩色了。但是，为了实现调整红绿蓝光的比例，需要在背光层和颜色薄膜之间加入一个控制阀门，即液晶层liquid crystal，它可以通过改变电压的大小来控制开合的程度，开合大则光多，开合小则光少。</p><p>对于OLED来说，它不需要LCD屏幕的背光层和用于控制出光量的液晶层，它就像一个有着无数个小的彩色灯泡组成的屏幕，只需要给它通电就能发光。</p><h5 id="LCD的致命缺陷"><a href="#LCD的致命缺陷" class="headerlink" title="LCD的致命缺陷"></a>LCD的致命缺陷</h5><p>它的液晶层不能完全关合，如果LCD显示黑色，会有部分光穿过颜色层，所以LCD的黑色实际上是白色和黑色混合而成的灰色。而OLED不一样，OLED显示黑色的时候可以直接关闭区域的像素点。</p><p>此外，由于背光层的存在，所以LCD显示器的背光非常容易从屏幕与边框之间的缝隙泄漏出去，即会产生显示器漏光现象。</p><h5 id="OLED屏幕的优势"><a href="#OLED屏幕的优势" class="headerlink" title="OLED屏幕的优势"></a>OLED屏幕的优势</h5><ul><li>1、由于没有有背光层和液晶层的存在，所以它的<strong>厚度更薄，其弯曲程度可以达到180%</strong>。</li><li>2、对比度（白色比黑色的比值）更高，使其画面颜色越浓；相较于LCD来说，<strong>OLED是油画，色彩纯而细腻，而LCD是水彩笔画，色彩朦胧且淡</strong>。</li><li>3、OLED每个像素点都是独立的，所以OLED可以单独点亮某些像素点，即能实现<strong>单独点亮</strong>。而LCD只能控制整个背光层的开关。并且，由于OLED单独点亮的功能，使其<strong>耗电程度大大降低</strong>。</li><li>4、OLED的<strong>屏幕响应时间很快</strong>，不会造成画面残留以致造成视觉上的拖影现象。而LCD则会有严重的拖影现象。</li></ul><h5 id="OLED屏幕的劣势"><a href="#OLED屏幕的劣势" class="headerlink" title="OLED屏幕的劣势"></a>OLED屏幕的劣势</h5><ul><li>1、由于OLED是<strong>有机材料</strong>，导致其寿命是不如LCD的<br>有机材料的。并且，由于OLED单独点亮的功能，会使每个像素点工作的时间不一样，这样，在屏幕老化时就会导致色彩显示不均匀，即产生<strong>烧屏</strong>现象。</li><li>2、由于OLED就不能采取控制电压的方式去调整亮度，所以目前只能通过不断的开关开关开关去进行调光。</li><li>3、OLED的屏幕像素点排列方式不如LCD的紧凑，所以在分辨率相同的情况下，OLED的屏幕是不如LCD清楚的。即OLED的<strong>像素密度较低</strong>。</li></ul><h4 id="2、屏幕适配方案"><a href="#2、屏幕适配方案" class="headerlink" title="2、屏幕适配方案"></a>2、屏幕适配方案</h4><p>我们都知道，Android 的 系统碎片化、机型以及屏幕尺寸碎片化、屏幕分辨率碎片化非常地严重。所以，一个好的屏幕适配方案是很重要的。接下来，我将介绍目前主流的屏幕适配方案。</p><h5 id="1、最原始的Android适配方案：dp-自适应布局或weight比例布局"><a href="#1、最原始的Android适配方案：dp-自适应布局或weight比例布局" class="headerlink" title="1、最原始的Android适配方案：dp + 自适应布局或weight比例布局"></a>1、最原始的Android适配方案：dp + 自适应布局或weight比例布局</h5><p>首先，我们来回顾一下px、dp、dpi、ppi、density等概念：</p><ul><li>px：像素点，px = density * dp。</li><li>ppi：像素密度，每英寸所包含的像素数目，屏幕物理参数，不可调整，dpi没有人为调整时 = ppi。</li><li>dpi：像素密度，在系统软件上指定的单位尺寸的像素数量，可人为调整，dpi没有人为调整时 = ppi。</li><li>dp：density-independent pixels，即密度无关像素，基于屏幕物理分辨率的一个抽象的单位，以dp为尺寸单位的控件，在不同分辨率和尺寸的手机上代表了不同的真实像素，比如在分辨率较低的手机中，可能1dp = 1px,而在分辨率较高的手机中，可能1dp=2px，这样的话，一个64<em>64dp的控件，在不同的手机中就能表现出差不多的大小了，px = dp </em> （dpi / 160）。</li><li>denstiy：密度，屏幕上每平方英寸所包含的像素点个数，density = dpi / 160。</li></ul><p>通常情况下，我们只需要使用dp + 自适应布局（如鸿神的AutoLayout、ConstraintLayout等等）或weight比例布局即可基本解决碎片化问题，当然，这种方式也存在一些问题，比如dpi和ppi的差异所导致在同一分辨率手机上控件大小的不同。</p><h5 id="2、宽高限定符适配方案"><a href="#2、宽高限定符适配方案" class="headerlink" title="2、宽高限定符适配方案"></a>2、宽高限定符适配方案</h5><p>它就是穷举市面上所有的Android手机的宽高像素值，通过设立一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190420175718265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxNnlsZzA4,size_16,color_FFFFFF,t_70" alt="image"></p><p>比如以480x320为基准分辨率：</p><ul><li>宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320。</li><li>高度为480，将任何分辨率的高度整分为480份，取值为y1-y480。</li></ul><p>那么对于800*480的分辨率的dimens文件来说：</p><ul><li>x1=(480/320)*1=1.5px</li><li>x2=(480/320)*2=3px</li></ul><p><img src="http://img.jeepxie.net/upload/6/45/64555d6e993f2e28bee628c8cc52d171_thumb.png" alt="image"></p><p>此时，如果UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens去引用，而当APP运行在不同分辨率的手机中时，系统会根据这些dimens去引用该分辨率对应的文件夹下面去寻找对应的值。但是这个方案由一个缺点，就是无法做到向下兼容去使用更小的dimens，比如说800x480的手机就一定要找到800x480的限定符，否则就只能用统一默认的dimens文件了。</p><h5 id="3、UI适配框架AndroidAutoLayout的适配方案"><a href="#3、UI适配框架AndroidAutoLayout的适配方案" class="headerlink" title="3、UI适配框架AndroidAutoLayout的适配方案"></a>3、UI适配框架AndroidAutoLayout的适配方案</h5><p>因宽高限定符方案的启发，鸿神出品了一款能使用UI适配更加开发高效和适配精准的项目。</p><p><a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="external">项目地址</a></p><p>基本使用步骤如下：</p><p>第一步：在你的项目的AndroidManifest中注明你的设计稿的尺寸：</p><pre><code>&lt;meta-data android:name=&quot;design_width&quot; android:value=&quot;768&quot;&gt;&lt;/meta-data&gt;&lt;meta-data android:name=&quot;design_height&quot; android:value=&quot;1280&quot;&gt;&lt;/meta-data&gt;</code></pre><p>第二步：让你的Activity继承自AutoLayoutActivity。如果你不希望继承AutoLayoutActivity，可以在编写布局文件时，直接使用AutoLinearLayout、Auto<em>*</em>等适配布局即可。</p><p>接下来，直接在布局文件里面使用具体的像素值就可以了，因为在APP运行时，AndroidAutoLayout会帮助我们根据不同手机的具体尺寸按比例伸缩。</p><p>AndroidAutoLayout在宽高限定符适配的基础上，解决了其dimens不能向下兼容的问题，但是它在运行时会在onMeasure里面对dimens去做变换，所以对于自定义控件或者某些特定的控件需要进行单独适配；并且，整个UI的适配过程都是由框架完成的，以后想替换成别的UI适配方案成本会比较高，而且，不幸的是，项目已经停止维护了。</p><h5 id="4、smallestWidth适配方案（sw限定符适配）"><a href="#4、smallestWidth适配方案（sw限定符适配）" class="headerlink" title="4、smallestWidth适配方案（sw限定符适配）"></a>4、smallestWidth适配方案（sw限定符适配）</h5><p>smallestWidth即最小宽度，系统会根据当前设备屏幕的 最小宽度 来匹配 values-sw<n>dp。</n></p><p>我们都知道，移动设备都是允许屏幕可以旋转的，当屏幕旋转时，屏幕的高宽就会互换，加上 最小 这两个字，是因为这个方案是不区分屏幕方向的，它只会把屏幕的高度和宽度中值最小的一方认为是 最小宽度。</p><p>并且它跟宽高限定符适配原理上是一样，都是系统通过特定的规则来选择对应的文件。它与AndroidAutoLayout一样，同样解决了其dimens不能向下兼容的问题，如果该屏幕的最小宽度是360dp，但是项目中没有values-sw360dp文件夹的话，它就可能找到values-sw320dp这个文件夹，其尺寸规则命名如下图所示：</p><p><img src="https://i2.wp.com/5b0988e595225.cdn.sohucs.com/images/20180815/8abd457b9b8c40ab91dc58888aa8c6d9.png?zoom=2&amp;w" alt="image"></p><p>假如加入我们的设计稿的像素宽度是375，那么其对应的values-sw360dp和values-sw400dp宽度如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/ui_adpt_sw_1.png" alt="image"></p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/ui_adpt_sw_2.png?raw=true" alt="image"></p><p>smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。虽然多个dimens文件可能导致apk变大，但是其增加大小范围也只是在300kb-800kb这个区间，这还是可以接受的。这套方案唯一的变数就是选择需要适配哪些最小宽度限定符的文件，如果您生成的 values-sw<n>dp 与设备实际的 最小宽度 差别不大，那误差也就在能接受的范围内，如果差别很大，那效果就会很差。最后，总结一下这套方案的优缺点：</n></p><p><strong>优点：</strong></p><ul><li>1、稳定且无性能损耗。</li><li>2、可通过选择需要哪些最小宽度限定符文件去控制适配范围。</li><li>3、在自动生成values-sw<n>的插件基础下，学习成本较低。</n></li></ul><p>插件地址为<a href="https://github.com/ladingwu/dimens_sw" target="_blank" rel="external">自动生成values-sw<n>的项目代码</n></a>。生成需要的values-sw<n>dp文件夹的步骤如下：</n></p><ul><li>1、clone该项目到本地,以Android项目打开。</li><li>2、DimenTypes文件中写入你希望适配的sw尺寸，默认的这些尺寸能够覆盖几乎所有手机适配需求。</li><li>3、DimenGenerator文件中填写设计稿的尺寸(DESIGN_WIDTH是设计稿宽度，DESIGN_HEIGHT是设计稿高度)。</li><li>4、执行lib module中的DimenGenerator.main()方法，当前地址下会生成相应的适配文件,把相应的文件连带文件夹拷贝到正在开发的项目中。</li></ul><p><strong>缺点：</strong></p><ul><li>1、侵入性高，后续切换其他屏幕适配方案需修改大量 dimens 引用。</li><li>2、覆盖更多不同屏幕的机型需要生成更多的资源文件，使APK体积变大。</li><li>3、不能自动支持横竖屏切换时的适配，如要支持需使用 values-w<n>dp 或 屏幕方向限定符 再生成一套资源文件，又使APK体积变大。</n></li></ul><p><strong>如果想让屏幕宽度随着屏幕的旋转而做出改变该怎么办呢？</strong></p><p>此时根据 values-w<n>dp (去掉 sw 中的 s) 去生成一套资源文件即可。</n></p><p><strong>如果想区分屏幕的方向来做适配该怎么办呢？</strong></p><p>去根据 屏幕方向限定符 生成一套资源文件，后缀加上 -land 或 -port 即可，如：values-sw360dp-land (最小宽度 360 dp 横向)，values-sw400dp-port (最小宽度 720 dp 纵向)。</p><p><strong>注意：</strong></p><p>如果UI设计上明显更适合使用wrap_content,match_parent,layout_weight等,我们就要毫不犹豫的使用，毕竟，上述都是仅仅针对不得不使用固定宽高的情况，我相信基础的UI适配知识大部分开发者还是具备的。如果不具备的话，请看下方：</p><div align="center"><br><img src="http://image.diydoutu.com/12138865495338.gif?imageView2/0/format/gif/q/75" width="30%"><br></div><h5 id="5、今日头条适配方案"><a href="#5、今日头条适配方案" class="headerlink" title="5、今日头条适配方案"></a>5、今日头条适配方案</h5><p>它的原理是根据屏幕的宽度或高度动态调整每个设备的 density (每 dp 占当前设备屏幕多少像素)，通过修改density值的方式，强行把所有不同尺寸分辨率的手机的宽度dp值改成一个统一的值，这样就可以解决所有的适配问题。其对应的重要公式如下：</p><pre><code>当前设备屏幕总宽度（单位为像素）/  设计图总宽度（单位为 dp) = density</code></pre><p>今日头条适配方案默认项目中只能以高或宽中的一个作为基准来进行适配，并不像 AndroidAutoLayout 一样，高以高为基准，宽以宽为基准，来同时进行适配，为什么？</p><p>因为，现在中国大部分市面上的 Android 设备的屏幕高宽比都不一致，特别是现在的全面屏、刘海屏、弹性折叠屏，使这个问题更加严重，不同厂商推出的手机的屏幕高宽比都可能不一致。所以，我们只能以高或宽其中的一个作为基准进行适配，以此避免布局在高宽比不一致的屏幕上出现变形。</p><p>它有以下优势：</p><ul><li>1、使用成本低，操作简单，使用该方案后在页面布局时不需要额外的代码和操作。</li><li>2、侵入性低，和项目完全解耦，在项目布局时不会依赖哪怕一行该方案的代码，而且使用的还是 Android 官方的 API，意味着当你遇到什么问题无法解决，想切换为其他屏幕适配方案时，基本不需要更改之前的代码，整个切换过程几乎在瞬间完成，试错成本接近于 0。</li><li>3、可适配三方库的控件和系统的控件(不止是是 Activity 和 Fragment，Dialog、Toast 等所有系统控件都可以适配)，由于修改的 density 在整个项目中是全局的，所以只要一次修改，项目中的所有地方都会受益。</li><li>4、不会有任何性能的损耗。</li><li>5、不涉及私有API。</li></ul><p>它的缺点如下所示：</p><ul><li>1、适配范围不可控，只能一刀切的将整个项目进行适配，这种将所有控件都强行使用我们项目自身的设计图尺寸进行适配的方案会有问题：当某个系统控件或三方库控件的设计图尺寸和和我们项目自身的设计图尺寸差距越大时，该系统控件或三方库控件的适配效果就越差。比较好的解决方案就是按 Activity 为单位，取消当前 Activity 的适配效果，改用其他的适配方案。</li><li>2、对旧项目的UI适配兼容性不够。</li></ul><p><strong>注意：</strong></p><p>千万不要在此方案上使用smallestWidth适配方案中直接填写设计图上标注的 px 值的做法，这样会使项目强耦合于这个方案，后续切换其它方案都不得不将所有的 layout 文件都改一遍。</p><p>这里推荐一下JessYanCoding的<a href="https://github.com/JessYanCoding/AndroidAutoSize" target="_blank" rel="external">AndroidAutoSize</a>项目，用法如下：</p><p>1、首先在项目的build.gradle中添加该库的依赖：</p><pre><code>implementation &apos;me.jessyan:autosize:1.1.2&apos;</code></pre><p>2、接着 AndroidManifest 中填写全局设计图尺寸 (单位 dp)，如果使用副单位，则可以直接填写像素尺寸，不需要再将像素转化为 dp：</p><pre><code>&lt;manifest&gt;    &lt;application&gt;                    &lt;meta-data            android:name=&quot;design_width_in_dp&quot;            android:value=&quot;360&quot;/&gt;        &lt;meta-data            android:name=&quot;design_height_in_dp&quot;            android:value=&quot;640&quot;/&gt;               &lt;/application&gt;           &lt;/manifest&gt;</code></pre><p><strong>为什么只需在AndroidManifest.xml 中填写一下 meta-data 标签就可实现自动运行？</strong></p><p>在 App 启动时，系统会在 App 的主进程中自动实例化声明的 ContentProvider，并调用它的 onCreate 方法，执行时机比 Application#onCreate 还靠前，可以做一些初始化的工作，这个时候我们就可以利用它的 onCreate 方法在其中启动框架。如果项目使用了多进程，调用Application#onCreate 中调用下 ContentProvider#query 就能够使用 ContentProvider 在当前进程中进行实例化。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>上述介绍的所有方案并没有哪一个是十分完美的，但我们能清晰的认识到不同方案的优缺点，并将它们的优点相结合，这样才能应付更加复杂的开发需求，创造出最卓越的产品。比如SmallestWidth 限定符适配方案 主打的是稳定性，在运行过程中极少会出现安全隐患，适配范围也可控，不会产生其他未知的影响，而 今日头条适配方案 主打的是降低开发成本、提高开发效率，使用上更灵活，也能满足更多的扩展需求。所以，具体情况具体分析，到底选择哪一个屏幕适配方案还是需要去根据我们项目自身的需求去选择。</p><h3 id="三、优化工具"><a href="#三、优化工具" class="headerlink" title="三、优化工具"></a>三、优化工具</h3><h4 id="1、Systrace"><a href="#1、Systrace" class="headerlink" title="1、Systrace"></a>1、Systrace</h4><p>早在<a href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android启动速度优化</a>一文中我们就了解过Systrace的使用、原理及它作为启动速度分析的用法。而它其实主要是用来分析绘制性能方面的问题。下面我就详细介绍下Systrace作为绘制优化工具有哪些必须关注的点。</p><h5 id="1、关注Frames"><a href="#1、关注Frames" class="headerlink" title="1、关注Frames"></a>1、关注Frames</h5><p>首先，先在左边栏选中我们当前的应用进程，在应用进程一栏下面有一栏Frames，我们可以看到有绿、黄、红三种不同的小圆圈，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/systrace_frames.png" alt="image"></p><p>图中每一个小圆圈代表着当前帧的状态，大致的对应关系如下：</p><ul><li>正常：绿色。</li><li>丢帧：黄色。</li><li>严重丢帧：红色。</li></ul><p>并且，选中其中某一帧，我们还可以在视图最下方的详情框看到该帧对应的相关的Alerts报警信息，以帮助我们去排查问题；此外，如果是大于等于Android 5.0的设备（即API Level21），创建帧的工作工作分为UI线程和render线程。而在Android 5.0之前的版本中，创建帧的所有工作都是在UI线程上完成的。接下来，我们看看该帧对应的详情图，如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/systrace_frame_detail.png" alt="image"></p><p>对应到此帧，我们发现这里可能有两个绘制问题：Bitmap过大、布局嵌套层级过多导致的measure和layout次数过多，这就需要我们去在项目中找到该帧对应的Bitmap进行相应的优化，针对布局嵌套层级过多的问题去选择更高效的布局方式，这块后面我们会详细介绍。</p><h5 id="2、关注Alerts栏"><a href="#2、关注Alerts栏" class="headerlink" title="2、关注Alerts栏"></a>2、关注Alerts栏</h5><p>此外，Systrace的显示界面还在在右边侧栏提供了一栏Alert框去显示出它所检测出所有可能有绘制性能问题的地方及对应的数量，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/systrace_alert.png" alt="image"></p><p>在这里，我们可以将Alert框看做是一个是待修复的Bug列表，通常一个区域的改进可以消除应用程序中的所有类中该类型的警报，所以，不要为这里的警报数量所担忧。</p><h4 id="2、Layout-Inspector"><a href="#2、Layout-Inspector" class="headerlink" title="2、Layout Inspector"></a>2、Layout Inspector</h4><p>Layout Inspector是AndroidStudio自带的工具，它的主要作用就是用来查看视图层级结构的。</p><p>具体的操作路径为：</p><pre><code>点击Tools工具栏 -&gt;第三栏的Layout Inspector -&gt; 选中当前的进程</code></pre><p>下面为操作之后打开的<a href="">Awesome-WanAndroid</a>首页图，如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/layout_inspect_overview.png" alt="image"></p><p>其中，最右侧的View Tree就是用来查看视图的层级结构的，非常方便，这是它最主要的功能，中间的是一个屏幕截图，最右边的是一个属性表格，比如我在截图中选中某一个TextView（Kotlin/入门及知识点一栏），在属性表格的text中就可以显示相关的信息，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/layout_inspect_pro_table.png" alt="image"></p><h4 id="3、Choreographer"><a href="#3、Choreographer" class="headerlink" title="3、Choreographer"></a>3、Choreographer</h4><p>Choreographer是用来获取FPS的，并且可以用于线上使用，具备实时性，但是仅能在Api 16之后使用，具体的调用代码如下：</p><pre><code>Choreographer.getInstance().postFrameCallback();</code></pre><p>使用Choreographer获取FPS的完整代码如下所示：</p><pre><code>private long mStartFrameTime = 0;private int mFrameCount = 0;/** * 单次计算FPS使用160毫秒 */private static final long MONITOR_INTERVAL = 160L; private static final long MONITOR_INTERVAL_NANOS = MONITOR_INTERVAL * 1000L * 1000L;/** * 设置计算fps的单位时间间隔1000ms,即fps/s */private static final long MAX_INTERVAL = 1000L; @TargetApi(Build.VERSION_CODES.JELLY_BEAN)private void getFPS() {    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) {        return;    }    Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {        @Override        public void doFrame(long frameTimeNanos) {            if (mStartFrameTime == 0) {                mStartFrameTime = frameTimeNanos;            }            long interval = frameTimeNanos - mStartFrameTime;            if (interval &gt; MONITOR_INTERVAL_NANOS) {                double fps = (((double) (mFrameCount * 1000L * 1000L)) / interval) * MAX_INTERVAL;                // log输出fps                LogUtils.i(&quot;当前实时fps值为： &quot; + fps);                mFrameCount = 0;                mStartFrameTime = 0;            } else {                ++mFrameCount;            }            Choreographer.getInstance().postFrameCallback(this);        }    });}</code></pre><h4 id="4、Tracer-for-OpenGL-ES-与-GAPID（Graphics-API-Debugger）"><a href="#4、Tracer-for-OpenGL-ES-与-GAPID（Graphics-API-Debugger）" class="headerlink" title="4、Tracer for OpenGL ES 与 GAPID（Graphics API Debugger）"></a>4、Tracer for OpenGL ES 与 GAPID（Graphics API Debugger）</h4><p>Tracer for OpenGL ES 是 Android 4.1 新增加的工具，它可逐帧、逐函数的记录 App 使用 OpenGL ES 的绘制过程，并且，它可以记录每个 OpenGL 函数调用的消耗时间。当使用Systrace还找不到渲染问题时，就可以去尝试使用它。</p><p>而GAPID是 Android Studio 3.1 推出的工具，可以认为是Tracer for OpenGL ES的进化版，它不仅实现了跨平台，而且支持Vulkan与回放。由于它们主要是用于OpenGL相关开发的使用，这里我就不多介绍了。</p><h4 id="5、自动化测量-UI-渲染性能的方式"><a href="#5、自动化测量-UI-渲染性能的方式" class="headerlink" title="5、自动化测量 UI 渲染性能的方式"></a>5、自动化测量 UI 渲染性能的方式</h4><p>在自动化测试中，我们通常希望通过执行性能测试的自动化脚本来进行线下的自动化检测，那么，有哪些命令可以用于测量UI渲染的性能呢？</p><p>我们都知道，dumpsys是一款输出有关系统服务状态信息的Android工具，利用它我们可以获取当前设备的UI渲染性能信息，目前常用的有如下两种命令：</p><h5 id="1、gfxinfo"><a href="#1、gfxinfo" class="headerlink" title="1、gfxinfo"></a>1、gfxinfo</h5><p>gfxinfo的主要作用是输出各阶段发生的动画与帧相关的信息，命令格式如下：</p><pre><code>adb shell dumpsys gfxinfo &lt;PackageName&gt;</code></pre><p>这里我以<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>项目为例，输出其对应的gfxinfo信息如下所示：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys gfxinfo json.chao.com.wanandroidApplications Graphics Acceleration Info:Uptime: 549887348 Realtime: 549887348** Graphics info for pid 1722     [json.chao.com.wanandroid] **Stats since: 549356564232951nsTotal frames rendered: 5210Janky frames: 193 (3.70%)50th percentile: 5ms90th percentile: 9ms95th percentile: 13ms99th percentile: 34msNumber Missed Vsync: 31Number High input latency: 0Number Slow UI thread: 153Number Slow bitmap uploads: 6Number Slow issue draw commands: 51HISTOGRAM: 5ms=4254 6ms=131 7ms=144 8ms=87 9ms=80 10ms=83 11ms=108 12ms=57 13ms=29 14ms=17 15ms=17 16ms=14 17ms=20 18ms=15 19ms=15 20ms=17 21ms=9 22ms=14 23ms=8 24ms=9 25ms=4 26ms=5 27ms=4 28ms=4 29ms=1 30ms=2 31ms=4 32ms=3 34ms=6 36ms=5 38ms=7 40ms=8 42ms=0 44ms=3 46ms=3 48ms=5 53ms=2 57ms=0 61ms=3 65ms=0 69ms=1 73ms=1 77ms=0 81ms=0 85ms=0 89ms=1 93ms=1 97ms=0 101ms=0 105ms=0 109ms=0 113ms=1 117ms=0 121ms=0 125ms=0 129ms=0 133ms=0 150ms=2 200ms=0 250ms=2 300ms=1 350ms=1 400ms=0 450ms=1 500ms=0 550ms=1 600ms=0 650ms=0 700ms=0 750ms=0 800ms=0 850ms=0 900ms=0 950ms=0 1000ms=0 1050ms=0 1100ms=0 1150ms=0 1200ms=0 1250ms=0 1300ms=0 1350ms=0 1400ms=0 1450ms=0 1500ms=0 1550ms=0 1600ms=0 1650ms=0 1700ms=0 1750ms=0 1800ms=0 1850ms=0 1900ms=0 1950ms=0 2000ms=0 2050ms=0 2100ms=0 2150ms=0 2200ms=0 2250ms=0 2300ms=0 2350ms=0 2400ms=0 2450ms=0 2500ms=0 2550ms=0 2600ms=0 2650ms=0 2700ms=0 2750ms=0 2800ms=0 2850ms=0 2900ms=0 2950ms=0 3000ms=0 3050ms=0 3100ms=0 3150ms=0 3200ms=0 3250ms=0 3300ms=0 3350ms=0 3400ms=0 3450ms=0 3500ms=0 3550ms=0 3600ms=0 3650ms=0 3700ms=0 3750ms=0 3800ms=0 3850ms=0 3900ms=0 3950ms=0 4000ms=0 4050ms=0 4100ms=0 4150ms=0 4200ms=0 4250ms=0 4300ms=0 4350ms=0 4400ms=0 4450ms=0 4500ms=0 4550ms=0 4600ms=0 4650ms=0 4700ms=0 4750ms=0 4800ms=0 4850ms=0 4900ms=0 4950ms=0Caches:Current memory usage / total memory usage (bytes):TextureCache          5087048 / 59097600Layers total          0 (numLayers = 0)RenderBufferCache           0 /  4924800GradientCache           20480 /  1048576PathCache                   0 /  9849600TessellationCache           0 /  1048576TextDropShadowCache         0 /  4924800PatchCache                  0 /   131072FontRenderer A8        184219 /  1478656    A8   texture 0       184219 /  1478656FontRenderer RGBA           0 /        0FontRenderer total     184219 /  1478656Other:FboCache                    0 /        0Total memory usage:6586184 bytes, 6.28 MBPipeline=FrameBuilderProfile data in ms:    json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity/android.view.ViewRootImpl@4a2142e (visibility=8)    json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.ArticleDetailActivity/android.view.ViewRootImpl@4bccbcf (visibility=8)View hierarchy:json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity/android.view.ViewRootImpl@4a2142e151 views, 154.02 kB of display listsjson.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.ArticleDetailActivity/android.view.ViewRootImpl@4bccbcf19 views, 18.70 kB of display listsTotal ViewRootImpl: 2Total Views:        170Total DisplayList:  172.73 kB</code></pre><p>下面，我将对其中的关键信息进行分析。</p><p><strong>帧的聚合分析数据</strong></p><p>开始的一栏是统计的当前界面所有帧的聚合分析数据，主要作用是<strong>综合查看App的渲染性能以及帧的稳定性。</strong></p><ul><li>Graphics info for pid 1722     [json.chao.com.wanandroid] -&gt; 说明了当前提供的是Awesome-WanAndroid应用界面的帧信息，对应的进程id为1722。</li><li>Total frames rendered 5210 -&gt; 本次dump的数据搜集了5210帧的信息。</li><li>Janky frames: 193 (3.70%) -&gt; 5210帧中有193帧发生了Jank，即单帧耗时时间超过了16ms，卡顿的概率为3.70%。</li><li>50th percentile: 5ms -&gt; 所有帧耗时排序后，其中前50%最大的耗时帧的耗时为5ms。</li><li>90th percentile: 9ms -&gt; 同上，依次类推。</li><li>95th percentile: 13ms -&gt; 同上，依次类推。</li><li>99th percentile: 34ms -&gt; 同上，依次类推。</li><li>Number Missed Vsync: 31 -&gt; 垂直同步失败的帧数为31。</li><li>Number High input latency: 0 -&gt; 处理input耗时的帧数为0。</li><li>Number Slow UI thread: 153 -&gt; 因UI线程的工作而导致耗时的帧数为153。</li><li>Number Slow bitmap uploads: 6 -&gt; 因bitmap加载导致耗时的帧数为6。</li><li>Number Slow issue draw commands: 51 -&gt; 因绘制问题导致耗时的帧数为51。</li><li>HISTOGRAM: 5ms=4254 6ms=131 7ms=144 8ms=87… -&gt; 直方图数据列表，说明了耗时0~5ms的帧数为4254，耗时5~6ms的帧数为131，后续的数据依次类推即可。</li></ul><p>后续的log数据表明了不同组件的缓存占用信息，帧的建立路径信息以及总览信息等等，参考意义不大。</p><p>可以看到，上述的数据只能让我们总体感受到绘制性能的好坏，并不能去定位具体帧的问题，那么，还有更好的方式去获取具体帧的信息吗？</p><p><strong>添加framestats去获取最后120帧的详细信息</strong></p><p>该命令的格式如下：</p><pre><code>adb shell dumpsys gfxinfo &lt;PackageName&gt; framestats</code></pre><p>这里还是以Awesome-Android项目为例，输出项目标签页的帧详细信息：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys gfxinfo json.chao.com.wanandroid framestatsApplications Graphics Acceleration Info:Uptime: 603118462 Realtime: 603118462...Window: json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivityStats since: 603011709157414nsTotal frames rendered: 3295Janky frames: 117 (3.55%)50th percentile: 5ms90th percentile: 9ms95th percentile: 14ms99th percentile: 32msNumber Missed Vsync: 17Number High input latency: 3Number Slow UI thread: 97Number Slow bitmap uploads: 13Number Slow issue draw commands: 20HISTOGRAM: 5ms=2710 6ms=75 7ms=81 8ms=70...---PROFILEDATA---Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,0,603111579233508,603111579233508,9223372036854775807,0,603111580203105,603111580207688,603111580417688,603111580651698,603111580981282,603111581033157,603111581263417,603111583942011,603111584638678,1590000,259000,0,603111595904553,603111595904553,9223372036854775807,0,603111596650344,603111596692428,603111596828678,603111597073261,603111597301386,603111597362376,603111597600292,603111600584667,603111601288261,1838000,278000,...,---PROFILEDATA---...</code></pre><p>这里我们只需关注其中的PROFILEDATA一栏，因为它表明了最近120帧每个帧的状态信息。</p><p>因为其中的数据是以csv格式显示的，我们将PROFILEDATA中的数据全部拷贝过来，然后放入一个txt文件中，接着，把.txt后缀改为.csv，使用WPS表格工具打开，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/framestats_data.png" alt="image"></p><p>从上图中，我们看到输出的第一行是对应的输出数据列的格式，下面我将详细进行分析。</p><p><strong>Flags:</strong></p><ul><li>Flags为0则可计算得出该帧耗时：FrameCompleted - IntendedVsync。</li><li>Flags为非0则表示绘制时间超过16ms，为异常帧。</li></ul><p><strong>IntendedVsync：</strong></p><ul><li>帧的预期Vsync时刻，如果预期的Vsync时刻与现实的Vsync时刻不一致，则表明UI线程中有耗时工作导致其无法响应Vsync信号。</li></ul><p><strong>Vsync：</strong></p><ul><li>花费在Vsync监听器和帧绘制的时间，比如Choreographer frame回调、动画、View.getDrawingTime等待。</li><li>理解Vsync：Vsync避免了在屏幕刷新时，把数据从后台缓冲区复制到帧缓冲区所消耗的时间。</li></ul><p><strong>OldestInputEvent：</strong></p><ul><li>输入队列中最旧输入事件的时间戳，如果没有输入事件，则此列数据都为Long.MAX_VALUE。</li><li>通常用于framework层开发。</li></ul><p><strong>NewestInputEvent：</strong></p><ul><li>输入队列中最新输入时间的时间戳，如果没有输入事件，则此列数据都为0。</li><li>计算App大致的延迟添加时间：FrameCompleted - NewestInputEvent。</li><li>通常用于framework层开发。</li></ul><p><strong>HandleInputStart：</strong></p><ul><li>将输入事件分发给App对应的时间戳时刻。</li><li>用于测量App处理输入事件的时间：AnimationStart - HandleInputStart。当值大于2ms时，说明程序花费了很长的时间来处理输入事件，比如View.onTouchEvent等事件。注意在Activity切换或产生点击事件时此值一般都比较大，此时是可以接受的。</li></ul><p><strong>AnimationStart：</strong></p><ul><li>运行Choreographer（舞蹈编排者）注册动画的时间戳。</li><li>用来评估所有运行的所有动画器（ObjectAnimator、ViewPropertyAnimator、常用转换器）需要多长时间：AnimationStart - PerformTraversalsStart。当值大于2ms时，请查看此时是否执行的是自定义动画且动画是否有耗时操作。</li></ul><p><strong>PerformTraversalsStart：</strong></p><ul><li>执行布局递归遍历开始的时间戳。</li><li>用于获取measure、layout的时间：DrawStart - PerformTraversalsStart。（注意滚动或动画期间此值应接近于0）。</li></ul><p><strong>DrawStart：</strong></p><ul><li>draw阶段开始的时间戳，它记录了任何无效视图的DisplayList的起点。</li><li>用于获取视图数中所有无效视图调用View.draw方法所需的时间：SyncStart - DrawStart。</li><li>在此过程中，硬件加速模块中的DisplayList发挥了重要作用，Android系统仍然使用invalidate()调用draw()方法请求屏幕更新和渲染视图，但是对实际图形的处理方式有所不同。Android系统并没有立即执行绘图命令，而是将它们记录在DisplayList中，该列表包含视图层次结构绘图所需的所有信息。相对于软件渲染的另一个优化是，Android系统仅需要记录和更新DispalyList，以显示被invalidate() 标记为dirty的视图。只需重新发布先前记录的Displaylist，即可重新绘制尚未失效的视图。此时的硬件绘制模型主要包括三个过程：刷新视图层级、记录和更新DisplayList、绘制DisplayList。相对于软件绘制模型的刷新视图层级、然后直接去绘制视图层级的两个过程，虽然多了一个步骤，但是节省了很多不必要的绘制开销。</li></ul><p><strong>SyncQueued：</strong></p><ul><li>sync请求发送到RenderThread线程的时间戳。</li><li>获取sync就绪所花费的时间：SyncStart - SyncQueued。如果值大于0.1ms，则说明RenderThread正在忙于处理不同的帧。</li></ul><p><strong>SyncStart：</strong></p><ul><li>绘图的sync阶段开始的时间戳。</li><li>IssueDrawCommandsStart - SyncStart &gt; 0.4ms左右则表明有许多新的位图需要上传至GPU。</li></ul><p><strong>IssueDrawCommandsStart：</strong></p><ul><li>硬件渲染器开始GPU发出绘图命令的时间戳。</li><li>用于观察App此时绘制时消耗了多少GPU：FrameCompleted - IssueDrawCommandsStart。</li></ul><p><strong>SwapBuffers：</strong></p><ul><li>eglSwapBuffers被调用时的时间戳。</li><li>通常用于Framework层开发。</li></ul><p><strong>FrameCompleted：</strong></p><ul><li>当前帧完成绘制的时间戳。</li><li>获取当前帧绘制的总时间：FrameCompleted - IntendedVsync。</li></ul><p>综上，我们可以利用这些数据计算获取我们在自动化测试中想关注的因素，比如帧耗时、该帧调用View.draw方法所消耗的时间。framestats和帧耗时信息等一般2s收集一次，即一次120帧。为了精确控制收集数据的时间窗口，如将数据限制为特定的动画，可以重置计数器，重新聚合统计的信息，对应命令如下：</p><pre><code>adb shell dumpsys gfxinfo &lt;PackageName&gt; reset</code></pre><h5 id="2、SurfaceFlinger"><a href="#2、SurfaceFlinger" class="headerlink" title="2、SurfaceFlinger"></a>2、SurfaceFlinger</h5><p>我们都知道，在Android 4.1以后，系统使用了三级缓冲机制，即此时有三个Graphic Buffer，那么<strong>如何查看每个Graphic Buffer占用的内存呢？</strong></p><p>答案是使用SurfaceFlinger，命令如下所示：</p><pre><code>adb shell dumpsys SurfaceFlinger</code></pre><p>输出的结果非常多，因为包含很多系统应用和界面的相关信息，这里我们仅过滤出Awesome-WanAndroid应用对应的信息：</p><pre><code>+ Layer 0x7f5a92f000 (json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0)  layerStack=   0, z=    21050, pos=(0,0), size=(1080,2280), crop=(   0,   0,1080,2280), finalCrop=(   0,   0,  -1,  -1), isOpaque=1, invalidate=0, dataspace=(deprecated) sRGB Linear Full range, pixelformat=RGBA_8888 alpha=0.000, flags=0x00000002, tr=[1.00, 0.00][0.00, 1.00]  client=0x7f5dc23600  format= 1, activeBuffer=[1080x2280:1088,  1], queued-frames=0, mRefreshPending=0        mTexName=386 mCurrentTexture=0        mCurrentCrop=[0,0,0,0] mCurrentTransform=0        mAbandoned=0        - BufferQueue mMaxAcquiredBufferCount=1 mMaxDequeuedBufferCount=2          mDequeueBufferCannotBlock=0 mAsyncMode=0          default-size=[1080x2280] default-format=1 transform-hint=00 frame-counter=51        FIFO(0):        Slots:          // 序号           // 表明是否使用的状态 // 对象地址 // 当前负责第几帧 // 手机屏幕分辨率大小         &gt;[00:0x7f5e05a5c0] state=ACQUIRED 0x7f5b1ca580 frame=51 [1080x2280:1088,  1]          [02:0x7f5e05a860] state=FREE     0x7f5b1ca880 frame=49 [1080x2280:1088,  1]          [01:0x7f5e05a780] state=FREE     0x7f5b052a00 frame=50 [1080x2280:1088,  1]</code></pre><p>在Slots中，显示的是缓冲区相关的信息，可以看到，此时App使用的是00号缓冲区，即第一个缓冲区。</p><p>接着，在SurfaceFlinger命令输出log的最下方有一栏Allocated buffers，这这里可以使用当前缓冲区对应的对象地址去查询其占用的内存大小。具体对应到我们这里的是0x7f5b1ca580，匹配到的结果如下所示：</p><pre><code>0x7f5b052a00: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#00x7f5b1ca580: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#00x7f5b1ca880: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0</code></pre><p>可以看到，这里每一个Graphic Buffer都占用了9MB多的内存，通常分辨率越大，单个Graphic Buffer占用的内存就越多，如1080 x 1920的手机屏幕，一般占用8160kb的内存大小。此外，如果应用使用了其它的Surface，如SurfaceView或TextureView（两者一般用在opengl进行图像处理或视频处理的过程中），这个值会更大。如果当App退到后台，系统就会将这部分内存回收。</p><p>了解了常用布局优化常用的工具与命令之后，我们就应该开始着手进行优化了，但在开始之前，我们还得对Android的布局加载原理有比较深入的了解。</p><div align="center"><br><img src="http://image.diydoutu.com/12139979399503.gif?imageView2/0/format/gif/q/75" width="30%"><br></div><h3 id="四、布局加载原理"><a href="#四、布局加载原理" class="headerlink" title="四、布局加载原理"></a>四、布局加载原理</h3><h4 id="1、为什么要了解Android布局加载原理？"><a href="#1、为什么要了解Android布局加载原理？" class="headerlink" title="1、为什么要了解Android布局加载原理？"></a>1、为什么要了解Android布局加载原理？</h4><p>知其然知其所以然，不仅要明白在平时开发过程中是怎样对布局API进行调用，还要知道它内部的实现原理是什么。明白具体的实现原理与流程之后，我们可能会发现更多可优化的点。</p><h4 id="2、布局加载源码分析"><a href="#2、布局加载源码分析" class="headerlink" title="2、布局加载源码分析"></a>2、布局加载源码分析</h4><p>我们都知道，Android的布局都是通过setContentView()这个方法进行设置的，那么它的内部肯定实现了布局的加载，接下来，我们就详细分析下它内部的实现原理与流程。</p><p>以<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>项目为例，我们在通用Activity基类的onCreate方法中进行了布局的设置：</p><pre><code>setContentView(getLayoutId());</code></pre><p>点进去，发现是调用了AppCompatActivity的setContentView方法：</p><pre><code>@Overridepublic void setContentView(@LayoutRes int layoutResID) {    getDelegate().setContentView(layoutResID);}</code></pre><p>这里的setContentView其实是AppCompatDelegate这个代理类的抽象方法：</p><pre><code> /** * Should be called instead of {@link Activity#setContentView(int)}} */public abstract void setContentView(@LayoutRes int resId);</code></pre><p>在这个抽象方法的左边，会有一个绿色的小圆圈，点击它就可以查看到对应的实现类与方法，这里的实现类是AppCompatDelegateImplV9，实现方法如下所示：</p><pre><code> @Overridepublic void setContentView(int resId) {    ensureSubDecor();    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);    contentParent.removeAllViews();    LayoutInflater.from(mContext).inflate(resId, contentParent);    mOriginalWindowCallback.onContentChanged();}</code></pre><p>setContentView方法中主要是获取到了content父布局，移除其内部所有视图之后并<strong>最终调用了LayoutInflater对象的inflate去加载对应的布局</strong>。接下来，我们关注inflate内部的实现：</p><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {    return inflate(resource, root, root != null);}</code></pre><p>这里只是调用了inflate另一个的重载方法：</p><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    if (DEBUG) {        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;                + Integer.toHexString(resource) + &quot;)&quot;);    }    // 1    final XmlResourceParser parser = res.getLayout(resource);    try {        // 2        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}</code></pre><p>在注释1处，通过Resources的getLayout方法获取到了一个XmlResourceParser对象，继续跟踪下getLayout方法：</p><pre><code>public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException {    return loadXmlResourceParser(id, &quot;layout&quot;);}</code></pre><p>这里继续调用了loadXmlResourceParser方法，注意第二个参数传入的为layout，说明此时加载的是一个Xml资源布局解析器。我们继续跟踪loadXmlResourceParse方法：</p><pre><code>@NonNullXmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type)        throws NotFoundException {    final TypedValue value = obtainTempTypedValue();    try {        final ResourcesImpl impl = mResourcesImpl;        impl.getValue(id, value, true);        if (value.type == TypedValue.TYPE_STRING) {            // 1            return impl.loadXmlResourceParser(value.string.toString(), id,                    value.assetCookie, type);        }        throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id)                + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;);    } finally {        releaseTempTypedValue(value);    }}</code></pre><p>在注释1处，如果值类型为字符串的话，则调用了ResourcesImpl实例的loadXmlResourceParser方法。我们首先看看这个方法的注释：</p><pre><code>/** * Loads an XML parser for the specified file. * * @param file the path for the XML file to parse * @param id the resource identifier for the file * @param assetCookie the asset cookie for the file * @param type the type of resource (used for logging) * @return a parser for the specified XML file * @throws NotFoundException if the file could not be loaded */@NonNullXmlResourceParser loadXmlResourceParser(@NonNull String file, @AnyRes int id, int assetCookie,        @NonNull String type)        throws NotFoundException {        ...        final XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file);        ...        return block.newParser();        ...}</code></pre><p>注释的意思说明了这个方法是用于<strong>加载指定文件的Xml解析器</strong>，这里我们之间查看关键的mAssets.openXmlBlockAsset方法，这里的mAssets对象是AssetManager类型的，看看AssetManager实例的openXmlBlockAsset方法做了什么处理：</p><pre><code>/** * {@hide} * Retrieve a non-asset as a compiled XML file.  Not for use by * applications. *  * @param cookie Identifier of the package to be opened. * @param fileName Name of the asset to retrieve. *//*package*/ final XmlBlock openXmlBlockAsset(int cookie, String fileName)    throws IOException {    synchronized (this) {        if (!mOpen) {            throw new RuntimeException(&quot;Assetmanager has been closed&quot;);        }        // 1        long xmlBlock = openXmlAssetNative(cookie, fileName);        if (xmlBlock != 0) {            XmlBlock res = new XmlBlock(this, xmlBlock);            incRefsLocked(res.hashCode());            return res;        }    }    throw new FileNotFoundException(&quot;Asset XML file: &quot; + fileName);}</code></pre><p>可以看到，最终是调用了注释1处的openXmlAssetNative方法，这是定义在AssetManager中的一个Native方法：</p><pre><code>private native final long openXmlAssetNative(int cookie, String fileName);</code></pre><p>与此同时，我们可以猜到读取Xml文件肯定是通过IO流的方式进行的，而openXmlBlockAsset方法后抛出的IOException异常也验证了我们的想法。因为涉及到IO流的读取，所以这里是Android布局加载流程一个耗时点<br>，也有可能是我们后续优化的一个方向。</p><p>分析完Resources实例的getLayout方法的实现之后，我们继续跟踪inflate方法的注释2处：</p><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    if (DEBUG) {        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;                + Integer.toHexString(resource) + &quot;)&quot;);    }    // 1    final XmlResourceParser parser = res.getLayout(resource);    try {        // 2        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}</code></pre><p>infalte的实现代码如下：</p><pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {    synchronized (mConstructorArgs) {        ...        try {            // Look for the root node.            int type;            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;                    type != XmlPullParser.END_DOCUMENT) {                // Empty            }            if (type != XmlPullParser.START_TAG) {                throw new InflateException(parser.getPositionDescription()                        + &quot;: No start tag found!&quot;);            }            final String name = parser.getName();            ...            // 1            if (TAG_MERGE.equals(name)) {                if (root == null || !attachToRoot) {                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;                            + &quot;ViewGroup root and attachToRoot=true&quot;);                }                rInflate(parser, root, inflaterContext, attrs, false);            } else {                // Temp is the root view that was found in the xml                // 2                final View temp = createViewFromTag(root, name, inflaterContext, attrs);                ...            }            ...        }        ...    }    ...}</code></pre><p>可以看到，infalte内部是通过XmlPull解析的方式对布局的每一个节点进行创建对应的视图的。首先，在注释1处会判断节点是否是merge标签，如果是，则对merge标签进行校验，如果merge节点不是当前布局的父节点，则抛出异常。然后，在注释2处，<strong>通过createViewFromTag方法去根据每一个标签创建对应的View视图</strong>。我们继续跟踪下createViewFromTag方法的实现：</p><pre><code>private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) {    return createViewFromTag(parent, name, context, attrs, false);} View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,        boolean ignoreThemeAttr) {    ...    try {        View view;        if (mFactory2 != null) {            view = mFactory2.onCreateView(parent, name, context, attrs);        } else if (mFactory != null) {            view = mFactory.onCreateView(name, context, attrs);        } else {            view = null;        }        if (view == null &amp;&amp; mPrivateFactory != null) {            view = mPrivateFactory.onCreateView(parent, name, context, attrs);        }        if (view == null) {            final Object lastContext = mConstructorArgs[0];            mConstructorArgs[0] = context;            try {                if (-1 == name.indexOf(&apos;.&apos;)) {                    view = onCreateView(parent, name, attrs);                } else {                    view = createView(name, null, attrs);                }            } finally {                mConstructorArgs[0] = lastContext;            }        }        return view;    }     ...}</code></pre><p>在createViewFromTag方法中，首先会判断mFactory2是否存在，存在就会使用mFactory2的onCreateView方法区创建视图，否则就会调用mFactory的onCreateView方法，接下来，如果此时的tag是一个Fragment，则会调用mPrivateFactory的onCreateView方法，否则的话，最终都会调用LayoutInflater实例的createView方法：</p><pre><code> public final View createView(String name, String prefix, AttributeSet attrs)        throws ClassNotFoundException, InflateException {   ...    try {        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);        if (constructor == null) {            // Class not found in the cache, see if it&apos;s real, and try to add it            // 1            clazz = mContext.getClassLoader().loadClass(                    prefix != null ? (prefix + name) : name).asSubclass(View.class);            if (mFilter != null &amp;&amp; clazz != null) {                boolean allowed = mFilter.onLoadClass(clazz);                if (!allowed) {                    failNotAllowed(name, prefix, attrs);                }            }            // 2            constructor = clazz.getConstructor(mConstructorSignature);            constructor.setAccessible(true);            sConstructorMap.put(name, constructor);        } else {            ...        }        ...        // 3        final View view = constructor.newInstance(args);        if (view instanceof ViewStub) {            // Use the same context when inflating ViewStub later.            final ViewStub viewStub = (ViewStub) view;            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));        }        mConstructorArgs[0] = lastContext;        return view;    }    ...}</code></pre><p>LayoutInflater的createView方法中，首先，在注释1处，使用类加载器创建了对应的Class实例，然后在注释2处根据Class实例获取到了对应的构造器实例，并最终在注释3处通过构造器实例constructor的newInstance方法创建了对应的View对象。可以看到，在视图节点的创建过程中采用到了反射，我们都知道反射是比较耗性能的，过多的反射可能会导致布局加载过程变慢，这个点可能是后续优化的一个方向。</p><p>最后，我们来总结下Android中的布局加载流程：</p><ul><li>1、在setContentView方法中，会通过LayoutInflater的inflate方法去加载对应的布局。</li><li>2、inflate方法中首先会调用Resources的getLayout方法去通过IO的方式去加载对应的Xml布局解析器到内存中。</li><li>3、接着，会通过createViewFromTag根据每一个tag创建具体的View对象。</li><li>4、它内部主要是按优先顺序为Factory2和Factory的onCreatView、createView方法进行View的创建，而createView方法内部采用了构造器反射的方式实现。</li></ul><p>从以上分析可知，在Android的布局加载流程中，性能瓶颈主要存在两个地方：</p><ul><li>1、布局文件解析中的IO过程。</li><li>2、创建View对象时的反射过程。</li></ul><h4 id="3、LayoutInflater-Factory分析"><a href="#3、LayoutInflater-Factory分析" class="headerlink" title="3、LayoutInflater.Factory分析"></a>3、LayoutInflater.Factory分析</h4><p>在前面分析的View的创建过程中，我们明白系统会优先使用Factory2和Factory去创建对应的View，那么它们究竟是干什么的呢？</p><p>其实LayoutInflater.Factory是layoutInflater中创建View的一个Hook，Hook即挂钩，我们可以利用它在创建View的过程中加入一些日志或进行其它更高级的定制化处理：比如可以全局替换自定义的TextView等等。</p><p>接下来，我们查看下Factory2的实现：</p><pre><code> public interface Factory2 extends Factory {    /**     * Version of {@link #onCreateView(String, Context, AttributeSet)}     * that also supplies the parent that the view created view will be     * placed in.     *     * @param parent The parent that the created view will be placed     * in; &lt;em&gt;note that this may be null&lt;/em&gt;.     * @param name Tag name to be inflated.     * @param context The context the view is being created in.     * @param attrs Inflation attributes as specified in XML file.     *     * @return View Newly created view. Return null for the default     *         behavior.     */    public View onCreateView(View parent, String name, Context context, AttributeSet attrs);}</code></pre><p>可以看到，Factory2是直接继承于Factory,继续跟踪下Factory的源码：</p><pre><code> public interface Factory {    /**     * Hook you can supply that is called when inflating from a LayoutInflater.     * You can use this to customize the tag names available in your XML     * layout files.     *     * &lt;p&gt;     * Note that it is good practice to prefix these custom names with your     * package (i.e., com.coolcompany.apps) to avoid conflicts with system     * names.     *     * @param name Tag name to be inflated.     * @param context The context the view is being created in.     * @param attrs Inflation attributes as specified in XML file.     *     * @return View Newly created view. Return null for the default     *         behavior.     */    public View onCreateView(String name, Context context, AttributeSet attrs);}</code></pre><p>onCreateView方法中的第一个参数就是指的tag名字，比如TextView等等，我们还注意到Factory2比Factory的onCreateView方法多一个parent的参数，这是当前创建的View的父View。看来，Factory2比Factory功能要更强大一些。</p><p>最后，我们总结下Factory与Factory2的区别：</p><ul><li>1、Factory2继承与Factory。</li><li>2、Factory2比Factory的onCreateView方法多一个parent的参数，即当前创建View的父View。</li></ul><h3 id="五、获取界面布局耗时"><a href="#五、获取界面布局耗时" class="headerlink" title="五、获取界面布局耗时"></a>五、获取界面布局耗时</h3><h4 id="1、常规方式"><a href="#1、常规方式" class="headerlink" title="1、常规方式"></a>1、常规方式</h4><p>如果要获取每个界面的加载耗时，我们就必需在setContentView方法前后进行手动埋点。但是它有如下缺点：</p><ul><li>1、不够优雅。</li><li>2、代码有侵入性。</li></ul><h4 id="2、AOP"><a href="#2、AOP" class="headerlink" title="2、AOP"></a>2、AOP</h4><p>关于AOP的使用，我在<a href="">《深入探索Android启动速度优化》</a>一文的<strong>AOP(Aspect Oriented Programming)打点</strong>部分已经详细讲解过了，这里就不再赘述，还不了解的同学可以点击上面的链接先去学习下AOP的使用。</p><p>我们要使用AOP去获取界面布局的耗时，那么我们的切入点就是setContentView方法，声明一个@Aspect注解的PerformanceAop类，然后，我们就可以在里面实现对setContentView进行切面的方法，如下所示：</p><pre><code>@Around(&quot;execution(* android.app.Activity.setContentView(..))&quot;)public void getSetContentViewTime(ProceedingJoinPoint joinPoint) {    Signature signature = joinPoint.getSignature();    String name = signature.toShortString();    long time = System.currentTimeMillis();    try {        joinPoint.proceed();    } catch (Throwable throwable) {        throwable.printStackTrace();    }    LogHelper.i(name + &quot; cost &quot; + (System.currentTimeMillis() - time));}</code></pre><p>为了获取方法的耗时，我们必须使用@Around注解，这样第一个参数ProceedingJoinPoint就可以提供proceed方法去执行我们的setContentView方法，在此方法的前后就可以获取setContentView方法的耗时。后面的execution表明了在setContentView方法执行内部去调用我们写好的getSetContentViewTime方法，后面括号内的*是通配符，表示匹配任何Activity的setContentView方法，并且方法参数的个数和类型不做限定。</p><p>完成AOP获取界面布局耗时的方法之后，重装应用，打开几个Activity界面，就可以看到如下的界面布局加载耗时日志：</p><pre><code>2020-01-01 12:20:17.605 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 1742020-01-01 12:20:58.010 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 132020-01-01 12:21:27.058 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 442020-01-01 12:21:31.128 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 612020-01-01 12:23:09.805 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 22</code></pre><p>可以看到，Awesome-WanAndroid项目里面各个界面的加载耗时一般都在几十毫秒作用，加载慢的界面可能会达到100多ms，当然，不同手机的配置不一样，但是，这足够让我们发现那些界面布局的加载比较慢。</p><h4 id="3、LayoutInflaterCompat-setFactory2"><a href="#3、LayoutInflaterCompat-setFactory2" class="headerlink" title="3、LayoutInflaterCompat.setFactory2"></a>3、LayoutInflaterCompat.setFactory2</h4><p>上面我们使用了AOP的方式监控了Activity的布局加载耗时，那么，如果我们需要监控每一个控件的加载耗时，该怎么实现呢？</p><p>答案是使用LayoutInflater.Factory2，我们在基类Activity的onCreate方法中直接使用LayoutInflaterCompat.setFactory2方法对Factory2的onCreateView方法进行重写，代码如下所示：</p><pre><code>@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    // 使用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件的加载耗时，    // 也可以做全局的自定义控件替换处理，比如：将TextView全局替换为自定义的TextView。    LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() {        @Override        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {            if (TextUtils.equals(name, &quot;TextView&quot;)) {                // 生成自定义TextView            }            long time = System.currentTimeMillis();            // 1            View view = getDelegate().createView(parent, name, context, attrs);            LogHelper.i(name + &quot; cost &quot; + (System.currentTimeMillis() - time));            return view;        }        @Override        public View onCreateView(String name, Context context, AttributeSet attrs) {            return null;        }    });    // 2、setFactory2方法需在super.onCreate方法前调用，否则无效            super.onCreate(savedInstanceState);    setContentView(getLayoutId());    unBinder = ButterKnife.bind(this);    mActivity = this;    ActivityCollector.getInstance().addActivity(this);    onViewCreated();    initToolbar();    initEventAndData();}</code></pre><p>这样我们就实现了利用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件加载耗时的处理，后续我们可以将这些数据上传到我们自己的APM服务端，作为监控数据可以分析出哪些控件加载比较耗时。当然，这里我们也可以做全局的自定义控件替换处理，比如在上述代码中，我们可以将TextView全局替换为自定义的TextView。</p><p>然后，我们注意到这里我们使用getDelegate().createView方法来创建对应的View实例，跟踪进去发现这里的createView是一个抽象方法：</p><pre><code>public abstract View createView(@Nullable View parent, String name, @NonNull Context context,       @NonNull AttributeSet attrs);</code></pre><p>它对应的实现方法为AppCompatDelegateImplV9对象的createView方法，代码如下所示：</p><pre><code>@Overridepublic View createView(View parent, final String name, @NonNull Context context,        @NonNull AttributeSet attrs) {    ...    return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,            IS_PRE_LOLLIPOP, /* Only read android:theme pre-L (L+ handles this anyway) */            true, /* Read read app:theme as a fallback at all times for legacy reasons */            VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */    );}</code></pre><p>这里最终又调用了AppCompatViewInflater对象的createView方法：</p><pre><code> public final View createView(View parent, final String name, @NonNull Context context,        @NonNull AttributeSet attrs, boolean inheritContext,        boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) {    ...    // We need to &apos;inject&apos; our tint aware Views in place of the standard framework versions    switch (name) {        case &quot;TextView&quot;:            view = new AppCompatTextView(context, attrs);            break;        case &quot;ImageView&quot;:            view = new AppCompatImageView(context, attrs);            break;        case &quot;Button&quot;:            view = new AppCompatButton(context, attrs);            break;        case &quot;EditText&quot;:            view = new AppCompatEditText(context, attrs);            break;        case &quot;Spinner&quot;:            view = new AppCompatSpinner(context, attrs);            break;        case &quot;ImageButton&quot;:            view = new AppCompatImageButton(context, attrs);            break;        case &quot;CheckBox&quot;:            view = new AppCompatCheckBox(context, attrs);            break;        case &quot;RadioButton&quot;:            view = new AppCompatRadioButton(context, attrs);            break;        case &quot;CheckedTextView&quot;:            view = new AppCompatCheckedTextView(context, attrs);            break;        case &quot;AutoCompleteTextView&quot;:            view = new AppCompatAutoCompleteTextView(context, attrs);            break;        case &quot;MultiAutoCompleteTextView&quot;:            view = new AppCompatMultiAutoCompleteTextView(context, attrs);            break;        case &quot;RatingBar&quot;:            view = new AppCompatRatingBar(context, attrs);            break;        case &quot;SeekBar&quot;:            view = new AppCompatSeekBar(context, attrs);            break;    }    if (view == null &amp;&amp; originalContext != context) {        // If the original context does not equal our themed context, then we need to manually        // inflate it using the name so that android:theme takes effect.        view = createViewFromTag(context, name, attrs);    }    if (view != null) {        // If we have created a view, check its android:onClick        checkOnClickListener(view, attrs);    }    return view;}</code></pre><p>在AppCompatViewInflater对象的createView方法中系统根据不同的tag名字创建出了对应的AppCompat兼容控件。看到这里，我们明白了Android系统是使用了LayoutInflater的Factor2/Factory结合了AppCompat兼容类来进行高级版本控件的适配。</p><p>接下来，我们注意到注释1处，setFactory2方法需在super.onCreate方法前调用，否则无效，这是为什么呢？</p><p>这里可以先大胆猜测一下，可能是因为在super.onCreate()方法中就需要将Factory2实例存储到内存中。下面，我们就跟踪一下super.onCreate()的源码，看看是否如我们所假设的一样。AppCompatActivity的onCreate方法如下所示：</p><pre><code>@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    final AppCompatDelegate delegate = getDelegate();    delegate.installViewFactory();    delegate.onCreate(savedInstanceState);    if (delegate.applyDayNight() &amp;&amp; mThemeId != 0) {        // If DayNight has been applied, we need to re-apply the theme for        // the changes to take effect. On API 23+, we should bypass        // setTheme(), which will no-op if the theme ID is identical to the        // current theme ID.        if (Build.VERSION.SDK_INT &gt;= 23) {            onApplyThemeResource(getTheme(), mThemeId, false);        } else {            setTheme(mThemeId);        }    }    super.onCreate(savedInstanceState);}</code></pre><p>第一行的delegate实例的installViewFactory()方法就吸引了我们的注意，因为它包含了一个敏感的关键字“Factory“，这里我们继续跟踪进installViewFactory()方法：</p><pre><code>public abstract void installViewFactory();</code></pre><p>这里一个是抽象方法，点击左边绿色圆圈，可以看到这里具体的实现类为AppCompatDelegateImplV9，其实现的installViewFactory()方法如下所示：</p><pre><code>@Overridepublic void installViewFactory() {    LayoutInflater layoutInflater = LayoutInflater.from(mContext);    if (layoutInflater.getFactory() == null) {        LayoutInflaterCompat.setFactory2(layoutInflater, this);    } else {        if (!(layoutInflater.getFactory2() instanceof AppCompatDelegateImplV9)) {            Log.i(TAG, &quot;The Activity&apos;s LayoutInflater already has a Factory installed&quot;                    + &quot; so we can not install AppCompat&apos;s&quot;);        }    }}</code></pre><p>可以看到，如果我们在super.onCreate()方法前没有设置LayoutInflater的Factory2实例的话，这里就会设置一个默认的Factory2。最后，我们再来看下默认Factory2的onCreateView方法的实现：</p><pre><code>/** * From {@link LayoutInflater.Factory2}. */@Overridepublic final View onCreateView(View parent, String name, Context context, AttributeSet attrs) {    // 1、First let the Activity&apos;s Factory try and inflate the view    final View view = callActivityOnCreateView(parent, name, context, attrs);    if (view != null) {        return view;    }    // 2、If the Factory didn&apos;t handle it, let our createView() method try    return createView(parent, name, context, attrs);}</code></pre><p>在注释1处，我们首先会尝试让Activity的Facotry实例去加载对应的View实例，如果Factory不能够处理它，在注释2处，就会调用createView方法去创建对应的View，AppCompatDelegateImplV9类的createView方法的实现上面我们已经分析过了，此处就不再赘述了。</p><p>下篇，我们将进入布局优化的实战环节，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第五章 布局优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/80921" target="_blank" rel="external">极客时间之Android开发高手课 UI优化</a></p><p>3、<a href="http://mobile.zol.com.cn/680/6809348.html" target="_blank" rel="external">手机屏幕的前世今生 可能比你想的还精彩</a></p><p>4、<a href="https://www.zhihu.com/question/22263252" target="_blank" rel="external">OLED 和 LCD 什么区别？</a></p><p>5、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826034&amp;idx=1&amp;sn=5e86768d7abc1850b057941cdd003927&amp;chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&amp;scene=21#wechat_redirect" target="_blank" rel="external">Android 目前稳定高效的UI适配方案</a></p><p>6、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-smallestWidth 限定符适配方案</a></p><p>7、<a href="https://github.com/ladingwu/dimens_sw" target="_blank" rel="external">dimens_sw github</a></p><p>8、<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247484502&amp;idx=2&amp;sn=a60ea223de4171dd2022bc2c71e09351&amp;scene=21#wechat_redirect" target="_blank" rel="external">一种极低成本的Android屏幕适配方式</a></p><p>9、<a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-今日头条适配方案</a></p><p>10、<a href="https://juejin.im/post/5bce688e6fb9a05cf715d1c2#heading-0" target="_blank" rel="external">今日头条屏幕适配方案终极版正式发布!</a></p><p>11、<a href="https://www.jianshu.com/p/b492140a555f" target="_blank" rel="external">使用Systrace分析UI性能</a></p><p>12、<a href="https://gapid.dev/about/" target="_blank" rel="external">GAPID-Graphics API Debugger</a></p><p>13、<a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a></p><p>14、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 屏幕绘制机制及硬件加速</a></p><p>15、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 图形处理官方教程</a></p><p>16、<a href="https://zhuanlan.zhihu.com/p/20712354" target="_blank" rel="external">Vulkan - 高性能渲染</a></p><p>17、<a href="https://source.android.com/devices/graphics/arch-vulkan" target="_blank" rel="external">Android Vulkan Tutorial</a></p><p>18、<a href="https://developer.android.com/training/testing/performance#top_of_page" target="_blank" rel="external">Test UI performance-gfxinfo</a></p><p>19、<a href="https://www.jianshu.com/p/7477e381a7ea" target="_blank" rel="external">使用dumpsys gfxinfo 测UI性能（适用于Android6.0以后）</a></p><p>20、<a href="https://developer.android.com/reference/android/view/TextureView" target="_blank" rel="external">TextureView API</a></p><p>21、<a href="https://developer.android.com/reference/android/text/PrecomputedText" target="_blank" rel="external">PrecomputedText API</a></p><p>22、<a href="https://fblitho.com/docs/tutorial" target="_blank" rel="external">Litho Tutorial</a></p><p>23、<a href="https://tech.meituan.com/2019/03/14/litho-use-and-principle-analysis.html" target="_blank" rel="external">基本功 | Litho的使用及原理剖析</a></p><p>24、<a href="https://flutter.cn/docs/resources/technical-overview" target="_blank" rel="external">Flutter官方文档中文版</a></p><p>25、<a href="https://www.bilibili.com/video/av48772383/?spm_id_from=333.788.videocard.0" target="_blank" rel="external">[Google Flutter 团队出品] 深入了解 Flutter 的高性能图形渲染</a></p><p>26、<a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="external">Flutter渲染机制—UI线程</a></p><p>27、<a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489230&amp;idx=1&amp;sn=adc193e35903ab90a4c966059933a35a&amp;source=41#wechat_redirect" target="_blank" rel="external">RenderThread:异步渲染动画</a></p><p>28、<a href="https://developer.android.com/guide/topics/renderscript/compute" target="_blank" rel="external">RenderScript官方文档</a></p><p>29、<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">RenderScript :简单而快速的图像处理</a></p><p>30、<a href="https://www.jianshu.com/p/b72da42e1463" target="_blank" rel="external">RenderScript渲染利器</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2019年终总结</title>
      <link>http://yoursite.com/2019/12/29/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <guid>http://yoursite.com/2019/12/29/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sun, 29 Dec 2019 13:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>一转眼，一年很快就过去了，还记得一年前我写的<a href="https://jsonchao.github.io/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" target="_blank" rel="external">2018年终总结</a>，当时定了比较完善的学习计划，到目前为止，由于今年换工作变动等等其它原因，使本年度实施的学习计划与2018年所制定的有一些差异，接下来，便开始回顾一下我的2019年主要做了哪些事情。</p><h3 id="二、回顾我的2019年"><a href="#二、回顾我的2019年" class="headerlink" title="二、回顾我的2019年"></a>二、回顾我的2019年</h3><h3 id="第一季度（1-3月）："><a href="#第一季度（1-3月）：" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目"><a href="#1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目" class="headerlink" title="1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目"></a>1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目</h4><p><a href="https://github.com/JsonChao/Awesome-Third-Library-Source-Analysis" target="_blank" rel="external">Awesome-Third-Library-Source-Analysis项目地址</a></p><p>众所周知，优秀源码的阅读与理解是最能提升自身功力的途径，如果想要成为一名优秀的Android工程师，那么Android优秀三方库源码的分析和理解则是必备技能。因此，为了将知识成体系地聚合起来，笔者创建了Awesome-Third-Library-Source-Analysis这个项目，为的就是让每一个Android工程师能够从以下七方面全方位地提升自己。</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Android_hot_third_source_analysis.png" alt="image"></p><p>这个项目目前已经全部完成，感兴趣的同学可以点击上方链接进行查看。</p><h4 id="2、Android核心源码"><a href="#2、Android核心源码" class="headerlink" title="2、Android核心源码"></a>2、Android核心源码</h4><p>主要基于《Android进阶解密》一书学习与Android应用开发紧密相关的Framework核心源码：</p><ul><li>Context家族</li><li>AMS</li><li>WMS</li><li>PMS</li><li>JNI原理</li></ul><h4 id="3、Android插件化知识相关"><a href="#3、Android插件化知识相关" class="headerlink" title="3、Android插件化知识相关"></a>3、Android插件化知识相关</h4><p>主要基于《Android进阶解密》一书学习和理解插件化知识，以此将FrameWork核心源码的相关知识融会贯通：</p><ul><li>JVM核心知识</li><li>Davilk/ART核心知识</li><li>类加载机制</li><li>热修复原理</li><li>插件化原理（基于VirtualAPK）</li></ul><h3 id="第二季度（4-6月）："><a href="#第二季度（4-6月）：" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、面试"><a href="#1、面试" class="headerlink" title="1、面试"></a>1、面试</h4><p>整个4月份则都是在反复地重复找工作、面试的这样的过程，期间也将Awesome-Android-Interview这个面试开源项目进行了进一步的总结与完善。</p><p><a href="https://github.com/JsonChao/Awesome-Android-Interview" target="_blank" rel="external">Awesome-Android-Interview项目地址</a></p><p>随着Android技术发展的成熟，Kotlin、大前端技术RN、Flutter、小程序等一下子就进入了我们的视野内，同时，Android自身的技术栈也正在不断扩展，比如前段时间Google推出的Jetpack。因此，Android开发者们越来越焦虑，越来越迷茫，每个人的时间和精力是有限的，我们到底该学什么才能有效地提高自身的竞争力呢?其实，首先我们应该优先深入学习工作中用到的技术，其次，关注这2年来Android最新的面试题所涉及的知识点，根据自身的实际情况有选择地进行针对性的学习和提升。</p><p>这里多说一句，其实找工作就是一个不断进行自我认知的一个过程，它能让你清晰地认识到自己哪方面存在着不足，哪一方面自己可能有一些优势，<strong>当你因此而找到自己的优势或感兴趣的方向时，坚持下去，肯定会有所收获。</strong></p><p>后面的5、6月份则都是在适应的过程中度过，因为以前都是在比较小的团队进行开发，所以一下转到大的开发团队后则有一些不适应。而且，团队内的外包人员占总人员比例是比较大的，大致为80%左右，这导致了许多应用代码或多或少都存在一些问题。因此，我们需要定制更多的流程与组件来检测甚至解决这些问题。</p><h4 id="2、开发效率提升"><a href="#2、开发效率提升" class="headerlink" title="2、开发效率提升"></a>2、开发效率提升</h4><p>主要基于 <strong>《Android群英传 神兵利器》</strong> 一书系统提升开发效率。（主要是换了Mac pro，QAQ~）</p><h3 id="第三季度（7-9月）："><a href="#第三季度（7-9月）：" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、系统学习Android源码设计模式"><a href="#1、系统学习Android源码设计模式" class="headerlink" title="1、系统学习Android源码设计模式"></a>1、系统学习Android源码设计模式</h4><p>主要基于 <strong>《HeadFirst设计模式》</strong> 与 <strong>《Android源码设计模式解析与实战》</strong> 两本书进一步加深对Android FrameWork层的的理解与思考。</p><h4 id="2、工作、学习效率提升"><a href="#2、工作、学习效率提升" class="headerlink" title="2、工作、学习效率提升"></a>2、工作、学习效率提升</h4><p>主要基于 <strong>《番茄工作法图解》</strong> 一书系统学习了番茄工作法的实施。</p><h4 id="3、算法基础学习"><a href="#3、算法基础学习" class="headerlink" title="3、算法基础学习"></a>3、算法基础学习</h4><p>主要基于 <strong>《漫画算法》</strong> 一书对算法中常见的数据结构与一些比较经典的算法实现进行了深入地了解。</p><h3 id="第四季度（10-12月）："><a href="#第四季度（10-12月）：" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、深入学习Android性能优化"><a href="#1、深入学习Android性能优化" class="headerlink" title="1、深入学习Android性能优化"></a>1、深入学习Android性能优化</h4><p>主要基于 <strong>极客时间之《Android开发高手课》</strong>、<strong><a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化</a></strong>、<strong>《移动性能实战》</strong> 和 <strong>《Android应用性能优化最佳实践》（已完成）</strong>、收藏的其它性能优化课程、文章对Android性能优化相关知识进行全面、系统、深入地学习。并且，因此我开源了Awesome-Android-Performance项目。</p><p><a href="https://github.com/JsonChao/Awesome-Android-Performance" target="_blank" rel="external">项目地址</a></p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/android-performance.png" alt="image"></p><blockquote><p>深入探索Android性能优化，从应用层、Framework层、Native层、ART/Dalvik以及Linux内核实现原理等各个层次深入挖掘各项性能优化技术~</p></blockquote><p>众所周知，性能优化是Android细分领域中最难且也是知识面涉及最深和最广的方向之一，但是如果你想要成为一名顶尖的Android工程师，性能优化细分领域则是非常好的实战与理论结合的场所。因此，为了将性能优化涉及的各个层面的知识成体系地糅合到一起，笔者创建了Awesome-Android-Performance这个项目，希望能带领读者从Android系统架构中的应用层、Framework层、Native层、ART/Dalvik以及Linux内核层这一大垂直领域去深入探索与挖掘性能优化的极致技术。</p><p>在写这篇年终总结之前，我刚刚完成了<a href="https://jsonchao.github.io/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="external">《深入探索Android内存优化》</a>这篇文章，这篇文章含金量比较高，建议对内存优化感兴趣的同学仔细阅读，必定有所收获。而且，内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。</p><h4 id="2、前端基础"><a href="#2、前端基础" class="headerlink" title="2、前端基础"></a>2、前端基础</h4><p>大前端是未来的趋势，技多不压身，因此，基于 <strong>《大前端入门指南 前端基础部分》</strong> 一书我对HTML、CSS、JavaScript的基础核心知识进行了学习。</p><h4 id="3、算法学习"><a href="#3、算法学习" class="headerlink" title="3、算法学习"></a>3、算法学习</h4><p>主要基于 <strong>《剑指Offer》（进行中）</strong> 一书系统学习算法面试的解题思路。</p><p>接下来，我对我的2020年制定了<strong>最核心的学习计划</strong>，所以会尽可能高标准地去实现好它。</p><h3 id="二、展望我的2020年"><a href="#二、展望我的2020年" class="headerlink" title="二、展望我的2020年"></a>二、展望我的2020年</h3><h3 id="第一季度（1-3月）：-1"><a href="#第一季度（1-3月）：-1" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、继续深入学习Android性能优化"><a href="#1、继续深入学习Android性能优化" class="headerlink" title="1、继续深入学习Android性能优化"></a>1、继续深入学习Android性能优化</h4><p>主要基于 <strong>极客时间之《Android开发高手课》</strong>、<strong><a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化</a></strong>、<strong>《移动性能实战》</strong> 和 <strong>《Android应用性能优化最佳实践》（已完成）</strong>、收藏的其它性能优化课程、文章对Android性能优化相关知识进行全面、系统、深入地学习。并且计划在3月底完成<a href="https://github.com/JsonChao/Awesome-Android-Performance" target="_blank" rel="external">Awesome-Android-Performance</a>项目。</p><h4 id="2、系统学习数据结构与算法"><a href="#2、系统学习数据结构与算法" class="headerlink" title="2、系统学习数据结构与算法"></a>2、系统学习数据结构与算法</h4><p>算法是比较难的东西，所以我将算法的学习全部放在了早上，详细的算法学习计划如下：</p><ul><li>1、全面了解<strong>数据结构与算法知识地图，建立算法知识框架</strong></li><li>2、300分钟搞定数据结构与算法，学习Google算法面试的精髓（每周六上午）</li><li>3、剑指Offer，系统学习算法面试的解题思路 13 - 68题（每天早上）</li><li>4、字节跳动leetcode 38道算法题（每天早上）</li><li>5、腾讯leetcode 11道高频算法题（每天早上）</li></ul><h3 id="第二季度（4-6月）：-1"><a href="#第二季度（4-6月）：-1" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、Android-Framework层深入学习"><a href="#1、Android-Framework层深入学习" class="headerlink" title="1、Android Framework层深入学习"></a>1、Android Framework层深入学习</h4><p>主要基于 <strong><a href="https://coding.imooc.com/class/340.html" target="_blank" rel="external">剖析Framework面试 冲击Android高级职位</a></strong> 课程 将Framework的设计思想与实现细节、总体流程融合起来，追求真正的融会贯通。</p><h4 id="2、深入并系统学习热修复与插件化"><a href="#2、深入并系统学习热修复与插件化" class="headerlink" title="2、深入并系统学习热修复与插件化"></a>2、深入并系统学习热修复与插件化</h4><p>主要基于 <strong><a href="https://coding.imooc.com/class/106.html" target="_blank" rel="external">Android应用发展趋势必备武器 热修复与插件化</a></strong> 课程深入并系统地学习热修复与插件化技术。</p><h4 id="3、算法"><a href="#3、算法" class="headerlink" title="3、算法"></a>3、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录 &amp; 总结 &amp; 归纳</p><h3 id="第三季度（7-9月）：-1"><a href="#第三季度（7-9月）：-1" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、继续Android-Framework层深入学习"><a href="#1、继续Android-Framework层深入学习" class="headerlink" title="1、继续Android Framework层深入学习"></a>1、继续Android Framework层深入学习</h4><p>主要基于 <strong>《深入理解Android内核设计思想》</strong> 一书将Framework的设计思想与实现细节、总体流程融合起来，追求真正的融会贯通。</p><h4 id="2、继续深入并系统学习热修复与插件化"><a href="#2、继续深入并系统学习热修复与插件化" class="headerlink" title="2、继续深入并系统学习热修复与插件化"></a>2、继续深入并系统学习热修复与插件化</h4><p>主要基于 <strong>《深入探索Android热修复技术原理》</strong>、<strong>《Android插件化开发指南》</strong> 两本书 深入并系统地学习热修复与插件化技术。</p><h4 id="3、算法-1"><a href="#3、算法-1" class="headerlink" title="3、算法"></a>3、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录 &amp; 总结 &amp; 归纳</p><h3 id="第四季度（10-12月）：-1"><a href="#第四季度（10-12月）：-1" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、全面深入地掌握NDK技术"><a href="#1、全面深入地掌握NDK技术" class="headerlink" title="1、全面深入地掌握NDK技术"></a>1、全面深入地掌握NDK技术</h4><p>NDK技术是成为Android开发高手必须掌握的一个技能，因此，为了督促自身去深入学习NDK技术，我开源了Awesome-Android-NDK项目。</p><p><a href="https://github.com/JsonChao/Awesome-Android-NDK" target="_blank" rel="external">项目地址</a></p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-NDK/master/ScreenShots/NDK%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF.png" alt="image"></p><blockquote><p>深入解码Android NDK技术、扎实C、C++、Shell、Linux基础，掌握JNI语法实现，熟悉Cmake、MakeFile的编译底层原理，全面解密顶级公司核心技术，搭乘着音视频与图像处理的5G快车，成长为最具核心竞争力的高级人才。</p></blockquote><h4 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>成长的道路总会充满坎坷与荆棘，但是梦想与热情总是使我们充满力量，我相信，未来，会有更广阔的天空。</p><pre><code>心中有多少希望，未来就会有多精彩，愿你我都将充满力量地前行。</code></pre><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/12/29/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android内存优化</title>
      <link>http://yoursite.com/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 29 Dec 2019 10:54:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>本篇是Android内存优化的进阶篇，难度会比较大，建议对内存优化不是非常熟悉的前仔细看看在前几篇文章中，笔者曾经写过的一篇<a href="https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之内存优化</a>，其中详细分析了以下几大模块：</p><ul><li>Android的内存管理机制</li><li>优化内存的意义</li><li>避免内存泄漏</li><li>优化内存空间</li><li>图片管理模块的设计与实现</li></ul><p>如果你对以上基础内容都比较了解了，那么我们便开始接下来的Android内存优化探索之旅吧。</p><h3 id="一、内存优化相关概念"><a href="#一、内存优化相关概念" class="headerlink" title="一、内存优化相关概念"></a>一、内存优化相关概念</h3><p>Android的给每个应用进程分配的内存都是非常有限的，那么为什么不能把图片下载来都放到磁盘中呢？那是因为放在内存中，展示会更“快”，快的原因有两点：</p><ul><li>硬件快：内存本身读取、存入速度快。</li><li>复用快：解码成果有效保存，复用时，直接使用解码后对象，而不是再做一次图像解码。</li></ul><p>这里说一下解码的概念。Android系统要在屏幕上展示图片的时候只认“像素缓冲”，而这也是大多数操作系统的特征。而我们常见的jpg，png等图片格式，都是把“像素缓冲”使用不同的手段压缩后的结果，所以这些格式的图片，要在设备上展示，就必须经过一次解码，它的执行速度会受图片压缩比、尺寸等因素影响。(官方建议：把从内存淘汰的图片，降低压缩比存储到本地，以备后用，这样可以最大限度地降低以后复用时的解码开销。)</p><p>接下来，我们来了解一下内存优化的一些重要概念。</p><h4 id="手机RAM"><a href="#手机RAM" class="headerlink" title="手机RAM:"></a>手机RAM:</h4><p>手机不使用PC的DDR内存，采用的是LPDDR RAM，即”低功耗双倍数据速率内存“。</p><pre><code>LPDDR系列的带宽 = 时钟频率 ✖️内存总线位数 / 8LPDDR4 = 1600MHZ ✖️64 / 8 ✖️双倍速率 = 25.6GB/s。</code></pre><h4 id="那么内存占用是否越少越好？"><a href="#那么内存占用是否越少越好？" class="headerlink" title="那么内存占用是否越少越好？"></a>那么内存占用是否越少越好？</h4><p>当系统内存充足的时候，我们可以多用一些获得更好的性能。当系统内存不足的时候，希望可以做到”用时分配，及时释放“。</p><h4 id="内存优化的纬度"><a href="#内存优化的纬度" class="headerlink" title="内存优化的纬度"></a>内存优化的纬度</h4><p>对于Android内存优化来说又可以细分为两个维度：</p><h5 id="1、RAM优化"><a href="#1、RAM优化" class="headerlink" title="1、RAM优化"></a>1、RAM优化</h5><p>主要是降低运行时内存。它的目的如下：</p><ul><li>防止应用发生OOM。</li><li>降低应用由于内存过大被LMK机制杀死的概率。</li><li>避免不合理使用内存导致GC次数增多，从而导致应用发生卡顿。</li></ul><h5 id="2、ROM优化"><a href="#2、ROM优化" class="headerlink" title="2、ROM优化"></a>2、ROM优化</h5><p>降低应用占ROM的体积。APK瘦身。它的目的为：</p><ul><li>降低应用占用空间，避免因ROM空间不足导致程序无法安装</li></ul><h4 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h4><p>那么，内存问题主要是有哪几类呢？下面我来一一叙述：</p><h5 id="1、内存抖动"><a href="#1、内存抖动" class="headerlink" title="1、内存抖动"></a>1、内存抖动</h5><p>内存波动图形呈锯齿张、GC导致卡顿。</p><p>这个问题在Dalvik虚拟机上会更加明显，而ART虚拟机在内存管理跟回收策略上都做了大量优化，内存分配和GC效率相比提升了5~10倍。</p><h5 id="2、内存泄漏"><a href="#2、内存泄漏" class="headerlink" title="2、内存泄漏"></a>2、内存泄漏</h5><p>对象被持有导致无法释放或不能按照对象正常的生命周期进行释放。</p><p>可用内存减少、频繁GC，容易导致内存泄漏。</p><h5 id="3、内存溢出"><a href="#3、内存溢出" class="headerlink" title="3、内存溢出"></a>3、内存溢出</h5><p>OOM、程序异常。</p><h3 id="二、常见工具选择"><a href="#二、常见工具选择" class="headerlink" title="二、常见工具选择"></a>二、常见工具选择</h3><p>在内存优化的上一篇我们已经介绍过了相关的工具，这里再简单回忆一下。</p><h4 id="1、Memory-Profiler"><a href="#1、Memory-Profiler" class="headerlink" title="1、Memory Profiler"></a>1、Memory Profiler</h4><p>它的作用如下：</p><ul><li>实时图表展示应用内存使用量</li><li>识别内存泄漏、抖动等</li><li>提供捕获堆转储、强制GC以及根据内存分配的能力</li></ul><p>它的优点即：</p><ul><li>方便直观</li><li>线下使用</li></ul><h4 id="2、Memory-Analyzer"><a href="#2、Memory-Analyzer" class="headerlink" title="2、Memory Analyzer"></a>2、Memory Analyzer</h4><p>强大的Java Heap分析工具，查找内存泄漏及内存占用<br>生成整体报告、分析问题等。建议线下深入使用。</p><h4 id="3、LeakCanary"><a href="#3、LeakCanary" class="headerlink" title="3、LeakCanary"></a>3、LeakCanary</h4><p>自动内存泄漏检测神器。仅用于线下集成。</p><p>它的缺点比较明显，虽然使用了idleHandler与多进程，但是dumphprof的SuspendAll Thread的特性依然会导致应用卡顿。<br>在三星等手机，系统会缓存最后一个Activity，此时应该采用更严格的检测模式。</p><h4 id="4、那么如何定制线上的LeakCanary？"><a href="#4、那么如何定制线上的LeakCanary？" class="headerlink" title="4、那么如何定制线上的LeakCanary？"></a>4、那么如何定制线上的LeakCanary？</h4><p>定制LeakCanary其实就是对haha组件来进行定制。haha库是square出品的一款<strong>自动分析Android堆栈的java库</strong>。haha库的<a href="https://github.com/square/haha" target="_blank" rel="external">链接地址</a>。</p><p>它的基本用法如下所示：</p><pre><code>// 导出堆栈文件File heapDumpFile = ...Debug.dumpHprofData(heapDumpFile.getAbsolutePath());// 根据堆栈文件创建出内存映射文件缓冲区DataBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);// 根据文件缓存区创建出对应的快照Snapshot snapshot = Snapshot.createSnapshot(buffer);// 从快照中获取指定的类ClassObj someClass = snapshot.findClass(&quot;com.example.SomeClass&quot;);</code></pre><p>在实现线上版的LeakCanary的时候主要要做2个工作：</p><ul><li>1、在过程中加上对大对象的分析过程。</li><li>2、解决掉将hprof文件映射到内存中的时候可能内存暴涨的问题。</li></ul><h4 id="5、实现内存泄漏监控闭环"><a href="#5、实现内存泄漏监控闭环" class="headerlink" title="5、实现内存泄漏监控闭环"></a>5、实现内存泄漏监控闭环</h4><p>在实现了线上版的LeakCanary之后，就需要将线上版的LeakCanary与服务器和前端页面结合起来。例如，当LeakCanary上发现内存泄漏时，手机将上传内存快照至服务器，此时服务器分析Hprof，如果不是系统原因导致误报则通过git得到该最近修改人，最后将内存泄漏bug单提交给负责人。该负责人通过前端实现的bug单系统即可看到自己新增的bug。</p><h3 id="三、Android内存管理机制回顾"><a href="#三、Android内存管理机制回顾" class="headerlink" title="三、Android内存管理机制回顾"></a>三、Android内存管理机制回顾</h3><p>ART和Dalvik虚拟机使用分页和内存映射来管理内存。下面我们先从Java的内存分配开始说起。</p><h4 id="1、Java内存分配"><a href="#1、Java内存分配" class="headerlink" title="1、Java内存分配"></a>1、Java内存分配</h4><p>Java的内存分配区域为如下几部分：</p><ul><li>方法区:主要存放静态常量</li><li>虚拟机栈：Java变量引用</li><li>本地方法栈：native变量引用</li><li>堆：对象</li><li>程序计数器：计算当前线程的当前方法执行到多少行</li></ul><h4 id="2、Java内存回收算法"><a href="#2、Java内存回收算法" class="headerlink" title="2、Java内存回收算法"></a>2、Java内存回收算法</h4><h5 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h5><p>流程可简述为两步：</p><ul><li>标记所有需要回收的对象</li><li>统一回收所有被标记的对象</li></ul><p>它的优点实现比较简单，缺点也很明显：</p><ul><li>标记、清除效率不高</li><li>产生大量内存碎片</li></ul><h5 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h5><p>流程可简述为三步：</p><ul><li>将内存划分为大小相等的两块</li><li>一块内存用完之后复制存活对象到另一块</li><li>清理另一块内存</li></ul><p>它的优点为 实现简单，运行高效，每次仅需遍历标记一半的内存区域。而缺点则会浪费一半空间，代价大。</p><h5 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h5><p>流程可简述为三步：</p><ul><li>标记过程与”标记-清除算法“一样</li><li>存活对象往一端进行移动</li><li>清理其余内存</li></ul><p>它的优点如下：</p><ul><li>避免标记-清除导致的内存碎片</li><li>避免复制算法的空间浪费</li></ul><h5 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h5><p>现在主流的虚拟机一般用的比较多的还是分带收集算法，它具有如下特点：</p><ul><li>结合多种算法优势</li><li>新生代对象存活率低，复制</li><li>老年代对象存活率高，标记-整理</li></ul><h4 id="3、Android内存管理机制"><a href="#3、Android内存管理机制" class="headerlink" title="3、Android内存管理机制"></a>3、Android内存管理机制</h4><p>Android中的内存是弹性分配的，分配值与最大值受具体设备影响。</p><p>对于OOM场景其实由细分为两种，一种是内存真正不足<br>了，二另一种则是可用内存不足。要注意一下这两种的区分。</p><p>以Android中的虚拟机的角度来说，我们要清楚Dalvik与Art区别，Dalvik仅固定一种回收算法，而Art回收算法可运行期选择，并且，Art具备内存整理能力，减少内存空洞。</p><p>最后，LMK机制（Low Memory killer）保证了进程资源的合理利用，它的实现原理主要是根据进程分类和回收收益来综合决定的。</p><h3 id="四、内存抖动"><a href="#四、内存抖动" class="headerlink" title="四、内存抖动"></a>四、内存抖动</h3><p>当内存频繁分配和回收导致内存不稳定，就会出现内存抖动，它通常表现为 <strong>频繁GC、内存曲线呈锯齿状</strong>。</p><p>它的危害也很严重，通常会导致页面卡顿，甚至造成OOM。</p><h4 id="那么为什么内存抖动会导致OOM？"><a href="#那么为什么内存抖动会导致OOM？" class="headerlink" title="那么为什么内存抖动会导致OOM？"></a>那么为什么内存抖动会导致OOM？</h4><p>主要原因有两点：</p><ul><li>频繁创建对象，导致内存不足及碎片（不连续）</li><li>不连续的内存片无法被分配，导致OOM</li></ul><h4 id="内存抖动解决实战"><a href="#内存抖动解决实战" class="headerlink" title="内存抖动解决实战"></a>内存抖动解决实战</h4><p>点击按钮使用handler发送一个空消息，handler的handleMessage接收到消息后创建内存抖动：即在for循环创建100个容量为10万的strings数组并在30ms后继续发送空消息。</p><p>一般使用Memory Profiler或CPU Profiler结合代码排查即可找到内存抖动出现的地方。</p><p>通常的技巧就是着重查看循环或频繁调用的地方。</p><p>下面列举一些导致内存抖动的常见案例：</p><h5 id="1、字符串使用加号拼接："><a href="#1、字符串使用加号拼接：" class="headerlink" title="1、字符串使用加号拼接："></a>1、字符串使用加号拼接：</h5><ul><li>使用StringBuilder替代。</li><li>初始化时设置容量，减少StringBuilder的扩容。</li></ul><h5 id="2、资源复用"><a href="#2、资源复用" class="headerlink" title="2、资源复用"></a>2、资源复用</h5><ul><li>使用全局缓存池，以重用频繁申请和释放的对象。</li><li>注意结束使用后，需要手动释放对象池中的对象。</li></ul><h5 id="3、减少不合理的对象创建"><a href="#3、减少不合理的对象创建" class="headerlink" title="3、减少不合理的对象创建"></a>3、减少不合理的对象创建</h5><ul><li>ondraw、getView中对象的创建尽量进行复用。</li><li>避免在循环中不断创建局部变量。</li></ul><h5 id="4、使用合理的数据结构"><a href="#4、使用合理的数据结构" class="headerlink" title="4、使用合理的数据结构"></a>4、使用合理的数据结构</h5><p>使用SparseArray类族来替代HashMap。</p><h3 id="五、内存优化体系搭建"><a href="#五、内存优化体系搭建" class="headerlink" title="五、内存优化体系搭建"></a>五、内存优化体系搭建</h3><p>在开始我们今天正式的主题之前，我们先来回归一下内存泄漏的概念与解决技巧。</p><p>所谓的内存泄漏就是<strong>内存中存在已经没有用的对象。</strong>它的表现一般为 内存抖动、可用内存逐渐减少。<br>它的危害即会导致内存不足、GC频繁、OOM。</p><p>内存泄漏的分析一般可简述为两步：</p><ul><li>1、使用Memory Profiler初步观察。</li><li>2、通过Memory Analyzer结合代码确认。</li></ul><h4 id="1、MAT回顾"><a href="#1、MAT回顾" class="headerlink" title="1、MAT回顾"></a>1、MAT回顾</h4><h5 id="MAT查找内存泄漏"><a href="#MAT查找内存泄漏" class="headerlink" title="MAT查找内存泄漏"></a>MAT查找内存泄漏</h5><p>首先找到当前Activity，在Histogram中选择其List Objects中的 with incoming reference（哪些强引用引向了我），然后选择当前的一个Path to GC Roots/Merge to GC Roots的exclude All 弱软虚引用。最后找到最后的泄漏对象在左下角下会有一个小圆圈。</p><h5 id="MAT的关键使用细节"><a href="#MAT的关键使用细节" class="headerlink" title="MAT的关键使用细节"></a>MAT的关键使用细节</h5><p>要全面掌握MAT的用法，必须先了解下面的一些细节：</p><ul><li>善于使用Regex查找对应泄漏类。</li><li>使用group by package查找对应包下的具体类。</li></ul><p>其次，要明白with outgoing references和with incoming references的区别。</p><p>with outgoing references为它引用了哪些对象，with incoming references为哪些对象引用了它。</p><p>还需要了解Shallow Heap和Retained Heap的区别。</p><p>Shallow Heap为对象自身占用的内存，而Retained Heap则还包含对象引用的对象所占用的内存。</p><p>除此之外，MAT共有5个关键组件帮助我们去分析内存方面的问题，他们分别是Dominator_tree<br>、Histogram、thread_overview、Top Consumers、Leak Suspects。下面我们简单地了解一下它们。</p><h5 id="Dominator（支配者）："><a href="#Dominator（支配者）：" class="headerlink" title="Dominator（支配者）："></a>Dominator（支配者）：</h5><p>如果从GC Root到达对象A的路径上必须经过对象B，那么B就是A的支配者。</p><h5 id="Histogram和dominator-tree的区别："><a href="#Histogram和dominator-tree的区别：" class="headerlink" title="Histogram和dominator_tree的区别："></a>Histogram和dominator_tree的区别：</h5><ul><li>Histogram显示Shallow Heap、Retained Heap、Objects，而dominator_tree显示的是Shallow Heap、Retained Heap、Percentage。</li><li>Histogram基于类的角度，dominator_tree是基于实例的角度。Histogram不会具体显示每一个泄漏的对象，而dominator_tree会。</li></ul><h5 id="thread-overview"><a href="#thread-overview" class="headerlink" title="thread_overview"></a>thread_overview</h5><p>查看有多少线程和线程的Shallow Heap、Retained Heap、Context Class Loader与is Daemon。</p><h5 id="Top-Consumers"><a href="#Top-Consumers" class="headerlink" title="Top Consumers"></a>Top Consumers</h5><p>通过图形的形式列出占用内存比较多的对象。</p><p>在下方的Biggest Objects还可以查看其相对比较详细的信息，如Shallow Heap、Retained Heap。</p><h5 id="Leak-Suspects"><a href="#Leak-Suspects" class="headerlink" title="Leak Suspects"></a>Leak Suspects</h5><p>列出有内存泄漏的地方，点击Details可以查看其产生内存泄漏的引用链。</p><p>最后，我列举一些内存泄漏优化的技巧：</p><ul><li>1、使用类似Hack的方式修复系统内存泄漏：<br>LeakCanary的AndroidExcludeRefs列出了一些由于系统原因导致引用无法释放的例子，可使用类似Hack的方式去修复。</li><li>2、Activity的兜底内存回收策略：<br>在Activity的onDestory中递归释放其引用到的Bitmap、DrawingCache等资源，降低发生内存泄漏对应用内存的压力。</li></ul><h4 id="2、建立线上内存泄漏监控组件：使用定制化的LeakCanary"><a href="#2、建立线上内存泄漏监控组件：使用定制化的LeakCanary" class="headerlink" title="2、建立线上内存泄漏监控组件：使用定制化的LeakCanary"></a>2、建立线上内存泄漏监控组件：使用定制化的LeakCanary</h4><p>在线上也可以使用类似LeakCanary的自动化检测方案，但是需要对生成的Hprof内存快照文件做一些优化，裁剪大部分图片对应的byte数据以减少文件开销，最后使用7zip压缩，一般可节省90%大小。</p><h4 id="3、建立线上OOM监控组件：Probe"><a href="#3、建立线上OOM监控组件：Probe" class="headerlink" title="3、建立线上OOM监控组件：Probe"></a>3、建立线上OOM监控组件：Probe</h4><p>美团Android内存泄漏自动化链路分析组件Probe<br>在OOM时生成Hprof内存快照，然后通过单独进程对这个文件做进一步分析。</p><p>它的缺点比较多，具体为如下几点：</p><ul><li>在崩溃的时候生成内存快照容易导致二次崩溃。</li><li>部分手机生成Hprof快照比较耗时。</li><li>部分OOM是由虚拟内存不足导致。</li></ul><p>在实现自动化链路分析组件Probe的过程中主要要解决如下问题：</p><h5 id="1、链路分析时间过长"><a href="#1、链路分析时间过长" class="headerlink" title="1、链路分析时间过长"></a>1、链路分析时间过长</h5><ul><li>使用链路归并，将具有相同层级与结构的链路进行合并。</li><li>使用自适应扩容法，通过不断比较现有链路和新链路，结合扩容因子，逐渐完善为完整的泄漏链路。</li></ul><h5 id="2、分析进程占用内存过大"><a href="#2、分析进程占用内存过大" class="headerlink" title="2、分析进程占用内存过大"></a>2、分析进程占用内存过大</h5><p>分析进程占用的内存跟内存快照文件的大小不成正相关，而跟内存快照文件的Instance数量呈正相关。所以应该尽可能排除不需要的Instance实例。</p><h5 id="Prope分析流程"><a href="#Prope分析流程" class="headerlink" title="Prope分析流程"></a>Prope分析流程</h5><p>1、hprof 映射到内存 -&gt; 解析成Snapshot &amp; 计数压缩：</p><p>解析后的Snapshot中的Heap有四种类型，具体为：</p><ul><li>DefaultHeap</li><li>ImageHeap</li><li>App Heap：包括ClassInstance、ClassObj、ArrayInstance、RootObj。</li><li>System Heap</li></ul><p>解析完后使用了计数压缩策略，对相同的Instance使用计数，以减少占用内存。超过计数阈值的需要计入计数桶（计数桶记录了丢弃个数和每个Instance的大小）。</p><p>2、生成Dominator Tree。</p><p>3、计算RetainSize。</p><p>4、生成Reference链 &amp; 基础数据类型增强:</p><p>如果对象是基础数据类型，会将自身的RetainSize累加到父节点上，将怀疑对象替换为它的父节点。</p><p>5、链路归并。</p><p>6、计数桶补偿 &amp; 基础数据类型和父节点融合：</p><p>使用计数补偿策略计算RetainSize，主要是判断对象是否在计数桶中，如果在的话则将丢弃的个数和大小补偿到对象上，累积计算RetainSize，最后对RetainSize排序以查找可疑对象。</p><p>7、排序扩容。</p><p>8、查找泄露链路。</p><p>总体架构图如下：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/probe.jpg?raw=true" alt="image"></p><h4 id="4、实现单机版的Profile-Memory自动化内存分析"><a href="#4、实现单机版的Profile-Memory自动化内存分析" class="headerlink" title="4、实现单机版的Profile - Memory自动化内存分析"></a>4、实现单机版的Profile - Memory自动化内存分析</h4><p><a href="https://github.com/JsonChao/Chapter03" target="_blank" rel="external">项目地址点击此处</a></p><p>在配置的时候要注意两个问题：</p><ul><li>1、liballoc-lib.so在构建后工程的build-&gt;intermediates-&gt;cmake目录下。将对应的cpu abi目录拷贝到新建的libs目录下。</li><li>2、在DumpPrinter Java库的build.gradle中的jar闭包中需要加入以下代码以识别源码路径</li></ul><pre><code>sourceSets.main.java.srcDirs = [&apos;src&apos;]</code></pre><p>具体的使用步骤如下：</p><p>1、点击”开<br>始记录“按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配。</p><pre><code>12-26 10:54:03.963 30450-30450/com.dodola.alloctrack I/AllocTracker: ====current alloc count 388=====</code></pre><p>2、然后，点击多次”生成1000个对象“按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。</p><pre><code>12-26 10:54:03.963 30450-30450/com.dodola.alloctrack I/AllocTracker: ====current alloc count 388=====12-26 10:56:45.103 30450-30450/com.dodola.alloctrack I/AllocTracker: saveARTAllocationData write file to /storage/emulated/0/crashDump/1577329005</code></pre><p>3、可以看到数据保存在sdk下的crashDump目录下。</p><p>4、此时，通过gradle task :buildAlloctracker任务编译出存放在tools/DumpPrinter-1.0.jar的dump工具，然后采用如下命令来将数据解析到dump_log.txt文件中。</p><pre><code>java -jar tools/DumpPrinter-1.0.jar dump文件路径 &gt; dump_log.txt</code></pre><p>5、最后，就可以在dump_log.txt文件中看到解析出来的数据，如下所示：</p><pre><code>Found 4949 records:tid=1 byte[] (94208 bytes)    dalvik.system.VMRuntime.newNonMovableArray (Native method)    android.graphics.Bitmap.nativeCreate (Native method)    android.graphics.Bitmap.createBitmap (Bitmap.java:975)    android.graphics.Bitmap.createBitmap (Bitmap.java:946)    android.graphics.Bitmap.createBitmap (Bitmap.java:913)    android.graphics.drawable.RippleDrawable.updateMaskShaderIfNeeded (RippleDrawable.java:776)    android.graphics.drawable.RippleDrawable.drawBackgroundAndRipples (RippleDrawable.java:860)    android.graphics.drawable.RippleDrawable.draw (RippleDrawable.java:700)    android.view.View.getDrawableRenderNode (View.java:17736)    android.view.View.drawBackground (View.java:17660)    android.view.View.draw (View.java:17467)    android.view.View.updateDisplayListIfDirty (View.java:16469)    android.view.ViewGroup.recreateChildDisplayList (ViewGroup.java:3905)    android.view.ViewGroup.dispatchGetDisplayList (ViewGroup.java:3885)    android.view.View.updateDisplayListIfDirty (View.java:16429)    android.view.ViewGroup.recreateChildDisplayList (ViewGroup.java:3905)</code></pre><h4 id="5、图片监控体系搭建"><a href="#5、图片监控体系搭建" class="headerlink" title="5、图片监控体系搭建"></a>5、图片监控体系搭建</h4><p>在介绍图片监控体系的搭建之前，首先我们来回顾下Android Bitmap内存分配的变化：</p><p><strong>在Android 3.0之前</strong></p><ul><li>Bitmap对象存放在Java Heap，而像素数据是存放在Native内存中的。</li><li>如果不手动调用recycle，Bitmap Native内存的回收完全依赖finalize函数回调，但是回调时机是不可控的。</li></ul><p><strong>Android 3.0 ~ Android 7.0</strong></p><p>将Bitmap对象和像素数据统一放到Java Heap中，即使不调用recycle，Bitmap像素数据也会随着对象一起被回收。</p><p>Bitmap全部放在Java Heap中的缺点很明显：</p><ul><li>1、Bitmap是内存消耗的大户，而Max Java Heap一般限制为256、512MB，Bitmap过大过多容易导致OOM。</li><li>2、容易引起大量GC，没有充分利用系统的可用内存。</li></ul><p><strong>Android 8.0及之后</strong></p><ul><li>使用了能够辅助回收Native内存的NativeAllocationRegistry，以实现将像素数据放到Native内存中，并且可以和Bitmap对象一起快速释放，最后，在GC的时候还可以考虑这些Bitmap内存以防止被滥用。</li><li>Android 8.0为了解决图片内存占用过多和图像绘制效率过慢的问题新增了硬件位图Hardware Bitmap。</li></ul><h5 id="那么，如何将图片内存存放在Native中呢？"><a href="#那么，如何将图片内存存放在Native中呢？" class="headerlink" title="那么，如何将图片内存存放在Native中呢？"></a>那么，如何将图片内存存放在Native中呢？</h5><ul><li>1、调用libandroid_runtime.so中的Bitmap构造函数，申请一张空的Native Bitmap。对于不同Android版本而言，这里的获取过程都有一些差异需要适配。</li><li>2、申请一张普通的Java Bitmap。</li><li>3、将Java Bitmap的内容绘制到Native Bitmap中。</li><li>4、释放Java Bitmap内存。</li></ul><p>我们都知道，当系统内存不足，LMK会根据OOM_adj开始杀进程，从后台、桌面、服务、前台，直到手机重启。并且，如果频繁申请释放Java Bitmap也很容易导致内存抖动。对于这种种问题，我们如何评估内存对应用性能的影响呢？</p><p>主要从以下两个方面进行评估：</p><ul><li>1、崩溃中异常退出和OOM的比例。</li><li>2、低内存设备更容易出现内存不足和卡顿，需要查看应用中用户的手机内存在2GB以下所占的比例。</li></ul><p>对于具体的优化策略，我们可以从以下几个方面来进行。</p><h5 id="1、设备分级"><a href="#1、设备分级" class="headerlink" title="1、设备分级"></a>1、设备分级</h5><p>内存优化首先需要根据设备环境来综合考虑，让高端设备使用更多的内存，做到针对设备性能的好坏使用不同的内存分配和回收策略。</p><p>使用类似device-year-class的策略对设备进行分级，对于低端机用户可以关闭复杂的动画或”重功能“，使用565格式的图片或更小的缓存内存等。</p><p>业务开发人员需要考虑功能是否对低端机开启，在系统资源不够时主动去做降级处理。</p><h5 id="2、建立统一的缓存管理组件"><a href="#2、建立统一的缓存管理组件" class="headerlink" title="2、建立统一的缓存管理组件"></a>2、建立统一的缓存管理组件</h5><p>建立统一的缓存管理组件，合理使用OnTrimMemory回调，根据系统不同的状态去释放相应的内存。</p><p>在实现过程中，需要解决使用static LRUCache来缓存大尺寸Bitmap等问题。</p><p>并且，在通过实际的测试后，发现onTrimMemory的ComponetnCallbacks2.TRIM_MEMORY_COMPLETE并不等价于onLowMemory，因此建议仍然要去监听onLowMemory回调。</p><h5 id="3、低端机避免使用多进程"><a href="#3、低端机避免使用多进程" class="headerlink" title="3、低端机避免使用多进程"></a>3、低端机避免使用多进程</h5><p>一个空进程也会占用10MB内存，低端机应该尽可能减少使用多进程。</p><p>针对低端机用户可以推出4MB的轻量级版本，如今日头条极速版、Facebook Lite。</p><h5 id="4、统一图片库"><a href="#4、统一图片库" class="headerlink" title="4、统一图片库"></a>4、统一图片库</h5><p>需要收拢图片的调用，避免使用Bitmap.createBitmap、BitmapFactory相关的接口创建Bitmap，应该使用自己的图片框架。</p><h5 id="5、线下大图片检测"><a href="#5、线下大图片检测" class="headerlink" title="5、线下大图片检测"></a>5、线下大图片检测</h5><p>在开发过程中，如果检测到不合规的图片使用（如图片宽度超过View的宽度甚至图片宽度），应该立刻提示图片所在的Activity和堆栈，让开发人员更快发现并解决问题。在灰度和线上环境，可以将异常信息上报到后台，还可以计算超宽率（图片超过屏幕大小所占图片总数的比例）。</p><p><strong>常规实现</strong>：</p><p>继承ImageView，重写实现计算图片大小。但是侵入性强，并且不通用。</p><p>下面介绍一下ARTHook的方案。</p><p><strong>ARTHook优雅检测大图</strong></p><p>ARTHook，即挂钩，用额外的代码勾住原有的方法，以修改执行逻辑，主要用于以下几方面：</p><ul><li>1、AOP变成</li><li>2、运行时插桩</li><li>3、性能分析</li><li>4、安全审计</li></ul><p>具体我们是使用Epic来进行Hook，Epic是一个虚拟机层面，以Java方法为粒度的运行时Hook框架。简单来说，它就是ART上的Dexposed，并且它目前支持Android 4.0~10.0。</p><p><a href="https://github.com/tiann/epic/blob/master/README_cn.md" target="_blank" rel="external">Epic github地址</a></p><p>Epic的使用可简述为：</p><p>1、在build.gradle中添加</p><pre><code>compile &apos;me.weishu:epic:0.6.0&apos;</code></pre><p>2、继承XC_MethodHook，实现Hook方法前后的逻辑。如监控Java线程的创建和销毁：</p><pre><code>class ThreadMethodHook extends XC_MethodHook{    @Override    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {        super.beforeHookedMethod(param);        Thread t = (Thread) param.thisObject;        Log.i(TAG, &quot;thread:&quot; + t + &quot;, started..&quot;);    }    @Override    protected void afterHookedMethod(MethodHookParam param) throws Throwable {        super.afterHookedMethod(param);        Thread t = (Thread) param.thisObject;        Log.i(TAG, &quot;thread:&quot; + t + &quot;, exit..&quot;);    }}</code></pre><p>3、注入Hook好的方法：</p><pre><code>DexposedBridge.findAndHookMethod(Thread.class, &quot;run&quot;, new ThreadMethodHook());</code></pre><p>知道了Epic的基本使用方法之后，我们便可以利用它来进行大图片的监控报警了。</p><p>以<a href="">Awesome-WanAndroid</a>项目为例，首先，在WanAndroidApp的onCreate方法中添加如下代码：</p><pre><code>DexposedBridge.hookAllConstructors(ImageView.class, new XC_MethodHook() {        @Override        protected void afterHookedMethod(MethodHookParam param) throws Throwable {            super.afterHookedMethod(param);        // 这里找到所有通过ImageView的setImageBitmap方法设置的切入点，        // 其中最后一个参数ImageHook对象是继承了XC_MethodHook类以便于        // 重写afterHookedMethod方法拿到相应的参数进行监控逻辑的判断        DexposedBridge.findAndHookMethod(ImageView.class, &quot;setImageBitmap&quot;, Bitmap.class, new ImageHook());        }    });</code></pre><p>接下来，我们来实现我们的ImageHook类，如下所示：</p><pre><code>public class ImageHook extends XC_MethodHook {    @Override    protected void afterHookedMethod(MethodHookParam param) throws Throwable {        super.afterHookedMethod(param);        // 实现我们的逻辑        ImageView imageView = (ImageView) param.thisObject;        checkBitmap(imageView,((ImageView) param.thisObject).getDrawable());    }    private static void checkBitmap(Object thiz, Drawable drawable) {        if (drawable instanceof BitmapDrawable &amp;&amp; thiz instanceof View) {            final Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();            if (bitmap != null) {                final View view = (View) thiz;                int width = view.getWidth();                int height = view.getHeight();                if (width &gt; 0 &amp;&amp; height &gt; 0) {                    // 图标宽高都大于view的2倍以上，则警告                    if (bitmap.getWidth() &gt;= (width &lt;&lt; 1)                        &amp;&amp;  bitmap.getHeight() &gt;= (height &lt;&lt; 1)) {                    warn(bitmap.getWidth(), bitmap.getHeight(), width, height, new RuntimeException(&quot;Bitmap size too large&quot;));                }                } else {                    // 当宽高度等于0时，说明ImageView还没有进行绘制，使用ViewTreeObserver进行大图检测的处理。                    final Throwable stackTrace = new RuntimeException();                    view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {                        @Override                        public boolean onPreDraw() {                            int w = view.getWidth();                            int h = view.getHeight();                            if (w &gt; 0 &amp;&amp; h &gt; 0) {                                if (bitmap.getWidth() &gt;= (w &lt;&lt; 1)                                    &amp;&amp; bitmap.getHeight() &gt;= (h &lt;&lt; 1)) {                                    warn(bitmap.getWidth(), bitmap.getHeight(), w, h, stackTrace);                                }                                view.getViewTreeObserver().removeOnPreDrawListener(this);                            }                            return true;                        }                    });                }            }        }    }    private static void warn(int bitmapWidth, int bitmapHeight, int viewWidth, int viewHeight, Throwable t) {        String warnInfo = &quot;Bitmap size too large: &quot; +            &quot;\n real size: (&quot; + bitmapWidth + &apos;,&apos; + bitmapHeight + &apos;)&apos; +            &quot;\n desired size: (&quot; + viewWidth + &apos;,&apos; + viewHeight + &apos;)&apos; +            &quot;\n call stack trace: \n&quot; + Log.getStackTraceString(t) + &apos;\n&apos;;        LogHelper.i(warnInfo);    }}</code></pre><p>在上面，我们重写了ImageHook的afterHookedMethod方法，拿到了当前的ImageView和要设置的Bitmap对象，如果当前ImageView的宽高大于0，我们便进行大图检测的处理：ImageView的宽高都大于View的2倍以上，则警告，如果当前ImageView的宽高等于0，则说明ImageView还没有进行绘制，则使用ImageView的ViewTreeObserer获取其宽高进行大图检测的处理。至此，我们的大图检测检测组件就实现了。</p><p><strong>ARTHook方案实现小结</strong></p><ul><li>1、无侵入性</li><li>2、通用性强</li><li>3、兼容性问题大，开源方案不能带到线上环境。</li></ul><h5 id="6、线下重复图片检测"><a href="#6、线下重复图片检测" class="headerlink" title="6、线下重复图片检测"></a>6、线下重复图片检测</h5><p><a href="完全配置好的项目请参见https://github.com/JsonChao/Chapter04">项目地址</a></p><p>首先我们来了解一下这里的重复图片所指的概念：<br>即Bitmap像素数据完全一致，但是有多个不同的对象存在。</p><p>使用内存Hprof分析工具，自动将重复Bitmap的图片和引用堆栈输出。具体实现步骤如下：</p><ul><li>1、获取 android.graphics.Bitmap 实例对象的 mBuffer 为 ArrayInstance ，通过 getValues 获取数据为 Object 类型，后面计算 md5 需要为 byte[] 类型，所以通过反射的方式调用 ArrayInstance#asRawByteArray 直接返回 byte[] 数据。</li><li>2、根据 mBuffer 的数据生成 png 图片文件，参考了 <a href="https://github.com/JetBrains/adt-tools-base/blob/master/ddmlib/src/main/java/com/android/ddmlib/BitmapDecoder.java" target="_blank" rel="external">https://github.com/JetBrains/adt-tools-base/blob/master/ddmlib/src/main/java/com/android/ddmlib/BitmapDecoder.java</a> 实现。</li><li>3、获取堆栈信息，直接使用LeakCanary获取stack的方法，使用leakcanary-analyzer-1.6.2.jar 和 leakcanary-watcher-1.6.2.jar 这两个库文件。并用反射的方式调用了HeapAnalyzer#findLeakTrace 方法。</li></ul><p>其中，获取堆栈的信息也可以直接使用haha库来进行获取。这里简单说一下使用haha库获取堆栈的流程。</p><ul><li>1、预备一个已经存在重复bitmap的hprof文件。</li><li>2、利用HAHA库上的MemoryMappedFileBuffer读取hrpof文件 [关键代码 new MemoryMappedFileBuffer(heapDumpFile) ]</li><li>3、解析生成snapshot，获取heap，这里我只获取了app heap [关键代码 snapshot.getHeaps(); heap.getName().equals(“app”) ]</li><li>4、从snapshot中根据指定class查找出所有的Bitmap Classes [关键代码snapshot.findClasses(Bitmap.class.getName()) ]</li><li>5、从heap中获得所有的Bitmap实例instance [关键代码 clazz.getHeapInstances(heap.getId()) ]</li><li>6、根据instance中获取所有的属性信息Field[]，并从Field[]查找出我们需要的”mWidth” “mHeight” “mBuffer”信息</li><li>7、通过”mBuffer”属性即可获取他们的hashcode来判断相同</li><li>8、最后通过instance中mNextInstanceToGcRoot获取整个引用链信息并打印。</li></ul><p>在实现图片内存监控的过程中，应注意一下两点：</p><ul><li>1、在线上可以按照不同的系统、屏幕分辨率等纬度去分析图片内存的占用情况。</li><li>2、在OOM崩溃时，可以将图片总内存、Top N图片占用内存写入崩溃日志。</li></ul><h5 id="7、建立全局Bitmap监控"><a href="#7、建立全局Bitmap监控" class="headerlink" title="7、建立全局Bitmap监控"></a>7、建立全局Bitmap监控</h5><p>为了建立全局的Bitmap监控，我们必须对Bitmap的分配和回收进行追踪。我们先来看看Bitmap有哪些特点：</p><ul><li>创建场景比较单一：在Java层调用Bitmap.create或BitmapFactory等方法创建，可以封装一层对Bitmap创建的接口，注意要包含调用外部库产生的Bitmap。</li><li>创建频率比较低。</li><li>和Java对象的生命周期一样服从GC，可以使用WeakReference来追踪Bitmap的销毁。</li></ul><p>根据以上特点，我们可以建立一套Bitmap的高性价比监控组件：</p><ul><li>1、首先，在接口层将所有创建出来的Bitmap放入一个WeakHashMap中，并记录创建Bitmap的数据、堆栈等信息，然后每隔一定时间查看WeakHashMap中有哪些Bitmap仍然存活来判断是否出现Bitmap滥用或泄漏。</li><li>2、这个方案性能消耗很低，可以在正式环境中进行。注意正式与测试环境需要采用不同程度的监控。</li></ul><h4 id="6、建立全局的线程监控组件"><a href="#6、建立全局的线程监控组件" class="headerlink" title="6、建立全局的线程监控组件"></a>6、建立全局的线程监控组件</h4><p>每个线程初始化都需要mmap一定的栈大小，在默认情况下初始化一个线程需要mmap 1MB左右的内存空间，在32bit的应用中有4g的vmsize，实际能使用的有3g+，这样一个进程最大能创建的线程数可以达到3000个，但是linux对每个进程可创建的线程数也有一定的限制（/proc/pid/limits），并且不同厂商也能修改这个限制，超过该限制就会OOM。</p><p>对线程数量的限制，一定程度上可以避免OOM的发生。</p><h5 id="线程监控组件的实现原理"><a href="#线程监控组件的实现原理" class="headerlink" title="线程监控组件的实现原理"></a>线程监控组件的实现原理</h5><p>在线下或灰度的环境下通过一个定时器每隔10分钟dump出应用所有的线程相关信息，当线程数超过当前阈值时，将当前的线程信息上报并预警。</p><h4 id="7、建立线上应用内存监控体系"><a href="#7、建立线上应用内存监控体系" class="headerlink" title="7、建立线上应用内存监控体系"></a>7、建立线上应用内存监控体系</h4><p>具体的相关数据获取方式如下：</p><ul><li>1、首先，ActivityManager的getProcessMemoryInfo -&gt; Debug.MemoryInfo数据。</li><li>2、通过hook Debug.MemoryInfo的getMemoryStat方法（os v23及以上）可以获得Memory Profiler中的多项数据，进而获得细分内存使用情况。</li><li>3、通过Runtime获取DalvikHeap。</li><li>4、通过Debug.getNativeHeapAllocatedSize获取NativeHeap。</li></ul><p>对于监控场景，需要划分为两大类：</p><h5 id="1、常规内存监控"><a href="#1、常规内存监控" class="headerlink" title="1、常规内存监控"></a>1、常规内存监控</h5><p>根据斐波那契数列每隔一段时间（max：30min）获取内存的使用情况。内存监控方法有多种实现方式，我们先来介绍几种常规方式。</p><p><strong>针对场景进行线上Dump内存的方式</strong>：</p><p>具体使用Debug.dumpHprofData()实现。</p><p>其实现的流程为：</p><ul><li>1、超过最大内存的80%</li><li>2、内存Dump</li><li>3、回传文件</li><li>4、MAT手动分析</li></ul><p>但是有如下缺点：</p><ul><li>1、Dump文件太大，和对象数正相关，可以进行裁剪。</li><li>2、上传失败率高，分析困难。</li></ul><p><strong>LeakCanary带到线上的方式</strong>：</p><p>预设泄漏怀疑点，一旦发现泄漏进行回传。但这种实现方式缺点比较明显：</p><ul><li>不适合所有情况，需要预设怀疑点。</li><li>分析比较耗时，容易导致OOM。</li></ul><p><strong>定制LeakCanary方式</strong></p><p>定制LeakCanary需要解决以上产生的一些问题，下面这里分别列出对应的解决方案：</p><ul><li>1、预设怀疑点-&gt;自动找怀疑点。</li><li>2、分析泄漏链路慢-&gt;分析Retain size大的对象。</li><li>3、分析OOM-&gt;对象裁剪，不全部加载到内存。</li></ul><h5 id="2、低内存监控"><a href="#2、低内存监控" class="headerlink" title="2、低内存监控"></a>2、低内存监控</h5><ul><li>利用onLowMemory、onTrimMemory监听物理内存警告。</li><li>代码设置超过虚拟内存大小最大限制的90%则直接触发内存警告。</li><li>对于监控指标，一般为：发生频率、发生时各项内存使用状况、发生时App的当前场景。</li></ul><p>并且，为了准确衡量内存性能，我们引入了内存异常率和触顶率的指标。</p><p><strong>内存异常率</strong></p><p>内存UV异常率 = PSS 超过400MB的UV / 采集UV，PSS获取：通过Debug.MemoryInfo。</p><p>如果出现新的内存使用不当或内存泄漏的场景，这个指标会有所上涨。</p><p><strong>触顶率</strong></p><p>内存UV触顶率 = Java堆占用超过最大堆限制的85%的UV / 采集UV</p><p>计算触顶率的代码如下所示：</p><pre><code>long javaMax = Runtime.maxMemory();long javaTotal = Runtime.totalMemory();long javaUsed = javaTotal - runtime.freeMemory();float proportion = (float) javaUsed / javaMax;</code></pre><p>如果超过85%最大堆限制，GC会变得更加频发，容易造成OOM和卡顿。</p><p>这里小结一下，客户端只负责上报数据，由后台来计算平均PSS、图片内存、Java内存、异常率、触顶率等指标值，这样便可以通过版本对比来监控是否有新增内存问题。因此，建立线上监控完整方案需包含以下几点：</p><ul><li>待机内存、重点模块内存、OOM率。</li><li>整体及重点模块GC次数、GC时间。</li><li>增强的LeakCanry自动化内存泄漏分析。</li><li>低内存监控模块的设置。</li></ul><h4 id="8、GC监控组件搭建"><a href="#8、GC监控组件搭建" class="headerlink" title="8、GC监控组件搭建"></a>8、GC监控组件搭建</h4><p>通过Debug.startAllocCounting来监控GC情况，注意有一定性能影响。</p><p>在Android 6.0之前可以拿到内存分配次数和大小以及GC次数，代码如下所示：</p><pre><code>long allocCount = Debug.getGlobalAllocCount();long allocSize = Debug.getGlobalAllocSize();long gcCount = Debug.getGlobalGcInvocationCount();</code></pre><p>并且，在Android 6.0后可以拿到更精准的GC信息：</p><pre><code>Debug.getRuntimeStat(&quot;art.gc.gc-count&quot;);Debug.getRuntimeStat(&quot;art.gc.gc-time&quot;);Debug.getRuntimeStat(&quot;art.gc.blocking-gc-count&quot;);Debug.getRuntimeStat(&quot;art.gc.blocking-gc-time&quot;);</code></pre><p>一般关注阻塞式GC的次数和耗时，因为它会暂停线程，可能导致应用发生卡顿。建议仅对重度场景使用。</p><h4 id="9、设置内存兜底策略"><a href="#9、设置内存兜底策略" class="headerlink" title="9、设置内存兜底策略"></a>9、设置内存兜底策略</h4><p>设置内存兜底策略的目的，是为了在用户无感知的情况下，在接近触发系统异常前，选择合适的场景杀死进程并将其重启，从而使得应用内存占用回到正常情况。</p><p>一般进行执行内存兜底策略时需要满足以下条件：</p><ul><li>是否在主界面退到后台且位于后台时间超过30min。</li><li>当前时间为早上2~5点。</li><li>不存在前台服务（通知栏、音乐播放栏等情况）。</li><li>java heap必须大于当前进程最大可分配的85% || native内存大于800MB </li><li>vmsize超过了4G（32bit）的85%。</li><li>非大量的流量消耗（不超过1M/min） &amp;&amp; 进程无大量CPU调度情况。</li></ul><p>满足以上条件则杀死当前主进程并通过push进程重新拉起及初始化。</p><h4 id="10、内存优化的一些策略"><a href="#10、内存优化的一些策略" class="headerlink" title="10、内存优化的一些策略"></a>10、内存优化的一些策略</h4><p>下面列举一些我在内存优化过程中常用的一些策略。</p><h5 id="1、使bitmap资源在native中分配："><a href="#1、使bitmap资源在native中分配：" class="headerlink" title="1、使bitmap资源在native中分配："></a>1、使bitmap资源在native中分配：</h5><p>对于Android 2.x系统，使用反射将BitmapFactory.Options里面隐藏的inNativeAlloc打开。</p><p>对于Android 4.x系统，使用Fresco将bitmap资源在native中分配。</p><h5 id="2、使用inSampleSize避免不必要的大图加载。"><a href="#2、使用inSampleSize避免不必要的大图加载。" class="headerlink" title="2、使用inSampleSize避免不必要的大图加载。"></a>2、使用inSampleSize避免不必要的大图加载。</h5><h5 id="3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try-catch将其捕获，然后清除图片cache，尝试降低bitmap-format（ARGB8888、RGB565、ARGB4444、ALPHA8）。"><a href="#3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try-catch将其捕获，然后清除图片cache，尝试降低bitmap-format（ARGB8888、RGB565、ARGB4444、ALPHA8）。" class="headerlink" title="3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try catch将其捕获，然后清除图片cache，尝试降低bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。"></a>3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try catch将其捕获，然后清除图片cache，尝试降低bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。</h5><h5 id="4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80-）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。"><a href="#4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80-）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。" class="headerlink" title="4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。"></a>4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。</h5><p>计算当前应用内存占最大内存的比例的代码如下：</p><pre><code>max = Runtime.getRuntime().maxMemory();available = Runtime.getRuntime.totalMemory() - Runtime.getFreeMemory();ratio =available / max;</code></pre><p>显示地除去应用的memory，以加速内存收集的过程的代码如下：</p><pre><code>WindowManagerGlobal.getInstance().startTrimMemory(TRIM_MEMORY_COMPLETE);</code></pre><h5 id="5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。"><a href="#5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。" class="headerlink" title="5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。"></a>5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。</h5><h5 id="6、应用发生OOM时，需要上传更加详细的内存相关信息。"><a href="#6、应用发生OOM时，需要上传更加详细的内存相关信息。" class="headerlink" title="6、应用发生OOM时，需要上传更加详细的内存相关信息。"></a>6、应用发生OOM时，需要上传更加详细的内存相关信息。</h5><h5 id="7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。"><a href="#7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。" class="headerlink" title="7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。"></a>7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。</h5><h5 id="8、当UI隐藏时释放内存"><a href="#8、当UI隐藏时释放内存" class="headerlink" title="8、当UI隐藏时释放内存"></a>8、当UI隐藏时释放内存</h5><p>当用户切换到其它应用并且你的应用UI不再可见时，应该释放应用UI所占用的所有内存资源。这能够显著增加系统缓存进程的能力，能够提升用户体验。</p><p>在所有UI组件都隐藏的时候会接收到Activity的onTrimMemory()回调并带有参数TRIM_MEMORY_UI_HIDDEN。</p><h5 id="9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。"><a href="#9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。" class="headerlink" title="9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。"></a>9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。</h5><h3 id="六、线下Native内存泄漏监控搭建"><a href="#六、线下Native内存泄漏监控搭建" class="headerlink" title="六、线下Native内存泄漏监控搭建"></a>六、线下Native内存泄漏监控搭建</h3><p>在Android 8.0之后，可以使用Address Sanitizer、Malloc调试和Malloc钩子进行native内存分析，参见<a href="https://source.android.com/devices/tech/debug/native-memory" target="_blank" rel="external">native_memory</a></p><p>对于线下Native内存泄漏监控的建立，主要针对是否能重编so的情况来进行记录分配的内存信息。</p><h4 id="针对无法重编so的情况"><a href="#针对无法重编so的情况" class="headerlink" title="针对无法重编so的情况"></a>针对无法重编so的情况</h4><ul><li>使用PLT Hook拦截库的内存分配函数，然后重定向到我们自己的实现后去记录分配的内存地址、大小、来源so库路径等信息。</li><li>定期扫描分配与释放释放配对，对于不配对的分配输出上述记录的信息。</li></ul><h4 id="针对可重编的so情况"><a href="#针对可重编的so情况" class="headerlink" title="针对可重编的so情况"></a>针对可重编的so情况</h4><ul><li>通过GCC的”-finstrument-functions“参数给所有函数插桩，然后在桩中模拟调用栈的入栈与出栈操作。</li><li>通过ld的”–warp“参数拦截内存分配和释放函数，重定向到我们自己的实现后记录分配的内存地址、大小、来源so以及插桩调用栈此刻的内容。</li><li>定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。</li></ul><h3 id="七、内存优化演进"><a href="#七、内存优化演进" class="headerlink" title="七、内存优化演进"></a>七、内存优化演进</h3><h4 id="1、自动化测试阶段"><a href="#1、自动化测试阶段" class="headerlink" title="1、自动化测试阶段"></a>1、自动化测试阶段</h4><p>内存达到阈值后自动触发Hprof Dump，将得到的Hprof存档后由人工通过MAT进行分析。</p><h4 id="2、LeakCanary"><a href="#2、LeakCanary" class="headerlink" title="2、LeakCanary"></a>2、LeakCanary</h4><p>检测和分析报告都在一起，批量自动化测试和事后分析不太方便。</p><h4 id="3、使用基于LeakCannary的改进版ResourceCanary"><a href="#3、使用基于LeakCannary的改进版ResourceCanary" class="headerlink" title="3、使用基于LeakCannary的改进版ResourceCanary"></a>3、使用基于LeakCannary的改进版ResourceCanary</h4><p>它的主要特点如下：</p><h5 id="1、分离检测和分析两部分流程"><a href="#1、分离检测和分析两部分流程" class="headerlink" title="1、分离检测和分析两部分流程"></a>1、分离检测和分析两部分流程</h5><p>自动化测试由测试平台进行，分析则由监控平台的服务端离线完成，再通知相关开发解决问题。</p><h5 id="2、裁剪Hprof文件，以降低后台存储Hprof的开销"><a href="#2、裁剪Hprof文件，以降低后台存储Hprof的开销" class="headerlink" title="2、裁剪Hprof文件，以降低后台存储Hprof的开销"></a>2、裁剪Hprof文件，以降低后台存储Hprof的开销</h5><p>获取需要的类和对象相关的字符串信息即可，其它数据都可以在客户端裁剪，一般能Hprof大小会减小至原来的1/10左右。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在研发阶段需要不断实现更多的工具和组件，以此系统化地提升自动化程度，以最终提升发现问题的效率。</p><h3 id="八、内存优化工具"><a href="#八、内存优化工具" class="headerlink" title="八、内存优化工具"></a>八、内存优化工具</h3><p>除了常用的内存分析工具Memory Profiler、MAT、LeakCanary之外，还有一些其它的内存分析工具，下面我将一一为大家进行介绍。</p><h4 id="1、top"><a href="#1、top" class="headerlink" title="1、top"></a>1、top</h4><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序。</p><p>接下来，我们输入以下命令查看top命令的用法：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell top --helpusage: top [-Hbq] [-k FIELD,] [-o FIELD,] [-s SORT] [-n NUMBER] [-d SECONDS] [-p PID,] [-u USER,]Show process activity in real time.-H    Show threads-k    Fallback sort FIELDS (default -S,-%CPU,-ETIME,-PID)-o    Show FIELDS (def PID,USER,PR,NI,VIRT,RES,SHR,S,%CPU,%MEM,TIME+,CMDLINE)-O    Add FIELDS (replacing PR,NI,VIRT,RES,SHR,S from default)-s    Sort by field number (1-X, default 9)-b    Batch mode (no tty)-d    Delay SECONDS between each cycle (default 3)-n    Exit after NUMBER iterations-p    Show these PIDs-u    Show these USERs-q    Quiet (no header lines)Cursor LEFT/RIGHT to change sort, UP/DOWN move list, space to forceupdate, R to reverse sort, Q to exit.</code></pre><p>这里使用top仅显示一次进程信息，以便来讲解进程信息中各字段的含义。</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/top.png?raw=true" alt="image"></p><p>前四行是当前系统情况整体的统计信息区。下面我们看每一行信息的具体意义。</p><p>第一行，Tasks — 任务（进程），具体信息说明如下：</p><p>系统现在共有729个进程，其中处于运行中的有1个，715个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有8个。</p><p>第二行,内存状态，具体信息如下：</p><p>5847124k total — 物理内存总量（5.8GB）</p><p>5758016k used — 使用中的内存总量（5.7GB）</p><p>89108k free — 空闲内存总量（89MB）</p><p>112428k buffers — 缓存的内存量 （112M）</p><p>第三行，swap交换分区信息，具体信息说明如下：</p><p>2621436k total — 交换区总量（2.6GB）</p><p>612572k used — 使用的交换区总量（612MB）</p><p>2008864k free — 空闲交换区总量（2GB）</p><p>2657696k cached — 缓冲的交换区总量（2.6GB）</p><p>第四行，cpu状态信息，具体属性说明如下：</p><p>800%cpu - 8核CPU。</p><p>39%user - 39%CPU被用户进程使用。</p><p>0%nice - 优先值为负的进程占0%。</p><p>42%sys — 内核空间占用CPU的百分比为42%。</p><p>712%idle - 除IO等待时间以外的其它等待时间为712%。</p><p>0%iow - IO等待时间占0%。</p><p>0%irq - 硬中断时间占0%。</p><p>6%sirq - 软中断时间占0%。</p><p>对于内存监控，在top里我们要时刻监控第三行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p><p>在第五行及以下，就是各进程（任务）的状态监控，项目列信息说明如下：</p><p>PID — 进程id。</p><p>USER — 进程所有者。</p><p>PR — 进程优先级。</p><p>NI — nice值。负值表示高优先级，正值表示低优先级。</p><p>VIRT — 进程使用的虚拟内存总量。VIRT = SWAP + RES。</p><p>RES — 进程使用的、未被换出的物理内存大小。RES = CODE + DATA。</p><p>SHR — 共享内存大小。</p><p>S — 进程状态。D=不可中断的睡眠状态、R=运行、 S=睡眠、T=跟踪/停止、Z=僵尸进程。</p><p>%CPU — 上次更新到现在的CPU时间占用百分比。</p><p>%MEM — 进程使用的物理内存百分比。</p><p>TIME+ — 进程使用的CPU时间总计，单位1/100秒。</p><p>ARGS — 进程名称（命令名/命令行）。</p><p>这里可以看到第一行的就是Awesome-WanAndroid这个应用的进程，它的进程名称为json.chao.com.w+，PID为23104，进程所有者USER为u0_a714，进程优先级PR为10，nice置NI为-10。进程使用的虚拟内存总量VIRT为4.3GB，进程使用的、未被换出的物理内存大小RES为138M，共享内存大小SHR为66M，进程状态S是睡眠状态，上次更新到现在的CPU时间占用百分比%CPU为21.2。进程使用的物理内存百分比%MEM为2.4%，进程使用的CPU时间TIME+为1:47.58/100小时。</p><h4 id="2、dumpsys-meminfo"><a href="#2、dumpsys-meminfo" class="headerlink" title="2、dumpsys meminfo"></a>2、dumpsys meminfo</h4><p>在讲解dumpsys meminfo命令之前，我们必须先了解下Android中的几个内存指标的概念：</p><table><thead><tr><th>内存指标</th><th>英文全称</th><th>含义</th><th>等价</th></tr></thead><tbody><tr><td>USS</td><td>Unique Set Size</td><td>物理内存</td><td>进程独占的内存</td><td></td></tr><tr><td>PSS</td><td>Proportional Set Size</td><td>物理内存</td><td>PSS = USS + 按比例包含共享库</td><td></td></tr><tr><td>RSS</td><td>Resident Set Size</td><td>物理内存</td><td>RSS= USS+ 包含共享库</td><td></td></tr><tr><td>VSS</td><td>Virtual Set Size</td><td>虚拟内存</td><td>VSS= RSS+ 未分配实际物理内存</td><td></td></tr></tbody></table><p>从上可知，它们之间内存的大小关系为VSS &gt;= RSS &gt;= PSS &gt;= USS。</p><p>RSS与PSS相似，也包含进程共享内存，但比较麻烦的是RSS并没有把共享内存大小全都平分到使用共享的进程头上，以至于所有进程的RSS相加会超过物理内存很多。而VSS是虚拟地址，它的上限与进程的可访问地址空间有关，和当前进程的内存使用关系并不大。比如有很多的map内存也被算在其中，我们都知道，file的map内存对应的可能是一个文件或硬盘，或者某个奇怪的设备，它与进程使用内存并没有多少关系。</p><p>而PSS、USS最大的不同在于“共享内存“（比如两个App使用MMAP方式打开同一个文件，那么打开文件而使用的这部分内存就是共享的），USS不包含进程间共享的内存，而PSS包含。这也造成了USS因为缺少共享内存，所有进程的USS相加要小于物理内存大小的原因。</p><p>最早的时候官方就推荐使用PSS曲线图来衡量App的物理内存占用，而Android 4.4之后才加入USS。但是PSS，有个很大的问题，就是”共享内存“，考虑一种情况，如果A进程与B进程都会使用一个共享SO库，那么so库中初始化所用掉的那部分内存就会平分到A与B的头上。但是A是在B之后启动的，那么对于B的PSS曲线而言，在A启动的那一刻，即使B没有做任何事情，也会出现一个比较大的阶梯状下滑，这会给用曲线图分析软件内存的行为造成致命的麻烦。</p><p>USS虽然没有这个问题，但是由于Dalvik虚拟机申请内存牵扯到GC时延和多种GC策略，这些都会影响到曲线的异常波动。比如异步GC是Android 4.0以上系统很重要的特性，但是GC什么时候结束？曲线什么时候”降低“？就无法预计了。还有GC策略，什么时候开始增加Dalvik虚拟机的预申请内幕才能大小（Dalvik启动时是由一个标称的start内存大小的,为Java代码运行时预留，避免Java运行时再申请而造成卡顿），但是这个预申请大小是动态变化的，这一点也会造成USS忽大忽小。</p><p>了解完Android内存的性能指标之后，下面我们便来说说dumpsys meminfo这个命令的用法，首先我们输入adb shell dumpsys meminfo -h查看它的帮助文档：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfo -hmeminfo dump options: [-a] [-d] [-c] [-s] [--oom] [process]-a: include all available information for each process.-d: include dalvik details.-c: dump in a compact machine-parseable representation.-s: dump only summary of application memory usage.-S: dump also SwapPss.--oom: only show processes organized by oom adj.--local: only collect details locally, don&apos;t call process.--package: interpret process arg as package, dumping all            processes that have loaded that package.--checkin: dump data for a checkinIf [process] is specified it can be the name orpid of a specific process to dump.</code></pre><p>接着，我们之间输入adb shell dumpsys meminfo命令：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfoApplications Memory Usage (in Kilobytes):Uptime: 257501238 Realtime: 257501238// 根据进程PSS占用值从大到小排序Total PSS by process:    308,049K: com.tencent.mm (pid 3760 / activities)    225,081K: system (pid 2088)    189,038K: com.android.systemui (pid 2297 / activities)    188,877K: com.miui.home (pid 2672 / activities)    176,665K: com.plan.kot32.tomatotime (pid 22744 / activities)    175,231K: json.chao.com.wanandroid (pid 23104 / activities)    126,918K: com.tencent.mobileqq (pid 23741)    ...// 以oom来划分，会详细列举所有的类别的进程Total PSS by OOM adjustment:    432,013K: Native        76,700K: surfaceflinger (pid 784)        59,084K: android.hardware.camera.provider@2.4-service (pid 743)        26,524K: transport (pid 23418)        25,249K: logd (pid 597)        11,413K: media.codec (pid 1303)        10,648K: rild (pid 1304)        9,283K: media.extractor (pid 1297)        ...    661,294K: Persistent        225,081K: system (pid 2088)        189,038K: com.android.systemui (pid 2297 / activities)        103,050K: com.xiaomi.finddevice (pid 3134)        39,098K: com.android.phone (pid 2656)        25,583K: com.miui.daemon (pid 3078)        ...    219,795K: Foreground        175,231K: json.chao.com.wanandroid (pid 23104 / activities)        44,564K: com.miui.securitycenter.remote (pid 2986)    246,529K: Visible        71,002K: com.sohu.inputmethod.sogou.xiaomi (pid 4820)        52,305K: com.miui.miwallpaper (pid 2579)        40,982K: com.miui.powerkeeper (pid 3218)        24,604K: com.miui.systemAdSolution (pid 7986)        14,198K: com.xiaomi.metoknlp (pid 3506)        13,820K: com.miui.voiceassist:core (pid 8722)        13,222K: com.miui.analytics (pid 8037)        7,046K: com.miui.hybrid:entrance (pid 7922)        5,104K: com.miui.wmsvc (pid 7887)        4,246K: com.android.smspush (pid 8126)    213,027K: Perceptible        89,780K: com.eg.android.AlipayGphone (pid 8238)        49,033K: com.eg.android.AlipayGphone:push (pid 8204)        23,181K: com.android.thememanager (pid 11057)        13,253K: com.xiaomi.joyose (pid 5558)        10,292K: com.android.updater (pid 3488)        9,807K: com.lbe.security.miui (pid 23060)        9,734K: com.google.android.webview:sandboxed_process0 (pid 11150)        7,947K: com.xiaomi.location.fused (pid 3524)    308,049K: Backup        308,049K: com.tencent.mm (pid 3760 / activities)    74,250K: A Services        59,701K: com.tencent.mm:push (pid 7234)        9,247K: com.android.settings:remote (pid 27053)        5,302K: com.xiaomi.drivemode (pid 27009)    199,638K: Home        188,877K: com.miui.home (pid 2672 / activities)        10,761K: com.miui.hybrid (pid 7945)    53,934K: B Services        35,583K: com.tencent.mobileqq:MSF (pid 14119)        6,753K: com.qualcomm.qti.autoregistration (pid 8786)        4,086K: com.qualcomm.qti.callenhancement (pid 26958)        3,809K: com.qualcomm.qti.StatsPollManager (pid 26993)        3,703K: com.qualcomm.qti.smcinvokepkgmgr (pid 26976)    692,588K: Cached        176,665K: com.plan.kot32.tomatotime (pid 22744 / activities)        126,918K: com.tencent.mobileqq (pid 23741)        72,928K: com.tencent.mm:tools (pid 18598)        68,208K: com.tencent.mm:sandbox (pid 27333)        55,270K: com.tencent.mm:toolsmp (pid 18842)        24,477K: com.android.mms (pid 27192)        23,865K: com.xiaomi.market (pid 27825)        ...// 按内存的类别来进行划分Total PSS by category:    957,931K: Native    284,006K: Dalvik    199,750K: Unknown    193,236K: .dex mmap    191,521K: .art mmap    110,581K: .oat mmap    101,472K: .so mmap    94,984K: EGL mtrack    87,321K: Dalvik Other    84,924K: Gfx dev    77,300K: GL mtrack    64,963K: .apk mmap    17,112K: Other mmap    12,935K: Ashmem     3,364K: Stack     2,343K: .ttf mmap     1,375K: Other dev     1,071K: .jar mmap        20K: Cursor         0K: Other mtrack// 手机整体内存使用情况Total RAM: 5,847,124K (status normal)Free RAM: 3,711,324K (  692,588K cached pss + 2,428,616K cached kernel +   117,492K cached ion +   472,628K free)Used RAM: 2,864,761K (2,408,529K used pss +   456,232K kernel)Lost RAM:   184,330K    ZRAM:   174,628K physical used for   625,388K in swap (2,621,436K total swap)Tuning: 256 (large 512), oom   322,560K, restore limit   107,520K (high-end-gfx)</code></pre><p>根据dumpsys meminfo的输出结果，可归结为如下表格：</p><table><thead><tr><th></th><th>划分类型</th><th>排序指标</th><th>含义</th></tr></thead><tbody><tr><td>process</td><td>PSS</td><td>以进程的PSS从大到小依次排序显示，每行显示一个进程，一般用来做初步的竞品分析</td><td></td></tr><tr><td>OOM adj</td><td>PSS</td><td>展示当前系统内部运行的所有Android进程的内存状态和被杀顺序，越靠近下方的进程越容易被杀，排序按照一套复杂的算法，算法涵盖了前后台、服务或节目、可见与否、老化等</td><td></td></tr><tr><td>category</td><td>PSS</td><td>以Dalvik/Native/.art mmap/.dex map等划分并按降序列出各类进程的总PSS分布情况</td><td></td></tr><tr><td>total</td><td>-</td><td>总内存、剩余内存、可用内存、其他内存</td><td></td></tr></tbody></table><p>此外，为了查看单个App进程的内存信息，我们可以输入如下命令：</p><pre><code>dumpsys meminfo &lt;pid&gt; // 输出指定pid的某一进程dumpsys meminfo --package &lt;packagename&gt; // 输出指定包名的进程，可能包含多个进程</code></pre><p>这里我们输入adb shell dumpsys meminfo 23104这条命令，其中23104为Awesome-WanAndroid App的pid，结果如下所示：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfo 23104Applications Memory Usage (in Kilobytes):Uptime: 258375231 Realtime: 258375231** MEMINFO in pid 23104 [json.chao.com.wanandroid] **                Pss  Private  Private  SwapPss     Heap     Heap     Heap                Total    Dirty    Clean    Dirty     Size    Alloc     Free                ------   ------   ------   ------   ------   ------   ------Native Heap    46674    46620        0      164    80384    60559    19824Dalvik Heap     6949     6912       16       23    12064     6032     6032Dalvik Other     7672     7672        0        0       Stack      108      108        0        0      Ashmem      134      132        0        0     Gfx dev    16036    16036        0        0   Other dev       12        0       12        0   .so mmap     3360      228     1084       27  .jar mmap        8        8        0        0  .apk mmap    28279    11328    11584        0  .ttf mmap      295        0       80        0  .dex mmap     7780       20     4908        0  .oat mmap      660        0       92        0  .art mmap     8509     8028      104       69 Other mmap      982        8      848        0 EGL mtrack    29388    29388        0        0  GL mtrack    14864    14864        0        0    Unknown     2532     2500        8       20      TOTAL   174545   143852    18736      303    92448    66591    25856App Summary                   Pss(KB)                    ------       Java Heap:    15044     Native Heap:    46620            Code:    29332           Stack:      108        Graphics:    60288   Private Other:    11196          System:    11957           TOTAL:   174545       TOTAL SWAP PSS:      303Objects           Views:      171         ViewRootImpl:        1     AppContexts:        3           Activities:        1          Assets:       18        AssetManagers:        6   Local Binders:       32        Proxy Binders:       27   Parcel memory:       11         Parcel count:       45Death Recipients:        1      OpenSSL Sockets:        0        WebViews:        0SQL        MEMORY_USED:      371 PAGECACHE_OVERFLOW:       72          MALLOC_SIZE:      117DATABASES    pgsz     dbsz   Lookaside(b)          cache  Dbname        4       60            109      151/32/18  /data/user/0/json.chao.com.wanandroid/databases/bugly_db_        4       20             19         0/15/1  /data/user/0/json.chao.com.wanandroid/databases/aws_wan_android.db</code></pre><p>该命令输出的进程内存概括，我们应该着重关注几个点，下面我将进行一一讲解。</p><h5 id="1、查看Native-Heap的Heap-Alloc与Dalvik-Heap的Heap-Alloc"><a href="#1、查看Native-Heap的Heap-Alloc与Dalvik-Heap的Heap-Alloc" class="headerlink" title="1、查看Native Heap的Heap Alloc与Dalvik Heap的Heap Alloc"></a>1、查看Native Heap的Heap Alloc与Dalvik Heap的Heap Alloc</h5><p>我们可以查看Native Heap的Heap Alloc的数值变化，它表示native的内存占用，如果持续上升，则可能有泄漏，而Dalvik Heap的Heap Alloc则表示Java层的内存占用。</p><h5 id="2、查看Views、Activities、AppContexts数量变化情况"><a href="#2、查看Views、Activities、AppContexts数量变化情况" class="headerlink" title="2、查看Views、Activities、AppContexts数量变化情况"></a>2、查看Views、Activities、AppContexts数量变化情况</h5><p>如果Views与Activities、AppContexts持续上升，则表明有内存泄漏的风险。</p><h5 id="3、SQL的MEMORY-USED与PAGECACHE-OVERFLOW"><a href="#3、SQL的MEMORY-USED与PAGECACHE-OVERFLOW" class="headerlink" title="3、SQL的MEMORY_USED与PAGECACHE_OVERFLOW"></a>3、SQL的MEMORY_USED与PAGECACHE_OVERFLOW</h5><p>SQL的MEMOERY_USED表示数据库使用的内存，而PAGECACHE_OVERFLOW则表示溢出也使用的缓存，这个数值越小越好。</p><h5 id="4、查看DATABASES信息"><a href="#4、查看DATABASES信息" class="headerlink" title="4、查看DATABASES信息"></a>4、查看DATABASES信息</h5><p>其中pgsz表示数据库分页大小，这里全是4KB；Lookaside(b)表示使用了多少个Lookaside的slots，可理解为内存占用的大小；而cache一栏中的 151/32/18  则分别表示分页缓存命中次数/未命中次数/分页缓存个数，这里的未命中次数不应该大于命中次数。</p><h4 id="3、LeakInspector"><a href="#3、LeakInspector" class="headerlink" title="3、LeakInspector"></a>3、LeakInspector</h4><p>LeakInspector是腾讯内部的使用的一站式内存泄漏解决方案，它是Android手机经过长期积累和提炼、集内存泄漏检测、自动修复系统Bug、自动回收已泄露Activity内资源、自动分析GC链、白名单过滤等功能于一体，并深度对接研发流程、自动分析责任人并提缺陷单的全链路体系。</p><h5 id="那么LeakInspector与LeakCanary又有什么不同呢？"><a href="#那么LeakInspector与LeakCanary又有什么不同呢？" class="headerlink" title="那么LeakInspector与LeakCanary又有什么不同呢？"></a>那么LeakInspector与LeakCanary又有什么不同呢？</h5><p>它们之间主要有四个方面的不同：</p><p>一、检测能力与原理方面不同</p><p>1、检测能力</p><p>它们都支持对Activity、Fragment及其它自定义类的泄漏检测，但是LeakInspector还增加了Btiamp的检测能力：</p><ul><li>检测有没有在View上decode超过该View尺寸的图片，若有则上报出现问题的Activity及与其对应的View id，并记录它的个数与平均占用内存的大小。</li><li>检测图片尺寸是否超过所有手机屏幕大小，违规则报警。</li></ul><p>这一个部分的实现原理，主要是采用ARTHook来实现，还不清楚的朋友请再仔细看看大图检测的部分。</p><p>2、检测原理</p><p>两个工具的泄漏检测原理都是在onDestroy时检查弱引用，不同之处在于LeakInspector直接使用WeakReference来检测对象是否已经被释放，而LeakCanary则使用ReferenceQueue，两者效果是一样的。</p><p>并且针对Activity，我们通常都会使用Application的registerActivityLifecycleCallbacks来注册Activity的生命周期，以重写onActivityDestroyed方法实现。但是在Android 4.0以下，系统并没有提供这个方法，为了避免手动在每一个Activity的onDestroy中去添加这份代码，我们可以使用发射Instrumentation来截获onDestory，以降低接入成本。代码如下所示：</p><pre><code>Class&lt;?&gt; clazz = Class.forName(&quot;android.app.ActivityThread&quot;);Method method = clazz.getDeclaredMethod(&quot;currentActivityThread&quot;, null);method.setAccessible(true);sCurrentActivityThread = method.invoke(null, null);Field field = sCurrentActivityThread.getClass().getDeclaredField(&quot;mInstumentation&quot;);field.setAccessible(true);field.set(sCurrentActivityThread, new MonitorInstumentation());</code></pre><p>二、泄漏现场处理方面不同</p><p>1、dump采集</p><p>两者都能采集dump，但是LeakInspector提供了回调方法，我们可以增加更多的自定义信息，如运行时Log、trace、dumpsys meminfo等信息，以辅助分析定位问题。</p><p>2、白名单定义</p><p>这里的白名单是为了处理一些系统引起的泄漏问题，以及一些因为业务逻辑要开后门的情形而设置的。分析时如果碰到白名单上标识的类，则不对这个泄漏做后续的处理。二者的配置差异如下所示：</p><p>（1）LeakInspector的白名单以XML配置的形式存放在服务器上。</p><ul><li>优点：跟产品甚至不同版本的应用绑定，我们可以很方便地修改相应的配置。</li><li>缺点：白名单里的类不区分系统版本一刀切。</li></ul><p>而LeakCanary的白名单是直接写死在其源码的AndroidExcludedRefs类里。</p><ul><li>优点：定义非常详细，并区分系统版本。</li><li>缺点：每次修改必定得重新编译。</li></ul><p>（2）LeakCanary的系统白名单里定义的类比LeakInspector中定义的多很多，因为它没有自动修复系统泄漏功能。</p><p>3、自动修复系统泄漏</p><p>针对系统泄漏，LeakInspector通过反射自动修复了目前碰到的一些系统泄漏，只要在onDestory里面调研一个修复系统泄漏的方法即可。而LeakCanary虽然能识别系统泄漏，但是它仅仅对该类问题给出了分析，没有提供实际可用的解决方案。</p><p>4、回收资源</p><p>如果检测到发生了内存泄漏，LeakInspector会对整个Activity的View进行遍历，把图片资源等一些占内存的数据释放掉，保证此次泄漏只会泄漏一个Activity的空壳，尽量减少对内存的影响。代码大致如下所示：</p><pre><code>if (View instanceof ImageView) {    // ImageView ImageButton处理    recycleImageView(app, (ImageView) view);} else if (view instanceof TextView) {    // 释放TextView、Button周边图片资源    recycleTextView((TextView) view);} else if (View instanceof ProgressBar) {    recycleProgressBar((ProgressBar) view);} else {    if (view instancof android.widget.ListView) {        recycleListView((android.widget.ListView) view);    } else if (view instanceof android.support.v7.widget.RecyclerView) {        recycleRecyclerView((android.support.v7.widget.RecyclerView) view);    } else if (view instanceof FrameLayout) {        recycleFrameLayout((FrameLayout) view);    } else if (view instanceof LinearLayout) {        recycleLinearLayout((LinearLayout) view);    }    if (view instanceof ViewGroup) {        recycleViewGroup(app, (ViewGroup) view);    }}</code></pre><p>这里以recycleTextView为例，它回收资源的方式如下所示：</p><pre><code>private static void recycleTextView(TextView tv) {    Drawable[] ds = tv.getCompoundDrawables();    for (Drawable d : ds) {        if (d != null) {            d.setCallback(null);        }    }    tv.setCompoundDrawables(null, null, null, null);    // 取消焦点，让Editor$Blink这个Runnable不再被post，解决内存泄漏。    tv.setCursorVisible(false);}</code></pre><p>三、后期处理不同</p><p>1、分析与展示</p><p>采集dump之后，LeakInspector会上传dump文件，并调用MAT命令行来进行分析，得到这次泄漏的GC链；而LeakCanary则用开源组件HAHA来分析得到一个GC链。但是LeakCanary得到的GC链包含被hold主的类对象，一般都不需要用MAT打开Hporf即可解决问题；而LeakInpsector得到的GC链李只有类名，还需要MAT打开Hprof才能具体去定位问题，不是很方便。</p><p>2、后续跟进闭环</p><p>LeakInspector在dump分析结束之后，会提交缺陷单，并且把缺陷单分配给对应类的负责人；如果发现重复的问题则更新旧单，同时具备重新打开单等状态转换罗家。而LeakCanary仅会在通知栏提醒用户，需要用户自己记录该问题并做后续处理。</p><p>四、配合自动化测试方面不同</p><p>LeakInspector跟自动化测试可以无缝结合，当自动化脚本执行中发现内存泄漏，可以由它采集dump并发送到服务进行分析，最后提单，整个流程是不需要人力介入的。而LeakCanary则把分析结果通过通知栏告知用户，需要人工介入才能进入下一个流程。</p><h4 id="4、JHat"><a href="#4、JHat" class="headerlink" title="4、JHat"></a>4、JHat</h4><p>JHat是Oracle推出的一款Hprof分析软件，它和MAT并称为Java内存静态分析利器。不同于MAT的单人界面式分析，jHat使用多人界面式分析。它被内置在JDK中，在命令行中输入jhat命令可查看没有有相应的命令。</p><pre><code>quchao@quchaodeMacBook-Pro ~ % jhatERROR: No arguments suppliedUsage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;    -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For            example, -J-mx512m to use a maximum heap size of 512MB    -stack false:     Turn off tracking object allocation call stack.    -refs false:      Turn off tracking of references to objects    -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000    -exclude &lt;file&gt;:  Specify a file that lists data members that should            be excluded from the reachableFrom query.    -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in            both heap dumps with the same ID and same class will            be marked as not being &quot;new&quot;.    -debug &lt;int&gt;:     Set debug level.                0:  No debug output                1:  Debug hprof file parsing                2:  Debug hprof file parsing, no server    -version          Report version number    -h|-help          Print this help and exit    &lt;file&gt;            The file to readFor a dump file that contains multiple heap dumps,you may specify which dump in the fileby appending &quot;#&lt;number&gt;&quot; to the file name, i.e. &quot;foo.hprof#3&quot;.</code></pre><p>如上，则表明存在jhat命令。它的使用很简单，直在命令行输入jhat xxx.hprof即可：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % jhat Documents/heapdump/new-33.hprofSnapshot read, resolving...Resolving 408200 objects...Chasing references, expect 81 dots.................................................................................Eliminating duplicate references.................................................................................Snapshot resolved.Started HTTP server on port 7000Server is ready.</code></pre><p>jHat的执行过程是解析Hprof文件，然后启动httpsrv服务，默认是在7000端口监听Web客户端链接，维护Hprof解析后数据，以持续供给Web客户端的查询操作。</p><p>启动服务器后，我们打开入口地址127.0.0.1:7000即可查看All Classes界面：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/all_classes.png?raw=true" alt="image"></p><p>jHat还有两个比较重要的功能：</p><h5 id="1、统计表"><a href="#1、统计表" class="headerlink" title="1、统计表"></a>1、统计表</h5><p>打开127.0.0.1:7000/histo/:</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/heap_histogram.png?raw=true" alt="image"></p><h5 id="2、OQL查询"><a href="#2、OQL查询" class="headerlink" title="2、OQL查询"></a>2、OQL查询</h5><p>OQL是一种模仿SQL语句的查询语句，通常用来查询某个类的实例数量，打开127.0.0.1:7000/oql/并输入java.lang.String查询String实例的数量，如下所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/oql.png?raw=true" alt="image"></p><p>JHat比MAT更加灵活，且符合大型团队安装简单、团队协作的需求你，并不适合中小型高效沟通型团队使用。</p><h4 id="5、GC-Log"><a href="#5、GC-Log" class="headerlink" title="5、GC Log"></a>5、GC Log</h4><p>GC Log分为Dalvik和ART的GC日志，关于Dalvik的GC日志，在前篇<a href="https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之内存优化</a>已经详细讲解过了，接下来我们说说ART的GC日志。</p><p>ART的日志与Dalvik的日志差距非常大，除了格式不同之外，打印的时间也不同，非要在慢GC时才打印除了。下面我们看看这条ART GC Log：</p><table><thead><tr><th>Explicit</th><th>（full）</th><th>concurrent mark sweep GC</th><th>freed 104710 （7MB） AllocSpace objects,</th><th>21（416KB） LOS objects，</th><th>33% free,25MB/38MB</th><th>paused 1.230ms total 67.216ms</th></tr></thead><tbody><tr><td>GC产生的原因</td><td>GC类型</td><td>采集方法</td><td>释放的数量和占用的空间</td><td>释放的大对象数量和所占用的空间</td><td>堆中空闲空间的百分比和（对象的个数）/（堆的总空间）</td><td>暂停耗时</td><td></td></tr></tbody></table><p>GC产生的原因如下：</p><ul><li>Concurrent、Alloc、Explicit跟Dalvik的基本一样，这里就不重复介绍了。</li><li>NativeAlloc：Native内存分配时，比如为Bitmaps或者RenderScript分配对象， 这会导致Native内存压力，从而触发GC。</li><li>Background:后台GC，触发是为了给后面的内存申请预留更多空间。</li><li>CollectorTransition：由堆转换引起的回收，这是运行时切换GC而引起的。收集器转换包括将所有对象从空闲列表空间复制到碰撞指针空间（反之亦然）。当前，收集器转换仅在以下情况下出现：在内存较小的设备上，App将进程状态从可察觉的暂停状态变更为可察觉的非暂停状态（反之亦然）。</li><li>HomogeneousSpaceCompact：齐性空间压缩是指空闲列表到压缩的空闲列表空间，通常发生在当App已经移动到可察觉的暂停进程状态。这样做的主要原因是减少了内存使用并对堆内存进行碎片整理。</li><li>DisableMovingGc：不是真正的触发GC原因，发生并发堆压缩时，由于使用了 </li><li>GetPrimitiveArrayCritical，收集会被阻塞。一般情况下，强烈建议不要使用 </li><li>GetPrimitiveArrayCritical，因为它在移动收集器方面具有限制。</li><li>HeapTrim：不是触发GC原因，但是请注意，收集会一直被阻塞，直到堆内存整理完毕。</li></ul><p>GC类型如下：</p><ul><li>Full：与Dalvik的FULL GC差不多。</li><li>Partial：跟Dalvik的局部GC差不多，策略时不包含Zygote Heap。</li><li>Sticky：另外一种局部中的局部GC，选择局部的策略是上次垃圾回收后新分配的对象。</li></ul><p>GC采集的方法如下：</p><ul><li>mark sweep：先记录全部对象，然后从GC ROOT开始找出间接和直接的对象并标注。利用之前记录的全部对象和标注的对象对比，其余的对象就应该需要垃圾回收了。</li><li>concurrent mark sweep：使用mark sweep采集器的并发GC。</li><li>mark compact：在标记存活对象的时候，所有的存活对象压缩到内存的一端，而另一端可以更加高效地被回收。</li><li>semispace：在做垃圾扫描的时候，把所有引用的对象从一个空间移到另外一个空间，然后直接GC剩余在旧空间中的对象即可。</li></ul><p>通过GC日志，我们可以知道GC的量和它对卡顿的影响，也可以初步定位一些如主动调用GC、可分配的内存不足、过多使用Weak Reference等问题。</p><h4 id="6、自带防泄漏功能的线程池组件"><a href="#6、自带防泄漏功能的线程池组件" class="headerlink" title="6、自带防泄漏功能的线程池组件"></a>6、自带防泄漏功能的线程池组件</h4><p>我们在做子线程操作的时候，喜欢使用匿名内部类Runnable来操作,但是,如果某个Activity放在线程池中的任务不能及时执行完毕，在Activity销毁时很容易导致内存泄漏。因为这个匿名内部类Runnable类持有一个指向Outer类的引用，这样一来如果Activity里面的Runnable不能及时执行，就会使它外围的Activity无法释放，产生内存泄漏。从上面的分析可知，只要在Activity退出时没有这个引用即可，那我们就通过反射，在Runnable进入线程池前先干掉它，代码如下所示：</p><pre><code>Field f = job.getClass().getDeclaredField(&quot;this$0&quot;);f.setAccessible(true);f.set(job, null);</code></pre><p>这个任务就是我们的Runnable对象，而”this$0“就是上面所指的外部类的引用了。这里注意使用WeakReference装起来，要执行了先get一下，如果是null则说明Activity已经回收，任务就放弃执行。</p><h4 id="7、Chrome-Devtool"><a href="#7、Chrome-Devtool" class="headerlink" title="7、Chrome Devtool"></a>7、Chrome Devtool</h4><p>对于HTML5页面而言，抓取JavaScript的内存需要使用Chrome Devtools来进行远程调试。方式有如下两种：</p><ul><li>直接把URL抓取出来放到Chrome里访问。</li><li>用Android H5远程调试。</li></ul><h5 id="纯H5"><a href="#纯H5" class="headerlink" title="纯H5"></a>纯H5</h5><p>1、手机安装Chrome，打开USB调试模式，通过USB连上电脑，在Chrome里打开一个页面，比如百度页面。然后在PC Chrome地址栏里访问Chrome://inspect，如下图所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/chrome_dev1.png?raw=true" alt="image"></p><p>2、最后，直接点击Chrome下面的inspect选项即可弹出开发者工具界面。如下图所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/chrome_dev2.png?raw=true" alt="image"></p><h5 id="默认Hybrid-H5调试"><a href="#默认Hybrid-H5调试" class="headerlink" title="默认Hybrid H5调试"></a>默认Hybrid H5调试</h5><p>Android 4.4及以上系统的原生浏览器就是Chrome浏览器，可以使用Chrome Devtool远程调试WebView，前提是需要在App的代码里把调试开关打开，如下代码所示：</p><pre><code>if (Build.VERSION_SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; 是debug模式) {    WebView.setWebContentsDebuggingEnabled(ture);}</code></pre><p>打开后的调试方法跟纯H5页面调试方法一样，直接在App中打开H5页面，再到PC Chrome的inpsector页面就可以看到调试目标页面。</p><p>这里总结一下JS中几种常见的内存问题点：</p><ul><li>closure闭包函数。</li><li>事件监听。</li><li>变量作用域使用不当，全局变量的引用导致无法释放。</li><li>DOM节点的泄漏。</li></ul><p>若想更深入地学习Chrome开发者工具的使用方法，请查看<a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools" target="_blank" rel="external">《Chrome开发者工具中文手册》</a>。</p><h3 id="九、内存问题总结"><a href="#九、内存问题总结" class="headerlink" title="九、内存问题总结"></a>九、内存问题总结</h3><p>在我们进行内存优化的过程中，有许多内存问题都可以归结为一类问题，为了便于以后快速地解决类似的内存问题，我将它们归结成了以下的多个要点：</p><h4 id="1、内类时有危险的编码方式"><a href="#1、内类时有危险的编码方式" class="headerlink" title="1、内类时有危险的编码方式"></a>1、内类时有危险的编码方式</h4><p>说道内类就不得不提到”this$0“，它是一种奇特的内类成员，每个类实例都具有一个this$0，当它的内类需要访问它的成员时，内类就会持有外类的this$0，通过this$0就可以访问外部类所有的成员。</p><p>解决方案是在Activity关闭时，触发onDestory时解除内类和外部的引用关系。</p><h4 id="2、普通Hanlder内部类的问题"><a href="#2、普通Hanlder内部类的问题" class="headerlink" title="2、普通Hanlder内部类的问题"></a>2、普通Hanlder内部类的问题</h4><p>这也是一个this$0间接引用的问题，对于Handler的解决方案一般博阿凯如下三个要点：</p><ul><li>1、把内类声明成static，来断绝this$0的引用。因为static描述的内类从Java编译原理的角度看，”内类“与”外类“相互怒独立，互相都没有访问对方成员变量的能力。</li><li>2、使用WeakReference来引用外部类的实例。</li><li>3、在外部类（如Activity）销毁的时候使用removeCallbackAndMessages来移除回调和消息。</li></ul><p>这里需要在使用过程中注意对WeakReference进行判空。</p><h4 id="3、登录界面的内存问题"><a href="#3、登录界面的内存问题" class="headerlink" title="3、登录界面的内存问题"></a>3、登录界面的内存问题</h4><p>如果在闪屏页跳转到登录界面时没有调用finish()，则会造成闪屏页的内存泄漏，在碰到这种”过渡界面“的情况时，需要注意不要产生这样的内存Bug。</p><h4 id="4、使用系统服务时产生的内存问题"><a href="#4、使用系统服务时产生的内存问题" class="headerlink" title="4、使用系统服务时产生的内存问题"></a>4、使用系统服务时产生的内存问题</h4><p>我们通常都会使用getSystemService方法来获取系统服务，但是当在Activity中调用时，会默认把Activity的Context传给系统服务，在某些不确定的情况下，某些系统服务内部会产生异常，从而hold住外界传入的Context。</p><p>解决方案是直接使用Applicaiton的Context去获取系统服务。</p><h4 id="5、把WebView类型的泄漏装进垃圾桶进程"><a href="#5、把WebView类型的泄漏装进垃圾桶进程" class="headerlink" title="5、把WebView类型的泄漏装进垃圾桶进程"></a>5、把WebView类型的泄漏装进垃圾桶进程</h4><p>我们都知道，对应WebView来说，其网络延时、引擎Session管理、Cookies管理、引擎内核线程、HTML5调用系统声音、视频播放组件等产生的引用链条无法及时打断，造成的内存问题基本上可以用”无解“来形容。</p><p>解决方案是我们可以把WebView装入另一个进程。<br>在AndroidManifest中对当前的Activity设置android:process属性即可，最后再Activity的onDestory中退出进程，这样即可基本上终结WebView造成的泄漏。</p><h4 id="6、在适当的时候对组件进行注销"><a href="#6、在适当的时候对组件进行注销" class="headerlink" title="6、在适当的时候对组件进行注销"></a>6、在适当的时候对组件进行注销</h4><p>我们在平常开发过程中经常需要在Activity创建的时候去注册一些组件，如广播、定时器、事件总线等等。这个时候我们应该在适当的时候对组件进行注销，如onPause或onDestory方法中。</p><h4 id="7、Handler-FrameLayout的postDelyed方法触发的内存问题"><a href="#7、Handler-FrameLayout的postDelyed方法触发的内存问题" class="headerlink" title="7、Handler/FrameLayout的postDelyed方法触发的内存问题"></a>7、Handler/FrameLayout的postDelyed方法触发的内存问题</h4><p>不仅在使用Handler的sendMessage方法时，我们需要在onDestory中使用removeCallbackAndMessage移除回调和消息，在使用到Handlerh/FrameLayout的postDelyed方法时,我们需要调用removeCallbacks去移除实现控件内部的延时器对Runnable内类的持有。</p><h4 id="8、图片放错资源目录也会有内存问题"><a href="#8、图片放错资源目录也会有内存问题" class="headerlink" title="8、图片放错资源目录也会有内存问题"></a>8、图片放错资源目录也会有内存问题</h4><p>在做资源适配的时候，因为需要考虑到APK的瘦身问题，无法为每张图片在每个drawable/mipmap目录下安置一张适配图片的副本。很多同学不知道图片应该放哪个目录，如果放到分辨率低的目录如hdpi目录，则可能会造成内存问题，这个时候建议尽量问设计人员要高品质图片然后往高密度目录下方，如xxhdpi目录，这样在低密屏上”放大倍数“是小于1的，在保证画质的前提下，内存也是可控的。也可以使用Drawable.createFromSream替换getResources().getDrawable来加载，这样便可以绕过Android的默认适配规则。</p><p>对于已经被用户使用物理“返回键”退回到后台的进程，如果包含了以下几点，则不会被轻易杀死。</p><ul><li>进程包含了服务startService，而服务本身调用了startForeground（需通过反射调用）。</li><li>主Activity没有实现onSaveInstanceState接口。</li></ul><p>但建议在运行一段时间（如3小时）后主动保存界面进程，然后重启它，这样可以有效地降低内存负载。</p><h3 id="十、内存优化常见问题"><a href="#十、内存优化常见问题" class="headerlink" title="十、内存优化常见问题"></a>十、内存优化常见问题</h3><h4 id="1、你们内存优化项目的过程是怎么做的？"><a href="#1、你们内存优化项目的过程是怎么做的？" class="headerlink" title="1、你们内存优化项目的过程是怎么做的？"></a>1、你们内存优化项目的过程是怎么做的？</h4><h5 id="1、分析现状、确认问题"><a href="#1、分析现状、确认问题" class="headerlink" title="1、分析现状、确认问题"></a>1、分析现状、确认问题</h5><p>我们发现我们的APP在内存方面可能存在很大的问题，第一方面的原因是我们的线上的OOM率比较高。第二点呢，我们经常会看到在我们的Android Studio的Profiler工具中内存的抖动比较频繁。这是我一个初步的现状，然后在我们知道了这个初步的现状之后，进行了问题的确认，我们经过一系列的调研以及深入研究，我们最终发现我们的项目中存在以下几点大问题，比如说：内存抖动、内存溢出、内存泄漏，还有我们的Bitmap使用非常粗犷。</p><h5 id="2、针对性优化"><a href="#2、针对性优化" class="headerlink" title="2、针对性优化"></a>2、针对性优化</h5><p>比如内存抖动的解决 -&gt; Memory Profiler工具的使用（呈现了锯齿张图形） -&gt; 分析到具体代码存在的问题（频繁被调用的方法中出现了日志字符串的拼接），也可以说说内存泄漏或内存溢出的解决。</p><h5 id="3、效率提升"><a href="#3、效率提升" class="headerlink" title="3、效率提升"></a>3、效率提升</h5><p>为了不增加业务同学的工作量，我们使用了一些工具类或ARTHook这样的大图检测方案,没有任何的侵入性,同时,我们将这些技术教给了大家,然后让大家一起进行工作效率上的提升。</p><p>我们对内存优化工具Memory Profiler、MAT的使用比较熟悉，因此针对一系列不同问题的情况，我们写了一系列解决方案的文档，分享给大家。这样，我们整个团队成员的内存优化意识就变强了。</p><h4 id="2、你做了内存优化最大的感受是什么？"><a href="#2、你做了内存优化最大的感受是什么？" class="headerlink" title="2、你做了内存优化最大的感受是什么？"></a>2、你做了内存优化最大的感受是什么？</h4><h6 id="1、磨刀不误砍柴工"><a href="#1、磨刀不误砍柴工" class="headerlink" title="1、磨刀不误砍柴工"></a>1、磨刀不误砍柴工</h6><p>我们一开始并没有直接去分析项目中代码哪些地方存在内存问题，而是先去学习了Google官方的一些文档，比如说学习了Memory Profiler工具的使用、学习了MAT工具的使用，在我们将这些工具学习熟练之后，当在我们的项目中遇到内存问题时，我们就能够很快地进行排查定位问题进行解决。</p><h5 id="2、技术优化必须结合业务代码"><a href="#2、技术优化必须结合业务代码" class="headerlink" title="2、技术优化必须结合业务代码"></a>2、技术优化必须结合业务代码</h5><p>一开始，我们做了整体APP运行阶段的一个内存上报，然后，我们在一些重点的内存消耗模块进行了一些监控，但是后面发现这些监控并没有紧密地结合我们的业务代码，比如说在梳理完项目之后，发现我们项目中存在使用多个图片库的情况，多个图片库的内存缓存肯定是不公用的，所以导致我们整个项目的内存使用量非常高。所以进行技术优化时必须结合我们的业务代码。</p><h5 id="3、系统化完善解决方案"><a href="#3、系统化完善解决方案" class="headerlink" title="3、系统化完善解决方案"></a>3、系统化完善解决方案</h5><p>我们在做内存优化的过程中，不仅做了Android端的优化工作，还将我们Android端一些数据的采集上报到了我们的服务器，然后传到我们的后台，这样，方便我们的无论是Bug跟踪人员或者是Crash跟踪人员进行一系列问题的解决。</p><h4 id="3、如何检测所有不合理的地方？"><a href="#3、如何检测所有不合理的地方？" class="headerlink" title="3、如何检测所有不合理的地方？"></a>3、如何检测所有不合理的地方？</h4><p>比如说大图片的检测，我们最初的一个方案是通过继承ImageView，重写它的onDraw方法来实现。但是，我们在推广它的过程中，发现很多开发人员并不接受，因为很多ImageView之前已经写过了，你现在让他去替换，工作成本是比较高的。所以说，后来我们就想，有没有一种方案可以免替换，最终我们就找到了ARTHook这样一个Hook的方案。</p><h3 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h3><p>对于内存优化的专项优化而言，我们要着重注意两点，即优化大方向和优化细节。</p><p>对于优化的大方向，我们应该优先去做见效快的地方，主要有以下三部分：</p><ul><li>1、内存泄漏</li><li>2、内存抖动</li><li>3、Bitmap</li></ul><p>对于优化细节，我们应该注意一些系统属性或内存回调的使用等等，如下：</p><ul><li>1、LargeHeap属性</li><li>2、onTrimMemory</li><li>3、使用优化过后的集合：如SparseArray</li><li>4、谨慎使用SharedPreference</li><li>5、谨慎使用外部库</li><li>6、业务架构设计合理</li></ul><p>在本篇文章，我们除了建立了内存的监控闭环这一核心体系之外，还是实现了以下组件：</p><ul><li>1、实现了线下的native内存泄漏监控。</li><li>2、根据设备分级来使用不同的内存和分配回收策略。</li><li>3、针对低端机做了功能或图片加载格式的降级处理。</li><li>4、针对缓存滥用的问题实现了统一的缓存管理组件。</li><li>5、实现了大图监控和重复图片的监控。</li><li>6、在前台每隔一定时间去获取当前应用内存占最大内存的比例，当超过设定阈值时则主动释放应用cache。</li><li>7、当UI隐藏时释放内存以增加系统缓存应用进程的能力。</li><li>8、高效实现了应用全局内的Bitmap监控。</li><li>9、实现了全局的线程监控</li><li>10、针对内存使用的重度场景实现了GC监控。</li></ul><p>最后，当监控到应用内存超过阈值时，还定制了完善的兜底策略来重启应用进程。</p><p>从性能分类的纬度来看，除了内存监控方面外，是否也同样建立了卡顿、缓存、电量、异常流量、布局、包体积、IO、存储相关的监控与优化体系。总的来说，要想实现更健全的功能、更深层次的定位问题、线上问题快速准确的发现，还是有很多事情可以做的。</p><pre><code>路漫漫其修远兮，吾将上下而求索。</code></pre><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第四章 内存优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/71277" target="_blank" rel="external">极客时间之Android开发高手课 内存优化</a></p><p>3、<a href="https://mp.Aweixin.qq.com/s/KtGfi5th-4YHOZsEmTOsjg?" target="_blank" rel="external">微信 Android 终端内存优化实践</a></p><p>4、<a href="https://static001.geekbang.org/con/19/pdf/593bc30c21689.pdf" target="_blank" rel="external">GMTC－Android内存泄漏自动化链路分析组件Probe.key</a></p><p>5、<a href="https://developer.android.com/topic/performance/memory#monitor" target="_blank" rel="external">Manage your app’s memory</a></p><p>6、<a href="https://developer.android.com/topic/performance/memory-overview.html" target="_blank" rel="external">Overview of memory management</a></p><p>7、<a href="https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg" target="_blank" rel="external">Android内存优化杂谈</a></p><p>8、<a href="http://hukai.me/android-performance-memory/" target="_blank" rel="external">Android性能优化之内存篇</a></p><p>9、<a href="http://hukai.me/android-training-managing_your_app_memory/" target="_blank" rel="external">管理应用的内存</a></p><p>10、《Android移动性能实战》第二章 内存</p><p>11、<a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a></p><p>12、<a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="external">Android内存分析命令</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android稳定性优化</title>
      <link>http://yoursite.com/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 24 Nov 2019 14:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h3><h2 id="一、正确认识"><a href="#一、正确认识" class="headerlink" title="一、正确认识"></a>一、正确认识</h2><ul><li>稳定性很重要，Crash是P0优先级</li><li>稳定性可优化的面很广</li></ul><h3 id="1-1-稳定性纬度"><a href="#1-1-稳定性纬度" class="headerlink" title="1.1 稳定性纬度"></a>1.1 稳定性纬度</h3><ul><li>Crash纬度</li><li>性能纬度：启动速度、内存、绘制等等优化方向，相对于Crash来说是次要的</li><li>业务高可用纬度</li></ul><h3 id="1-2-稳定性优化概述"><a href="#1-2-稳定性优化概述" class="headerlink" title="1.2 稳定性优化概述"></a>1.2 稳定性优化概述</h3><ul><li>重在预防、监控必不可少</li><li>思考更深一层、重视隐含信息：如解决Crash问题时思考是否会引发同一类问题</li><li>长效保持需要科学流程</li></ul><h3 id="1-3-Crash相关指标"><a href="#1-3-Crash相关指标" class="headerlink" title="1.3 Crash相关指标"></a>1.3 Crash相关指标</h3><h4 id="1-3-1-UV、PV"><a href="#1-3-1-UV、PV" class="headerlink" title="1.3.1 UV、PV"></a>1.3.1 UV、PV</h4><ul><li>PV（Page View）：访问量</li><li>UV（Unique Visitor）：独立访客，0 - 24小时内的同一终端只计算一次</li></ul><h4 id="1-3-2-UV、PV、启动Crash率"><a href="#1-3-2-UV、PV、启动Crash率" class="headerlink" title="1.3.2 UV、PV、启动Crash率"></a>1.3.2 UV、PV、启动Crash率</h4><ul><li>UV Crash率：针对用户使用量的统计，统计一段时间内所有用户发生崩溃的占比</li><li>Crash UV / DAU：评估Crash率的影响范围，结合PV</li></ul><p>注意：沿用同一指标</p><ul><li>PV Crash率：评估相关Crash影响的严重程度</li><li>启动Crash率：影响最严重的Crash，对用户伤害最大，无法通过热修复拯救，需结合客户端容灾</li><li>增量、存量Crash率：增量Crash是新版本重点，存量Crash是需要持续啃的硬骨头，优先解决增量、持续跟进存量</li></ul><h4 id="1-4-Crash率评价"><a href="#1-4-Crash率评价" class="headerlink" title="1.4 Crash率评价"></a>1.4 Crash率评价</h4><ul><li>必须在千分之二以下</li><li>万分位为优秀</li></ul><h4 id="1-5-Crash关键问题"><a href="#1-5-Crash关键问题" class="headerlink" title="1.5 Crash关键问题"></a>1.5 Crash关键问题</h4><p>尽可能还原Crash现场:</p><ul><li>堆栈、设备、OS版本、进程、线程名、Logcat<br>前后台、使用时长、App版本、小版本、渠道<br>CPU架构、内存信息、线程数、资源包信息、用户行为日志</li><li>Crash现场信息、Crash Top机型、OS版本、分布版本、区域<br>Crash起始版本、上报趋势、是否新增、持续、量级<br>根据以上信息决定Crash是否需要立马解决以及在哪个版本进行解决</li><li>参考Bugly平台的APM后台聚合展示</li></ul><h4 id="1-6-APM-Crash部分整体架构"><a href="#1-6-APM-Crash部分整体架构" class="headerlink" title="1.6 APM Crash部分整体架构"></a>1.6 APM Crash部分整体架构</h4><h5 id="采集层"><a href="#采集层" class="headerlink" title="采集层"></a>采集层</h5><ul><li>错误堆栈</li><li>设备信息</li><li>行为日志</li><li>其它信息</li></ul><h5 id="处理层"><a href="#处理层" class="headerlink" title="处理层"></a>处理层</h5><ul><li>数据清洗</li><li>数据聚合</li><li>纬度分类</li><li>趋势对比</li></ul><h5 id="展示层"><a href="#展示层" class="headerlink" title="展示层"></a>展示层</h5><ul><li>数据还原</li><li>纬度信息</li><li>起始版本</li><li>其它信息</li></ul><h5 id="报警层"><a href="#报警层" class="headerlink" title="报警层"></a>报警层</h5><ul><li>环比：期与上一期进行对比</li><li>同比：如本月10号与上月10号</li><li>邮件</li><li>IM</li><li>电话</li></ul><h5 id="责任归属"><a href="#责任归属" class="headerlink" title="责任归属"></a>责任归属</h5><ul><li>设立专项小组轮值</li><li>自动匹配责任人</li><li>处理流程全纪录</li></ul><h2 id="二、Crash优化"><a href="#二、Crash优化" class="headerlink" title="二、Crash优化"></a>二、Crash优化</h2><h3 id="2-1-单个Crash处理方案"><a href="#2-1-单个Crash处理方案" class="headerlink" title="2.1 单个Crash处理方案"></a>2.1 单个Crash处理方案</h3><p>1、根据堆栈及现场信息找答案</p><ul><li>解决90%问题</li><li>解决完后需考虑产生Crash深层次的原因</li></ul><p>2、找共性：机型、OS、实验开关、资源包，考虑影响范围</p><p>3、线下复现、远程调试</p><h3 id="2-2-Crash率治理方案"><a href="#2-2-Crash率治理方案" class="headerlink" title="2.2 Crash率治理方案"></a>2.2 Crash率治理方案</h3><ul><li>1、解决线上常规Crash</li><li>2、系统级Crash尝试Hook绕过</li><li>3、疑难Crash重点突破或更换方案</li></ul><h3 id="2-3-Java-Crash"><a href="#2-3-Java-Crash" class="headerlink" title="2.3 Java Crash"></a>2.3 Java Crash</h3><p>出现未捕获异常，导致出现异常退出</p><pre><code>Thread.setDefaultUncaughtExceptionHandler()；</code></pre><p>我们通过设置自定义的UncaughtExceptionHandler，就可以在崩溃发生的时候获取到现场信息。注意，这个钩子是针对单个进程而言的，在多进程的APP中，监控哪个进程，就需要在哪个进程中设置一遍ExceptionHandler。</p><p>获取主线程的堆栈信息：</p><pre><code>Looper.getMainLooper().getThread().getStackTrace();</code></pre><p>获取当前线程的堆栈信息：</p><pre><code>Thread.currentThread().getStackTrace();</code></pre><p>获取全部线程的堆栈信息：</p><pre><code>Thread.getAllStackTraces();</code></pre><p>第三方Crash监控工具如Fabric、腾讯Bugly，都是以字符串拼接的方式将数组StackTraceElement[]转换成字符串形式，进行保存、上报或者展示。</p><h4 id="2-3-1-如何反混淆上传的堆栈信息？"><a href="#2-3-1-如何反混淆上传的堆栈信息？" class="headerlink" title="2.3.1 如何反混淆上传的堆栈信息？"></a>2.3.1 如何反混淆上传的堆栈信息？</h4><ul><li>每次打包生成混淆APK的时候，需要把Mapping文件保存并上传到监控后台；</li><li>Android原生的反混淆的工具包是retrace.jar，在监控后台用来实时解析每个上报的崩溃时。它会将Mapping文件进行文本解析和对象实例化，这个过程比较耗时。因此可以将Mapping对象实例进行内存缓存，但为了防止内存泄露和内存过多占用，需要增加定期自动回收的逻辑。</li></ul><h4 id="2-3-2-获取logcat方法"><a href="#2-3-2-获取logcat方法" class="headerlink" title="2.3.2 获取logcat方法"></a>2.3.2 获取logcat方法</h4><p>logcat日志流程是这样的，应用层 –&gt; liblog.so –&gt; logd，底层使用ring buffer来存储数据。获取的方式有以下三种：</p><h5 id="1-通过logcat命令获取。"><a href="#1-通过logcat命令获取。" class="headerlink" title="1. 通过logcat命令获取。"></a>1. 通过logcat命令获取。</h5><ul><li>优点：非常简单，兼容性好。</li><li>缺点：整个链路比较长，可控性差，失败率高，特别是堆破坏或者堆内存不足时，基本会失败。</li></ul><h5 id="2-hook-liblog-so实现。通过hook-liblog-so-中-android-log-buf-write-方法，将内容重定向到自己的buffer中。"><a href="#2-hook-liblog-so实现。通过hook-liblog-so-中-android-log-buf-write-方法，将内容重定向到自己的buffer中。" class="headerlink" title="2. hook liblog.so实现。通过hook liblog.so 中__android_log_buf_write 方法，将内容重定向到自己的buffer中。"></a>2. hook liblog.so实现。通过hook liblog.so 中__android_log_buf_write 方法，将内容重定向到自己的buffer中。</h5><ul><li>优点：简单，兼容性相对还好。</li><li>缺点：要一直打开。</li></ul><h5 id="3-自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。"><a href="#3-自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。" class="headerlink" title="3. 自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。"></a>3. 自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。</h5><ul><li>优点：比较灵活，预先分配好资源，成功率也比较高。</li><li>缺点：实现非常复杂</li></ul><h4 id="2-3-3-获取Java-堆栈"><a href="#2-3-3-获取Java-堆栈" class="headerlink" title="2.3.3 获取Java 堆栈"></a>2.3.3 获取Java 堆栈</h4><p>native崩溃时，通过unwind只能拿到Native堆栈。我们希望可以拿到当时各个线程的Java堆栈。</p><h5 id="1-Thread-getAllStackTraces-。"><a href="#1-Thread-getAllStackTraces-。" class="headerlink" title="1. Thread.getAllStackTraces()。"></a>1. Thread.getAllStackTraces()。</h5><p>优点：简单，兼容性好。</p><p>缺点：</p><ul><li>成功率不高，依靠系统接口在极端情况也会失败。</li><li>7.0之后这个接口是没有主线程堆栈。</li><li>使用Java层的接口需要暂停线程。</li></ul><h5 id="2-hook-libart-so。通过hook-ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。"><a href="#2-hook-libart-so。通过hook-ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。" class="headerlink" title="2. hook libart.so。通过hook ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。"></a>2. hook libart.so。通过hook ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。</h5><ul><li>优点：信息很全，基本跟ANR的日志一样，有native线程状态，锁信息等等。</li><li>缺点：黑科技的兼容性问题，失败时可以用Thread.getAllStackTraces()兜底</li></ul><h4 id="2-3-4-Java-Crash处理流程"><a href="#2-3-4-Java-Crash处理流程" class="headerlink" title="2.3.4 Java Crash处理流程"></a>2.3.4 Java Crash处理流程</h4><p>借用Gityuan流程图如下所示：</p><p><img src="http://gityuan.com/images/stability/app_crash.jpg" alt="image"></p><p>1、首先发生crash所在进程，在创建之初便准备好了defaultUncaughtHandler，用来来处理Uncaught Exception，并输出当前crash基本信息；</p><p>2、调用当前进程中的AMP.handleApplicationCrash；经过binder ipc机制，传递到system_server进程；</p><p>3、接下来，进入system_server进程，调用binder服务端执行AMS.handleApplicationCrash；</p><p>4、从mProcessNames查找到目标进程的ProcessRecord对象；并将进程crash信息输出到目录/data/system/dropbox；</p><p>5、执行makeAppCrashingLocked：</p><ul><li>创建当前用户下的crash应用的error receiver，并忽略当前应用的广播；</li><li>停止当前进程中所有activity中的WMS的冻结屏幕消息，并执行相关一些屏幕相关操作；</li></ul><p>6、再执行handleAppCrashLocked方法：</p><ul><li>当1分钟内同一进程连续crash两次时，且非persistent进程，则直接结束该应用所有activity，并杀死该进程以及同一个进程组下的所有进程。然后再恢复栈顶第一个非finishing状态的activity;</li><li>当1分钟内同一进程连续crash两次时，且persistent进程，，则只执行恢复栈顶第一个非finishing状态的activity;</li><li>当1分钟内同一进程未发生连续crash两次时，则执行结束栈顶正在运行activity的流程。</li></ul><p>7、通过mUiHandler发送消息SHOW_ERROR_MSG，弹出crash对话框；</p><p>8、到此，system_server进程执行完成。回到crash进程开始执行杀掉当前进程的操作；</p><p>9、当crash进程被杀，通过binder死亡通知，告知system_server进程来执行appDiedLocked()；</p><p>10、最后，执行清理应用相关的activity/service/ContentProvider/receiver组件信息。</p><h5 id="补充：binder-死亡通知原理"><a href="#补充：binder-死亡通知原理" class="headerlink" title="补充：binder 死亡通知原理"></a>补充：binder 死亡通知原理</h5><p>流程图如下：</p><p><img src="http://gityuan.com/images/stability/binder_died.jpg" alt="image"></p><p>由于Crash进程中拥有一个Binder服务端ApplicationThread，而应用进程在创建过程调用attachApplicationLocked()，从而attach到system_server进程，在system_server进程内有一个ApplicationThreadProxy，这是相对应的Binder客户端。当Binder服务端ApplicationThread所在进程(即Crash进程)挂掉后，则Binder客户端能收到相应的死亡通知，从而进入binderDied流程。</p><h3 id="2-4-Native-Crash"><a href="#2-4-Native-Crash" class="headerlink" title="2.4 Native Crash"></a>2.4 Native Crash</h3><p>特点:</p><ul><li>访问非法地址</li><li>地址对齐出错</li><li>发送程序主动abort</li></ul><p>上述都会产生相应的signal信号，导致程序异常退出</p><h4 id="2-4-1-合格的异常捕获组件"><a href="#2-4-1-合格的异常捕获组件" class="headerlink" title="2.4.1 合格的异常捕获组件"></a>2.4.1 合格的异常捕获组件</h4><ul><li>支持在crash时进行更多扩张操作</li><li>打印logcat和日志</li><li>上报crash次数</li><li>对不同crash做不同恢复措施</li><li>可以针对业务不断改进的适应</li></ul><h4 id="2-4-2-现有方案"><a href="#2-4-2-现有方案" class="headerlink" title="2.4.2 现有方案"></a>2.4.2 现有方案</h4><h5 id="Google-Breakpad"><a href="#Google-Breakpad" class="headerlink" title="Google Breakpad"></a>Google Breakpad</h5><ul><li>优点：权威、跨平台</li><li>缺点：代码体量较大</li></ul><h5 id="Logcat"><a href="#Logcat" class="headerlink" title="Logcat"></a>Logcat</h5><ul><li>优点：利用安卓系统实现</li><li>缺点：需要在crash时启动新进程过滤logcat日志，不可靠</li></ul><h5 id="coffeecatch"><a href="#coffeecatch" class="headerlink" title="coffeecatch"></a>coffeecatch</h5><ul><li>优点：实现简洁、改动容易</li><li>缺点：有兼容性问题</li></ul><h4 id="2-4-3-Native崩溃捕获流程"><a href="#2-4-3-Native崩溃捕获流程" class="headerlink" title="2.4.3 Native崩溃捕获流程"></a>2.4.3 Native崩溃捕获流程</h4><h5 id="1、编译端"><a href="#1、编译端" class="headerlink" title="1、编译端"></a>1、编译端</h5><p>编译C/C++需将带符号信息的文件保留下来。</p><h5 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h5><p>捕获到崩溃时，将收集到尽可能多的有用信息写入日志文件，然后选择合适的时机上传到服务器。</p><h5 id="3、服务端"><a href="#3、服务端" class="headerlink" title="3、服务端"></a>3、服务端</h5><p>读取客户端上报的日志文件，寻找合适的符号文件，生成可读的C/C++调用栈。</p><h4 id="2-4-4-Native崩溃捕获的难点"><a href="#2-4-4-Native崩溃捕获的难点" class="headerlink" title="2.4.4 Native崩溃捕获的难点"></a>2.4.4 Native崩溃捕获的难点</h4><p>核心：如何确保客户端在各种极端情况下依然可以生成崩溃日志。</p><h5 id="1、文件句柄泄漏，导致创建日志文件失败？"><a href="#1、文件句柄泄漏，导致创建日志文件失败？" class="headerlink" title="1、文件句柄泄漏，导致创建日志文件失败？"></a>1、文件句柄泄漏，导致创建日志文件失败？</h5><p>提前申请文件句柄fd预留。</p><h5 id="2、栈溢出导致日志生成失败？"><a href="#2、栈溢出导致日志生成失败？" class="headerlink" title="2、栈溢出导致日志生成失败？"></a>2、栈溢出导致日志生成失败？</h5><ul><li>使用额外的栈空间signalstack，避免栈溢出导致进程没有空间创建调用栈执行处理函数。（signalstack：系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</li><li>特殊请求需直接替换当前栈，所以应在堆中预留部分空间。</li></ul><h5 id="3、堆内存耗尽导致日志生产失败？"><a href="#3、堆内存耗尽导致日志生产失败？" class="headerlink" title="3、堆内存耗尽导致日志生产失败？"></a>3、堆内存耗尽导致日志生产失败？</h5><p>参考Breakpad重新封装Linux Syscall Support的做法以避免直接调用libc去分配堆内存。</p><h5 id="4、堆破坏或二次崩溃导致日志生成失败？"><a href="#4、堆破坏或二次崩溃导致日志生成失败？" class="headerlink" title="4、堆破坏或二次崩溃导致日志生成失败？"></a>4、堆破坏或二次崩溃导致日志生成失败？</h5><p>Breakpad使用了fork子进程甚至孙进程的方式去收集崩溃现场，即便出现二次崩溃，也只是这部分信息丢失。</p><p>这里说下Breakpad缺点：</p><ul><li>生成的minidump文件时二进制的，包含过多不重要的信息，导致文件数MB。但minidump可以使用gdb调试、看到传入参数。</li></ul><p>未来Chromium会使用Crashpad替代Breakpad。</p><h5 id="5、想要遵循Android的文本格式并添加更多重要的信息？"><a href="#5、想要遵循Android的文本格式并添加更多重要的信息？" class="headerlink" title="5、想要遵循Android的文本格式并添加更多重要的信息？"></a>5、想要遵循Android的文本格式并添加更多重要的信息？</h5><p>改造Breakpad，增加Logcat信息，Java调用栈信息、其它有用信息。</p><h4 id="2-4-5-Native崩溃捕获注册"><a href="#2-4-5-Native崩溃捕获注册" class="headerlink" title="2.4.5 Native崩溃捕获注册"></a>2.4.5 Native崩溃捕获注册</h4><p>一个Native Crash log信息如下：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/native_crash_log.png" alt="image"></p><p>堆栈信息中 pc 后面跟的内存地址，就是当前函数的栈地址，我们可以通过下面的命令行得出出错的代码行数</p><pre><code>arm-linux-androideabi-addr2line -e 内存地址</code></pre><p>下面列出全部的信号量以及所代表的含义：</p><pre><code>#define SIGHUP 1  // 终端连接结束时发出(不管正常或非正常)#define SIGINT 2  // 程序终止(例如Ctrl-C)#define SIGQUIT 3 // 程序退出(Ctrl-\)#define SIGILL 4 // 执行了非法指令，或者试图执行数据段，堆栈溢出#define SIGTRAP 5 // 断点时产生，由debugger使用#define SIGABRT 6 // 调用abort函数生成的信号，表示程序异常#define SIGIOT 6 // 同上，更全，IO异常也会发出#define SIGBUS 7 // 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数#define SIGFPE 8 // 计算错误，比如除0、溢出#define SIGKILL 9 // 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略#define SIGUSR1 10 // 未使用，保留#define SIGSEGV 11 // 非法内存操作，与 SIGBUS不同，他是对合法地址的非法访问，    比如访问没有读权限的内存，向没有写权限的地址写数据#define SIGUSR2 12 // 未使用，保留#define SIGPIPE 13 // 管道破裂，通常在进程间通信产生#define SIGALRM 14 // 定时信号,#define SIGTERM 15 // 结束程序，类似温和的 SIGKILL，可被阻塞和处理。通常程序如    果终止不了，才会尝试SIGKILL#define SIGSTKFLT 16  // 协处理器堆栈错误#define SIGCHLD 17 // 子进程结束时, 父进程会收到这个信号。#define SIGCONT 18 // 让一个停止的进程继续执行#define SIGSTOP 19 // 停止进程,本信号不能被阻塞,处理或忽略#define SIGTSTP 20 // 停止进程,但该信号可以被处理和忽略#define SIGTTIN 21 // 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号#define SIGTTOU 22 // 类似于SIGTTIN, 但在写终端时收到#define SIGURG 23 // 有紧急数据或out-of-band数据到达socket时产生#define SIGXCPU 24 // 超过CPU时间资源限制时发出#define SIGXFSZ 25 // 当进程企图扩大文件以至于超过文件大小资源限制#define SIGVTALRM 26 // 虚拟时钟信号. 类似于SIGALRM,     但是计算的是该进程占用的CPU时间.#define SIGPROF 27 // 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间#define SIGWINCH 28 // 窗口大小改变时发出#define SIGIO 29 // 文件描述符准备就绪, 可以开始进行输入/输出操作#define SIGPOLL SIGIO // 同上，别称#define SIGPWR 30 // 电源异常#define SIGSYS 31 // 非法的系统调用</code></pre><p>一般关注SIGILL, SIGABRT, SIGBUS, SIGFPE, SIGSEGV, SIGSTKFLT, SIGSYS即可。</p><p>要订阅异常发生的信号，最简单的做法就是直接用一个循环遍历所有要订阅的信号，对每个信号调用sigaction()。</p><p>注意：</p><ul><li>JNI_OnLoad是最适合安装信号初识函数的地方。</li><li>建议在上报时调用Java层的方法统一上报。Native崩溃捕获注册。</li></ul><h4 id="2-4-6-崩溃分析流程"><a href="#2-4-6-崩溃分析流程" class="headerlink" title="2.4.6 崩溃分析流程"></a>2.4.6 崩溃分析流程</h4><p>首先，应收集崩溃现场的一些信息，如下：</p><h5 id="1、崩溃信息"><a href="#1、崩溃信息" class="headerlink" title="1、崩溃信息"></a>1、崩溃信息</h5><ul><li>进程名、线程名</li><li>崩溃堆栈和类型</li><li>有时候也需要知道主线程的调用栈</li></ul><h5 id="2、系统信息"><a href="#2、系统信息" class="headerlink" title="2、系统信息"></a>2、系统信息</h5><ul><li>系统运行日志</li></ul><pre><code>/system/etc/event-log-tags</code></pre><ul><li>机型、系统、厂商、CPU、ABI、Linux版本等</li></ul><p>注意寻找共性问题</p><ul><li>设备状态</li><li>是否root</li><li>是否是模拟器</li></ul><h5 id="3、内存信息"><a href="#3、内存信息" class="headerlink" title="3、内存信息"></a>3、内存信息</h5><p><strong>系统剩余内存</strong></p><pre><code>/proc/meminfo</code></pre><p>当系统可用内存小于MemTotal的10%时，OOM、大量GC、系统频繁自杀拉起等问题非常容易出现</p><p><strong>应用使用内存</strong></p><p>包括Java内存、RSS、PSS</p><p>PSS和RSS通过/proc/self/smap计算，可以得到apk、dex、so等更详细的分类统计。</p><p><strong>虚拟内存</strong></p><p>大小：</p><pre><code>/proc/self/status</code></pre><p>具体分布情况：</p><pre><code>/proc/self/maps</code></pre><p>注意：</p><p>对于32位进程，32位CPU，虚拟内存达到3GB就可能会引起内存失败的问题。如果是64位的CPU，虚拟内存一般在3~4GB。如果支持64位进程，虚拟内存就不会成为问题。</p><h5 id="4、资源信息"><a href="#4、资源信息" class="headerlink" title="4、资源信息"></a>4、资源信息</h5><p>如果应用堆内存和设备内存比较充足，但还出现内存分配失败，则可能跟资源泄漏有关。</p><p><strong>文件句柄fd</strong></p><p>限制数：</p><pre><code>/proc/self/limits</code></pre><p>一般单个进程允许打开的最大句柄个数为1024，如果超过800需将所有fd和文件名输出日志进行排查。</p><p><strong>线程数</strong></p><p>大小：</p><pre><code>/proc/self/status</code></pre><p>一个线程一般占2MB的虚拟内存，线程数超过400个比较危险，需要将所有tid和线程名输出到日志进行排查。</p><p><strong>JNI</strong></p><p>容易出现引用失效、引用爆表等崩溃。</p><p>通过DumpReferenceTables统计JNI的引用表，进一步分析是否出现JNI泄漏等问题。</p><p><strong>补充：dumpReferenceTables的出处</strong></p><p>在dalvik.system.VMDebug类中，是一个native方法，亦是static方法；在JNI中可以这么调用</p><pre><code>jclass vm_class = env-&gt;FindClass(&quot;dalvik/system/VMDebug&quot;);jmethodID dump_mid = env-&gt;GetStaticMethodID( vm_class, &quot;dumpReferenceTables&quot;, &quot;()V&quot; );env-&gt;CallStaticVoidMethod( vm_class, dump_mid );</code></pre><h5 id="5、应用信息"><a href="#5、应用信息" class="headerlink" title="5、应用信息"></a>5、应用信息</h5><ul><li>崩溃场景</li><li>关键操作路径</li><li>其它跟自身应用相关的自定义信息：运行时间、是否加载补丁、是否全新安装或升级。</li></ul><p>接下来进行崩溃分析：</p><h5 id="1、确定重点"><a href="#1、确定重点" class="headerlink" title="1、确定重点"></a>1、确定重点</h5><ul><li>确认严重程度</li><li>优先解决Top崩溃或对业务有重大影响的崩溃：如启动、支付过程的崩溃</li><li>Java崩溃：如果是OOM，需进一步查看日志中的内存信息和资源信息</li><li>Native崩溃：查看signal、code、fault addr以及崩溃时的Java堆栈</li></ul><p>常见的崩溃类型有</p><p>SIGSEGV：空指针、非法指针等<br>SIGABRT：ANR、调用abort推出等</p><p>如果是ANR，先看主线程堆栈、是否因为锁等待导致，然后看ANR日志中的iowait、CPU、GC、systemserver等信息，确定是I/O问题或CPU竞争问题还是大量GC导致的ANR。</p><p>注意：</p><p>当从一条崩溃日志中无法看出问题原因时，需要查看相同崩溃点下的更多崩溃日志，或者也可以查看内存信息、资源信息等进行异常排查。</p><h5 id="2、查找共性"><a href="#2、查找共性" class="headerlink" title="2、查找共性"></a>2、查找共性</h5><p>机型、系统、ROM、厂商、ABI这些信息都可以作为共性参考，对于下一步复现问题有明确指引。</p><h5 id="3、尝试复现"><a href="#3、尝试复现" class="headerlink" title="3、尝试复现"></a>3、尝试复现</h5><p>复现之后再增加日志或使用Debugger、GDB进行调试。如不能复现，可以采用一些高级手段，如xlog日志、远程诊断、动态分析等等。</p><p>补充：系统崩溃解决方式</p><ul><li>1、通过共性信息查找可能的原因</li><li>2、尝试使用其它使用方式规避</li><li>3、Hook解决</li></ul><h4 id="2-4-7-实战：使用Breakpad捕获native崩溃"><a href="#2-4-7-实战：使用Breakpad捕获native崩溃" class="headerlink" title="2.4.7 实战：使用Breakpad捕获native崩溃"></a>2.4.7 实战：使用Breakpad捕获native崩溃</h4><p>首先，这里给出《Android开发高手课》张绍文老师写的<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter01" target="_blank" rel="external">crash捕获示例工程</a>，工程里面已经集成了Breakpad 来获取发生 native crash 时候的系统信息和线程堆栈信息。下面来详细介绍下使用Breakpad来分析native崩溃的流程：</p><p>1、示例工程是采用cmake的构建方式，所以需要先到Android Studio中SDK Manager中的SDK Tools下下载NDK和cmake。</p><p>2、安装实例工程后，点击CRASH按钮产生一个native崩溃。生成的 crash信息，如果授予Sdcard权限会优先存放在/sdcard/crashDump下，便于我们做进一步的分析。反之会放到目录 /data/data/com.dodola.breakpad/files/crashDump中。</p><p>3、使用adb pull命令将抓取到的crash日志文件放到电脑本地目录中：</p><pre><code>adb pull /sdcard/crashDump/***.dmp &gt; ~/Documents/crash_log.dmp</code></pre><p>4、下载并编译Breakpad源码，在src/processor目录下找到minidump_stackwalk，使用这个工具将dmp文件转换为txt文件：</p><pre><code>// 在项目目录下clone Breakpad仓库git clone https://github.com/google/breakpad.git// 切换到Breakpad根目录进行配置、编译cd breakpad./configure &amp;&amp; make// 使用src/processor目录下的minidump_stackwalk工具将dmp文件转换为txt文件./src/processor/minidump_stackwalk ~/Documents/crashDump/crash_log.dmp &gt;crash_log.txt </code></pre><p>5、打开crash_log.txt，可以得到如下内容：</p><pre><code>Operating system: Android                  0.0.0 Linux 4.4.78-perf-g539ee70 #1 SMP PREEMPT Mon Jan 14 17:08:14 CST 2019 aarch64CPU: arm64     8 CPUsGPU: UNKNOWNCrash reason:  SIGSEGV /SEGV_MAPERRCrash address: 0x0Process uptime: not availableThread 0 (crashed) 0  libcrash-lib.so + 0x650</code></pre><p>其中我们需要的关键信息为CPU是arm64的，并且crash的地址为0x650。接下来我们需要将这个地址转换为代码中对应的行。</p><p>6、ndk 中提供的addr2line来根据地址进行一个符号反解的过程。</p><p>如果是arm64的so使用 $NDKHOME/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line。</p><p>如果是arm的so使用 $NDKHOME/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-addr2line。</p><p>由crash_log.txt的信息可知，我们机器的cpu架构是arm64的，因此需要使用aarch64-linux-android-addr2line这个命令行工具。该命令的一般使用格式如下：<br>    // 注意：在mac下 ./ 代表执行文件    ./aarch64-linux-android-addr2line -e 对应的.so 需要解析的地址</p><p>上述中对应的.so文件在项目编译之后，会出现在Chapter01-master/sample/build/intermediates/merged_native_libs/debug/out/lib/arm64-v8a/libcrash-lib.so这个位置，由于我的手机CPU架构是arm64的，所以这里选择的是arm64-v8a中的libcrash-lib.so。接下来我们使用aarch64-linux-android-addr2line这个命令：</p><pre><code>./aarch64-linux-android-addr2line -f -C -e ~/Documents/open-project/Chapter01-master/sample/build/intermediates/merged_native_libs/debug/out/lib/arm64-v8a/libcrash-lib.so 0x650参数含义：-e --exe=&lt;executable&gt;：指定需要转换地址的可执行文件名。-f --functions：在显示文件名、行号输出信息的同时显示函数名信息。-C --demangle[=style]：将低级别的符号名解码为用户级别的名字。</code></pre><p>结果输出为：</p><pre><code>Crash()/Users/quchao/Documents/open-project/Chapter01-master/sample/src/main/cpp/crash.cpp:10</code></pre><p>由此，我们得出crash的代码行为crahs.cpp文件中的第10行，接下来根据项目具体情况进行相应的修改即可。</p><p>Tips：这是从事NDK开发（音视频、图像处理、OpenCv、热修复框架开发）同学调试native层错误时经常要使用的技巧，强烈建议熟练掌握。</p><h4 id="2-4-8-疑难Crash解决方案"><a href="#2-4-8-疑难Crash解决方案" class="headerlink" title="2.4.8 疑难Crash解决方案"></a>2.4.8 疑难Crash解决方案</h4><h5 id="问题1：如何解决Android-7-0-Toast-BadTokenException？"><a href="#问题1：如何解决Android-7-0-Toast-BadTokenException？" class="headerlink" title="问题1：如何解决Android 7.0 Toast BadTokenException？"></a>问题1：如何解决Android 7.0 Toast BadTokenException？</h5><p>参考Android 8.0 try catch的做法，代理Toast里的mTN（handler）就可以实现捕获异常。</p><h5 id="问题2：如果解决-SharedPreference-apply-引起的-ANR-问题"><a href="#问题2：如果解决-SharedPreference-apply-引起的-ANR-问题" class="headerlink" title="问题2：如果解决 SharedPreference apply 引起的 ANR 问题"></a>问题2：如果解决 SharedPreference apply 引起的 ANR 问题</h5><p><strong>apply为什么会引起ANR</strong>？</p><p>SP 调用 apply 方法，会创建一个等待锁放到 QueuedWork 中，并将真正数据持久化封装成一个任务放到异步队列中执行，任务执行结束会释放锁。Activity onStop 以及 Service 处理 onStop，onStartCommand 时，执行 QueuedWork.waitToFinish() 等待所有的等待锁释放。</p><p><strong>如何解决？</strong></p><p>所有此类 ANR 都是经由 QueuedWork.waitToFinish() 触发的，只要在调用此函数之前，将其中保存的队列手动清空即可。</p><p>具体是Hook ActivityThrad的Handler变量，拿到此变量后给其设置一个Callback，Handler 的 dispatchMessage 中会先处理 callback。最后在 Callback<br>中调用队列的清理工作，注意队列清理需要反射调用 QueuedWork。</p><p>注意：</p><p>apply 机制本身的失败率就比较高（1.8%左右），清理等待锁队列对持久化造成的影响不大。</p><h5 id="问题3：如何解决TimeoutExceptin异常？"><a href="#问题3：如何解决TimeoutExceptin异常？" class="headerlink" title="问题3：如何解决TimeoutExceptin异常？"></a>问题3：如何解决TimeoutExceptin异常？</h5><p>它是由系统的FinalizerWatchdogDaemon抛出来的。</p><p>这里首先介绍下看门狗 WatchDog，它 的作用是监控重要服务的运行状态，当重要服务停止时，发生 Timeout 异常崩溃，WatchDog 负责将应用重启。而当关闭 WatchDog（执行stop（）方法）后，当重要服务停止时，也不会发生 Timeout 异常，是一种通过非正常手段防止异常发生的方法。</p><p><strong>规避方案：</strong></p><p>stop方法，在Android 6.0之前会有线程同步问题。<br>因为6.0之前调用threadToStop的interrupt方法是没有加锁的，所以可能会有线程同步的问题。</p><p>注意：Stop的时候有一定概率导致即使没有超时也会报timeoutexception。</p><p>缺点：</p><p>只是为了避免上报异常采取的一种hack方案，并没有真正解决引起finialize超市的问题。</p><h5 id="问题4：如何解决输入法的内存泄漏？"><a href="#问题4：如何解决输入法的内存泄漏？" class="headerlink" title="问题4：如何解决输入法的内存泄漏？"></a>问题4：如何解决输入法的内存泄漏？</h5><p>通过反射将输入法的两个View置空。</p><h4 id="2-4-9-进程保活"><a href="#2-4-9-进程保活" class="headerlink" title="2.4.9 进程保活"></a>2.4.9 进程保活</h4><p>请参考<a href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android启动速度优化</a>一文。</p><p>这里补充一个方案，利用SyncAdapter提高进程优先级，它是Android系统提供一个账号同步机制，它属于核心进程级别，而使用了SyncAdapter的进程优先级本身也会提高，使用方式请Google，关联SyncAdapter后，进程的优先级变为1，仅低于前台正在运行的进程，因此可以降低应用被系统杀掉的概率。</p><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><ul><li>重在预防：重视应用的整个流程、包括开发人员的培训、编译检查、静态扫描、规范的测试、灰度、发布流程等</li><li>不应该随意使用try catch去隐藏问题，而应该从源头入手，了解崩溃的本质原因，保证后面的运行流程。</li><li>解决崩溃的过程应该由点到面，考虑一类崩溃怎么解决。</li><li>崩溃与内存、卡顿、I/O内存紧密相关</li></ul><h2 id="三、ANR优化"><a href="#三、ANR优化" class="headerlink" title="三、ANR优化"></a>三、ANR优化</h2><h3 id="3-1-ANR监控实现方式"><a href="#3-1-ANR监控实现方式" class="headerlink" title="3.1 ANR监控实现方式"></a>3.1 ANR监控实现方式</h3><h4 id="1、使用FileObserver监听-data-anr-traces-txt的变化"><a href="#1、使用FileObserver监听-data-anr-traces-txt的变化" class="headerlink" title="1、使用FileObserver监听 /data/anr/traces.txt的变化"></a>1、使用FileObserver监听 /data/anr/traces.txt的变化</h4><p>缺点：高版本ROM需要root权限</p><p>解决方案：海外Google Play服务、国内Hardcoder</p><h4 id="2、监控消息队列的运行时间（WatchDog）"><a href="#2、监控消息队列的运行时间（WatchDog）" class="headerlink" title="2、监控消息队列的运行时间（WatchDog）"></a>2、监控消息队列的运行时间（WatchDog）</h4><h5 id="卡顿监控原理："><a href="#卡顿监控原理：" class="headerlink" title="卡顿监控原理："></a>卡顿监控原理：</h5><p>利用主线程的消息队列处理机制，应用发生卡顿，一定是在dispatchMessage中执行了耗时操作。我们通过给主线程的Looper设置一个Printer，打点统计dispatchMessage方法执行的时间，如果超出阀值，表示发生卡顿，则dump出各种信息，提供开发者分析性能瓶颈。</p><p>为卡顿监控代码增加ANR的线程监控，在发送消息时，在ANR线程中保存一个状态，主线程消息执行完后再Reset标志位。如果在ANR线程中收到发送消息后，超过一定时间没有复位，就可以任务发生了ANR。</p><p>缺点：</p><ul><li>无法准确判断是否真正出现ANR，只能说明APP发生了UI阻塞，需要进行二次校验。校验的方式就是等待手机系统出现发生了Error的进程，并且Error类型是NOT_RESPONDING（值为2）。<br>在每次出现ANR弹框前，Native层都会发出signal为SIGNAL_QUIT（值为3）的信号事件，也可以监听此信号。</li><li>无法得到完整ANR日志</li><li>隶属于卡顿优化的方式</li></ul><h4 id="需要考虑应用退出场景"><a href="#需要考虑应用退出场景" class="headerlink" title="需要考虑应用退出场景"></a>需要考虑应用退出场景</h4><ul><li>主动自杀</li><li>Process.killProcess()、exit()等。</li><li>崩溃</li><li>系统重启</li><li>系统异常、断电、用户重启等：通过比较应用开机运行时间是否比之前记录的值更小。</li><li>被系统杀死</li><li>被LMK杀死、从系统的任务管理器中划掉等。</li></ul><p>注意：由于traces.txt上传比较耗时，所以一般线下采用，线上建议综合ProcessErrorStateInfo和出现ANR时的堆栈信息来实现ANR的实时上传。</p><h3 id="3-2-ANR优化"><a href="#3-2-ANR优化" class="headerlink" title="3.2 ANR优化"></a>3.2 ANR优化</h3><p>ANR发生原因：没有在规定的时间内完成要完成的事情。</p><h4 id="3-2-1-ANR分类"><a href="#3-2-1-ANR分类" class="headerlink" title="3.2.1 ANR分类"></a>3.2.1 ANR分类</h4><h5 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h5><ul><li>Activity onCreate方法或Input事件超过5s没有完成</li><li>BroadcastReceiver前台10s，后台60s</li><li>ContentProvider 在publish过超时10s;</li><li>Service前台20s，后台200s</li></ul><h5 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h5><ul><li>主线程有耗时操作</li><li>复杂布局</li><li>IO操作</li><li>被子线程同步锁block</li><li>被Binder对端block</li><li>Binder被占满导致主线程无法和SystemServer通信</li><li>得不到系统资源（CPU/RAM/IO）</li></ul><p>从进程角度看发生原因有：</p><ul><li>当前进程：主线程本身耗时或者主线程的消息队列存在耗时操作、主线程被本进程的其它子线程所blocked</li><li>远端进程：binder call、socket通信</li></ul><p>Andorid系统监测ANR的核心原理是消息调度和超时处理。</p><h4 id="3-2-2-ANR排查流程"><a href="#3-2-2-ANR排查流程" class="headerlink" title="3.2.2 ANR排查流程"></a>3.2.2 ANR排查流程</h4><h5 id="1、Log获取"><a href="#1、Log获取" class="headerlink" title="1、Log获取"></a>1、Log获取</h5><p>1、抓取bugreport</p><pre><code>adb shell bugreport &gt; bugreport.txt</code></pre><p>2、直接导出/data/anr/traces.txt文件</p><pre><code>adb pull /data/anr/traces.txt trace.txt</code></pre><h5 id="2、搜索“ANR-in”处log关键点解读"><a href="#2、搜索“ANR-in”处log关键点解读" class="headerlink" title="2、搜索“ANR in”处log关键点解读"></a>2、搜索“ANR in”处log关键点解读</h5><ul><li>发生时间（可能会延时10-20s）</li><li>pid：当pid=0，说明在ANR之前，进程就被LMK杀死或出现了Crash，所以无法接受到系统的广播或者按键消息，因此会出现ANR</li><li><p>cpu负载Load: 7.58 / 6.21 / 4.83</p><p>  代表此时一分钟有平均有7.58个进程在等待<br>  1、5、15分钟内系统的平均负荷<br>  当系统负荷持续大于1.0，必须将值降下来<br>  当系统负荷达到5.0，表面系统有很严重的问题</p></li><li><p>cpu使用率</p></li></ul><pre><code>CPU usage from 18101ms to 0ms ago28% 2085/system_server: 18% user + 10% kernel / faults: 8689 minor 24 major11% 752/android.hardware.sensors@1.0-service: 4% user + 6.9% kernel / faults: 2 minor9.8% 780/surfaceflinger: 6.2% user + 3.5% kernel / faults: 143 minor 4 major</code></pre><p>上述表示Top进程的cpu占用情况。</p><p>注意：如果CPU使用量很少，说明主线程可能阻塞。</p><h5 id="3、在bugreport-txt中根据pid和发生时间搜索到阻塞的log处"><a href="#3、在bugreport-txt中根据pid和发生时间搜索到阻塞的log处" class="headerlink" title="3、在bugreport.txt中根据pid和发生时间搜索到阻塞的log处"></a>3、在bugreport.txt中根据pid和发生时间搜索到阻塞的log处</h5><pre><code>----- pid 10494 at 2019-11-18 15:28:29 -----</code></pre><h5 id="4、往下翻找到“main”线程则可看到对应的阻塞log"><a href="#4、往下翻找到“main”线程则可看到对应的阻塞log" class="headerlink" title="4、往下翻找到“main”线程则可看到对应的阻塞log"></a>4、往下翻找到“main”线程则可看到对应的阻塞log</h5><pre><code>&quot;main&quot; prio=5 tid=1 Sleeping| group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x746bf7f0 self=0xe7c8f000| sysTid=10494 nice=-4 cgrp=default sched=0/0 handle=0xeb6784a4| state=S schedstat=( 5119636327 325064933 4204 ) utm=460 stm=51 core=4 HZ=100| stack=0xff575000-0xff577000 stackSize=8MB| held mutexes=</code></pre><p>关键字段含义：</p><ul><li>tid：线程号</li><li>sysTid：主进程线程号和进程号相同</li><li>Waiting/Sleeping：各种线程状态</li><li>nice：nice值越小，则优先级越高，-17~16</li><li>schedstat：Running、Runable时间(ns)与Switch次数</li><li>utm：该线程在用户态的执行时间(jiffies)</li><li>stm：该线程在内核态的执行时间(jiffies)</li><li>sCount：该线程被挂起的次数</li><li>dsCount：该线程被调试器挂起的次数</li><li>self：线程本身的地址</li></ul><h5 id="其它分析方法：Java线程调用分析方法"><a href="#其它分析方法：Java线程调用分析方法" class="headerlink" title="其它分析方法：Java线程调用分析方法"></a>其它分析方法：Java线程调用分析方法</h5><ul><li>先使用jps命令列出当前系统中运行的所有Java虚拟机进程，拿到应用进程的pid。</li><li>然后再使用jstack命令查看该进程中所有线程的状态以及调用关系，以及一些简单的分析结果。</li></ul><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>1、sp调用apply导致anr问题？</p><p>虽然apply并不会阻塞主线程，但是会将等待时间转嫁到主线程。</p><p>2、检测运行期间是否发生过异常退出？</p><p>在应用启动时设定一个标志，在主动自杀或崩溃后更新标志 ，下次启动时检测此标志即可判断。</p><h3 id="3-2-4-理解ANR的触发流程"><a href="#3-2-4-理解ANR的触发流程" class="headerlink" title="3.2.4 理解ANR的触发流程"></a>3.2.4 理解ANR的触发流程</h3><p>broadcast跟service超时机制大抵相同，但有一个非常隐蔽的技能点，那就是通过静态注册的广播超时会受SharedPreferences(简称SP)的影响。</p><p>当SP有未同步到磁盘的工作，则需等待其完成，才告知系统已完成该广播。并且只有XML静态注册的广播超时检测过程会考虑是否有SP尚未完成，动态广播并不受其影响。</p><ul><li><p>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding;</p></li><li><p>对于provider,在其进程启动时publish过程可能会出现ANR, 则会直接杀进程以及清理相应信息,而不会弹出ANR的对话框.</p></li><li><p>对于输入事件发生ANR，首先会调用InputMonitor.notifyANR，最终也会调用AMS.appNotResponding。</p></li></ul><h4 id="3-2-4-1-AMS-appNotResponding流程"><a href="#3-2-4-1-AMS-appNotResponding流程" class="headerlink" title="3.2.4.1 AMS.appNotResponding流程"></a>3.2.4.1 AMS.appNotResponding流程</h4><ul><li>输出ANR Reason信息到EventLog. 也就是说ANR触发的时间点最接近的就是EventLog中输出的am_anr信息;</li><li>收集并输出重要进程列表中的各个线程的traces信息，该方法较耗时; </li><li>输出当前各个进程的CPU使用情况以及CPU负载情况;</li><li>将traces文件和 CPU使用情况信息保存到dropbox，即data/system/dropbox目录（ANR信息最为重要的信息）</li><li>根据进程类型,来决定直接后台杀掉,还是弹框告知用户.</li></ul><h4 id="3-2-4-2-AMS-dumpStackTraces流程"><a href="#3-2-4-2-AMS-dumpStackTraces流程" class="headerlink" title="3.2.4.2 AMS.dumpStackTraces流程"></a>3.2.4.2 AMS.dumpStackTraces流程</h4><p>1、收集firstPids进程的stacks：</p><ul><li>第一个是发生ANR进程；</li><li>第二个是system_server；</li><li>其余的是mLruProcesses中所有的persistent进程。</li></ul><p>2、收集Native进程的stacks。(dumpNativeBacktraceToFile)</p><ul><li>依次是mediaserver,sdcard,surfaceflinger进程。</li></ul><p>3、收集lastPids进程的stacks：</p><ul><li>依次输出CPU使用率top 5的进程；</li></ul><p>注意：</p><p>上述导出每个进程trace时，进程之间会休眠200ms。</p><h2 id="四、移动端业务高可用方案建设"><a href="#四、移动端业务高可用方案建设" class="headerlink" title="四、移动端业务高可用方案建设"></a>四、移动端业务高可用方案建设</h2><h3 id="2-3-1-业务高可用重要性"><a href="#2-3-1-业务高可用重要性" class="headerlink" title="2.3.1 业务高可用重要性"></a>2.3.1 业务高可用重要性</h3><ul><li>高可用</li><li>性能</li><li>业务</li><li>侧重于用户功能完整可用</li><li>真实影响收入</li></ul><h3 id="2-3-2-业务高可用方案建设"><a href="#2-3-2-业务高可用方案建设" class="headerlink" title="2.3.2 业务高可用方案建设"></a>2.3.2 业务高可用方案建设</h3><ul><li>数据采集</li><li>梳理项目主流程、核心路径、关键节点</li><li>Aop自动采集、统一上报</li><li>报警策略：阈值报警、趋势报警、特定指标报警、直接上报（或底阈值）</li><li>异常监控</li><li>单点追查：需要针对性分析的特定问题，全量日志回捞，专项分析</li><li>兜底策略</li><li>配置中心、功能开关</li><li>跳转分发中心（组件化路由）</li></ul><h3 id="2-3-3-移动端容灾方案"><a href="#2-3-3-移动端容灾方案" class="headerlink" title="2.3.3 移动端容灾方案"></a>2.3.3 移动端容灾方案</h3><p>灾包括：</p><ul><li>性能异常</li><li>业务异常</li></ul><p>传统流程：</p><p>用户反馈、重新打包、渠道更新、不可接受。</p><h4 id="2-3-3-1-容灾方案建设："><a href="#2-3-3-1-容灾方案建设：" class="headerlink" title="2.3.3.1 容灾方案建设："></a>2.3.3.1 容灾方案建设：</h4><p><strong>功能开关</strong></p><p>配置中心，服务端下发配置控制</p><p>针对场景：</p><ul><li>功能新增</li><li>代码改动</li></ul><p><strong>统跳中心</strong></p><ul><li>界面切换通过路由，路由决定是否重定向</li><li>Native Bug不能热修复则跳转到临时H5页面</li></ul><p><strong>动态化修复</strong></p><ul><li>热修复能力，可监控、灰度、回滚、清除</li></ul><p><strong>推拉结合、多场景调用保证到达率</strong></p><p><strong>Weex、RN增量更新</strong></p><p><strong>安全模式</strong></p><p>微信读书、蘑菇街、淘宝、天猫等“重运营”的APP都使用了安全模式保障客户端启动流程，启动失败后给用户自救机会。先介绍一下它的核心特点：</p><ul><li>根据Crash信息自动恢复，多次启动失败重置应用为安装初始状态</li><li>严重Bug可阻塞性热修复</li></ul><p><strong>安全模式设计</strong></p><p>配置后台：统一的配置后台，具备灰度发布机制</p><p>1、客户端能力：</p><ul><li>在APP连续Crash的情况下具备分级、无感自修复能力</li><li>具备同步热修复能力</li><li>具备指定触发某项特定功能的能力</li><li>具体功能注册能力，方便后期扩展安全模式</li></ul><p>2、数据统计及告警</p><ul><li>统一的数据平台</li><li>监控告警功能，及时发现问题</li><li>查看热修复成功率等数据</li></ul><p>3、快速测试</p><ul><li>优化预发布环境下测试</li><li>优化回归验证安全模式难点等</li></ul><p><strong>天猫安全模式原理</strong></p><p>1、如何判断异常退出？</p><p>APP启动时记录一个flag值，满足以下条件时，将flag值清空</p><ul><li>APP正常启动10秒</li><li>用户正常退出应用</li><li>用户主动从前台切换到后台</li></ul><p>如果在启动阶段发生异常，则flag值不会清空，通过flag值就可以判断客户端是否异常退出，每次异常退出，flag值都+1。</p><p>2、安全模式的分级执行策略</p><p>分为两级安全模式，连续Crash 2次为一级安全模式，连续Crash 2次及以上为二级安全模式。</p><p>业务线可以在一级安全模式中注册行为，比如清空缓存数据，再进入该模式时，会使用注册行为尝试修复客户端<br>如果一级安全模式无法修复APP，则进入二级安全模式将APP恢复到初次安装状态，并将Document、Library、Cache三个根目录清空。</p><p>3、热修复执行策略</p><p>只要发现配置中需要热修复，APP就会同步阻塞进行热修复,保证修复的及时性</p><p>4、灰度方案</p><p>灰度时，配置中会包含灰度、正式两份配置及其灰度概率<br>APP根据特定算法算出自己是否满足灰度条件，则使用灰度配置</p><p><strong>易用性考量</strong></p><p>1、接入成本</p><p>完善文档、接口简洁</p><p>2、统一配置后台</p><p>可按照APP、版本配置</p><p>3、定制性</p><p>支持定制功能，让接入方来决定具体行为</p><p>4、灰度机制</p><p>5、数据分析</p><p>采用统一数据平台，为安全模式改进提供依据</p><p>6、快速测试</p><p>创建更多的针对性测试案例，如模拟连续Crash</p><p><strong>异常熔断</strong></p><ul><li>多次请求失败则可让网络库主动拒绝请求</li></ul><p><strong>容灾方案集合路径</strong></p><p>功能开关 -&gt; 统跳中心 -&gt; 动态修复 -&gt; 安全模式</p><h2 id="五、稳定性长效治理"><a href="#五、稳定性长效治理" class="headerlink" title="五、稳定性长效治理"></a>五、稳定性长效治理</h2><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><ul><li>统一编码规范、增强编码功底、技术评审、CodeReview机制</li><li>架构优化</li><li>能力收敛</li><li>统一容错：如在网络库utils中统一对返回信息进行预校验，如不合法就直接不走接下来的流程。</li></ul><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><ul><li>功能测试、自动化测试、回归测试、覆盖安装</li><li>特殊场景、机型等边界测试：如服务端返回异常数据、服务端宕机</li><li>云测平台：提供更全面的机型进行测试</li></ul><h3 id="合码阶段"><a href="#合码阶段" class="headerlink" title="合码阶段"></a>合码阶段</h3><ul><li>编译检测、静态扫描</li><li>预编译流程、主流程自动回归</li></ul><h3 id="发布阶段"><a href="#发布阶段" class="headerlink" title="发布阶段"></a>发布阶段</h3><ul><li>多轮灰度</li><li>分场景、纬度全面覆盖</li></ul><h3 id="运维阶段"><a href="#运维阶段" class="headerlink" title="运维阶段"></a>运维阶段</h3><ul><li>灵敏监控</li><li>回滚、降级策略</li><li>热修复、本地容灾方案</li></ul><h2 id="六、稳定性优化问题"><a href="#六、稳定性优化问题" class="headerlink" title="六、稳定性优化问题"></a>六、稳定性优化问题</h2><h3 id="1、你们做了哪些稳定性方面的优化？"><a href="#1、你们做了哪些稳定性方面的优化？" class="headerlink" title="1、你们做了哪些稳定性方面的优化？"></a>1、你们做了哪些稳定性方面的优化？</h3><ul><li>Crash专项优化</li><li>性能稳定性优化</li><li>业务稳定性优化</li></ul><p>根据以上三方面的优化我们搭建了移动端的高可用平台。</p><h3 id="2、性能稳定性是怎么做的？"><a href="#2、性能稳定性是怎么做的？" class="headerlink" title="2、性能稳定性是怎么做的？"></a>2、性能稳定性是怎么做的？</h3><ul><li>全面的性能优化：启动速度、内存优化、绘制优化</li><li>线下发现问题、优化为主</li><li>线上监控为主</li><li>Crash专项优化</li></ul><h3 id="3、业务稳定性如何保障？"><a href="#3、业务稳定性如何保障？" class="headerlink" title="3、业务稳定性如何保障？"></a>3、业务稳定性如何保障？</h3><ul><li>数据采集 + 报警</li><li>需要对项目的主流程与核心路径进行埋点监控，</li><li>同时还需知道每一步发生了多少异常，这样，我们就知道了所有业务流程的转换率以及相应界面的转换率</li><li>结合大盘，如果转换率低于某个值，进行报警</li><li>异常监控 + 单点追查</li><li>兜底策略</li></ul><h3 id="4、如果发送了异常情况，怎么快速止损？"><a href="#4、如果发送了异常情况，怎么快速止损？" class="headerlink" title="4、如果发送了异常情况，怎么快速止损？"></a>4、如果发送了异常情况，怎么快速止损？</h3><ul><li>功能开关</li><li>统跳中心</li><li>动态修复：热修复、资源包更新</li><li>自主修复：安全模式</li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Android稳定性优化是一个需要长期投入，持续运营和维护的一个过程，上文中我们不仅深入探讨了Java Crash、Native Crash和ANR的解决流程及方案，还分析了其内部实现原理和监控流程。到这里，可以看到，要想做好稳定性优化，我们必须对虚拟机运行、Linux信号处理和内存分配有一定程度的了解，只有深入了解这些底层知识，我们才能比别人设计出更好的稳定性优化方案。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、《Android性能优化最佳实践》第五章 稳定性优化 </p><p>2、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">慕课网之国内Top团队大牛带你玩转Android性能分析与优化 第十一章 App稳定性优化</a></p><p>3、<a href="https://time.geekbang.org/column/article/70966" target="_blank" rel="external">极客时间之Android开发高手课 崩溃优化</a> </p><p>4、<a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="external">Android 平台 Native 代码的崩溃捕获机制及实现</a></p><p>5、<a href="https://mp.weixin.qq.com/s__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488429&amp;idx=1&amp;sn=448b414a0424d06855359b3eb2ba8569&amp;source=41#wechat_redirect" target="_blank" rel="external">安全模式：天猫App启动保护实践</a></p><p>6、<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748107&amp;idx=1&amp;sn=55dff1b286e92cfb6aaee776df8ec89e&amp;chksm=bd12ae468a652750a7624c30eca56f6f83347b16cdfb9153b647c6e5229a822b16724a1bbd9d&amp;scene=38#wechat_redirect" target="_blank" rel="external">美团外卖Android Crash治理之路</a> （进阶）</p><p>7、<a href="https://mp.weixin.qq.com/s/PoWPWy3cXFlG1nohgJTJgw" target="_blank" rel="external">海神平台Crash监控SDK（Android）开发经验总结</a> </p><p>8、<a href="https://mp.weixin.qq.com/s?__biz=MzAxNzMxNzk5OQ==&amp;mid=2649485876&amp;idx=1&amp;sn=29ead87814c62a9b3e80cd6ada51e13c&amp;chksm=83f83b34b48fb2225db860a290b4e7ee3b30475d887c2b38e8e29881b297c3cdb5c6d44deaed&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android Native Crash 收集</a> </p><p>9、<a href="http://gityuan.com/2016/06/24/app-crash/" target="_blank" rel="external">理解Android Crash处理流程</a></p><p>10、<a href="https://www.jianshu.com/p/30c1a5ad63a3" target="_blank" rel="external">Android应用ANR分析</a> </p><p>11、<a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="external">理解Android ANR的触发原理</a></p><p>12、<a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="external">Input系统—ANR原理分析</a></p><p>13、<a href="https://www.jianshu.com/p/ad1a84b6ec69" target="_blank" rel="external">ANR监测机制</a> </p><p>14、<a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="external">理解Android ANR的触发原理</a> </p><p>15、<a href="http://gityuan.com/2016/12/02/app-not-response/" target="_blank" rel="external">理解Android ANR的信息收集过程</a> </p><p>16、<a href="https://www.jianshu.com/p/18f16aba79dd" target="_blank" rel="external">应用与系统稳定性第一篇—ANR问题分析的一般套路</a></p><p>17、<a href="https://www.jianshu.com/p/545e5e7bbf94" target="_blank" rel="external">巧妙定位ANR问题</a> </p><p>18、<a href="https://mp.weixin.qq.com/s/IFgXvPdiEYDs5cDriApkxQ" target="_blank" rel="external">剖析 SharedPreference apply 引起的 ANR 问题</a> </p><p>19、<a href="https://www.mkssoftware.com/docs/man5/siginfo_t.5.asp" target="_blank" rel="external">Linux错误信号</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
