<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Sun, 18 Aug 2019 14:11:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android性能优化之内存优化</title>
      <link>http://yoursite.com/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 18 Aug 2019 14:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。本篇，笔者将带领大家一起来系统地学习Android中的内存优化。</p><p>可能有不少读者都知道，在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面自动分配和释放内存，因此不需要像使用C/C++一样在代码中分配和释放某一块内存。Android系统的内存管理类似于JVM，通过new关键字来为对象分配内存，内存的释放由GC来回收。并且Android系统在内存管理上有一个Generational Heap Memory模型，当内存达到某一个阈值时，系统会根据不同的规则自动释放可以释放的内存。即便有了内存管理机制，但是，如果不合理地使用内存，也会造成一系列的性能问题，比如内存泄漏、内存抖动、短时间内分配大量的内存对象等等。下面，我就先谈谈Android的内存管理机制。</p><h3 id="一、Android内存管理机制"><a href="#一、Android内存管理机制" class="headerlink" title="一、Android内存管理机制"></a>一、Android内存管理机制</h3><p>我们都知道，应用程序的内存分配和垃圾回收都是由Android虚拟机完成的，在Android 5.0以下，使用的是Dalvik虚拟机，5.0及以上，则使用的是ART虚拟机。</p><h4 id="1-1、Java对象生命周期"><a href="#1-1、Java对象生命周期" class="headerlink" title="1.1、Java对象生命周期"></a>1.1、Java对象生命周期</h4><p>Java代码编译后生成的字节码.class文件从从文件系统中加载到虚拟机之后，便有了JVM上的Java对象，Java对象在JVM上运行有7个阶段，如下：</p><ul><li>Created</li><li>InUse</li><li>Invisible</li><li>Unreachable</li><li>Collected</li><li>Finalized</li><li>Deallocated</li></ul><h5 id="1、Created（创建）"><a href="#1、Created（创建）" class="headerlink" title="1、Created（创建）"></a>1、Created（创建）</h5><p>Java对象的创建分为如下几步：</p><ul><li>1、为对象分配存储空间。</li><li>2、构造对象。</li><li>3、从超类到子类对static成员进行初始化，类的static成员的初始化在ClassLoader加载该类时进行。</li><li>4、超类成员变量按顺序初始化，递归调用超类的构造方法。</li><li>5、子类成员变量按顺序初始化，一旦对象被创建，子类构造方法就调用该对象并为某些变量赋值。</li></ul><h5 id="2、InUse（应用）"><a href="#2、InUse（应用）" class="headerlink" title="2、InUse（应用）"></a>2、InUse（应用）</h5><p>此时对象至少被一个强引用持有。</p><h5 id="3、Invisible（不可见）"><a href="#3、Invisible（不可见）" class="headerlink" title="3、Invisible（不可见）"></a>3、Invisible（不可见）</h5><p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该对象仍然是存在的。简单的例子就是程序的执行已经超出了该对象的作用域了。但是，该对象仍可能被虚拟机下的某些已装载的静态变量线程或JNI等强引用持有，这些特殊的强引用称为“GC Root”。被这些GC Root强引用的对象会导致该对象的内存泄漏，因而无法被GC回收。</p><h5 id="4、Unreachable（不可达）"><a href="#4、Unreachable（不可达）" class="headerlink" title="4、Unreachable（不可达）"></a>4、Unreachable（不可达）</h5><p>该对象不再被任何强引用持有。</p><h5 id="5、Collected（收集）"><a href="#5、Collected（收集）" class="headerlink" title="5、Collected（收集）"></a>5、Collected（收集）</h5><p>当GC已经对该对象的内存空间重新分配做好准备时，对象进入收集阶段，如果该对象重写了finalize()方法，则执行它。</p><h5 id="6、Finalized（终结）"><a href="#6、Finalized（终结）" class="headerlink" title="6、Finalized（终结）"></a>6、Finalized（终结）</h5><p>等待垃圾回收器回收该对象空间。</p><h5 id="7、Deallocated（对象空间重新分配）"><a href="#7、Deallocated（对象空间重新分配）" class="headerlink" title="7、Deallocated（对象空间重新分配）"></a>7、Deallocated（对象空间重新分配）</h5><p>GC对该对象所占用的内存空间进行回收或者再分配，则该对象彻底消失。</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul><li>1、不需要使用该对象时，及时置空。</li><li>2、访问本地变量优于访问类中的变量。</li></ul><h4 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h4><p>在Android系统中，堆实际上就是一块匿名共享内存。Android虚拟机仅仅只是把它封装成一个mSpace，由底层C库来管理，并且仍然使用libc提供的函数malloc和free来分配和释放内存。</p><p>大多数静态数据会被映射到一个共享的进程中。常见的静态数据包括Dalvik Code、app resources、so文件等等。</p><p>在大多数情况下，Android通过显示分配共享内存区域（如ashmem或者gralloc）来实现动态RAM区域能够在不同进程之间共享的机制。例如，Window Surface在App和Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider和Clients之间共享内存。</p><p>上面说过，对于Android Runtime有两种虚拟机，Dalvik和ART，它们分配的内存区域块是不同的：</p><h5 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h5><ul><li>Linear Alloc</li><li>Zygote Space</li><li>Alloc Space</li></ul><h5 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h5><ul><li>Non Moving Space</li><li>Zygote Space</li><li>Alloc Space</li><li>Image Space</li><li>Large Obj Space</li></ul><p>不管是Dlavik还是ART，运行时堆都分为LinearAlloc（类似于ART的Non Moving Space）、Zygote Space和Alloc Space。Dalvik中的Linear Alloc是一个线性内存空间，是一个只读区域，主要用来存储虚拟机中的类，因为类加载后只需要读的属性，并且不会改变它。把这些只读属性以及在整个进程的生命周期都不能结束的永久数据放到线性分配器中管理，能很好地减少堆混乱和GC扫描，提升内存管理的性能。Zygote Space在Zygote进程和应用程序进程之间共享，Allocation Space则是每个进程独占。Android系统的第一个虚拟机由Zygote进程创建并且只有一个Zygote Space。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用的那部分堆内存划分为一部分，还没有使用的堆内存划分为另一部分，也就是Allocation Space。但无论是应用程序进程，还是Zygote进程，当他们需要分配对象时，都是在各自的Allocation Space堆上进行。</p><p>当在ART运行时，还有另外两个区块，即ImageSpace和Large Object Space。</p><ul><li>Image Space：存放一些预加载类，类似于Dalvik中的Linear Alloc。与Zygote Space一样，在Zygote进程和应用程序进程之间共享。 </li><li>Large Object Space：离散地址的集合，分配一些大对象，用于提高GC的管理效率和整体性能。</li></ul><p>注意：Image Space的对象只创建一次，而Zygote Space的对象需要在系统每次启动时，根据运行情况都重新创建一遍。</p><h4 id="1-3、内存回收机制"><a href="#1-3、内存回收机制" class="headerlink" title="1.3、内存回收机制"></a>1.3、内存回收机制</h4><p>在Android的高级系统版本中，针对Heap空间有一个Generational Heap Memory的模型，其中将整个内存分为三个区域：</p><ul><li>Young Generation（年轻代）</li><li>Old Generation（年老代）</li><li>Permanent Generation（持久代）</li></ul><p>模型示意图如下所示：</p><p><img src="http://www.jcodecraeer.com/uploads/20150920/1442716389944246.jpg" alt="image"></p><h5 id="1、Young-Generation"><a href="#1、Young-Generation" class="headerlink" title="1、Young Generation"></a>1、Young Generation</h5><p>由一个Eden区和两个Survivor区组成，程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当次Survivor区满时，此区存活的对象又被复制到另一个Survivor区，当这个Survivor区也满时，会将其中存活的对象复制到年老代。</p><h5 id="2、Old-Generation"><a href="#2、Old-Generation" class="headerlink" title="2、Old Generation"></a>2、Old Generation</h5><p>一般情况下，年老代中的对象生命周期都比较长。</p><h5 id="3、Permanent-Generation"><a href="#3、Permanent-Generation" class="headerlink" title="3、Permanent Generation"></a>3、Permanent Generation</h5><p>用于存放静态的类和方法，持久代对垃圾回收没有显著影响。</p><h5 id="总结：内存对象的处理过程如下："><a href="#总结：内存对象的处理过程如下：" class="headerlink" title="总结：内存对象的处理过程如下："></a>总结：内存对象的处理过程如下：</h5><ul><li>1、对象创建后在Eden区。</li><li>2、执行GC后，如果对象仍然存活，则复制到S0区。</li><li>3、当S0区满时，该区域存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换。</li><li>4、当第3步达到一定次数（系统版本不同会有差异）后，存活对象将被复制到Old Generation。</li><li>5、当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。</li></ul><p>系统在Young Generation、Old Generation上采用不同的回收机制。每一个Generation的内存区域都有固定的大小。随着新的对象陆续被分配到此区域，当对象总的大小临近这一级别内存区域的阈值时，会触发GC操作，以便腾出空间来存放其他新的对象。</p><p>执行GC占用的时间与Generation和Generation中的对象数量有关：</p><ul><li>Young Generation &lt; Old Generation &lt; Permanent Generation</li><li>Gener中的对象数量与执行时间成正比。</li></ul><h5 id="4、Young-Generation-GC"><a href="#4、Young-Generation-GC" class="headerlink" title="4、Young Generation GC"></a>4、Young Generation GC</h5><p>由于其对象存活时间短，因此基于Copying算法（扫描出存活的对象，并复制到一块新的完全未使用的控件中）来回收。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在Young Generation区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。</p><h5 id="5、Old-Generation-GC"><a href="#5、Old-Generation-GC" class="headerlink" title="5、Old Generation GC"></a>5、Old Generation GC</h5><p>由于其对象存活时间较长，比较稳定，因此采用Mark（标记）算法（扫描出存活的对象，然后再回收未被标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的效率损耗）来回收。</p><h3 id="1-4、GC类型"><a href="#1-4、GC类型" class="headerlink" title="1.4、GC类型"></a>1.4、GC类型</h3><p>在Android系统中，GC有三种类型：</p><ul><li>kGcCauseForAlloc：分配内存不够引起的GC，会Stop World。由于是并发GC，其它线程都会停止，直到GC完成。</li><li>kGcCauseBackground：内存达到一定阈值触发的GC，由于是一个后台GC，所以不会引起Stop World。</li><li>kGcCauseExplicit：显示调用时进行的GC，当ART打开这个选项时，使用System.gc时会进行GC。</li></ul><p>接下来，我们来学会如何分析Android虚拟机中的GC日志，日志如下：</p><pre><code>D/dalvikvm(7030)：GC_CONCURRENT freed 1049K, 60% free 2341K/9351K, external 3502K/6261K, paused 3ms 3ms</code></pre><p>GC_CONCURRENT是当前GC时的类型，GC日志中有以下几种类型：</p><ul><li>GC_CONCURRENT：当应用程序中的Heap内存占用上升时，避免Heap内存满了而触发的GC。</li><li>GC_FOR_MALLOC：这是由于Concurrent GC没有及时执行完，而应用又需要分配更多的内存，这时不得不停下来进行Malloc GC。</li><li>GC_EXTERNAL_ALLOC：这是为external分配的内存执行的GC。</li><li>GC_HPROF_DUMP_HEAP：创建一个HPROF profile的时候执行。</li><li>GC_EXPLICIT：显示调用了System.GC()。（尽量避免）</li></ul><p>再回到上面打印的日志:</p><ul><li>freed 1049k 表明在这次GC中回收了多少内存。</li><li>60% free 2341k/6261K 表明回收后60%的Heap可用，存活的对象大小为2341kb，heap大小是9351kb。</li><li>external 3502/6261K 是Native Memory的数据。存放Bitmap Pixel Data（位图数据）或者堆以外内存（NIO Direct Buffer）之类的。第一个值说明在Native Memory中已分配3502kb内存，第二个值是一个浮动的GC阈值，当分配内存达到这个值时，会触发一次GC。</li><li>paused 3ms 3ms 表明GC的暂停时间，如果是Concurrent GC，会看到两个时间，一个开始，一个结束，且时间很短，如如果是其他类型的GC，很可能只会看到一个时间，且这个时间是相对比较长的。并且，越大的Heap Size在GC时导致暂停的时间越长。</li></ul><p>注意：在ART模式下，多了一个Large Object Space，这部分内存并不是分配在堆上，但还是属于应用程序的内存空间。</p><p>在Dalvik虚拟机下，GC的操作都是并发的，也就意味着每次触发GC都会导致其它线程暂停工作（包括UI线程）。而在ART模式下，GC时不像Dalvik仅有一种回收算法，ART在不同的情况下会选择不同的回收算法，比如Alloc内存不够时会采用非并发GC，但在Alloc后，发现内存达到一定阈值时又会触发并发GC。所以在ART模式下，并不是所有的GC都是非并发的。</p><p>总体来看，在GC方面，与Dalvik相比，ART更为高效，不仅仅是GC的效率，大大地缩短了Pause时间，而且在内存分配上对大内存分配单独的区域，还能有算法在后台做内存整理，减少内存碎片。因此，在ART虚拟机下，可以避免较多的类似GC导致的卡顿问题。</p><h3 id="二、优化内存的意义"><a href="#二、优化内存的意义" class="headerlink" title="二、优化内存的意义"></a>二、优化内存的意义</h3><ul><li>减少OOM，提高应用稳定性。</li><li>减少卡顿，提高应用流畅度。</li><li>减少内存占用，提高应用后台运行时的存活率。</li><li>减少异常发生和代码逻辑隐患。</li></ul><p>注意：出现OOM是因为内存溢出导致，这种情况不一定会发生在相同的代码，也不一定是出现OOM的代码使用内存有问题，而是刚好执行到这段代码。</p><h3 id="三、避免内存泄漏"><a href="#三、避免内存泄漏" class="headerlink" title="三、避免内存泄漏"></a>三、避免内存泄漏</h3><h4 id="3-1-内存泄漏定义"><a href="#3-1-内存泄漏定义" class="headerlink" title="3.1 内存泄漏定义"></a>3.1 内存泄漏定义</h4><p>Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小。</p><h4 id="3-2-使用MAT来查找内存泄漏"><a href="#3-2-使用MAT来查找内存泄漏" class="headerlink" title="3.2 使用MAT来查找内存泄漏"></a>3.2 使用MAT来查找内存泄漏</h4><p>MAT工具可以帮助开发者定位导致内存泄漏的对象，以及发现大的内存对象，然后解决内存泄漏并通过优化内存对象，达到减少内存消耗的目的。</p><h5 id="3-2-1-使用步骤"><a href="#3-2-1-使用步骤" class="headerlink" title="3.2.1 使用步骤"></a>3.2.1 使用步骤</h5><p>1、在<a href="https://eclipse.org/mat/downloads.php下载MAT客户端。" target="_blank" rel="external">https://eclipse.org/mat/downloads.php下载MAT客户端。</a></p><p>2、从Android Studio进入Profile的Memory视图，选择需要分析的应用进程，对应用进行怀疑有内存问题的操作，结束操作后，主动GC几次，最后export dump文件。</p><p>3、因为Android Studio保存的是Android Dalvik/ART格式的.hprof文件，所以需要转换成J2SE HPROF格式才能被MAT识别和分析。Android SDK自带了一个转换工具在SDK的platform-tools下，其中转换语句为：</p><pre><code>./hprof-conv file.hprof converted.hprof</code></pre><p>4、通过MAT打开转换后的HPROF文件。</p><h5 id="3-2-2-MAT视图"><a href="#3-2-2-MAT视图" class="headerlink" title="3.2.2 MAT视图"></a>3.2.2 MAT视图</h5><p>在MAT窗口上，OverView是一个总体概览，显示总体的内存消耗情况和疑似问题。MAT提供了多种分析维度，其中Histogram、Dominator Tree、Top Consumers和Leak Suspects的分析维度不同。下面分别介绍下：</p><p>1、Histogram</p><p>列出内存中的所有实例类型对象和其个数以及大小，并在顶部的regex区域支持正则表达式查找。</p><p>2、Dominator Tree</p><p>列出最大的对象及其依赖存活的Object。相比Histogram，能更方便地看出引用关系。</p><p>3、Top Consumers</p><p>通过图像列出最大的Object。</p><p>4、Leak Suspects</p><p>通过MAT自动分析内存泄漏的原因和泄漏的一份总体报告。</p><p>分析内存最常用的是Histogram和Dominator Tree两个视图，视图中一共有四列：</p><ul><li>Class Name：类名。</li><li>Objects：对象实例个数。</li><li>Shallow Heap：对象自身占用的内存大小，不包括它引用的对象。非数组的常规对象的Shallow Heap Size由其成员变量的数量和类型决定，数组的Shallow Heap Size由数组元素的类型（对象类型、基本类型）和数组长度决定。真正的内存都在堆上，看起来是一堆原生的byte[]、char[]、int[]，对象本身的内存都很小。因此Shallow Heap对分析内存泄漏意义不是很大。</li><li>Retained Heap：是当前对象大小与当前对象可直接或间接引用到的对象的大小总和，包括被递归释放的。即：Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存大小。</li></ul><h5 id="3-2-3-查找内存泄漏具体位置"><a href="#3-2-3-查找内存泄漏具体位置" class="headerlink" title="3.2.3 查找内存泄漏具体位置"></a>3.2.3 查找内存泄漏具体位置</h5><p>常规方式：</p><ul><li>按照包名类型分类进行实例筛选或直接使用顶部Regex选取特定实例。</li><li>右击选中被怀疑的实例对象，选择Merge Shortest Paths to GC Root-&gt;exclude all phantom/weak/soft etc references。(显示GC Roots最短路径的强引用)</li><li>分析引用链或通过代码逻辑找出原因。 </li></ul><p>还有一种更快速的方法就是对比泄漏前后的HPROF数据：</p><ul><li>在两个HPROF文件中，把Histogram或者Dominator Tree增加到Compare Basket。</li><li>在Compare Basket中单击 ! ，生成对比结果视图。这样就可以对比相同的对象在不同阶段的对象实例个数和内存占用大小，如明显只需要一个实例的对象，或者不应该增加的对象实例个数却增加了，说明发生了内存泄漏，就需要去代码中定位具体的原因并解决。</li></ul><p>注意：如果目标不太明确，可以直接定位当RetainedHeap最大的Object，通过Select incoming references查看引用链，定位到可疑的对象，然后通过Path to GC Roots分析引用链。</p><p>此外，我们知道，当Hash集合中过多的对象返回相同的Hash值时，会严重影响性能，这时可以用Map Collision Ratio查找导致Hash集合的碰撞率较高的罪魁祸首。</p><p>在本人平时的项目开发中，一般会使用如下两种方式来快速对指定页面进行内存泄漏的检测：</p><ul><li><p>1、shell命令+LeakCanary+MAT：运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发GC，然后使用adb shell dumpsys meminfo packagename -d命令查看退出界面后Objects下的Views和Activities数目是否为0，如果不是则通过LeakCanary检查可能存在内存泄露的地方，最后通过MAT分析，如此反复，改善满意为止。</p></li><li><p>2、Profile MEMORY：运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面5次，然后收到GC（点击Profile MEMORY左上角的垃圾桶图标），如果此时total内存还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击Profile MEMORY左上角的垃圾桶图标旁的heap dump按钮查看当前的内存堆栈情况，选择按包名查找，找到当前测试的Activity，如果引用了多个实例，则表明发生了内存泄露。</p></li></ul><h4 id="3-3-常见内存泄漏场景"><a href="#3-3-常见内存泄漏场景" class="headerlink" title="3.3 常见内存泄漏场景"></a>3.3 常见内存泄漏场景</h4><h5 id="1、资源性对象未关闭"><a href="#1、资源性对象未关闭" class="headerlink" title="1、资源性对象未关闭"></a>1、资源性对象未关闭</h5><p>对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后在置为null。</p><h5 id="2、注册对象未注销"><a href="#2、注册对象未注销" class="headerlink" title="2、注册对象未注销"></a>2、注册对象未注销</h5><h5 id="3、类的静态变量持有大数据对象"><a href="#3、类的静态变量持有大数据对象" class="headerlink" title="3、类的静态变量持有大数据对象"></a>3、类的静态变量持有大数据对象</h5><h5 id="4、非静态内部类的静态实例"><a href="#4、非静态内部类的静态实例" class="headerlink" title="4、非静态内部类的静态实例"></a>4、非静态内部类的静态实例</h5><p>该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。</p><p>解决方案：</p><p>将内部类设为静态内部类或将内部类抽取来作为一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。</p><h5 id="5、Handler临时性内存泄漏"><a href="#5、Handler临时性内存泄漏" class="headerlink" title="5、Handler临时性内存泄漏"></a>5、Handler临时性内存泄漏</h5><p>Message发出之后存储在MessageQueue中，在Message中存在一个target，它是Handler的一个引用，Message在Queue中存在的时间过长，就会导致Handler无法被回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。并且消息队列是在一个Looper线程中不断地轮询处理消息，当这个Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中的Message持有Handler实例的引用，Handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。</p><p>解决方案：</p><ul><li>1、使用一个静态Handler内部类，然后对Handler持有的对象（一般是Activity）使用弱引用，这样在回收时，也可以回收Handler持有的对象。</li><li>2、在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。</li></ul><p>注意：AsyncTask内部也是Handler机制，同样存在内存泄漏风险，当其一般是临时性的。</p><h5 id="6、容器中的对象没清理造成的内存泄漏"><a href="#6、容器中的对象没清理造成的内存泄漏" class="headerlink" title="6、容器中的对象没清理造成的内存泄漏"></a>6、容器中的对象没清理造成的内存泄漏</h5><h5 id="7、WebView"><a href="#7、WebView" class="headerlink" title="7、WebView"></a>7、WebView</h5><p>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。</p><p>解决方案：</p><p>为WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。</p><h4 id="3-4-内存泄漏监控"><a href="#3-4-内存泄漏监控" class="headerlink" title="3.4 内存泄漏监控"></a>3.4 内存泄漏监控</h4><p>一般使用LeakCanary进行内存泄漏的监控即可，具体使用和原理分析请参见我之前的文章<a href="https://jsonchao.github.io/2019/01/06/Android主流三方库源码分析（六、深入理解Leakcanary源码）/" target="_blank" rel="external">Android主流三方库源码分析（六、深入理解Leakcanary源码）</a>。</p><p>除了基本使用外，我们还可以自定义处理结果，首先，继承DisplayLeakService实现一个自定义的监控处理Service，代码如下：</p><pre><code>public class LeakCnaryService extends DisplayLeakServcie {    private final String TAG = “LeakCanaryService”；    @Override    protected void afterDefaultHandling(HeapDump heapDump， AnalysisResult result， String leakInfo) {        ...    }}</code></pre><p>重写afterDefaultHanding方法，在其中处理需要的数据，三个参数的定义如下：</p><ul><li>heapDump：堆内存文件，可以拿到完成的hprof文件，以使用MAT分析。</li><li>result：监控到的内存状态，如是否泄漏等。</li><li>leakInfo：leak trace详细信息，除了内存泄漏对象，还有设备信息。</li></ul><p>然后在install时，使用自定义的LeakCanaryService即可，代码如下：</p><pre><code>public class BaseApplication extends Application {    @Override    public void onCreate() {        super.onCreate();        mRefWatcher = LeakCanary.install(this, LeakCanaryService.calss, AndroidExcludedRefs.createAppDefaults().build());    }    ...}</code></pre><p>经过这样的处理，就可以在LeakCanaryService中实现自己的处理方式，如丰富的提示信息，把数据保存在本地、上传到服务器进行分析。</p><p>注意：LeakCanaryService需要在AndroidManifest中注册。</p><h3 id="四、优化内存空间"><a href="#四、优化内存空间" class="headerlink" title="四、优化内存空间"></a>四、优化内存空间</h3><h4 id="4-1-对象引用"><a href="#4-1-对象引用" class="headerlink" title="4.1 对象引用"></a>4.1 对象引用</h4><p>从Java 1.2版本开始引入了三种对象引用方式：SoftReference、WeakReference和PhantomReference三个引用类，引用类的主要功能就是能够引用但仍可以被垃圾回收器回收的对象。在引入引用类之前，只能使用Strong Reference，如果没有指定对象引用类型，默认是强引用。</p><h5 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h5><p>如果一个对象具有强引用，GC就绝对不会回收它。当内存空间不足时，JVM会抛出OOM错误。</p><h5 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h5><p>如果一个对象只具有软引用，则内存空间足够，GC时就不会回收它；如果内存不足，就会回收这些对象的内存。可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个ReferenceQueue（引用队列）联合使用，如果软引用引用的对象被垃圾回收器回收，JVM会把这个软引用加入与之关联的引用队列中。</p><h5 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h5><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>注意：可能需要运行多次GC，才能找到并释放弱引用对象。</p><h5 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h5><p>只能用于跟踪即将对被引用对象进行的收集。虚拟机必须与ReferenceQueue类联合使用。因为它能够充当通知机制。</p><h4 id="4-2-减少不必要的内存开销"><a href="#4-2-减少不必要的内存开销" class="headerlink" title="4.2 减少不必要的内存开销"></a>4.2 减少不必要的内存开销</h4><h5 id="1、AutoBoxing"><a href="#1、AutoBoxing" class="headerlink" title="1、AutoBoxing"></a>1、AutoBoxing</h5><p>自动装箱的核心就是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。如int只占4字节，而Integer对象有16字节，特别是HashMap这类容器，进行增、删、改、查操作时，都会产生大量的自动装箱操作。</p><p>检测方式：使用TraceView查看耗时，如果发现调用了大量的integer.value，就说明发生了AutoBoxing。</p><h5 id="2、内存复用"><a href="#2、内存复用" class="headerlink" title="2、内存复用"></a>2、内存复用</h5><ul><li>资源复用：通用的字符串、颜色定义、简单页面布局的复用。</li><li>视图复用：可以使用ViewHolder实现ConvertView复用。</li><li>对象池：显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间。</li><li>Bitmap对象的复用：使用inBitmap属性可以告知Bitmap解码器尝试使用已经存在的内存区域，新解码的bitmap会尝试使用之前那张bitmap在heap中占据的pixel data内存区域。</li></ul><h4 id="4-3-使用最优的数据类型的"><a href="#4-3-使用最优的数据类型的" class="headerlink" title="4.3 使用最优的数据类型的"></a>4.3 使用最优的数据类型的</h4><h5 id="1、HashMap与ArrayMap"><a href="#1、HashMap与ArrayMap" class="headerlink" title="1、HashMap与ArrayMap"></a>1、HashMap与ArrayMap</h5><p>HashMap是一个散列链表，向HashMap中put元素时，先根据key的HashCode重新计算hash值，根据hash值得到这个元素在数组中的位置，如果数组该位置上已经存放有其它元素了，那么这个位置上的元素将以链表的形式存放，新加入的放在链头，最后加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。也就是说，向HashMap插入一个对象前，会给一个通向Hash阵列的索引，在索引的位置中，保存了这个Key对象的值。这意味着需要考虑的一个最大问题是冲突，当多个对象散列于阵列相同位置时，就会有散列冲突的问题。因此，HashMap会配置一个大的数组来减少潜在的冲突，并且会有其他逻辑防止链接算法和一些冲突的发生。</p><p>ArrayMap提供了和HashMap一样的功能，但避免了过多的内存开销，方法是使用两个小数组，而不是一个大数组。并且ArrayMap在内存上是连续不间断的。</p><p>总体来说，在ArrayMap中执行插入或者删除操作时，从性能角度上看，比HashMap还要更差一些，但如果只涉及很小的对象数，比如1000以下，就不需要担心这个问题了。因为此时ArrayMap不会分配过大的数组。</p><h5 id="2、枚举类型"><a href="#2、枚举类型" class="headerlink" title="2、枚举类型"></a>2、枚举类型</h5><p>使用枚举类型的dex size是普通常量定义的dex size的13倍以上，同时，运行时的内存分配，一个enum值的声明会消耗至少20bytes。</p><p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：IntDef和StringDef，用来提供编译期的类型检查。</p><p>注意：使用IntDef和StringDef需要在Gradle配置中引入相应的依赖包：</p><pre><code>compile &apos;com.android.support:support-annotations:22.0.0&apos;</code></pre><h5 id="3、LruCache"><a href="#3、LruCache" class="headerlink" title="3、LruCache"></a>3、LruCache</h5><p>最近最少使用缓存，使用强引用保存需要缓存的对象，它内部维护了一个由LinkedHashMap组成的双向列表，不支持线程安全，LruCache对它进行了封装，添加了线程安全操作。当其中的一个值被访问时，它被放到队列的尾部，当缓存将满时，队列头部的值（最近最少被访问的）被丢弃，之后可以被GC回收。</p><p>除了普通的get/set方法之外，还有sizeOf方法，它用来返回每个缓存对象的大小。此外，还有entryRemoved方法，当一个缓存对象被丢弃时调用的方法，当第一个参数为true：表明环处对象是为了腾出空间而被清理时。否则，表明缓存对象的entry被remove移除或者被put覆盖时。</p><p>注意：分配LruCache大小时应考虑应用剩余内存有多大。</p><h5 id="4、图片内存优化"><a href="#4、图片内存优化" class="headerlink" title="4、图片内存优化"></a>4、图片内存优化</h5><p>在Android默认情况下，当图片文件解码成位图时，会被处理成32bit/像素。红色、绿色、蓝色和透明通道各8bit，即使是没有透明通道的图片，如JEPG隔世是没有透明通道的，但然后会处理成32bit位图，这样分配的32bit中的8bit透明通道数据是没有任何用处的，这完全没有必要，并且在这些图片被屏幕渲染之前，它们首先要被作为纹理传送到GPU，这意味着每一张图片会同时占用CPU内存和GPU内存。</p><p>减少内存开销常用方式如下：</p><ul><li>1、设置位图的规格：当显示小图片或对图片质量要求不高时可以考虑使用RGB_565，用户头像或圆角图片一般可以尝试ARGB_4444。通过设置inPreferredConfig参数来实现不同的位图规格，代码如下所示：</li></ul><pre><code>BitmapFactory.Options options = new BitmapFactory.Options();options.inPreferredConfig = Bitmap.Config.RGB_565;BitmapFactory.decodeStream(is, null, options);</code></pre><ul><li>2、inSampleSize：位图功能对象中的inSampleSize属性实现了位图的缩放功能，代码如下所示：</li></ul><pre><code>BitampFactory.Options options = new BitmapFactory.Options();// 设置为4就是1/4大小的图片。因此，图片大小总会比原始图片小一倍以上。options.inSampleSize = 4;BitmapFactory.decodeSream(is, null, options);</code></pre><ul><li>3、inScaled，inDensity和inTargetDensity实现更细的缩放图片：当inScaled设置为true时，系统会按照现有的密度来划分目标密度，代码如下所示：</li></ul><pre><code>BitampFactory.Options options = new BitampFactory.Options();options.inScaled = true;options.inDensity = srcWidth;options.inTargetDensity = dstWidth;BitmapFactory.decodeStream(is, null, options);</code></pre><p>上述三种方案的缺点：使用了过多的算法，导致图片显示过程需要更多的时间开销，如果图片很多的话，就影响到图片的显示效果。最好的方案是结合这两个方法，达到最佳的性能结合，首先使用inSampleSize处理图片，转换为接近目标的2次幂，然后用inDensity和inTargetDensity生成最终想要的准确大小，因为inSampleSize会减少像素的数量，而基于输出密码的需要对像素重新过滤。但获取资源图片的大小，需要设置位图对象的inJustDecodeBounds值为true，然后继续解码图片文件，这样才能生产图片的宽高数据，并允许继续优化图片。总体的代码如下所示：</p><pre><code>BitmapFactory.Options options = new BitampFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeStream(is, null, options);options.inScaled = true;options.inDensity = options.outWidth;options.inSampleSize = 4;Options.inTargetDensity = desWith * options.inSampleSize;options.inJustDecodeBounds = false;BitmapFactory.decodeStream(is, null, options);</code></pre><h5 id="4、inBitmap"><a href="#4、inBitmap" class="headerlink" title="4、inBitmap"></a>4、inBitmap</h5><p>可以结合LruCache来实现，在LruCache移除超出cache size的图片时，暂时缓存Bitamp到一个软引用集合，需要创建新的Bitamp时，可以从这个软用用集合中找到最适合重用的Bitmap，来重用它的内存区域。</p><p>注意：新申请的Bitmap与旧的Bitmap必须有相同的解码格式，并且在Android 4.4之前，只能重用相同大小的Bitamp的内存区域，而Android 4.4之后可以重用任何bitmap的内存区域。</p><h3 id="五、图片管理模块设计与实现"><a href="#五、图片管理模块设计与实现" class="headerlink" title="五、图片管理模块设计与实现"></a>五、图片管理模块设计与实现</h3><p>在设计一个模块时，需要考虑以下几点：</p><ul><li>1、单一职责</li><li>2、避免不同功能之间的耦合</li><li>3、接口隔离</li></ul><p>在编写代码前先画好UML图，确定每一个对象、方法、接口的功能，首先尽量做到功能单一原则，在这个基础上，再明确模块与模块的直接关系，最后使用代码实现。</p><h4 id="5-1-实现异步加载功能"><a href="#5-1-实现异步加载功能" class="headerlink" title="5.1 实现异步加载功能"></a>5.1 实现异步加载功能</h4><h5 id="1-实现网络图片显示"><a href="#1-实现网络图片显示" class="headerlink" title="1.实现网络图片显示"></a>1.实现网络图片显示</h5><p>ImageLoader是实现图片加载的基类，其中ImageLoader有一个内部类BitmapLoadTask是继承AsyncTask的异步下载管理类，负责图片的下载和刷新，MiniImageLoader是ImageLoader的子类，维护类一个ImageLoader的单例，并且实现了基类的网络加载功能，因为具体的下载在应用中有不同的下载引擎，抽象成接口便于替换。代码如下所示：</p><pre><code>public abstract class ImageLoader {    private boolean mExitTasksEarly = false;   //是否提前结束    protected boolean mPauseWork = false;    private final Object mPauseWorkLock = new   Object();    protected ImageLoader() {    }    public void loadImage(String url, ImageView imageView) {        if (url == null) {            return;        }        BitmapDrawable bitmapDrawable = null;        if (bitmapDrawable != null) {            imageView.setImageDrawable(bitmapDrawable);        } else {            final BitmapLoadTask task = new BitmapLoadTask(url, imageView);            task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);        }    }    private class BitmapLoadTask extends AsyncTask&lt;Void, Void, Bitmap&gt; {        private String mUrl;        private final WeakReference&lt;ImageView&gt; imageViewWeakReference;        public BitmapLoadTask(String url, ImageView imageView) {            mUrl = url;            imageViewWeakReference = new WeakReference&lt;ImageView&gt;(imageView);        }        @Override        protected Bitmap doInBackground(Void... params) {            Bitmap bitmap = null;            BitmapDrawable drawable = null;            synchronized (mPauseWorkLock) {                while (mPauseWork &amp;&amp; !isCancelled()) {                    try {                        mPauseWorkLock.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }            if (bitmap == null                    &amp;&amp; !isCancelled()                    &amp;&amp; imageViewWeakReference.get() != null                    &amp;&amp; !mExitTasksEarly) {                bitmap = downLoadBitmap(mUrl);            }            return bitmap;        }        @Override        protected void onPostExecute(Bitmap bitmap) {            if (isCancelled() || mExitTasksEarly) {                bitmap = null;            }            ImageView imageView = imageViewWeakReference.get();            if (bitmap != null &amp;&amp; imageView != null) {                setImageBitmap(imageView, bitmap);            }        }        @Override        protected void onCancelled(Bitmap bitmap) {            super.onCancelled(bitmap);            synchronized (mPauseWorkLock) {                mPauseWorkLock.notifyAll();            }        }    }    public void setPauseWork(boolean pauseWork) {        synchronized (mPauseWorkLock) {            mPauseWork = pauseWork;            if (!mPauseWork) {                mPauseWorkLock.notifyAll();            }        }    }    public void setExitTasksEarly(boolean exitTasksEarly) {        mExitTasksEarly = exitTasksEarly;        setPauseWork(false);    }    private void setImageBitmap(ImageView imageView, Bitmap bitmap) {        imageView.setImageBitmap(bitmap);    }    protected abstract Bitmap downLoadBitmap(String    mUrl);}</code></pre><p>setPauseWork方法是图片加载线程控制接口，pauseWork控制图片模块的暂停和继续工作，一般在listView等控件中，滑动时停止加载图片，保证滑动流畅。另外，具体的图片下载和解码是和业务强相关的，因此在ImageLoader中不做具体的实现，只是定义类一个抽象方法。</p><p>MiniImageLoader是一个单例，保证一个应用只维护一个ImageLoader，减少对象开销，并管理应用中所有的图片加载。MiniImageLoader代码如下所示：</p><pre><code>public class MiniImageLoader extends ImageLoader {    private volatile static MiniImageLoader sMiniImageLoader = null;    private ImageCache mImageCache = null;    public static MiniImageLoader getInstance() {        if (null == sMiniImageLoader) {            synchronized (MiniImageLoader.class) {                MiniImageLoader tmp = sMiniImageLoader;                if (tmp == null) {                    tmp = new MiniImageLoader();                }                sMiniImageLoader = tmp;            }        }        return sMiniImageLoader;    }    public MiniImageLoader() {        mImageCache = new ImageCache();    }    @Override    protected Bitmap downLoadBitmap(String mUrl) {        HttpURLConnection urlConnection = null;        InputStream in = null;        try {            final URL url = new URL(mUrl);            urlConnection = (HttpURLConnection) url.openConnection();            in = urlConnection.getInputStream();            Bitmap bitmap = decodeSampledBitmapFromStream(in, null);            return bitmap;        } catch (MalformedURLException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();                urlConnection = null;            }            if (in != null) {                try {                    in.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return null;    }    public Bitmap decodeSampledBitmapFromStream(InputStream is, BitmapFactory.Options options) {        return BitmapFactory.decodeStream(is, null, options);    }}</code></pre><p>其中，volatile保证了对象从主内存加载。并且，上面的try …cache层级太多，Java中有一个Closeable接口，该接口标识类一个可关闭的对象，因此可以写如下的工具类：</p><pre><code>public class CloseUtils {    public static void closeQuietly(Closeable closeable) {        if (null != closeable) {            try {                closeable.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>改造后如下所示：</p><pre><code>finally {    if  (urlConnection != null) {        urlConnection.disconnect();        }    CloseUtil.closeQuietly(in);}</code></pre><p>同时，为了使ListView在滑动过程中更流畅，在滑动时暂停图片加载，减少系统开销，代码如下所示：</p><pre><code>listView.setOnScrollListener(new AbsListView.OnScrollListener() {    @Override    public void onScrollStateChanged(AbsListView absListView, int scrollState) {        if (scorllState == AbsListView.OnScrollListener.SCROLL_STAE_FLING) {            MiniImageLoader.getInstance().setPauseWork(true);        } else {            MiniImageLoader.getInstance().setPauseWork(false);        }    }}</code></pre><h5 id="2-单个图片内存优化"><a href="#2-单个图片内存优化" class="headerlink" title="2 单个图片内存优化"></a>2 单个图片内存优化</h5><p>这里使用一个BitmapConfig类来实现参数的配置，代码如下所示:</p><pre><code>public class BitmapConfig {    private int mWidth, mHeight;    private Bitmap.Config mPreferred;    public BitmapConfig(int width, int height) {        this.mWidth = width;        this.mHeight = height;        this.mPreferred = Bitmap.Config.RGB_565;    }    public BitmapConfig(int width, int height, Bitmap.Config preferred) {        this.mWidth = width;        this.mHeight = height;        this.mPreferred = preferred;    }    public BitmapFactory.Options getBitmapOptions() {        return getBitmapOptions(null);    }    // 精确计算，需要图片is流现解码，再计算宽高比    public BitmapFactory.Options getBitmapOptions(InputStream is) {        final BitmapFactory.Options options = new BitmapFactory.Options();        options.inPreferredConfig = Bitmap.Config.RGB_565;        if (is != null) {            options.inJustDecodeBounds = true;            BitmapFactory.decodeStream(is, null, options);            options.inSampleSize = calculateInSampleSize(options, mWidth, mHeight);        }        options.inJustDecodeBounds = false;        return options;    }    private static int calculateInSampleSize(BitmapFactory.Options    options, int mWidth, int mHeight) {        final int height = options.outHeight;        final int width = options.outWidth;        int inSampleSize = 1;        if (height &gt; mHeight || width &gt; mWidth) {            final int halfHeight = height / 2;            final int halfWidth = width / 2;            while ((halfHeight / inSampleSize) &gt; mHeight                    &amp;&amp; (halfWidth / inSampleSize) &gt; mWidth) {                inSampleSize *= 2;            }        }        return inSampleSize;    }}</code></pre><p>然后，调用MiniImageLoader的downLoadBitmap方法，增加获取BitmapFactory.Options的步骤：</p><pre><code>final URL url = new URL(urlString);urlConnection = (HttpURLConnection) url.openConnection();in = urlConnection.getInputStream();final BitmapFactory.Options options =    mConfig.getBitmapOptions(in);in.close();urlConnection.disconnect();urlConnection = (HttpURLConnection)    url.openConnection();in = urlConnection.getInputStream();Bitmap bitmap = decodeSampledBitmapFromStream(in,    options);</code></pre><p>优化后仍存在一些问题：</p><ul><li>1.相同的图片，每次都要重新加载；</li><li>2.整体内存开销不可控，虽然减少了单个图片开销，但是在片非常多的情况下，没有合理管理机制仍然对性能有严重影的。</li></ul><p>为了解决这两个问题，就需要有内存池的设计理念，通过内存池控制整体图片内存，不重新加载和解码已经显示过的图片。</p><h4 id="5-2-实现三级缓存"><a href="#5-2-实现三级缓存" class="headerlink" title="5.2 实现三级缓存"></a>5.2 实现三级缓存</h4><p>内存–本地–网络</p><h5 id="1、内存缓存"><a href="#1、内存缓存" class="headerlink" title="1、内存缓存"></a>1、内存缓存</h5><p>使用软引用和弱引用（SoftReference or WeakReference）来实现内存池是以前的常用做法，但是现在不建议。从API 9起（Android 2.3）开始，Android系统垃圾回收器更倾向于回收持有软引用和弱引用的对象，所以不是很靠谱，从Android 3.0开始（API 11）开始，图片的数据无法用一种可遇见的方式将其释放，这就存在潜在的内存溢出风险。<br>使用LruCache来实现内存管理是一种可靠的方式，它的主要算法原理是把最近使用的对象用强引用来存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。使用LruCache实现一个图片的内存缓存的代码如下所示：</p><pre><code>public class MemoryCache {    private final int DEFAULT_MEM_CACHE_SIZE = 1024 * 12;    private LruCache&lt;String, Bitmap&gt; mMemoryCache;    private final String TAG = &quot;MemoryCache&quot;;    public MemoryCache(float sizePer) {        init(sizePer);    }    private void init(float sizePer) {        int cacheSize = DEFAULT_MEM_CACHE_SIZE;        if (sizePer &gt; 0) {            cacheSize = Math.round(sizePer * Runtime.getRuntime().maxMemory() / 1024);        }        mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {            @Override            protected int sizeOf(String key, Bitmap value) {                final int bitmapSize = getBitmapSize(value) / 1024;                return bitmapSize == 0 ? 1 : bitmapSize;            }            @Override            protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {               super.entryRemoved(evicted, key, oldValue, newValue);            }        };    }    @TargetApi(Build.VERSION_CODES.KITKAT)    public int getBitmapSize(Bitmap bitmap) {        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {            return bitmap.getAllocationByteCount();        }        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) {            return bitmap.getByteCount();        }        return bitmap.getRowBytes() * bitmap.getHeight();    }    public Bitmap getBitmap(String url) {        Bitmap bitmap = null;        if (mMemoryCache != null) {            bitmap = mMemoryCache.get(url);        }        if (bitmap != null) {            Log.d(TAG, &quot;Memory cache exiet&quot;);        }        return bitmap;    }    public void addBitmapToCache(String url, Bitmap bitmap) {        if (url == null || bitmap == null) {            return;        }        mMemoryCache.put(url, bitmap);    }    public void clearCache() {        if (mMemoryCache != null) {            mMemoryCache.evictAll();        }    }}</code></pre><p>上述代码中cacheSize百分比占比多少合适？可以基于以下几点来考虑：</p><ul><li>1.应用中内存的占用情况，除了图片以外，是否还有大内存的数据需要缓存到内存。</li><li>2.在应用中大部分情况要同时显示多少张图片，优先保证最大图片的显示数量的缓存支持。</li><li>3.Bitmap的规格，计算出一张图片占用的内存大小。</li><li>4.图片访问的频率。</li></ul><p>在应用中，如果有一些图片的访问频率要比其它的大一些，或者必须一直显示出来，就需要一直保持在内存中，这种情况可以使用多个LruCache对象来管理多组Bitmap，对Bitmap进行分级，不同级别的Bitmap放到不同的LruCache中。</p><h5 id="2、bitmap内存复用"><a href="#2、bitmap内存复用" class="headerlink" title="2、bitmap内存复用"></a>2、bitmap内存复用</h5><p>从Android3.0开始Bitmap支持内存复用，也就是BitmapFactoy.Options.inBitmap属性，如果这个属性被设置有效的目标用对象，decode方法就在加载内容时重用已经存在的bitmap，这意味着Bitmap的内存被重新利用，这可以减少内存的分配回收，提高图片的性能。代码如下所示：</p><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {        mReusableBitmaps = Collections.synchronizedSet(newHashSet&lt;SoftReference&lt;Bitmap&gt;&gt;());}</code></pre><p>因为inBitmap属性在Android3.0以后才支持，在entryRemoved方法中加入软引用集合，作为复用的源对象，之前是直接删除，代码如下所示：</p><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {    mReusableBitmaps.add(new SoftReference&lt;Bitmap&gt;(oldValue));}</code></pre><p>同样在3.0以上判断，需要分配一个新的bitmap对象时，首先检查是否有可复用的bitmap对象：</p><pre><code>public static Bitmap decodeSampledBitmapFromStream(InputStream is, BitmapFactory.Options options, ImageCache cache) {     if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {         addInBitmapOptions(options, cache);     }     return BitmapFactory.decodeStream(is, null, options); }@TargetApi(Build.VERSION_CODES.HONEYCOMB)private static void addInBitmapOptions(BitmapFactory.Options options, ImageCache cache) {     options.inMutable = true;     if (cache != null) {         Bitmap inBitmap = cache.getBitmapFromReusableSet(options);         if (inBitmap != null) {             options.inBitmap = inBitmap;         }     } }</code></pre><p>接着，我们使用cache.getBitmapForResubleSet方法查找一个合适的bitmap赋值给inBitmap。代码如下所示：</p><pre><code>// 获取inBitmap,实现内存复用public Bitmap getBitmapFromReusableSet(BitmapFactory.Options options) {    Bitmap bitmap = null;    if (mReusableBitmaps != null &amp;&amp; !mReusableBitmaps.isEmpty()) {        final Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator = mReusableBitmaps.iterator();        Bitmap item;        while (iterator.hasNext()) {            item = iterator.next().get();            if (null != item &amp;&amp; item.isMutable()) {                if (canUseForInBitmap(item, options)) {                    Log.v(&quot;TEST&quot;, &quot;canUseForInBitmap!!!!&quot;);                    bitmap = item;                    // Remove from reusable set so it can&apos;t be used again                    iterator.remove();                    break;                }            } else {                // Remove from the set if the reference has been cleared.                iterator.remove();            }        }    }    return bitmap;}</code></pre><p>上述方法从软引用集合中查找规格可利用的Bitamp作为内存复用对象，因为使用inBitmap有一些限制，在Android 4.4之前，只支持同等大小的位图。因此使用了canUseForInBitmap方法来判断该Bitmap是否可以复用，代码如下所示：</p><pre><code>@TargetApi(Build.VERSION_CODES.KITKAT)private static boolean canUseForInBitmap(        Bitmap candidate, BitmapFactory.Options targetOptions) {    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) {        return candidate.getWidth() == targetOptions.outWidth                &amp;&amp; candidate.getHeight() == targetOptions.outHeight                &amp;&amp; targetOptions.inSampleSize == 1;    }    int width = targetOptions.outWidth / targetOptions.inSampleSize;    int height = targetOptions.outHeight / targetOptions.inSampleSize;    int byteCount = width * height * getBytesPerPixel(candidate.getConfig());    return byteCount &lt;= candidate.getAllocationByteCount();}</code></pre><h5 id="3、磁盘缓存"><a href="#3、磁盘缓存" class="headerlink" title="3、磁盘缓存"></a>3、磁盘缓存</h5><p>由于磁盘读取时间是不可预知的，所以图片的解码和文件读取都应该在后台进程中完成。DisLruCache是Android提供的一个管理磁盘缓存的类。</p><ul><li>1、首先调用DiskLruCache的open方法进行初始化，代码如下：</li></ul><pre><code>public static DiskLruCache open(File directory, int appVersion, int valueCou9nt, long maxSize)</code></pre><p>directory一般建议缓存到SD卡上。appVersion发生变化时，会自动删除前一个版本的数据。valueCount是指Key与Value的对应关系，一般情况下是1对1的关系。maxSize是缓存图片的最大缓存数据大小。初始化DiskLruCache的代码如下所示：</p><pre><code>private void init(final long cacheSize,final File cacheFile) {    new Thread(new Runnable() {        @Override        public void run() {            synchronized (mDiskCacheLock) {                if(!cacheFile.exists()){                    cacheFile.mkdir();                }                MLog.d(TAG,&quot;Init DiskLruCache cache path:&quot; + cacheFile.getPath() + &quot;\r\n&quot; + &quot;Disk Size:&quot; + cacheSize);                try {                    mDiskLruCache = DiskLruCache.open(cacheFile, MiniImageLoaderConfig.VESION_IMAGELOADER, 1, cacheSize);                    mDiskCacheStarting = false;                    // Finished initialization                    mDiskCacheLock.notifyAll();                     // Wake any waiting threads                }catch(IOException e){                    MLog.e(TAG,&quot;Init err:&quot; + e.getMessage());                }            }        }    }).start();}</code></pre><p>如果在初始化前就要操作写或者读会导致失败，所以在整个DiskCache中使用的Object的wait/notifyAll机制来避免同步问题。</p><ul><li>2、写入DiskLruCache</li></ul><p>首先，获取Editor实例，它需要传入一个key来获取参数，Key必须与图片有唯一对应关系，但由于URL中的字符可能会带来文件名不支持的字符类型，所以取URL的MD4值作为文件名，实现Key与图片的对应关系，通过URL获取MD5值的代码如下所示:</p><pre><code>private String hashKeyForDisk(String key) {    String cacheKey;    try {        final MessageDigest mDigest = MessageDigest.getInstance(&quot;MD5&quot;);        mDigest.update(key.getBytes());        cacheKey = bytesToHexString(mDigest.digest());    } catch (NoSuchAlgorithmException e) {        cacheKey = String.valueOf(key.hashCode());    }    return cacheKey;}private String bytesToHexString(byte[] bytes) {    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; bytes.length; i++) {        String hex = Integer.toHexString(0xFF &amp; bytes[i]);        if (hex.length() == 1) {            sb.append(&apos;0&apos;);        }        sb.append(hex);    }    return sb.toString();}</code></pre><p>然后，写入需要保存的图片数据，图片数据写入本地缓存的整体代码如下所示：</p><pre><code> public void saveToDisk(String imageUrl, InputStream in) {    // add to disk cache    synchronized (mDiskCacheLock) {        try {            while (mDiskCacheStarting) {                try {                    mDiskCacheLock.wait();                } catch (InterruptedException e) {}            }            String key = hashKeyForDisk(imageUrl);            MLog.d(TAG,&quot;saveToDisk get key:&quot; + key);            DiskLruCache.Editor editor = mDiskLruCache.edit(key);            if (in != null &amp;&amp; editor != null) {                // 当 valueCount指定为1时，index传0即可                OutputStream outputStream = editor.newOutputStream(0);                MLog.d(TAG, &quot;saveToDisk&quot;);                if (FileUtil.copyStream(in,outputStream)) {                    MLog.d(TAG, &quot;saveToDisk commit start&quot;);                    editor.commit();                    MLog.d(TAG, &quot;saveToDisk commit over&quot;);                } else {                    editor.abort();                    MLog.e(TAG, &quot;saveToDisk commit abort&quot;);                }            }            mDiskLruCache.flush();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>接着，读取图片缓存，通过DiskLruCache的get方法实现，代码如下所示：</p><pre><code>public Bitmap  getBitmapFromDiskCache(String imageUrl,BitmapConfig bitmapconfig) {    synchronized (mDiskCacheLock) {        // Wait while disk cache is started from background thread        while (mDiskCacheStarting) {            try {                mDiskCacheLock.wait();            } catch (InterruptedException e) {}        }        if (mDiskLruCache != null) {            try {                String key = hashKeyForDisk(imageUrl);                MLog.d(TAG,&quot;getBitmapFromDiskCache get key:&quot; + key);                DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);                if(null == snapShot){                    return null;                }                InputStream is = snapShot.getInputStream(0);                if(is != null){                    final BitmapFactory.Options options = bitmapconfig.getBitmapOptions();                    return BitmapUtil.decodeSampledBitmapFromStream(is, options);                }else{                    MLog.e(TAG,&quot;is not exist&quot;);                }            }catch (IOException e){                MLog.e(TAG,&quot;getBitmapFromDiskCache ERROR&quot;);            }        }    }    return null;}</code></pre><p>最后，要注意读取并解码Bitmap数据和保存图片数据都是有一定耗时的IO操作。所以这些方法都是在ImageLoader中的doInBackground方法中调用，代码如下所示：</p><pre><code>@Overrideprotected Bitmap doInBackground(Void... params) {    Bitmap bitmap = null;    synchronized (mPauseWorkLock) {        while (mPauseWork &amp;&amp; !isCancelled()) {            try {                mPauseWorkLock.wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    if (bitmap == null &amp;&amp; !isCancelled()            &amp;&amp; imageViewReference.get() != null &amp;&amp; !mExitTasksEarly) {        bitmap = getmImageCache().getBitmapFromDisk(mUrl, mBitmapConfig);    }    if (bitmap == null &amp;&amp; !isCancelled()            &amp;&amp; imageViewReference.get() != null &amp;&amp; !mExitTasksEarly) {        bitmap = downLoadBitmap(mUrl, mBitmapConfig);    }    if (bitmap != null) {        getmImageCache().addToCache(mUrl, bitmap);    }    return bitmap;}</code></pre><h4 id="5-3-图片加载三方库"><a href="#5-3-图片加载三方库" class="headerlink" title="5.3 图片加载三方库"></a>5.3 图片加载三方库</h4><p>目前使用最广泛的有Picasso、Glide和Fresco。Glide和Picasso比较相似，但是Glide相对于Picasso来说，功能更多，内部实现更复杂，对Glide有兴趣的同学可以阅读这篇文章<a href="https://jsonchao.github.io/2018/12/16/Android主流三方库源码分析（三、深入理解Glide源码）" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>。Fresco最大的亮点在与它的内存管理，特别实在低端机和Android 5.0以下的机器上的优势更加明显，而使用Fresco将很好地解决图片占用内存大的问题。因为，Fresco会将图片放到一个特别的内存区域，当图片不再显示时，占用的内存会自动释放。以下总结以下其优点：</p><ul><li>1、内存管理。</li><li>2、渐进式呈现：先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片。</li><li>3、支持更多的图片格式:如Gif和Webp。</li><li>4、图像加载策略丰富：其中的Image Pipeline可以为同一个图片指定不同的远程路径，比如先显示已经存在本地缓存中的图片，等高清图下载完成之后在显示高清图集。</li></ul><p>缺点：</p><ul><li>安装包过大，所以对图片加载和显示要求不是比较高的情况下建议使用Glide。</li></ul><h4 id="六、内存优化"><a href="#六、内存优化" class="headerlink" title="六、内存优化"></a>六、内存优化</h4><p>对于内存泄漏，其本质可理解为无法回收无用的对象。这里我总结了我在项目中遇到的一些常见的内存泄漏案例（包含解决方案）和常见的内存优化技术。</p><h5 id="6-1、常见的内存泄漏案例-完善3-3小节）："><a href="#6-1、常见的内存泄漏案例-完善3-3小节）：" class="headerlink" title="6.1、常见的内存泄漏案例(完善3.3小节）："></a>6.1、常见的内存泄漏案例(完善3.3小节）：</h5><ul><li>1、单例造成的内存泄漏（使用Application的Context）</li><li>2、非静态内部类创建静态实例造成的内存泄漏（将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，就使用Application的Context）</li><li>3、Handler造成的内存泄漏（将Handler类独立出来或者使用静态内部类）</li><li>4、线程造成的内存泄漏（将AsyncTask和Runnable类独立出来或者使用静态内部类）</li><li>5、BraodcastReceiver、Bitmap等资源未关闭造成的内存泄漏（应该在Activity销毁时及时关闭或者注销）</li><li>6、使用ListView时造成的内存泄漏（在构造Adapter时，使用缓存的convertView）</li><li>7、集合容器中的内存泄露（在退出程序之前，将集合里的东西clear，然后置为null，再退出程序）</li><li>8、WebView造成的泄露（为WebView另外开启一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放）</li></ul><h5 id="6-2、常见的内存优化点："><a href="#6-2、常见的内存优化点：" class="headerlink" title="6.2、常见的内存优化点："></a>6.2、常见的内存优化点：</h5><p>1、只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。</p><p>2、图片优化：</p><ul><li>颜色模式：RGB_8888-&gt;RGB_565</li><li>降低图片大小</li><li>降低采样率</li></ul><p>3、在App退到后台内存紧张即将被Kill掉时选择重写onTrimMemory()方法去释放掉图片缓存、静态缓存来自保。</p><p>4、item被回收不可见时释放掉对图片的引用：</p><ul><li>ListView：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。</li><li>RecyclerView：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。</li></ul><p>5、集合优化：Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p><p>6、避免创作不必要的对象：字符串拼接使用StringBuffer，StringBuilder。</p><p>7、onDraw方法里面不要执行对象的创建。</p><p>8、使用static final 优化成员变量。</p><p>9、使用增强型for循环语法。</p><p>10、在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。</p><p>11、适当采用软引用和弱引用。</p><p>12、采用内存缓存和磁盘缓存。</p><p>13、尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>对于内存优化，一般都是通过使用MAT等工具来进行检查和使用LeakCanary等内存泄漏监控工具来进行监控，以此来发现问题，再分析问题原因，解决发现的问题或者对当前的实现逻辑进行优化，优化完后在进行检查，直到达到预定的性能指标。下一篇，将会深入分析一下Android系统的存储优化相关技术，尽请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android应用性能优化最佳实践</p><p>2、<a href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ?" target="_blank" rel="external">必知必会 | Android 性能优化的方面方面都在这儿</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android性能优化之绘制优化</title>
      <link>http://yoursite.com/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 28 Jul 2019 10:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>我们都知道，造成绘制不流畅最大的罪魁祸首就是卡顿，而卡顿的主要场景有很多，按场景可以分成4类：UI绘制、应用启动、页面跳转、事件响应，其中又可细分为如下：</p><h5 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h5><ul><li>绘制</li><li>刷新</li></ul><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul><li>安装启动</li><li>冷启动</li><li>热启动</li></ul><h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><ul><li>页面间跳转</li><li>前后台切换</li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul><li>按键</li><li>系统事件</li><li>滑动</li></ul><p>造成其根本原因可以分为两大类：</p><h5 id="界面绘制"><a href="#界面绘制" class="headerlink" title="界面绘制"></a>界面绘制</h5><ul><li>绘制层级深</li><li>页面复杂</li><li>刷新不合理</li></ul><h5 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h5><ul><li>数据处理在UI线程</li><li>占用CPU高，导致主线程拿不到时间片</li><li>内存增加导致GC频繁，从而引起卡顿</li></ul><h3 id="一、Android系统显示原理"><a href="#一、Android系统显示原理" class="headerlink" title="一、Android系统显示原理"></a>一、Android系统显示原理</h3><p>Android的显示过程可以简单概括为：Android应用程序把经过测量、布局、绘制后的surface缓存数据、通过SurfaceFlinger把数据渲染到显示屏幕上，通过Android的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕。</p><h4 id="1-1、绘制原理"><a href="#1-1、绘制原理" class="headerlink" title="1.1、绘制原理"></a>1.1、绘制原理</h4><h5 id="1、应用层"><a href="#1、应用层" class="headerlink" title="1、应用层"></a>1、应用层</h5><p>在Android的每个View都会经过Measure和Layout来确定当前需要绘制的View所在的大小和位置，通过绘制到surface，在Android系统中整体的绘制源码是在ViewRootImpl类的performTraversals()方法，通过这个方法可以看出Measure和Layout都是递归来获取View的大小和位置，并且以深度作为优先级。显然，层级越深，元素越多，耗时就越长。</p><p>对于绘制，Android支持两种绘制方式：</p><ul><li>软件绘制（CPU）</li><li>硬件绘制（GPU）</li></ul><p>硬件加速从Android 3.0开始支持，它在UI显示和绘制效率方面远高于软件绘制。但它的局限如下：</p><ul><li>耗电：GPU功耗高于CPU。</li><li>兼容性：不兼容某些接口和函数。</li><li>内存大：使用OpenGL的接口需要占用内存8MB。</li></ul><h5 id="2、系统层"><a href="#2、系统层" class="headerlink" title="2、系统层"></a>2、系统层</h5><p>将数据渲染到屏幕上是通过系统级进程中的SurfaceFlinger服务来实现的，它的主要工作流程如下：</p><ul><li>1、响应客户端事件，创建Layer与客户端的Surface建立连接。</li><li>2、接收客户端数据和属性，修改Layer属性，如尺寸、颜色、透明度等。</li><li>3、将创建的Layer内容刷新到屏幕上。</li><li>4、维持Layer的序列，并对Layer最终输出做出裁剪计算。</li></ul><p>其中，SurfaceFlinger系统进程和应用进程使用了匿名共享内存SharedClient，并且，每一个应用和SurfaceFlinger之间都会创建一个SharedClient，并且，每个SharedClient中，最多可以创建31个SharedBufferStack，每一个SharedBufferStack对应一个Surface，即一个window。（其中包含了两个（小于4.1版本）或者三个（4.1及以上版本）缓冲区）</p><p>因此，从上可知，一个Android应用程序最多可以包含31个窗口。最后，显示的整体流程如下：</p><ul><li>应用层绘制到缓冲区</li><li>SurfaceFlinger把缓冲区数据渲染到屏幕，其中使用了Android匿名共享内存SharedClient缓存需要显示的数据来达到目的。</li></ul><p>绘制的过程首先是CPU准备数据，通过Driver层把数据交给CPU渲染，其中CPU主要负责Measure、Layout、Record、Execute的数据计算工作，GPU负责Rasterization（栅格化）、渲染。因为图形API不允许CPU直接和GPU通信，所以要通过一个图形驱动的中间层来进行连接。图形驱动里面维护了一个队列，CPU把display list（待显示的数据列表）添加到队列中，GPU从这个队列中取出数据进行绘制，最终才在显示屏上显示出来。</p><p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的60FPS。</p><h4 id="1-2-刷新机制"><a href="#1-2-刷新机制" class="headerlink" title="1.2 刷新机制"></a>1.2 刷新机制</h4><p>4.1版本的Project Butter对Android Display系统进行了重构，引入了三个核心元素：VSYNC（Vertical Synchronization）、Triple Buffer、Choreographer。其中作为Project Buffer核心的VSYNC，即垂直同步可认为是一种定时中断。而Choreographer起调度的作用，将绘制工作统一到VSYNC的某个时间点上，使应用的绘制工作有序。</p><h5 id="为什么要推出Project-Butter？"><a href="#为什么要推出Project-Butter？" class="headerlink" title="为什么要推出Project Butter？"></a>为什么要推出Project Butter？</h5><p>解决刷新不同步的问题。</p><h5 id="为什么要使用双缓冲技术？"><a href="#为什么要使用双缓冲技术？" class="headerlink" title="为什么要使用双缓冲技术？"></a>为什么要使用双缓冲技术？</h5><p>在Linux上通常使用Framebuffer来做显示输出，当用户进程更新Framebuffer中的数据后，显示驱动会把FrameBuffer中每个像素点的值更新到屏幕，但是如果上一帧数据还没显示完，Framebuffer中的数据又更新了，就会带来残影的问题，用户会觉得有闪烁感，所以采用了双缓冲技术。</p><h5 id="双缓冲的含义？"><a href="#双缓冲的含义？" class="headerlink" title="双缓冲的含义？"></a>双缓冲的含义？</h5><p>双缓冲意味着要使用两个缓冲区（在上文提及的SharedBufferStack中），其中一个称为Front Buffer，另一个称为Back Buffer。UI总是先在Back Buffer中绘制，然后再和Front Buffer交换，渲染到显示设备中。即只有当另一个buffer的数据准备好后，通过io_ctl来通知显示设备切换Buffer。</p><h5 id="Choreographer的作用是什么？"><a href="#Choreographer的作用是什么？" class="headerlink" title="Choreographer的作用是什么？"></a>Choreographer的作用是什么？</h5><p>当收到VSYNC信号时，调用用户设置的回调函数。回调类型的优先级从高到低为CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL。</p><h5 id="当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？"><a href="#当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？" class="headerlink" title="当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？"></a>当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？</h5><p>因为只有两个Buffer；所以4.1版本后，出现了第三个缓冲区：Triple Buffer。它利用CPU/GPU的空闲等待时间提前准备好数据，并不一定会使用。</p><p><strong>注意</strong>：除非必要，大部分情况下只是用到双缓冲。而且，缓冲区并不是越多越好，要做到平衡到最佳效果。</p><h5 id="Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？"><a href="#Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？" class="headerlink" title="Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？"></a>Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？</h5><p>因为VSync 中断处理的线程优先级一定要最高，否则即使接收到VSync中断，不能及时处理，也是徒劳无功。</p><h4 id="1-3、卡顿的根本原因"><a href="#1-3、卡顿的根本原因" class="headerlink" title="1.3、卡顿的根本原因"></a>1.3、卡顿的根本原因</h4><ul><li>绘制任务太重、绘制一帧内容耗时太长。</li><li>主线程太忙，导致VSync信号来时还没有准备好数据导致丢帧。</li></ul><h3 id="二、性能分析工具"><a href="#二、性能分析工具" class="headerlink" title="二、性能分析工具"></a>二、性能分析工具</h3><p>Android常用的性能优化工具一般有如下几种：</p><ul><li>Hierarchy View：查看Layout层次</li><li>Android Studio自带的Profile工具</li><li>静态代码检查工具Lint</li><li>TraceView</li><li>Systrace</li></ul><h4 id="2-1、卡顿检测工具Profile-GPU-Rendering"><a href="#2-1、卡顿检测工具Profile-GPU-Rendering" class="headerlink" title="2.1、卡顿检测工具Profile GPU Rendering"></a>2.1、卡顿检测工具Profile GPU Rendering</h4><p>它是Android手机上自带的一个辅助工具，打开Profile GPU Rendering后可以看到实时刷新的彩色图，其中每一根竖线表示一帧，由多个颜色组成，不同颜色的解释如下：</p><ul><li>每一条柱状图都由红、黄、蓝、紫组成，分别对应每一帧在不同阶段的实际耗时。</li><li>蓝色：测量绘制的时间，需要多长时间去创建和更新DisplayList。在蓝色的线很高时，有可能是因为需要重新绘制，或者自定义视图的onDraw函数处理事情太多。</li><li>红色：Android进行2D渲染Display List的执行的时间。当红色的线非常高时，可能是由于重新提交了视图导致的。</li><li>橙色：处理时间或CPU告诉GPU渲染一帧的地方，如果柱状图很高，就意味着GPU太繁忙了。</li><li>紫色：将资源转移到渲染线程的时间。（4.0版本以上提供）</li></ul><p>并且，从Android M开始变成了渲染八步骤：</p><h5 id="1、橙色-Swap-Buffers"><a href="#1、橙色-Swap-Buffers" class="headerlink" title="1、橙色-Swap Buffers"></a>1、橙色-Swap Buffers</h5><p>表示GPU处理任务的时间。</p><h5 id="2、红色-Command-Issue"><a href="#2、红色-Command-Issue" class="headerlink" title="2、红色-Command Issue"></a>2、红色-Command Issue</h5><p>进行2D渲染显示列表的时间，越高表示需要绘制的视图越多。</p><h5 id="3、浅蓝-Sync-amp-Upload"><a href="#3、浅蓝-Sync-amp-Upload" class="headerlink" title="3、浅蓝-Sync&amp;Upload"></a>3、浅蓝-Sync&amp;Upload</h5><p>准备有待绘制的图片所耗费的时间，越高表示图片数量越多或图片越大。</p><h5 id="4、深蓝-Draw"><a href="#4、深蓝-Draw" class="headerlink" title="4、深蓝-Draw"></a>4、深蓝-Draw</h5><p>测量和绘制视图所需的时间，越高表示视图越多或onDraw方法有耗时操作。</p><h5 id="5、一级绿-Measure-Layout"><a href="#5、一级绿-Measure-Layout" class="headerlink" title="5、一级绿-Measure/Layout"></a>5、一级绿-Measure/Layout</h5><p>onMeasure与onLayout所花费的时间。</p><h5 id="6、二级绿-Animation"><a href="#6、二级绿-Animation" class="headerlink" title="6、二级绿-Animation"></a>6、二级绿-Animation</h5><p>执行动画所需要花费的时间。越高表示使用了非官方动画工具或执行中有读写操作。</p><h5 id="7、三级绿-Input-Handling"><a href="#7、三级绿-Input-Handling" class="headerlink" title="7、三级绿-Input Handling"></a>7、三级绿-Input Handling</h5><p>系统处理输入事件所耗费的时间。</p><h5 id="8、四级绿-Misc-Time-Vsync-Delay"><a href="#8、四级绿-Misc-Time-Vsync-Delay" class="headerlink" title="8、四级绿-Misc Time/Vsync Delay"></a>8、四级绿-Misc Time/Vsync Delay</h5><p>主线程执行了太多任务，导致UI渲染跟不上vSync的信号而出现掉帧。</p><p>此外，可通过如下adb命令将具体的耗时输出到日志中来分析：</p><pre><code>adb shell dumpsys gfxinfo com.**.** </code></pre><h4 id="2-2、TraceView"><a href="#2-2、TraceView" class="headerlink" title="2.2、TraceView"></a>2.2、TraceView</h4><p>它主要用来分析函数的调用过程，可以对Android的应用程序以及Framework层代码进行性能分析。</p><p>使用TraceView查看耗时，主要关注Calls + Recur Calls / Total和（该方法调用次数+递归次数）和Cpu Time / Call（该方法耗时）这两个值，然后优化这些方法的逻辑和调用次数，减少耗时。</p><p><strong>注意</strong>：RealTime（实际时长）的实际执行时间要比CPU Time要长，因为它包括了CPU的上下文切换、阻塞、GC等。</p><h4 id="2-3、Systrace-UI性能分析"><a href="#2-3、Systrace-UI性能分析" class="headerlink" title="2.3、Systrace UI性能分析"></a>2.3、Systrace UI性能分析</h4><p>Systrace是Android 4.1及以上版本提供的性能数据采样和分析工具，它的作用有：</p><ul><li>收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务、View系统等）的运行信息，这样可以更直观地分析系统瓶颈，改进性能。</li><li>跟踪系统的I/0操作、内核工作队列、CPU负载等，在UI显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上。</li></ul><p><strong>注意：Systrace是以系统的角度返回一些信息，并不能定位到具体耗时的方法，建议使用TraceView。</strong></p><h5 id="1、Systrace使用方法"><a href="#1、Systrace使用方法" class="headerlink" title="1、Systrace使用方法"></a>1、Systrace使用方法</h5><p>使用事项如下：</p><ul><li>支持4.1版本及以上。</li><li>4.3以前的系统版本需要打开Setting&gt;Developer options&gt;Monitoring&gt;Enable traces。</li></ul><p>一般我们使用命令行来得到输出的html表单，在4.3版本及以上可以省略设置跟踪类别标签来获取默认值。命令如下：</p><pre><code>cd android-sdk/platform-tools/systracepython systrace.py --time=10 -o mynewtrace.html sched gfx view wm</code></pre><p>其中，常用的几个参数命令如下：</p><ul><li>-o <file>：保存的文件名。</file></li><li>-t N, –time=N：多少秒内的数据，默认为5s，以当前时间点往后倒N秒时间。</li></ul><p>其余标签用法请<a href="http://developer.android.com/intl/zh-cn/tools/help/systrace.html" target="_blank" rel="external">参见此处</a>。</p><p>此外，我们可以使用代码插桩的方式，在Android 4.3及以上版本可以使用Trace类的Trace.beginSection()与Trace.endSection()方法来进行追踪。其中需要注意：</p><ul><li>保证beginSection和endSection的调用次数要匹配。</li><li>Trace的begin与end必须在同一线程中执行。</li></ul><h5 id="2、分析Systrace报告"><a href="#2、分析Systrace报告" class="headerlink" title="2、分析Systrace报告"></a>2、分析Systrace报告</h5><p>使用Chrome打开文件后，其中和UI绘制关系最密切的是Alerts和Frame两个数据：</p><ul><li>Alerts：标记了性能有问题的点，单击该点可以查看详细信息，右侧的Alerts框还可以看到每个类型的Alerts的数量。</li><li>Frame：每个应用都有一行专门显示frame，每一帧就显示为一个绿色的圆圈。当显示为黄色或者红色时，它的渲染时间超过了16.6ms。</li></ul><p>这里，列出Systrace有用的快捷键：</p><ul><li>W：放大</li><li>S：缩小</li><li>A：左移</li><li>D：右移</li></ul><h3 id="三、布局优化"><a href="#三、布局优化" class="headerlink" title="三、布局优化"></a>三、布局优化</h3><h4 id="3-1、布局优化方法"><a href="#3-1、布局优化方法" class="headerlink" title="3.1、布局优化方法"></a>3.1、布局优化方法</h4><h5 id="1、减少层级"><a href="#1、减少层级" class="headerlink" title="1、减少层级"></a>1、减少层级</h5><ul><li>合理使用RelativeLayout和LinearLayout。</li><li>合理使用Merge。</li></ul><p>RelativeLayout也存在性能低的问题，原因是RelativeLayout会对子View做两次测量。但如果在LinearLayout中有weight属性，也需要进行两次测量，因为没有更多的依赖关系，所以仍然会比RelativeLayout的效率高。</p><p><strong>注意：由于Android的碎片化程度很高，所以使用RelativeLayout能使构建的布局适应性更强。</strong></p><p>merge的原理：在Android布局的源码中，如果是Merge标签，那么直接将其中的子元素添加到Merge标签Parent中。</p><p>注意：</p><ul><li>Merge只能用在布局XML文件的根元素。</li><li>使用merge来加载一个布局时，必须指定一个ViewGroup作为其父元素，并且要设置加载的attachToRoot参数为true。</li><li>不能在ViewStub中使用Merge标签。原因就是ViewStub的inflate方法中根本没有attachToRoot的设置。</li></ul><h5 id="2、提供显示速度"><a href="#2、提供显示速度" class="headerlink" title="2、提供显示速度"></a>2、提供显示速度</h5><p>ViewStub是一个轻量级的View，它是一个看不见的，并且不占布局位置，占用资源非常小的视图对象。可以为ViewStub指定一个布局，加载布局时，只有ViewStub会被初始化，然后当ViewStub被设置为可见时，或是调用了ViewStub.inflate()时，ViewStub所指向的布局会被加载和实例化，然后ViewStub的布局属性都会传给它指向的布局。</p><p>注意：</p><ul><li>ViewStub只能加载一次，之后ViewStub对象会被置为空。所以它不适用于需要按需显示隐藏的情况。</li><li>ViewStub只能用来加载一个布局文件，而不是某个具体的View。</li><li>ViewStub中不能嵌套Merge标签。</li></ul><h5 id="3、布局复用"><a href="#3、布局复用" class="headerlink" title="3、布局复用"></a>3、布局复用</h5><p>Android的布局复用可以通过<include>标签来实现。</include></p><p>一些优化总结：</p><ul><li>使用<viewstub>标签加载一些不常用的布局。</viewstub></li><li>尽可能少用wrap_content，wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content。</li><li>使用TextView替换RL、LL。</li><li>使用低端机进行优化，以发现性能瓶颈。</li><li>使用TextView的行间距替换多行文本：lineSpacingExtra/lineSpacingMultiplier。</li><li>使用Spannable/Html.fromHtml替换多种不同规格文字。</li><li>尽可能使用LinearLayout自带的分割线。</li><li>使用Space添加间距。</li><li>多利用lint + alibaba规约修复问题点。</li><li>嵌套层级过多可以考虑使用约束布局。</li></ul><h3 id="四、避免过度绘制"><a href="#四、避免过度绘制" class="headerlink" title="四、避免过度绘制"></a>四、避免过度绘制</h3><p>导致过度绘制的主要原因是：</p><ul><li>XML布局：控件有重叠且都有设置背景。</li><li>View自绘：View.OnDraw里面同一个区域被绘制多次。</li></ul><h4 id="4-1、过度绘制检测工具"><a href="#4-1、过度绘制检测工具" class="headerlink" title="4.1、过度绘制检测工具"></a>4.1、过度绘制检测工具</h4><p>打开手机开发者选项中的Show GPU Overdraw选项，会有不同的颜色来表示过度绘制次数，依次是无、蓝、绿、淡红、深红，分别对应0-4次过度绘制。</p><h4 id="4-2、如何避免过度绘制"><a href="#4-2、如何避免过度绘制" class="headerlink" title="4.2、如何避免过度绘制"></a>4.2、如何避免过度绘制</h4><h5 id="1、布局上的优化"><a href="#1、布局上的优化" class="headerlink" title="1、布局上的优化"></a>1、布局上的优化</h5><ul><li>移除XML中非必需的背景，或根据条件设置。</li><li>有选择性地移除窗口背景：getWindow().setBackgroundDrawable(null)。</li><li>按需显示占位背景图片。</li></ul><p>比如：在获取Avatar的图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到时，才设置对应的Background占位图片。</p><h5 id="2、自定义View优化"><a href="#2、自定义View优化" class="headerlink" title="2、自定义View优化"></a>2、自定义View优化</h5><p>通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制。并且，它还可以节约CPU和GPU资源，在clipRect区域之外的绘制指令都不会被执行。</p><p>在绘制一个单元之前，首先判断该单元的区域是否在Canvas的剪切域内。若不在，直接返回，避免CPU和GPU的计算和渲染工作。</p><h3 id="五、启动优化"><a href="#五、启动优化" class="headerlink" title="五、启动优化"></a>五、启动优化</h3><h4 id="5-1、应用启动流程"><a href="#5-1、应用启动流程" class="headerlink" title="5.1、应用启动流程"></a>5.1、应用启动流程</h4><p>应用的启动流程即为从点击图标到用户可操作的全部过程。它的意义就是为了避免用户一安装应用就卸载。</p><p>启动分为两种类型：</p><ul><li>冷启动：系统会重新创建一个新的进程分配给它。</li><li>温启动：只会走Activity的生命周期。</li><li>热启动：因为会从已有的进程中启动，所以它不会再创建和初始化Application，从后台切换到前台。</li></ul><p>具体又可分为如下过程：</p><h5 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h5><p>耗时最多，衡量标准。</p><pre><code>Click Event -&gt; IPC -&gt; Process.start -&gt; ActivityThread -&gt; bindApplication -&gt; LifeCycle -&gt; ViewRootImpl</code></pre><h5 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h5><p>最快。</p><pre><code>后台 -&gt; 前台</code></pre><h5 id="温启动"><a href="#温启动" class="headerlink" title="温启动"></a>温启动</h5><p>较快。</p><pre><code>LifeCycle</code></pre><h4 id="5-2、启动耗时监测"><a href="#5-2、启动耗时监测" class="headerlink" title="5.2、启动耗时监测"></a>5.2、启动耗时监测</h4><h5 id="0、查看Logcat"><a href="#0、查看Logcat" class="headerlink" title="0、查看Logcat"></a>0、查看Logcat</h5><p>在Android Studio Logcat中过滤关键字“Displayed”，可以看到对应的冷启动好事日志。</p><h5 id="1、adb-shell-am"><a href="#1、adb-shell-am" class="headerlink" title="1、adb shell am"></a>1、adb shell am</h5><p>使用adb shell获取应用真实的启动时间：</p><pre><code>adb shell am start -W [packageName]/[packageName.AppstartActivity]</code></pre><p>执行后会得到三个时间：ThisTime、TotalTime和WaitTime，一般查看得到的TotalTime，即应用的启动时间，包括创建进程+Application初始化+Activity初始化到界面显示，详情如下：</p><ul><li>ThisTime：最后一个Activity启动耗时。</li><li>TotalTime：所有Activity启动耗时。</li><li>WaitTime：AMS启动Activity的总耗时。</li></ul><p>特点：</p><ul><li>线下使用方便，不能带到线上。</li><li>非严谨、精确时间。</li></ul><h5 id="2、代码打点"><a href="#2、代码打点" class="headerlink" title="2、代码打点"></a>2、代码打点</h5><p>可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：</p><ul><li>在上传数据到服务器时建议根据用户ID的尾号来抽样上报。</li><li>在项目中核心基类的关键回调函数和核心方法中加入打点。</li></ul><p>代码如下：</p><pre><code>/*** 耗时监视器对象，记录整个过程的耗时情况，可以用在很多需要统计的地方，比如Activity的启动耗时和Fragment的启动耗时。*/public class TimeMonitor {    private final String TAG = TimeMonitor.class.getSimpleName();    private int mMonitord = -1;    // 保存一个耗时统计模块的各种耗时，tag对应某一个阶段的时间    private HashMap&lt;String, Long&gt; mTimeTag = new HashMap&lt;&gt;();    private long mStartTime = 0;    public TimeMonitor(int mMonitorId) {        Log.d(TAG, &quot;init TimeMonitor id: &quot; + mMonitorId);        this.mMonitorId = mMonitorId;    }    public int getMonitorId() {        return mMonitorId;    }    public void startMonitor() {        // 每次重新启动都把前面的数据清除，避免统计错误的数据        if (mTimeTag.size() &gt; 0) {        mTimeTag.clear();        }        mStartTime = System.currentTimeMillis();    }    /**    * 每打一次点，记录某个tag的耗时    */    public void recordingTimeTag(String tag) {        // 若保存过相同的tag，先清除        if (mTimeTag.get(tag) != null) {            mTimeTag.remove(tag);        }        long time = System.currentTimeMillis() - mStartTime;        Log.d(TAG, tag + &quot;: &quot; + time);        mTimeTag.put(tag, time);    }    public void end(String tag, boolean writeLog) {        recordingTimeTag(tag);        end(writeLog);    }    public void end(boolean writeLog) {        if (writeLog) {            //写入到本地文件        }    }    public HashMap&lt;String, Long&gt; getTimeTags() {        return mTimeTag;    }}</code></pre><p>为了使代码更好管理，定义一个打点配置类：</p><pre><code>/*** 打点配置类，用于统计各阶段的耗时，便于代码的维护和管理。*/public final class TimeMonitorConfig {    // 应用启动耗时    public static final int TIME_MONITOR_ID_APPLICATION_START = 1;}</code></pre><p>因为，耗时统计可能会在多个模块和类中需要打点，所以需要一个单例类来管理各个耗时统计的数据：</p><pre><code>/*** 采用单例管理各个耗时统计的数据。*/public class TimeMonitorManager {    private static TimeMonitorManager mTimeMonitorManager = null;private HashMap&lt;Integer, TimeMonitor&gt; mTimeMonitorMap = null;    public synchronized static TimeMonitorManager getInstance() {        if (mTimeMonitorManager == null) {            mTimeMonitorManager = new TimeMonitorManager();        }        return mTimeMonitorManager;    }    public TimeMonitorManager() {        this.mTimeMonitorMap = new HashMap&lt;Integer, TimeMonitor&gt;();    }    /**     * 初始化打点模块    */    public void resetTimeMonitor(int id) {        if (mTimeMonitorMap.get(id) != null) {            mTimeMonitorMap.remove(id);        }        getTimeMonitor(id);    }    /**    * 获取打点器    */    public TimeMonitor getTimeMonitor(int id) {        TimeMonitor monitor = mTimeMonitorMap.get(id);        if (monitor == null) {            monitor = new TimeMonitor(id);            mTimeMonitorMap.put(id, monitor);        }        return monitor;    }}</code></pre><p>主要在以下几个方面需要打点：</p><ul><li>应用程序的生命周期节点。</li><li>启动时需要初始化的重要方法，如数据库初始化，读取本地的一些数据。</li><li>其他耗时的一些算法。</li></ul><p>例如，启动时在Application和第一个Activity加入打点统计：</p><p><strong>Application：</strong></p><pre><code>@Overrideprotected void attachBaseContext(Context base) {    super.attachBaseContext(base);    TimeMonitorManager.getInstance().resetTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START);}@Overridepublic void onCreate() {    super.onCreate();    SoLoader.init(this, /* native exopackage */ false);    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;Application-onCreate&quot;);}</code></pre><p><strong>第一个Activity：</strong></p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;SplashActivity-onCreate&quot;);    super.onCreate(savedInstanceState);    initData();    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;SplashActivity-onCreate-Over&quot;);}@Overrideprotected void onStart() {    super.onStart();    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).end(&quot;SplashActivity-onStart&quot;, false);}</code></pre><p>特点：</p><ul><li>精确，可带到线上，推荐使用。</li></ul><p>注意：</p><ul><li>onWindowFocusChanged只是首帧时间，App启动完成的结束点应该是真实数据展示出来的时候，如列表第一条数据展示，记得使用getViewTreeObserver().addOnPreDrawListener()，它会把任务延迟到列表显示后再执行。                                                          </li></ul><h5 id="3、AOP埋点"><a href="#3、AOP埋点" class="headerlink" title="3、AOP埋点"></a>3、AOP埋点</h5><p>首先，为了引入AspectJ，在项目根目录的build.gradle下加入：</p><pre><code>classpath &apos;com.hujiang.aspectjx:gradle-android-plugin-aspectjx:2.0.0&apos;</code></pre><p>然后，在app目录下的build.gradle下加入：</p><pre><code>implement &apos;org.aspectj:aspectjrt:1.8.+&apos;apply plugin: &apos;android-aspectjx&apos;</code></pre><p>然后，可以使Join Points在程序运行时的执行点进行切面，如以下位置：</p><ul><li>函数调用、执行</li><li>获取、设置变量</li><li>类初始化</li></ul><p>此外，还可以使用PointCut，它是带条件的JoinPoints，会有更多方式选择我们感兴趣的点。这里，我们还必须了解Advice，它是一种Hook，指定插入代码的位置，它有如下分类：</p><ul><li>Before：PointCut之前执行</li><li>After：PointCut之后执行</li><li>Around：PointCut之前、之后分别执行</li></ul><p>这里举一个实例：</p><pre><code>@Before(&quot;execution(* android.app.Activity.on**(..))&quot;)public void onActivityCalled(JoinPoint joinPoint) throws Throwable {    ...}</code></pre><p>上面的execution是指的处理Join Point的类型，Join Point的类型有两类：</p><ul><li>call：插入在函数体里面。</li><li>execution：插入在函数体外面。</li></ul><p>在execution中的是一个匹配规则，第一个*代表匹配任意的方法返回值，后面的语法代码匹配所有Activity中on开头的方法。</p><p>如果我们想统计Application中的所有方法耗时，可以创建如下的切面类：</p><pre><code>@Aspectpublic class WanAndroidAop {    @Around(&quot;call (* com.json.chao.application.WandroidApplication.**(..))&quot;)    public void getTime(ProceedingJoinPoint joinPoint) {        Signature signature = joinPoin.getSignature();        String name = signature.toShortString();        long time = System.currentTimeMillis();        try {            joinPoint.proceed();        } catch (Throwable throwable) {            throwable.printStackTrace();        }        Log.i(TAG, name + &quot; cost&quot; + (System.currentTimeMillis() - time));    }}</code></pre><p>AOP特点：</p><ul><li>无侵入性</li><li>修改方便</li></ul><h4 id="5-3-启动速度分析工具"><a href="#5-3-启动速度分析工具" class="headerlink" title="5.3 启动速度分析工具"></a>5.3 启动速度分析工具</h4><p>目标：力求获取准确的数据评估。</p><h5 id="1、TraceView"><a href="#1、TraceView" class="headerlink" title="1、TraceView"></a>1、TraceView</h5><h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><ul><li>图形的形式展示执行时间、调用栈等。</li><li>信息全面，包含所有线程。</li><li>运行时开销严重，整体都会变慢，得出的结果并不真实。                                             <h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5></li></ul><p>主要做热点分析，得到两种数据：</p><ul><li>单次执行最耗时的方法。</li><li>执行次数最多的方法。</li></ul><h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><ul><li>1、代码中添加：Debug.startMethodTracing()、检测方法、Debug.stopMethodTracing()。</li><li>2、打开Profile-&gt;CPU-&gt;点击Record-&gt;点击Stop-&gt;查看Profile下方Top Down/Bottom Up找出耗时的热点方法。</li></ul><pre><code>Wall Clock Time：程序执行时间。Thread Time：CPU执行的时间。</code></pre><h5 id="2、Systrace-函数插桩"><a href="#2、Systrace-函数插桩" class="headerlink" title="2、Systrace+函数插桩"></a>2、Systrace+函数插桩</h5><h5 id="Systrace原理"><a href="#Systrace原理" class="headerlink" title="Systrace原理"></a>Systrace原理</h5><p>在系统的一些关键链路（如SystemServcie、虚拟机、Binder驱动）插入一些信息（Label），<br>通过Label的开始和结束来确定某个核心过程的执行时间，然后把这些Label信息收集起来得到系统关键路径的运行时间信息，<br>最后得到整个系统的运行性能信息。Android Framework里面一些重要的模块都插入了label信息(Java层通过android.os.Trace类完成，<br>native层通过ATrace宏完成），用户App中可以添加自定义的Lable。</p><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>结合Android内核的数据，生成Html报告。</li><li>API 18以上使用，推荐TraceCompat。</li><li>系统版本越高，Android Framework中添加的系统可用Label就越多，能够支持和分析的系统模块也就越多。</li><li>必须手动缩小范围，会帮助你加速收敛问题的分析过程，进而快速地定位和解决问题。</li></ul><h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><h5 id="1、命令行"><a href="#1、命令行" class="headerlink" title="1、命令行"></a>1、命令行</h5><p>python systrace.py -t 10 sched gfx view wm am app webview -a <package-name> -o <target-file.html></target-file.html></package-name></p><h5 id="2、代码插桩"><a href="#2、代码插桩" class="headerlink" title="2、代码插桩"></a>2、代码插桩</h5><p>定义Trace静态工厂类i，o封装Trace.begainSection(),Trace.endSection()。</p><p>分析App的冷启动： 在想要分析的方法前后进行插桩即可。</p><h4 id="5-4、启动优化方案"><a href="#5-4、启动优化方案" class="headerlink" title="5.4、启动优化方案"></a>5.4、启动优化方案</h4><h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><h5 id="1、点击图标很久都不响应"><a href="#1、点击图标很久都不响应" class="headerlink" title="1、点击图标很久都不响应"></a>1、点击图标很久都不响应</h5><p>预览窗口被禁用或设置为透明</p><h5 id="2、首页显示太慢"><a href="#2、首页显示太慢" class="headerlink" title="2、首页显示太慢"></a>2、首页显示太慢</h5><p>初始化任务太多</p><h5 id="3、首页显示后无法操作"><a href="#3、首页显示后无法操作" class="headerlink" title="3、首页显示后无法操作"></a>3、首页显示后无法操作</h5><p>太多任务初始化异步/延迟</p><h5 id="优化区域"><a href="#优化区域" class="headerlink" title="优化区域"></a>优化区域</h5><p>Application、Activity创建以及回调等过程</p><h5 id="通常手段"><a href="#通常手段" class="headerlink" title="通常手段"></a>通常手段</h5><ul><li>利用主题背景防止出现白屏</li><li>减少Application的onCreate中所要做的事情</li><li>一些不重要的SDK延迟或者异步加载</li><li>多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作</li><li>部分将要使用到的类异步加载（IntentService）</li><li>针对multidex专门做优化（5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了，无需优化）</li></ul><h5 id="具体优化步骤如下所示："><a href="#具体优化步骤如下所示：" class="headerlink" title="具体优化步骤如下所示："></a>具体优化步骤如下所示：</h5><h5 id="1、主题切换"><a href="#1、主题切换" class="headerlink" title="1、主题切换"></a>1、主题切换</h5><p>使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list）,在启动后，在Activity的onCreate()方法前再setTheme(R.style.AppTheme)</p><ul><li>优点：简单</li><li>缺点：<br>治标不治本，表面上产生一种快的感觉。</li></ul><p>对于中低端机，总的闪屏时间会更长，建议只在Android6.0/7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验。</p><h5 id="2、避免过重的App初始化"><a href="#2、避免过重的App初始化" class="headerlink" title="2、避免过重的App初始化"></a>2、避免过重的App初始化</h5><p>获取所有应用activity堆栈信息</p><pre><code>adb shell dumpsys activity</code></pre><p>adb获取自己的应用activity堆栈信息</p><pre><code>adb shell dumpsys activity | grep com.xxx.xxx.xx</code></pre><p>使用adb命令启动一个Activity</p><pre><code>adb shell am start com.growingwiththeweb.example/.MainActivity</code></pre><p>adb命令统计启动时间</p><pre><code>adb shell am start -W com.growingwiththeweb.example/.SplashActivity</code></pre><h5 id="2-1、第三方库懒加载"><a href="#2-1、第三方库懒加载" class="headerlink" title="2.1、第三方库懒加载"></a>2.1、第三方库懒加载</h5><p>可以考虑按需初始化，如图片库的初始化等等。</p><h5 id="2-2、异步初始化（如出现主线程要使用时还没初始化则在此次使用前初始化）"><a href="#2-2、异步初始化（如出现主线程要使用时还没初始化则在此次使用前初始化）" class="headerlink" title="2.2、异步初始化（如出现主线程要使用时还没初始化则在此次使用前初始化）"></a>2.2、异步初始化（如出现主线程要使用时还没初始化则在此次使用前初始化）</h5><p>核心思想：子线程分担主线程任务，并行减少时间。</p><p>异步优化注意点：</p><ul><li>1、不符合异步要求</li><li>2、需要在某个阶段完成（采用CountDownLatch确保异步任务完成后才到下一个阶段）</li><li>3、区分CPU密集型和IO密集型任务</li></ul><h5 id="异步优化最优解：异步启动器"><a href="#异步优化最优解：异步启动器" class="headerlink" title="异步优化最优解：异步启动器"></a>异步优化最优解：异步启动器</h5><p>常规异步优化痛点</p><ul><li>1、代码不优雅</li><li>2、场景不好处理（依赖关系）</li><li>3、维护成本高</li></ul><p>启动器</p><pre><code>核心思想：充分利用CPU多核，自动梳理任务顺序。</code></pre><p>启动器流程</p><pre><code>代码Task化，启动逻辑抽象成Task。根据所有任务依赖关系排序生成一个有向无环图多线程按照排序后的优先级依次执行</code></pre><h5 id="2-3、延迟初始化（利用闪屏页的停留时间进行部分初始化）"><a href="#2-3、延迟初始化（利用闪屏页的停留时间进行部分初始化）" class="headerlink" title="2.3、延迟初始化（利用闪屏页的停留时间进行部分初始化）"></a>2.3、延迟初始化（利用闪屏页的停留时间进行部分初始化）</h5><p>1、常规方案</p><pre><code>new Handler().postDelayed()界面UI展示后调用</code></pre><p>2、常规初始化痛点</p><pre><code>时机不容易控制导致界面UI卡顿        </code></pre><p>3、更优方案：延迟启动器</p><p>核心思想：利用IdleHandler特性，在CPU空闲时执行，对延迟任务进行分批初始化</p><p>优势：</p><ul><li>执行时机明确</li><li>缓解界面UI卡顿</li><li>真正提升用户体验</li></ul><h5 id="3、Multidex预加载优化"><a href="#3、Multidex预加载优化" class="headerlink" title="3、Multidex预加载优化"></a>3、Multidex预加载优化</h5><ul><li>1、启动时单独开一个进程去异步进行Multidex的第一次加载，即Dex提取和Dexopt操作。</li><li>2、此时，主进程Application进入while循环，不断检测Multidex操作是否完成。</li><li>3、M执行到Multidex时，则已经发现提取优化好了Dex，直接执行。MultiDex执行完之后主进程Application继续执行ContentProvider初始化和Application的onCreate方法。</li></ul><p><strong>注意：判断只有在主进程及SDK 5.0以下才进行Multidex的预加载。</strong></p><h5 id="4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）"><a href="#4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）" class="headerlink" title="4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）"></a>4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）</h5><h5 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h5><p>1、优化总方针</p><pre><code>异步、延迟、懒加载技术、业务相结合</code></pre><p>2、注意事项</p><ul><li>wall time（代码执行时间）与cpu time（代码消耗CPU时间），锁冲突会造成两者时间差距过大。</li><li>cpu time才是优化方向</li><li>按照systrace及cpu time跑满cpu</li><li>监控的完善</li><li>线上监控多阶段时间（App、Activity、生命周期间隔时间）</li><li>处理聚合看趋势</li><li>收敛启动代码修改权限</li><li>结合CI修改启动代码需要Review通知</li></ul><p>3、其它方案</p><ul><li><p>提前加载SharedPreferences<br>Multidex之前加载，利用此阶段CPU，注意重写getApplicationContext()返回this。</p></li><li><p>启动阶段不启动子进程</p></li></ul><pre><code>子进程会共享CPU资源，导致主进程CPU紧张注意启动顺序：App onCreate之前是ContentProvider</code></pre><ul><li>类加载优化：Multidex之前提前异步加载Activity对象</li></ul><p>原理：对象第一次创建的时候，JVM首先检查对应的Class对象是否已经加载。如果没有加载，JVM会根据类名查找.class文件，将其Class对象载入。同一个类第二次new的时候就不需要加载类对象，而是直接实例化，创建时间就缩短了。</p><pre><code>Class.forName()只加载类本身及其静态变量的引用类new 类实例 可以额外加载类成员变量的引用类替换系统的ClassLoader，打印类加载的时间，选取需要异步加载的类</code></pre><ul><li>WebView启动优化</li></ul><pre><code>1、WebView首次创建比较耗时，需要预先创建WebView提前将其内核初始化。2、使用WebView缓存池，用到WebView的时候都从缓存池中拿，注意内存泄漏问题。3、本地离线包，即预置静态页面资源。</code></pre><ul><li>数据预加载</li></ul><pre><code>在主页空闲时，将其它页面的数据加载好保存到内存或数据库，等到打开该页面时，判断已经预加载过，就直接从内存或数据库取数据并显示。</code></pre><ul><li><p><a href="https://juejin.im/post/5be1077d518825171140dbfa" target="_blank" rel="external">启动阶段抑制GC</a></p></li><li><p>CPU锁频（暴力拉伸CPU频率，导致耗电量增加）</p></li></ul><h5 id="6、常见问题"><a href="#6、常见问题" class="headerlink" title="6、常见问题"></a>6、常见问题</h5><p>1、启动优化是怎么做的？</p><pre><code>分析现状、确认问题针对性优化（先概括，引导其深入）长期保持优化效果</code></pre><p>2、是怎么异步的，异步遇到问题没有？</p><pre><code>体现演进过程详细介绍启动器</code></pre><p>3、启动优化有哪些容易忽略的注意点？</p><pre><code>cpu time与wall time注意延迟初始化的优化介绍下黑科技</code></pre><p>4、版本迭代导致的启动变慢有好的解决方式吗？</p><pre><code>启动器结合CI监控完善</code></pre><h3 id="六、合理的刷新机制"><a href="#六、合理的刷新机制" class="headerlink" title="六、合理的刷新机制"></a>六、合理的刷新机制</h3><h4 id="6-1-减少刷新次数"><a href="#6-1-减少刷新次数" class="headerlink" title="6.1 减少刷新次数"></a>6.1 减少刷新次数</h4><ul><li>控制刷新频率</li><li>避免没有必要的刷新</li></ul><h4 id="6-2-避免后台线程的影响"><a href="#6-2-避免后台线程的影响" class="headerlink" title="6.2 避免后台线程的影响"></a>6.2 避免后台线程的影响</h4><p>如通过监听ListView的onScrollStateChanged事件，在滚动时暂停图片下载线程工作，结束后再开始，可以提高ListView的滚动平滑度。</p><h4 id="6-3-缩小刷新区域"><a href="#6-3-缩小刷新区域" class="headerlink" title="6.3 缩小刷新区域"></a>6.3 缩小刷新区域</h4><p>如自定义View一般采用invalidate方法刷新，可以用以下重载方法刷新要刷新的区域：</p><ul><li>invalidate(Rect dirty);</li><li>invalidate(int left, int top, int right, int bottom);</li></ul><h3 id="七、提升动画性能"><a href="#七、提升动画性能" class="headerlink" title="七、提升动画性能"></a>七、提升动画性能</h3><p>提升动画性能主要从以下三个纬度着手：</p><ul><li>流畅度：控制每一帧动画在16m内完成。</li><li>内存：避免内存泄漏，减小内存开销。</li><li>耗电：减小运算量，优化算法，减小CPU占用。</li></ul><h4 id="7-1-帧动画"><a href="#7-1-帧动画" class="headerlink" title="7.1 帧动画"></a>7.1 帧动画</h4><p>消耗资源最多，效果最差，能不用就不用。</p><h4 id="7-2-补间动画"><a href="#7-2-补间动画" class="headerlink" title="7.2 补间动画"></a>7.2 补间动画</h4><p>使用补间动画实现导致View重绘非常频繁，更新DisplayList的次数过多，且有以下缺点：</p><ul><li>只能用于View对象。</li><li>只有4种动画操作。</li><li>只是改变View的显示效果，但是不会真正改变View的属性。</li></ul><h4 id="7-3-属性动画"><a href="#7-3-属性动画" class="headerlink" title="7.3 属性动画"></a>7.3 属性动画</h4><p>相比于补间动画，属性动画重绘明显会少很多，应优先使用。</p><h4 id="7-4-硬件加速"><a href="#7-4-硬件加速" class="headerlink" title="7.4 硬件加速"></a>7.4 硬件加速</h4><h5 id="1、硬件加速原理"><a href="#1、硬件加速原理" class="headerlink" title="1、硬件加速原理"></a>1、硬件加速原理</h5><p>核心类：DisplayList，每一个View对应一个。</p><p>在打开硬件渲染后绘制View时，其中执行绘制的draw()方法会把所有绘制命令记录到一个新的显示列表（DisplayList），这个显示列表包含了输出的View层级的绘制代码，但并不是加入到显示列表就立刻执行，当这个ViewTree的DisplayList全都记录完毕后，由OpenGLRender负责将Root View中的DisplayList渲染到屏幕上。而invalidate()方法只是在显示列表中记录和更新显示层级，去标记不需要绘制的View。</p><h5 id="2、硬件加速控制级别"><a href="#2、硬件加速控制级别" class="headerlink" title="2、硬件加速控制级别"></a>2、硬件加速控制级别</h5><p>如果应用程序中只使用了标准View或者Drawable，就可以为整个系统打开硬件加速的全局设置。</p><h5 id="3、在动画上使用硬件加速"><a href="#3、在动画上使用硬件加速" class="headerlink" title="3、在动画上使用硬件加速"></a>3、在动画上使用硬件加速</h5><p>硬件纹理操作对一个View进行动画绘制，如果不调用invalidate()方法，就可以减少对View自身频繁的重绘。同时Android 3.0的属性动画也减小了重绘，当View通过硬件层返回时，最终所有的层叠画面显示到屏幕，View的属性同时被处理好，因此只要设置这些属性，就可以明显提高绘制的效率，它们不需要View重绘，设置属性后，View会自动刷新。因此，属性动画中绘制的递归次数比补间动画少很多。</p><p>在Android 3.0前，使用View的绘制缓冲或Canvas.saveLayer()函数对离屏缓冲进行渲染。Android 3.0后则使用View,.setLayerType(type, paint)方法代替，type可以为以下三种Layer类型之一：</p><ul><li>LAYER_TYPE_NONE：普通渲染方式，不会返回一个离屏的缓冲，默认值。</li><li>LAYER_TYPE_HARDWARE：如果这个应用使用了硬件加速，这个View将会在硬件中渲染为硬件纹理。</li><li>LAYER_TYPE_SOFTWARE：此View通过软件渲染为一个Bitmap。</li></ul><h5 id="设计一个动画的流程如下："><a href="#设计一个动画的流程如下：" class="headerlink" title="设计一个动画的流程如下："></a>设计一个动画的流程如下：</h5><p>1、将要执行动画的View的LayerType设置为LAYER_TYPE_HARDWARE。</p><p>2、计算动画View的属性等信息，更新View的属性。</p><p>3、若动画结束，将LayerType设置为NONE。</p><h5 id="硬件加速需要注意的问题："><a href="#硬件加速需要注意的问题：" class="headerlink" title="硬件加速需要注意的问题："></a>硬件加速需要注意的问题：</h5><ul><li>在软件渲染时，可以使用重用Bitmap的方法来节省内存，但是如果开起来硬件加速，这个方案就不起作用。</li><li>开启硬件加速的View在前台运行时，需要耗费额外的内存，加速的UI切换到后台时，产生的额外内存有可能不释放。</li><li>当UI中存在过渡绘制时，硬件加速会比较容易发问题。</li></ul><h3 id="八、卡顿监控方案与实现"><a href="#八、卡顿监控方案与实现" class="headerlink" title="八、卡顿监控方案与实现"></a>八、卡顿监控方案与实现</h3><p>目前比较流行的方案都是利用了Looper中的Printer来实现监控。</p><h4 id="8-1-监控原理"><a href="#8-1-监控原理" class="headerlink" title="8.1 监控原理"></a>8.1 监控原理</h4><p>利用主线程的消息队列处理机制，通过自定义Printer，然后在Printer中获取到两次被调用的时间差，这个时间差就是执行时间。如果该时间超过阈值（如1000ms）时，主线程卡顿发生，并抛出各种有用信息，供开发者分析。（此外，也可以在UI线程以外开启一个异步线程，定时向UI线程发送一个任务，并记下发送时间。任务的内容是将执行时间同步到发送线程，如果UI线程被阻塞，那么发送过去的任务不能被准时执行。但此方法会增加系统开销，不可取）</p><h5 id="可抓取的信息"><a href="#可抓取的信息" class="headerlink" title="可抓取的信息"></a>可抓取的信息</h5><ul><li>基础信息：系统版本、机型、进程名、应用版本号、磁盘空间、UID等。</li><li>耗时信息：卡顿开始和结束时间。</li><li>CPU信息：CPU的信息、整体CPU使用率和本进程CPU使用率（可粗略判断是当前应用消耗CPU资源太多导致的卡顿，还是其他原因）等。</li><li>堆栈信息。</li></ul><h5 id="注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。"><a href="#注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。" class="headerlink" title="注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。"></a>注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。</h5><h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>至此，这里我们分析一下绘制优化应经历的几个过程：</p><ul><li>1、发现问题：除使用时感知的卡顿外，还应通过卡段监控工具来发现整体的耗时情况，或打开开发者选项的一些辅助工具来发现问题。</li><li>2、分析问题：可以使用Systrace和TraceView来分析耗时，使用Hierarhy Viewer来分析页面层级。</li><li>3、寻求原因：深入探索导致问题的根本原因。</li><li>4、解决问题。</li></ul><p>应用之所以会出现卡顿，除了绘制方面的问题，还有一个影响因素就是内存，不合理地使用内存不仅会导致卡顿，还会对耗电和应用的稳定性造成很大影响，下一篇文章，笔者将对Android中的内存优化进行全面的讲解，若读者觉得哪里有写的不好的地方或有误的地方希望多多进行批评指正，愿我们共同进步和成长！</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android应用性能优化最佳实践</p><p>2、<a href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ?" target="_blank" rel="external">必知必会 | Android 性能优化的方面方面都在这儿</a></p><p>3、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">极客时间之Top团队大牛带你玩转Android性能分析与优化</a></p><p>4、<a href="https://github.com/zeshaoaaa/LaunchStarter" target="_blank" rel="external">启动器源码</a></p><p>5、<a href="https://github.com/lanshifu/MultiDexTest" target="_blank" rel="external">MultiDex优化源码</a></p><p>6、<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter07" target="_blank" rel="external">使用gradle自动化增加Trace Tag</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android开发工程师高效成长指南</title>
      <link>http://yoursite.com/2019/05/12/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%AB%98%E6%95%88%E6%88%90%E9%95%BF%E6%8C%87%E5%8D%97/</link>
      <guid>http://yoursite.com/2019/05/12/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%AB%98%E6%95%88%E6%88%90%E9%95%BF%E6%8C%87%E5%8D%97/</guid>
      <pubDate>Sun, 12 May 2019 13:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>从去年的互联网寒冬开始，移动开发甚至前后端的招聘需求越来越少，公司对开发者的技术要求也越来越高。特别是对于我们Android开发来说，似乎我们的生存空间越来越小，处境也变得越来越困难。所以，在这个时代，我们必须找到适合自己的一条“黄金路”。其实，对于Android来说，它其实有很多个细分领域，比如音视频、iot、图像处理、安全攻防、移动AI、性能优化等，职业生涯的前几年，我们只要选中其中的某一个领域，把它研究到极致，就可以拥有真正的核心竞争力，而对于像前后端、Flutter等跨领域的知识我们只要有一定程度的了解即可。这其实就是很多大厂一直青睐的T型人才。下面，我就性能优化这一细分领域来分析一下如何把它做到极致。</p><p>性能优化其实一块很深很深的知识领域，对于Android来说，它从最上层的应用层，顺延着Framework层、ART/Davilk、Linux内核层，一直到最底层的硬件层，都有我们需要深入研究的技术点。因此，根据这一思路，我根据我自身的情况，定制了一套自下而上的学习路线。下面，我就来说一下详细的学习方案。</p><p>对于学习资源来说，最重要的就是高质量和成体系的知识。因此，在学习的时候，我们必须以经典的高质量书籍为主，其他优秀的文章、视频教程为辅。</p><h3 id="一、成长路线规划"><a href="#一、成长路线规划" class="headerlink" title="一、成长路线规划"></a>一、成长路线规划</h3><p>首先是数学和算法，要想成为世界上最顶尖的程序员，这两门功课必须要打好基础。</p><h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h4><ul><li>数学之美</li><li>程序员的数学基础课（极客时间）</li></ul><h4 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h4><ul><li>大话数据结构</li><li>算法图解</li><li>剑指Offer</li><li>数据结构与算法之美（极客时间）</li><li>算法面试通关（极客时间）</li><li>LetteCode</li><li>编程之美</li><li>编程珠玑</li><li>趣学算法</li><li>算法（红本）</li></ul><h4 id="硬件原理"><a href="#硬件原理" class="headerlink" title="硬件原理"></a>硬件原理</h4><ul><li>深入浅出计算机组成原理（极客时间）</li></ul><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><ul><li>计算机网络：自顶向下方法</li><li>趣谈网络协议（极客时间）</li><li>图解TCP/IP</li><li>HTTP权威指南</li><li>Wireshark网络分析就这么简单</li><li>Wireshark网络分析的艺术</li><li>Web性能权威指南</li><li>Unix网络编程：卷1</li></ul><h4 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h4><ul><li>现代操作系统</li><li>鸟哥的Linux私房菜</li><li>深入理解计算机系统</li><li>Linux程序设计</li><li>UNIX环境高级编程</li><li>深入Linux内核架构</li><li>性能之巅</li><li>最强Android书</li><li>Linux性能优化实战</li></ul><h4 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h4><ul><li>编码</li><li>编译原理</li></ul><h4 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h4><ul><li>Java核心技术 卷1</li><li>Java编程思想</li><li>Java并发编程实战（极客时间）</li><li>Java并发编程的艺术</li><li>Java核心技术36讲（极客时间）</li><li>深入理解JVM</li><li>深入拆解JVM（极客时间）</li><li>揭秘JVM</li><li>程序员的自我修养—链接、装载与库</li><li>垃圾回收算法手册</li><li>深入理解Android JVM ART</li><li>深入解析Android 虚拟机</li></ul><h4 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h4><ul><li>HeadFirst设计模式</li><li>Android源码设计模式</li><li>Android进阶解密</li><li>Android框架解密</li><li>深入理解Android内核设计思想</li><li>Android系统源代码情景分析</li></ul><h4 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h4><ul><li>More Effective C++</li><li>Effective Java</li><li>Kotlin实战、快速上手Kotlin开发（极客时间）</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li>第一行代码</li><li>Android开发进阶 从小工到专家</li><li>Android进阶之光</li><li>Android开发艺术探索</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul><li>Android开发高手课（极客时间）</li><li>Android应用性能优化最佳实践</li></ul><h4 id="组件化、热修复、插件化"><a href="#组件化、热修复、插件化" class="headerlink" title="组件化、热修复、插件化"></a>组件化、热修复、插件化</h4><ul><li>Android组件化架构</li><li>Android热修复技术原理</li><li>Android插件化开发指南</li></ul><h3 id="二、如何读书？"><a href="#二、如何读书？" class="headerlink" title="二、如何读书？"></a>二、如何读书？</h3><p>首先，我们需要定一个学习计划，比如一年读50本书，一周一本。读书的时候可以<strong>根据同一个技能点按照难度选取3到5本书阅读，其中最好的书读3遍</strong>。对于碎片化的时间，我们也可以充分利用起来对某一个知识点进行系统学习，以求真正地将其完全掌握。最后，这里再重申一遍，<strong>要想真正掌握一本书的核心内容，需要读三遍。第一遍：细读，目的在于完整阅读全书，并且划出重点，写上读书笔记；一个月后读第二遍：扫读，主要快速翻阅第一遍阅读时做的笔记和划的重点，目的在于加深记忆；半年后第三遍：忆读，读的时候只看目录，然后去回想内容，如果回想不起来，再去进行扫读。这样三遍下来，基本上一本书的核心内容就能够很好的吸收</strong>。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>当你对某一个细分领域有非常深入的理解后，比如性能优化，音视频等，其实，此时许多底层知识都已经打通了。假如，你现在再去学习前端、Vue/React或者后端、其它领域的知识，都能够在较短时间内快速领悟到中高级层面的知识。我想，这就是一通百通的能力吧。</p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/05/12/Android%E5%BC%80%E5%8F%91%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%AB%98%E6%95%88%E6%88%90%E9%95%BF%E6%8C%87%E5%8D%97/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android系统启动流程之Launcher进程启动</title>
      <link>http://yoursite.com/2019/03/09/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BLauncher%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</link>
      <guid>http://yoursite.com/2019/03/09/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BLauncher%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</guid>
      <pubDate>Sat, 09 Mar 2019 07:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前面几篇文章我们已经详细分析了Android系统启动流程的init进程、Zygote进程和SystemServer进程。本篇，我们来分析一下Launcher的启动过程。</p><p>Android系统启动的最后一步就是启动了一个Launcher应用程序来显示系统中已经安装的应用程序。<strong>Launcher在启动的过程中会请求请求PMS返回系统中已安装的应用程序的信息，并将这些信息封装成一个快捷图标列表显示在系统屏幕上，从而使得用户可以点击这些快捷图片来启动相应的应用程序。</strong></p><p>Launcher作为Android系统的桌面，它的作用有两点：</p><ul><li>1、作为Android系统的启动器，用于启动应用程序。</li><li>2、作为Android系统的桌面，用于显示和管理应用程序的快捷图标或者其它桌面组件。</li></ul><p>下面，我们从以下两个方面来分析Launcher的启动过程：</p><ul><li>1、Launcher启动流程</li><li>2、Launcher中应用图标的显示过程</li></ul><h3 id="一、Launcher启动过程分析"><a href="#一、Launcher启动过程分析" class="headerlink" title="一、Launcher启动过程分析"></a>一、Launcher启动过程分析</h3><p>SystemServer进程在启动的过程中会启动PMS，PMS启动后会将系统中的应用程序安装完成，先前已经启动的AMS会将Launcher启动起来。在SystemServer的startOtherServices()方法中，调用了AMS的systemReady()方法，此即为Launcher的入口，如下所示：</p><pre><code>private void startOtherServices() {    ...    mActivityManagerService.systemReady(() -&gt; {        Slog.i(TAG, &quot;Making services ready&quot;);        traceBeginAndSlog(&quot;StartActivityManagerReadyPhase&quot;);        mSystemServiceManager.startBootPhase(                SystemService.PHASE_ACTIVITY_MANAGER_READY);        ...        }    ...}</code></pre><p>在Android 8.0及以上的部分源码中，都引入了Java Lambda表达式，可见其重要性的上升。下面继续分析AMS的systemReady()方法：</p><pre><code>public void systemReady(final Runnable goingCallback, TimingsTraceLog traceLog) {    ...    synchronized (this) {        ...        mStackSupervisor.resumeFocusedStackTopActivityLocked();        mUserController.sendUserSwitchBroadcasts(-1, currentUserId);        ...    }}</code></pre><p>在systemReady()方法中继续调用了ActivityStackSupervisor的resumeFocusedStackTopActivityLocked()方法，如下所示：</p><pre><code>boolean resumeFocusedStackTopActivityLocked() {    return resumeFocusedStackTopActivityLocked(null, null, null);}boolean resumeFocusedStackTopActivityLocked(        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions) {    ...    if (targetStack != null &amp;&amp; isFocusedStack(targetStack)) {        // 1        return targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);    }    ...    return false;}</code></pre><p>最终，调用了注释1处ActivityStack（描述Acitivity堆栈）的resumeTopActivityUncheckedLocked()方法，如下所示：</p><pre><code>@GuardedBy(&quot;mService&quot;)boolean resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options) {    if (mStackSupervisor.inResumeTopActivity) {        // Don&apos;t even start recursing.        return false;    }    boolean result = false;    try {        // Protect against recursion.        mStackSupervisor.inResumeTopActivity = true;        // 1        result = resumeTopActivityInnerLocked(prev, options);        // When resuming the top activity, it may be necessary to pause the top activity (for        // example, returning to the lock screen. We suppress the normal pause logic in        // {@link #resumeTopActivityUncheckedLocked}, since the top activity is resumed at the        // end. We call the {@link ActivityStackSupervisor#checkReadyForSleepLocked} again here        // to ensure any necessary pause logic occurs. In the case where the Activity will be        // shown regardless of the lock screen, the call to        // {@link ActivityStackSupervisor#checkReadyForSleepLocked} is skipped.        final ActivityRecord next = topRunningActivityLocked(true /* focusableOnly */);        if (next == null || !next.canTurnScreenOn()) {            checkReadyForSleep();        }    } finally {        mStackSupervisor.inResumeTopActivity = false;    }     return result;}</code></pre><p>在注释1处调用了resumeTopActivityInnerLocked()方法，如下所示：</p><pre><code>@GuardedBy(&quot;mService&quot;)private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) {    ...     if (!hasRunningActivity) {        // There are no activities left in the stack, let&apos;s look somewhere else.        return resumeTopActivityInNextFocusableStack(prev, options, &quot;noMoreActivities&quot;);    }    ...}</code></pre><p>resumeTopActivityInnerLocked()方法非常长，大概有好几百行代码，但是对于主要流程来说最关键的就是在其中调用了resumeTopActivityInNextFocusableStack()方法，如下所示：</p><pre><code>private boolean resumeTopActivityInNextFocusableStack(ActivityRecord prev,        ActivityOptions options, String reason) {    if (adjustFocusToNextFocusableStack(reason)) {        // Try to move focus to the next visible stack with a running activity if this        // stack is not covering the entire screen or is on a secondary display (with no home        // stack).        return mStackSupervisor.resumeFocusedStackTopActivityLocked(                mStackSupervisor.getFocusedStack(), prev, null);    }    // Let&apos;s just start up the Launcher...    ActivityOptions.abort(options);    if (DEBUG_STATES) Slog.d(TAG_STATES,            &quot;resumeTopActivityInNextFocusableStack: &quot; + reason + &quot;, go home&quot;);    if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();    // Only resume home if on home display    // 1    return isOnHomeDisplay() &amp;&amp;            mStackSupervisor.resumeHomeStackTask(prev, reason);}</code></pre><p>在注释1处，调用了ActivityStackSupervisor的resumeHomeStackTask()方法，如下所示：</p><pre><code>boolean resumeHomeStackTask(ActivityRecord prev, String reason) {    ...    // Only resume home activity if isn&apos;t finishing.    if (r != null &amp;&amp; !r.finishing) {        moveFocusableActivityStackToFrontLocked(r, myReason);        return resumeFocusedStackTopActivityLocked(mHomeStack, prev, null);    }    // 1    return mService.startHomeActivityLocked(mCurrentUser, myReason);}</code></pre><p>注释1处，调用了AMS的startHomeActivityLocked()方法，如下所示：</p><pre><code>boolean startHomeActivityLocked(int userId, String reason) {    // 1    if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL            &amp;&amp; mTopAction == null) {        // We are running in factory test mode, but unable to find        // the factory test app, so just sit around displaying the        // error message and don&apos;t try to start anything.        return false;    }    // 2    Intent intent = getHomeIntent();    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);    if (aInfo != null) {        intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name));        // Don&apos;t do this if the home app is currently being        // instrumented.        aInfo = new ActivityInfo(aInfo);        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);        ProcessRecord app = getProcessRecordLocked(aInfo.processName,                aInfo.applicationInfo.uid, true);        // 3        if (app == null || app.instr == null) {            intent.setFlags(intent.getFlags() | FLAG_ACTIVITY_NEW_TASK);            final int resolvedUserId = UserHandle.getUserId(aInfo.applicationInfo.uid);            // For ANR debugging to verify if the user activity is the one that actually            // launched.            final String myReason = reason + &quot;:&quot; + userId + &quot;:&quot; + resolvedUserId;            // 4            mActivityStartController.startHomeActivity(intent, aInfo, myReason);        }    } else {        Slog.wtf(TAG, &quot;No home screen found for &quot; + intent, new Throwable());    }    return true;}</code></pre><p>首先，会在注释1处判断工厂模式和mTopAction的值，这里的工厂模式mFactoryTest代表的了系统的运行模式，它分为三种：</p><ul><li>1、非工厂模式</li><li>2、低级工厂模式</li><li>3、高级工厂模式</li></ul><p>而mTopAction是来描述第一个被启动Activity组件的Action，默认值为Intent.ACTION_MAIN。所以，此时可知当mFactoryTest为低级工厂模式并且mTopAction为空时，则返回false。接着，在注释2处，调用了getHomeintent()方法，如下所示：</p><pre><code>Intent getHomeIntent() {    // 1    Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null);    intent.setComponent(mTopComponent);    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);    if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) {        // 2        intent.addCategory(Intent.CATEGORY_HOME);    }    return intent;}</code></pre><p>在getHomeIntent()方法的注释1处，根据mTopAction和mTopData创建了Intent。注释2处，会判断如果系统运行模式不是低级工厂模式，则会将Category设置为Intent.CATEGORY_HOME，最后返回该Intent。</p><p>我们再回到AMS的startHomeActivityLocked()方法的注释3处，这里会判断符合上述Intent的应用程序是否已经启动，如果没有启动，则会在注释4处调用ActivityStartController的startHomeActivity()方法启动该应用程序，即Launcher。下面我们继续看看startHomeActivity()方法，如下所示：</p><pre><code>void startHomeActivity(Intent intent, ActivityInfo aInfo, String reason) {    // 1    mSupervisor.moveHomeStackTaskToTop(reason);    // 2    mLastHomeActivityStartResult = obtainStarter(intent, &quot;startHomeActivity: &quot; + reason)            .setOutActivity(tmpOutRecord)            .setCallingUid(0)            .setActivityInfo(aInfo)            .execute();    mLastHomeActivityStartRecord = tmpOutRecord[0];    if (mSupervisor.inResumeTopActivity) {        // If we are in resume section already, home activity will be initialized, but not        // resumed (to avoid recursive resume) and will stay that way until something pokes it        // again. We need to schedule another resume.        mSupervisor.scheduleResumeTopActivities();    }}</code></pre><p>注释1处，会将Launcher放入HomeStack中，它是ActivityStackSupervisor中用于存储Launcher的变量。然后，在注释2处调用了obtainStarter()方法，如下所示：</p><pre><code>** * @return A starter to configure and execute starting an activity. It is valid until after *         {@link ActivityStarter#execute} is invoked. At that point, the starter should be *         considered invalid and no longer modified or used. */ActivityStarter obtainStarter(Intent intent, String reason) {    return mFactory.obtain().setIntent(intent).setReason(reason);}</code></pre><p>可知这里最终会返回一个配置好指定intent和reason和ActivityStarter，当它调用execute()方法时，则会启动Launcher，如下所示：</p><pre><code>int execute() {    try {        // TODO(b/64750076): Look into passing request directly to these methods to allow        // for transactional diffs and preprocessing.        if (mRequest.mayWait) {            return startActivityMayWait(mRequest.caller, mRequest.callingUid,                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,                    mRequest.inTask, mRequest.reason,                    mRequest.allowPendingRemoteAnimationRegistryLookup);        } else {            return startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,                    mRequest.outActivity, mRequest.inTask, mRequest.reason,                    mRequest.allowPendingRemoteAnimationRegistryLookup);        }    } finally {        onExecutionComplete();    }}</code></pre><p>可以看到，这里调用了startActivity()方法来启动Launcher，最终会进入Launcher的onCreate()方法，Launcher启动完成。</p><h3 id="二、Launcher中应用图标的显示过程"><a href="#二、Launcher中应用图标的显示过程" class="headerlink" title="二、Launcher中应用图标的显示过程"></a>二、Launcher中应用图标的显示过程</h3><p>应用程序图标是进入应用程序的入口，接下来我们了解一下Launcher是如何显示应用程序图标的。首先从Launcher的onCreate()方法开始，如下所示：</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    ...    // 1    LauncherAppState app = LauncherAppState.getInstance(this);    mOldConfig = new Configuration(getResources().getConfiguration());    // 2    mModel = app.setLauncher(this);    initDeviceProfile(app.getInvariantDeviceProfile());    ...    // We only load the page synchronously if the user rotates (or triggers a    // configuration change) while launcher is in the foreground    int currentScreen = PagedView.INVALID_RESTORE_PAGE;    if (savedInstanceState != null) {        currentScreen = savedInstanceState.getInt(RUNTIME_STATE_CURRENT_SCREEN, currentScreen);    }    // 3    if (!mModel.startLoader(currentScreen)) {        if (!internalStateHandled) {            // If we are not binding synchronously, show a fade in animation when            // the first page bind completes.            mDragLayer.getAlphaProperty(ALPHA_INDEX_LAUNCHER_LOAD).setValue(0);        }    } else {        // Pages bound synchronously.        mWorkspace.setCurrentPage(currentScreen);        setWorkspaceLoading(true);    }}</code></pre><p>首先，在注释1处得到LauncherAppState的实例，在注释2处，调用了它的setLauncher()方法将Launcher对象传进去，setLauncher()方法如下所示：</p><pre><code> LauncherModel setLauncher(Launcher launcher) {    getLocalProvider(mContext).setLauncherProviderChangeListener(launcher);    mModel.initialize(launcher);    return mModel;}</code></pre><p>在setLauncher()方法里面继续调用了LauncherModel的initialize()方法，如下所示：</p><pre><code>/*** Set this as the current Launcher activity object for the loader.*/public void initialize(Callbacks callbacks) {    synchronized (mLock) {        Preconditions.assertUIThread();        mCallbacks = new WeakReference&lt;&gt;(callbacks);    }}</code></pre><p>从此处我们可以得知Launcher被封装成了一个弱引用对象mCallbacks。我们再回到Launcher的onCreate()方法的注释3处的LauncherModel的startLoader()方法，如下所示：</p><pre><code>// 1@Thunk static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);static {    sWorkerThread.start();}// 2@Thunk static final Handler sWorker = new Handler(sWorkerThread.getLooper());public boolean startLoader(int synchronousBindPage) {    // Enable queue before starting loader. It will get disabled in Launcher#finishBindingItems    InstallShortcutReceiver.enableInstallQueue(InstallShortcutReceiver.FLAG_LOADER_RUNNING);    synchronized (mLock) {        // Don&apos;t bother to start the thread if we know it&apos;s not going to do anything        if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {            final Callbacks oldCallbacks = mCallbacks.get();            // Clear any pending bind-runnables from the synchronized load process.            mUiExecutor.execute(oldCallbacks::clearPendingBinds);            // If there is already one running, tell it to stop.            stopLoader();            // 3            LoaderResults loaderResults = new LoaderResults(mApp, sBgDataModel,                    mBgAllAppsList, synchronousBindPage, mCallbacks);            if (mModelLoaded &amp;&amp; !mIsLoaderTaskRunning) {                // Divide the set of loaded items into those that we are binding synchronously,                // and everything else that is to be bound normally (asynchronously).                loaderResults.bindWorkspace();                // For now, continue posting the binding of AllApps as there are other                // issues that arise from that.                loaderResults.bindAllApps();                loaderResults.bindDeepShortcuts();                loaderResults.bindWidgets();                return true;            } else {                // 4                startLoaderForResults(loaderResults);            }        }    }    return false;}</code></pre><p>在注释1处，新建了具有消息循环的线程HandlerThread对象。注释2处，新建了Handler，并传入了HandlerThread的Looper，此处Handler就是用于向HandlerThread发送消息。接着，在注释3处，创建了LoaderResults，在注释4处，调用了startLoaderForResults()方法并将LoaderResults传入，如下所示：</p><pre><code>public void startLoaderForResults(LoaderResults results) {    synchronized (mLock) {        stopLoader();        mLoaderTask = new LoaderTask(mApp, mBgAllAppsList, sBgDataModel, results);        runOnWorkerThread(mLoaderTask);    }}</code></pre><p>在startLoaderForResults()方法中，调用了runOnWorkerThread()，如下所示：</p><pre><code>/** Runs the specified runnable immediately if called from the worker thread, otherwise it is * posted on the worker thread handler. */private static void runOnWorkerThread(Runnable r) {    // 1    if (sWorkerThread.getThreadId() == Process.myTid()) {        // 2        r.run();    } else {        // If we are not on the worker thread, then post to the worker handler        // 3        sWorker.post(r);    }}</code></pre><p>首先，注释1处会先判断当前的执行线程是否是工作线程，如果是则直接调用注释2处Runnable的run()方法，否则，调用sWorker这个Handler对象的post()方法将LoaderTask作为消息发送给HandlerThread。接下来，我们看看LoaderTask，它实现了Runnable接口，当其所描述的消息被处理时，则会调用它的run()方法，如下所示：</p><pre><code>/*** Runnable for the thread that loads the contents of the launcher:*   - workspace icons*   - widgets*   - all apps icons*   - deep shortcuts within apps*/public class LoaderTask implements Runnable {    ...     synchronized (this) {        // Skip fast if we are already stopped.        if (mStopped) {            return;        }    }    TraceHelper.beginSection(TAG);    try (LauncherModel.LoaderTransaction transaction = mApp.getModel().beginLoader(this)) {        TraceHelper.partitionSection(TAG, &quot;step 1.1: loading workspace&quot;);        // 1        loadWorkspace();        verifyNotStopped();        TraceHelper.partitionSection(TAG, &quot;step 1.2: bind workspace workspace&quot;);        // 2        mResults.bindWorkspace();        // Notify the installer packages of packages with active installs on the first screen.        TraceHelper.partitionSection(TAG, &quot;step 1.3: send first screen broadcast&quot;);        sendFirstScreenActiveInstallsBroadcast();        // Take a break        TraceHelper.partitionSection(TAG, &quot;step 1 completed, wait for idle&quot;);        waitForIdle();        verifyNotStopped();        // second step        TraceHelper.partitionSection(TAG, &quot;step 2.1: loading all apps&quot;);        // 3        loadAllApps();        TraceHelper.partitionSection(TAG, &quot;step 2.2: Binding all apps&quot;);        verifyNotStopped();        // 4        mResults.bindAllApps();        ...     } catch (CancellationException e) {        // Loader stopped, ignore        TraceHelper.partitionSection(TAG, &quot;Cancelled&quot;);    }    TraceHelper.endSection(TAG);}</code></pre><p><strong>Launcher是用工作区的形式来显示系统安装的应用程序快捷图标的，每一个工作区都是用来描述一个抽象桌面的，它由n个屏幕组成，每个屏幕又分为n个单元格，每个单元格用来显示一个应用程序的快捷图标。</strong></p><p>首先，在注释1、2处调用了loadWorkSpace()和LoaderResults的bindWorkspace()方法来加载和绑定工作区信息。注释3处调用了loadAllApps()和LoaderResults的bindAllApps()方法来加载系统已经安装的应用程序信息，bindAllApps()方法如下所示：</p><pre><code>public void bindAllApps() {    // shallow copy    @SuppressWarnings(&quot;unchecked&quot;)    final ArrayList&lt;AppInfo&gt; list = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();    Runnable r = new Runnable() {        public void run() {            // 1            Callbacks callbacks = mCallbacks.get();            if (callbacks != null) {                // 2                callbacks.bindAllApplications(list);            }        }    };    // 3    mUiExecutor.execute(r);}</code></pre><p>首先，在注释1处会从mCallbacks这个Launcher的弱引用对象中取出Launcher对象，并在注释2处调用了它的bindAllApplication()来绑定所有的应用程序信息，最后在注释3处使用mUiExecutor这个MainThreadExecutor执行器对象去执行这个创建好的Runnable对象。接下来，我们看看Launcher的bindAllApplications()方法，如下所示：</p><pre><code>// Main container view for the all apps screen.@Thunk AllAppsContainerView mAppsView;/*** Add the icons for all apps.** Implementation of the method from LauncherModel.Callbacks.*/public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps) {    // 1    mAppsView.getAppsStore().setApps(apps);    if (mLauncherCallbacks != null) {        mLauncherCallbacks.bindAllApplications(apps);    }}</code></pre><p>在注释1处，调用了AllAppsContainerView的getAppsStore()方法得到了一个AllAppsStore对象，AllAppsContainerView是所有App屏幕的主容器视图，AllAppsStore是一个负责维护所有app信息集合的通用工具类。下面，我们看看AllAppsStore对象的setApps()方法：</p><pre><code>/** * Sets the current set of apps. */public void setApps(List&lt;AppInfo&gt; apps) {    mComponentToAppMap.clear();    addOrUpdateApps(apps);}</code></pre><p>这里继续调用了addOrUpdateApps()方法：</p><pre><code> private final HashMap&lt;ComponentKey, AppInfo&gt; mComponentToAppMap = new HashMap&lt;&gt;();/*** Adds or updates existing apps in the list*/public void addOrUpdateApps(List&lt;AppInfo&gt; apps) {    for (AppInfo app : apps) {        mComponentToAppMap.put(app.toComponentKey(), app);    }    notifyUpdate();}</code></pre><p>可以看到，最终将所有app信息保存在了AllAppsStore的HashMap容器中。</p><p>当AllAppsContainerView加载完XML布局时，会调用自身的onFinishInflate()方法，如下所示：</p><pre><code>@Overrideprotected void onFinishInflate() {    super.onFinishInflate();    // This is a focus listener that proxies focus from a view into the list view.  This is to    // work around the search box from getting first focus and showing the cursor.    setOnFocusChangeListener((v, hasFocus) -&gt; {        if (hasFocus &amp;&amp; getActiveRecyclerView() != null) {            getActiveRecyclerView().requestFocus();        }    });    mHeader = findViewById(R.id.all_apps_header);    // 1    rebindAdapters(mUsingTabs, true /* force */);    mSearchContainer = findViewById(R.id.search_container_all_apps);    mSearchUiManager = (SearchUiManager) mSearchContainer;    mSearchUiManager.initialize(this);}</code></pre><p>在注释1处，进行了适配器数据的绑定，我们继续查看rebindAdapters()方法：</p><pre><code>private void rebindAdapters(boolean showTabs) {    rebindAdapters(showTabs, false /* force */);}private void rebindAdapters(boolean showTabs, boolean force) {    ...    if (mUsingTabs) {        // 1        mAH[AdapterHolder.MAIN].setup(mViewPager.getChildAt(0), mPersonalMatcher);        mAH[AdapterHolder.WORK].setup(mViewPager.getChildAt(1), mWorkMatcher);        onTabChanged(mViewPager.getNextPage());    } else {        // 2        mAH[AdapterHolder.MAIN].setup(findViewById(R.id.apps_list_view), null);        mAH[AdapterHolder.WORK].recyclerView = null;    }    setupHeader();    ...}</code></pre><p>可以看到，不管是否正在使用标签，最终都会调用到AdapterHolder的setup()方法，它时AllAppsContainerView的内部类，如下所示：</p><pre><code>void setup(@NonNull View rv, @Nullable ItemInfoMatcher matcher) {        appsList.updateItemFilter(matcher);        recyclerView = (AllAppsRecyclerView) rv;        recyclerView.setEdgeEffectFactory(createEdgeEffectFactory());        // 1        recyclerView.setApps(appsList, mUsingTabs);        recyclerView.setLayoutManager(layoutManager);        // 2        recyclerView.setAdapter(adapter);        recyclerView.setHasFixedSize(true);        // No animations will occur when changes occur to the items in this RecyclerView.        recyclerView.setItemAnimator(null);        FocusedItemDecorator focusedItemDecorator = new FocusedItemDecorator(recyclerView);        recyclerView.addItemDecoration(focusedItemDecorator);        adapter.setIconFocusListener(focusedItemDecorator.getFocusListener());        applyVerticalFadingEdgeEnabled(verticalFadingEdge);        applyPadding();    }</code></pre><p>注释1处，会将app信息列表appsList设置给AllAppsRecyclerView对象，在注释2处，为其设置了Adapter。最终，应用程序快捷图标列表就会显示到屏幕上了。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>到此，我们终于将Android系统启动流程这一主题分析完毕，结合前面的几篇内容，可以得出核心流程如下：</p><ul><li>1、<strong>启动电源以及系统启动</strong>：当电源按下时引导芯片从预定义的订房（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。</li><li>2、<strong>引导程序BootLoader</strong>：BootLoader是在Android系统开始运行前的一个小程序，主要用于把系统OS拉起来并运行。。</li><li>3、<strong>Linux内核启动</strong>：当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。当其完成系统设置时，会先在系统文件中寻找init.rc文件，并启动init进行。</li><li>4、<strong>init进程启动</strong>：初始化和启动属性服务，并且启动Zygote进程。</li><li>5、<strong>Zygote进程启动</strong>：创建JVM并为其注册JNI方法，创建服务器端Socket，启动SystemServer进程。</li><li>6、<strong>SystemServer进程启动</strong>：启动Binder线程池和SystemServiceManager，并且启动各种系统服务。</li><li>7、<strong>Launcher启动</strong>：被SystemServer进程启动的AMS会启动Launcher，Launcher启动后会将已安装应用的快捷图标显示到系统桌面上。</li></ul><p>下一系列，笔者将会给大家带来Android中的跨进程通信Binder的详细讲解，尽请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android V9.0.0 源码</p><p>2、Android进阶解密第二章</p><p>3、<a href="http://gityuan.com/android/" target="_blank" rel="external">Android系统开篇</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/03/09/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BLauncher%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android系统启动流程之SystemServer进程启动</title>
      <link>http://yoursite.com/2019/03/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E4%B9%8BSystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</link>
      <guid>http://yoursite.com/2019/03/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E4%B9%8BSystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</guid>
      <pubDate>Sun, 03 Mar 2019 14:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>在上一篇中，笔者已经分析过Android系统启动流程中的init进程启动部分。Android系统中各个进程的先后顺序为：</p><p>init进程 –-&gt; Zygote进程 –&gt; SystemServer进程 –&gt;应用进程</p><p>其中Zygote进程由init进程启动，SystemServer进程和应用进程由Zygote进程启动。在这一篇中，我将继续分析Android系统启动流程中的SystemServer进程启动部分。</p><p>SystemServer进程主要是用于创建系统服务的，例如AMS、WMS、PMS。这篇文章将从以下两个部分来对SystemServer进行分析：</p><ul><li>Zygote处理SystemServer进程</li><li>SystemServer进程解析</li></ul><h3 id="一、Zygote处理SystemServer进程"><a href="#一、Zygote处理SystemServer进程" class="headerlink" title="一、Zygote处理SystemServer进程"></a>一、Zygote处理SystemServer进程</h3><p>由前文可知，在ZygoteInit的forkSystemServer()方法中启动了SystemServer进程，如下所示：</p><pre><code>private static Runnable forkSystemServer(String abiList, String socketName,        ZygoteServer zygoteServer) {    ...    try {        parsedArgs = new ZygoteConnection.Arguments(args);        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);        boolean profileSystemServer = SystemProperties.getBoolean(                &quot;dalvik.vm.profilesystemserver&quot;, false);        if (profileSystemServer) {            parsedArgs.runtimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;        }        /* Request to fork the system server process */        // 1        pid = Zygote.forkSystemServer(                parsedArgs.uid, parsedArgs.gid,                parsedArgs.gids,                parsedArgs.runtimeFlags,                null,                parsedArgs.permittedCapabilities,                parsedArgs.effectiveCapabilities);    } catch (IllegalArgumentException ex) {        throw new RuntimeException(ex);    }    /* For child process */    // 2    if (pid == 0) {        if (hasSecondZygote(abiList)) {            waitForSecondaryZygote(socketName);        }        // 3        zygoteServer.closeServerSocket();        // 4        return handleSystemServerProcess(parsedArgs);    }    return null;}</code></pre><p>在注释1处，调用了Zygote的forkSystemServer()方法创建了SystemServer进程，并返回了当前进程的pid。在注释2处，如果pid==0则说明Zygote进程创建SystemServer进程成功，当前运行在SystemServer进程中。接着，在注释3处，由于SystemServer进程fork了Zygote进程的地址空间，所以会得到Zygote进程创建的Socket，这个Socket对于SystemServer进程是无用的，因此，在此处关闭了该Socket。最后，在注释4处，调用了handleSystemServerprocess()方法来启动SystemServer进程。handleSystemServerProcess()方法如下所示：</p><pre><code>/** * Finish remaining work for the newly forked system server process. */private static Runnable handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) {    ...    if (parsedArgs.invokeWith != null) {        ...    } else {        ClassLoader cl = null;        if (systemServerClasspath != null) {            // 1            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);            Thread.currentThread().setContextClassLoader(cl);        }        /*         * Pass the remaining arguments to SystemServer.         */        // 2        return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);    }}</code></pre><p>在注释1处，使用了systemServerClassPath和targetSdkVersion创建了一个PathClassLoader。接着，在注释2处，执行了ZygoteInit的zygoteInit()方法，该方法如下所示：</p><pre><code>public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {    if (RuntimeInit.DEBUG) {        Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;);    }    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;);    RuntimeInit.redirectLogStreams();    RuntimeInit.commonInit();    // 1    ZygoteInit.nativeZygoteInit();    // 2    return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);}</code></pre><p>在zygoteInit()方法中，首先在注释1处执行了nativeZygoteInit()方法，这里看到方法前缀为native可知是一个本地函数，因此，我们先了解它对应的JNI文件，在AndroidRuntime.cpp类中可以查看到nativeZygoteInit()方法对应的native函数，如下所示：</p><pre><code>/** JNI registration.*/int register_com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env){    const JNINativeMethod methods[] = {        { &quot;nativeZygoteInit&quot;, &quot;()V&quot;,            (void*) com_android_internal_os_ZygoteInit_nativeZygoteInit },    };    return jniRegisterNativeMethods(env, &quot;com/android/internal/os/ZygoteInit&quot;,        methods, NELEM(methods));}</code></pre><p>这里使用了JNI动态注册的方式，将nativeZygoteInit()方法和native函数com_android_internal_os_ZygoteInit_nativeZygoteInit()建立了映射关系，我们看到这个native方法的代码：</p><pre><code>static AndroidRuntime* gCurRuntime = NULL;static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz){    gCurRuntime-&gt;onZygoteInit();}</code></pre><p>可以看到，gCurRuntime是AndroidRuntime类型的指针，具体指向的是其子类AppRuntime，它在app_main.cpp中定义，代码如下所示：</p><pre><code>class AppRuntime : public AndroidRuntime{    ...    virtual void onZygoteInit()    {        // 1        sp&lt;ProcessState&gt; proc = ProcessState::self();        ALOGV(&quot;App process: starting thread pool.\n&quot;);        // 2        proc-&gt;startThreadPool();    }    ...}</code></pre><p>在注释1处，创建了一个ProcessState实例， 在Android中ProcessState是客户端和服务端公共的部分，作为Binder通信的基础，ProcessState是一个singleton类，每个<br>进程只有一个对象，这个对象负责打开Binder驱动，建立线程池，让其进程里面的所有线程都能通过Binder通信。在注释2处，调用了ProcessState实例的startThreadPool()函数启动了一个Binder线程池，其实里面最终会调用到IPCThreadState实例的joinThreadPool()函数进程Binder线程池相关的处理。现在，我们再回到zygoteInit()方法的注释2处，这里调用了RuntimeInit的applicationInit()方法，代码如下所示：</p><pre><code>protected static Runnable applicationInit(int targetSdkVersion, String[] argv,    ClassLoader classLoader) {    ...    // Remaining arguments are passed to the start class&apos;s static main    return findStaticMain(args.startClass, args.startArgs, classLoader);}</code></pre><p>在applicationInit()方法中最后调用了findStaticMain()方法：</p><pre><code>protected static Runnable findStaticMain(String className, String[] argv,        ClassLoader classLoader) {    Class&lt;?&gt; cl;    try {        // 1        cl = Class.forName(className, true, classLoader);    } catch (ClassNotFoundException ex) {        throw new RuntimeException(                &quot;Missing class when invoking static main &quot; + className,                ex);    }    Method m;    try {        // 2        m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });    } catch (NoSuchMethodException ex) {        throw new RuntimeException(                &quot;Missing static main on &quot; + className, ex);    } catch (SecurityException ex) {        throw new RuntimeException(                &quot;Problem getting static main on &quot; + className, ex);    }    int modifiers = m.getModifiers();    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {        throw new RuntimeException(                &quot;Main method is not public and static on &quot; + className);    }    /*     * This throw gets caught in ZygoteInit.main(), which responds     * by invoking the exception&apos;s run() method. This arrangement     * clears up all the stack frames that were required in setting     * up the process.     */    // 3    return new MethodAndArgsCaller(m, argv);}</code></pre><p>首先，在注释1处，通过发射得到了SystemServer类。接着，在注释2处，找到了SystemServer中的main()方法。最后，在注释3处，会将main()方法传入MethodAndArgsCaller()方法中，这里的MethodAndArgsCaller()方法是一个Runnable实例，它最终会一直返回出去，直到在ZygoteInit的main()方法中被使用，如下所示：</p><pre><code>if (startSystemServer) {    Runnable r = forkSystemServer(abiList, socketName, zygoteServer);    // {@code r == null} in the parent (zygote) process, and {@code r != null} in the    // child (system_server) process.    if (r != null) {        r.run();        return;    }}</code></pre><p>可以看到，最终直接调用了这个Runnable实例的run()方法，代码如下所示：</p><pre><code>/** * Helper class which holds a method and arguments and can call them. This is used as part of * a trampoline to get rid of the initial process setup stack frames. */static class MethodAndArgsCaller implements Runnable {    /** method to call */    private final Method mMethod;    /** argument array */    private final String[] mArgs;    public MethodAndArgsCaller(Method method, String[] args) {        mMethod = method;        mArgs = args;    }    public void run() {        try {            // 1            mMethod.invoke(null, new Object[] { mArgs });        } catch (IllegalAccessException ex) {            throw new RuntimeException(ex);        } catch (InvocationTargetException ex) {            Throwable cause = ex.getCause();            if (cause instanceof RuntimeException) {                throw (RuntimeException) cause;            } else if (cause instanceof Error) {                throw (Error) cause;            }            throw new RuntimeException(ex);        }    }}</code></pre><p>在注释1处，这个mMethod就是指的SystemServer的main()方法，这里动态调用了SystemServer的main()方法，最终，SystemServer进程就进入了SystemServer的main()方法中了。这里还有个遗留问题，为什么不直接在findStaticMain()方法中直接动态调用SystemServer的main()方法呢？原因就是这种递归返回后再执行入口方法的方式会让SystemServer的main()方法看起来像是SystemServer的入口方法，而且，这样也会清除之前所有SystemServer相关设置过程中需要的堆栈帧。</p><h3 id="二、SystemServer进程解析"><a href="#二、SystemServer进程解析" class="headerlink" title="二、SystemServer进程解析"></a>二、SystemServer进程解析</h3><p>接下来我们看看SystemServer的main()方法：</p><pre><code>/*** The main entry point from zygote.*/public static void main(String[] args) {    new SystemServer().run();}</code></pre><p>main()方法中调用了SystemServer的run()方法，如下所示：</p><pre><code>private void run() {    try {        ...        // 1        Looper.prepareMainLooper();        ...        // Initialize native services.        // 2        System.loadLibrary(&quot;android_servers&quot;);        // Check whether we failed to shut down last time we tried.        // This call may not return.        performPendingShutdown();         // Initialize the system context.        createSystemContext();        // Create the system service manager.        // 3        mSystemServiceManager = new SystemServiceManager(mSystemContext);        mSystemServiceManager.setStartInfo(mRuntimeRestart,                mRuntimeStartElapsedTime, mRuntimeStartUptime);        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);        // Prepare the thread pool for init tasks that can be parallelized        SystemServerInitThreadPool.get();    } finally {        traceEnd();  // InitBeforeStartServices    }    // Start services.    try {        traceBeginAndSlog(&quot;StartServices&quot;);        // 4        startBootstrapServices();        // 5        startCoreServices();        // 6        startOtherServices();        SystemServerInitThreadPool.shutdown();    } catch (Throwable ex) {        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);        throw ex;    } finally {        traceEnd();    }    ...    // Loop forever.    // 7    Looper.loop();    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);}</code></pre><p>在注释1处，创建了消息Looper。在注释2处，加载了动态库libandroid_servers.so。接着，在注释3处，创建了SystemServerManager，它的作用是对系统服务进行创建、启动和生命周期管理。在注释4处的startBootstarpServices()方法中使用SystemServiceManager启动了ActivityManagerService、PackageManagerService、PowerManagerService等引导服务。在注释5处的startCoreServices()方法中则启动了BatteryService、WebViewUpdateService、DropBoxManagerService、UsageStatsService4个核心服务。在注释6处的startOtherServices()方法中启动了WindowManagerService、InputManagerService、CameraService等其它服务。这些服务的父类都是SystemService。</p><p>可以看到，上面把系统服务分成了三种类型：引导服务、核心服务、其它服务。这些系统服务共有100多个，其中对于我们来说比较关键的有：</p><ul><li>引导服务：ActivityManagerService，负责四大组件的启动、切换、调度。</li><li>引导服务：PackageManagerService，负责对APK进行安装、解析、删除、卸载等操作。</li><li>引导服务：PowerManagerService，负责计算系统中与Power相关的计算，然后决定系统该如何反应。</li><li>核心服务：BatteryService，管理电池相关的服务。</li><li>其它服务：WindowManagerService，窗口管理服务。</li><li>其它服务：InputManagerService，管理输入事件。</li></ul><p>很多系统服务的启动逻辑都是类似的，这里我以启动ActivityManagerService服务来进行举例，代码如下所示：</p><pre><code>mActivityManagerService = mSystemServiceManager.startService(        ActivityManagerService.Lifecycle.class).getService();</code></pre><p>SystemServiceManager的startService()方法启动了ActivityManagerService，该启动方法如下所示：</p><pre><code>@SuppressWarnings(&quot;unchecked&quot;)public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) {    try {        final String name = serviceClass.getName();        ...        try {            Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);            // 1            service = constructor.newInstance(mContext);        } catch (InstantiationException ex) {        ...        // 2        startService(service);        return service;    } finally {        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);    }}</code></pre><p>在注释1处使用反射创建了ActivityManagerService实例，并在注释2处调用了另一个startService()重载方法，如下所示：</p><pre><code>public void startService(@NonNull final SystemService service) {    // Register it.    // 1    mServices.add(service);    // Start it.    long time = SystemClock.elapsedRealtime();    try {        // 2        service.onStart();    } catch (RuntimeException ex) {        throw new RuntimeException(&quot;Failed to start service &quot; + service.getClass().getName()                + &quot;: onStart threw an exception&quot;, ex);    }    warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onStart&quot;);}</code></pre><p>在注释1处，首先会将ActivityManagerService添加在mServices中，它是一个存储SystemService类型的ArrayList，这样就完成了ActivityManagerService的注册。在注释2处，调用了ActivityManagerService的onStart()方法完成了启动ActivityManagerService服务。</p><p>除了使用SystemServiceManager的startService()方法来启动系统服务外，也可以直接调用服务的main()方法来启动系统服务，如PackageManagerService：</p><pre><code>mPackageManagerService = PackageManagerService.main(mSystemContext, installer,        mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</code></pre><p>这里直接调用了PackageManagerService的main()方法：</p><pre><code>public static PackageManagerService main(Context context, Installer installer,        boolean factoryTest, boolean onlyCore) {    // Self-check for initial settings.    PackageManagerServiceCompilerMapping.checkProperties();    // 1    PackageManagerService m = new PackageManagerService(context, installer,            factoryTest, onlyCore);    m.enableSystemUserPackages();    // 2    ServiceManager.addService(&quot;package&quot;, m);    // 3    final PackageManagerNative pmn = m.new PackageManagerNative();    ServiceManager.addService(&quot;package_native&quot;, pmn);    return m;}</code></pre><p>在注释1处，直接新建了一个PackageManagerService实例，并在注释2处将PackageManagerService注册到服务大管家ServiceManager中，ServiceManager用于管理系统中的各种Service，用于系统C/S架构中的Binder进程间通信，即如果Client端需要使用某个Servcie，首先应该到ServiceManager查询Service的相关信息，然后使用这些信息和该Service所在的Server进程建立通信通道，这样Client端就可以服务端进程的Service进行通信了。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>SystemService的启动流程分析至此已经完结，经过以上的分析可知，SystemService进程被创建后，主要的处理如下：</p><ul><li>1、启动Binder线程池，这样就可以与其他进程进行Binder跨进程通信。</li><li>2、创建SystemServiceManager，它用来对系统服务进行创建、启动和生命周期管理。</li><li>3、启动各种系统服务：引导服务、核心服务、其他服务，共100多种。应用开发主要关注引导服务ActivityManagerService、PackageManagerService和其他服务WindowManagerService、InputManagerService即可。</li></ul><p>下篇，将会给大家带来Android系统启动流程之Launcher进程启动的详细分析，希望大家多多支持~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android V9.0.0 源码</p><p>2、Android进阶解密第二章</p><p>3、<a href="http://gityuan.com/android/" target="_blank" rel="external">Android系统开篇</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/03/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E4%B9%8BSystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
