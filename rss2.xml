<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Sun, 03 Mar 2019 14:32:38 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android系统启动流程之SystemServer进程启动</title>
      <link>http://yoursite.com/2019/03/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E4%B9%8BSystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</link>
      <guid>http://yoursite.com/2019/03/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E4%B9%8BSystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</guid>
      <pubDate>Sun, 03 Mar 2019 14:32:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>在上一篇中，笔者已经分析过Android系统启动流程中的init进程启动部分。Android系统中各个进程的先后顺序为：</p><p>init进程 –-&gt; Zygote进程 –&gt; SystemServer进程 –&gt;应用进程</p><p>其中Zygote进程由init进程启动，SystemServer进程和应用进程由Zygote进程启动。在这一篇中，我将继续分析Android系统启动流程中的SystemServer进程启动部分。</p><p>SystemServer进程主要是用于创建系统服务的，例如AMS、WMS、PMS。这篇文章将从以下两个部分来对SystemServer进行分析：</p><ul><li>Zygote处理SystemServer进程</li><li>SystemServer进程解析</li></ul><h3 id="一、Zygote处理SystemServer进程"><a href="#一、Zygote处理SystemServer进程" class="headerlink" title="一、Zygote处理SystemServer进程"></a>一、Zygote处理SystemServer进程</h3><p>由前文可知，在ZygoteInit的forkSystemServer()方法中启动了SystemServer进程，如下所示：</p><pre><code>private static Runnable forkSystemServer(String abiList, String socketName,        ZygoteServer zygoteServer) {    ...    try {        parsedArgs = new ZygoteConnection.Arguments(args);        ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);        ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);        boolean profileSystemServer = SystemProperties.getBoolean(                &quot;dalvik.vm.profilesystemserver&quot;, false);        if (profileSystemServer) {            parsedArgs.runtimeFlags |= Zygote.PROFILE_SYSTEM_SERVER;        }        /* Request to fork the system server process */        // 1        pid = Zygote.forkSystemServer(                parsedArgs.uid, parsedArgs.gid,                parsedArgs.gids,                parsedArgs.runtimeFlags,                null,                parsedArgs.permittedCapabilities,                parsedArgs.effectiveCapabilities);    } catch (IllegalArgumentException ex) {        throw new RuntimeException(ex);    }    /* For child process */    // 2    if (pid == 0) {        if (hasSecondZygote(abiList)) {            waitForSecondaryZygote(socketName);        }        // 3        zygoteServer.closeServerSocket();        // 4        return handleSystemServerProcess(parsedArgs);    }    return null;}</code></pre><p>在注释1处，调用了Zygote的forkSystemServer()方法创建了SystemServer进程，并返回了当前进程的pid。在注释2处，如果pid==0则说明Zygote进程创建SystemServer进程成功，当前运行在SystemServer进程中。接着，在注释3处，由于SystemServer进程fork了Zygote进程的地址空间，所以会得到Zygote进程创建的Socket，这个Socket对于SystemServer进程是无用的，因此，在此处关闭了该Socket。最后，在注释4处，调用了handleSystemServerprocess()方法来启动SystemServer进程。handleSystemServerProcess()方法如下所示：</p><pre><code>/** * Finish remaining work for the newly forked system server process. */private static Runnable handleSystemServerProcess(ZygoteConnection.Arguments parsedArgs) {    ...    if (parsedArgs.invokeWith != null) {        ...    } else {        ClassLoader cl = null;        if (systemServerClasspath != null) {            // 1            cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);            Thread.currentThread().setContextClassLoader(cl);        }        /*         * Pass the remaining arguments to SystemServer.         */        // 2        return ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);    }}</code></pre><p>在注释1处，使用了systemServerClassPath和targetSdkVersion创建了一个PathClassLoader。接着，在注释2处，执行了ZygoteInit的zygoteInit()方法，该方法如下所示：</p><pre><code>public static final Runnable zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) {    if (RuntimeInit.DEBUG) {        Slog.d(RuntimeInit.TAG, &quot;RuntimeInit: Starting application from zygote&quot;);    }    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ZygoteInit&quot;);    RuntimeInit.redirectLogStreams();    RuntimeInit.commonInit();    // 1    ZygoteInit.nativeZygoteInit();    // 2    return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);}</code></pre><p>在zygoteInit()方法中，首先在注释1处执行了nativeZygoteInit()方法，这里看到方法前缀为native可知是一个本地函数，因此，我们先了解它对应的JNI文件，在AndroidRuntime.cpp类中可以查看到nativeZygoteInit()方法对应的native函数，如下所示：</p><pre><code>/** JNI registration.*/int register_com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env){    const JNINativeMethod methods[] = {        { &quot;nativeZygoteInit&quot;, &quot;()V&quot;,            (void*) com_android_internal_os_ZygoteInit_nativeZygoteInit },    };    return jniRegisterNativeMethods(env, &quot;com/android/internal/os/ZygoteInit&quot;,        methods, NELEM(methods));}</code></pre><p>这里使用了JNI动态注册的方式，将nativeZygoteInit()方法和native函数com_android_internal_os_ZygoteInit_nativeZygoteInit()建立了映射关系，我们看到这个native方法的代码：</p><pre><code>static AndroidRuntime* gCurRuntime = NULL;static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz){    gCurRuntime-&gt;onZygoteInit();}</code></pre><p>可以看到，gCurRuntime是AndroidRuntime类型的指针，具体指向的是其子类AppRuntime，它在app_main.cpp中定义，代码如下所示：</p><pre><code>class AppRuntime : public AndroidRuntime{    ...    virtual void onZygoteInit()    {        // 1        sp&lt;ProcessState&gt; proc = ProcessState::self();        ALOGV(&quot;App process: starting thread pool.\n&quot;);        // 2        proc-&gt;startThreadPool();    }    ...}</code></pre><p>在注释1处，创建了一个ProcessState实例， 在Android中ProcessState是客户端和服务端公共的部分，作为Binder通信的基础，ProcessState是一个singleton类，每个<br>进程只有一个对象，这个对象负责打开Binder驱动，建立线程池，让其进程里面的所有线程都能通过Binder通信。在注释2处，调用了ProcessState实例的startThreadPool()函数启动了一个Binder线程池，其实里面最终会调用到IPCThreadState实例的joinThreadPool()函数进程Binder线程池相关的处理。现在，我们再回到zygoteInit()方法的注释2处，这里调用了RuntimeInit的applicationInit()方法，代码如下所示：</p><pre><code>protected static Runnable applicationInit(int targetSdkVersion, String[] argv,    ClassLoader classLoader) {    ...    // Remaining arguments are passed to the start class&apos;s static main    return findStaticMain(args.startClass, args.startArgs, classLoader);}</code></pre><p>在applicationInit()方法中最后调用了findStaticMain()方法：</p><pre><code>protected static Runnable findStaticMain(String className, String[] argv,        ClassLoader classLoader) {    Class&lt;?&gt; cl;    try {        // 1        cl = Class.forName(className, true, classLoader);    } catch (ClassNotFoundException ex) {        throw new RuntimeException(                &quot;Missing class when invoking static main &quot; + className,                ex);    }    Method m;    try {        // 2        m = cl.getMethod(&quot;main&quot;, new Class[] { String[].class });    } catch (NoSuchMethodException ex) {        throw new RuntimeException(                &quot;Missing static main on &quot; + className, ex);    } catch (SecurityException ex) {        throw new RuntimeException(                &quot;Problem getting static main on &quot; + className, ex);    }    int modifiers = m.getModifiers();    if (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) {        throw new RuntimeException(                &quot;Main method is not public and static on &quot; + className);    }    /*     * This throw gets caught in ZygoteInit.main(), which responds     * by invoking the exception&apos;s run() method. This arrangement     * clears up all the stack frames that were required in setting     * up the process.     */    // 3    return new MethodAndArgsCaller(m, argv);}</code></pre><p>首先，在注释1处，通过发射得到了SystemServer类。接着，在注释2处，找到了SystemServer中的main()方法。最后，在注释3处，会将main()方法传入MethodAndArgsCaller()方法中，这里的MethodAndArgsCaller()方法是一个Runnable实例，它最终会一直返回出去，直到在ZygoteInit的main()方法中被使用，如下所示：</p><pre><code>if (startSystemServer) {    Runnable r = forkSystemServer(abiList, socketName, zygoteServer);    // {@code r == null} in the parent (zygote) process, and {@code r != null} in the    // child (system_server) process.    if (r != null) {        r.run();        return;    }}</code></pre><p>可以看到，最终直接调用了这个Runnable实例的run()方法，代码如下所示：</p><pre><code>/** * Helper class which holds a method and arguments and can call them. This is used as part of * a trampoline to get rid of the initial process setup stack frames. */static class MethodAndArgsCaller implements Runnable {    /** method to call */    private final Method mMethod;    /** argument array */    private final String[] mArgs;    public MethodAndArgsCaller(Method method, String[] args) {        mMethod = method;        mArgs = args;    }    public void run() {        try {            // 1            mMethod.invoke(null, new Object[] { mArgs });        } catch (IllegalAccessException ex) {            throw new RuntimeException(ex);        } catch (InvocationTargetException ex) {            Throwable cause = ex.getCause();            if (cause instanceof RuntimeException) {                throw (RuntimeException) cause;            } else if (cause instanceof Error) {                throw (Error) cause;            }            throw new RuntimeException(ex);        }    }}</code></pre><p>在注释1处，这个mMethod就是指的SystemServer的main()方法，这里动态调用了SystemServer的main()方法，最终，SystemServer进程就进入了SystemServer的main()方法中了。这里还有个遗留问题，为什么不直接在findStaticMain()方法中直接动态调用SystemServer的main()方法呢？原因就是这种递归返回后再执行入口方法的方式会让SystemServer的main()方法看起来像是SystemServer的入口方法，而且，这样也会清除之前所有SystemServer相关设置过程中需要的堆栈帧。</p><h3 id="二、SystemServer进程解析"><a href="#二、SystemServer进程解析" class="headerlink" title="二、SystemServer进程解析"></a>二、SystemServer进程解析</h3><p>接下来我们看看SystemServer的main()方法：</p><pre><code>/*** The main entry point from zygote.*/public static void main(String[] args) {    new SystemServer().run();}</code></pre><p>main()方法中调用了SystemServer的run()方法，如下所示：</p><pre><code>private void run() {    try {        ...        // 1        Looper.prepareMainLooper();        ...        // Initialize native services.        // 2        System.loadLibrary(&quot;android_servers&quot;);        // Check whether we failed to shut down last time we tried.        // This call may not return.        performPendingShutdown();         // Initialize the system context.        createSystemContext();        // Create the system service manager.        // 3        mSystemServiceManager = new SystemServiceManager(mSystemContext);        mSystemServiceManager.setStartInfo(mRuntimeRestart,                mRuntimeStartElapsedTime, mRuntimeStartUptime);        LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);        // Prepare the thread pool for init tasks that can be parallelized        SystemServerInitThreadPool.get();    } finally {        traceEnd();  // InitBeforeStartServices    }    // Start services.    try {        traceBeginAndSlog(&quot;StartServices&quot;);        // 4        startBootstrapServices();        // 5        startCoreServices();        // 6        startOtherServices();        SystemServerInitThreadPool.shutdown();    } catch (Throwable ex) {        Slog.e(&quot;System&quot;, &quot;******************************************&quot;);        Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex);        throw ex;    } finally {        traceEnd();    }    ...    // Loop forever.    // 7    Looper.loop();    throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);}</code></pre><p>在注释1处，创建了消息Looper。在注释2处，加载了动态库libandroid_servers.so。接着，在注释3处，创建了SystemServerManager，它的作用是对系统服务进行创建、启动和生命周期管理。在注释4处的startBootstarpServices()方法中使用SystemServiceManager启动了ActivityManagerService、PackageManagerService、PowerManagerService等引导服务。在注释5处的startCoreServices()方法中则启动了BatteryService、WebViewUpdateService、DropBoxManagerService、UsageStatsService4个核心服务。在注释6处的startOtherServices()方法中启动了WindowManagerService、InputManagerService、CameraService等其它服务。这些服务的父类都是SystemService。</p><p>可以看到，上面把系统服务分成了三种类型：引导服务、核心服务、其它服务。这些系统服务共有100多个，其中对于我们来说比较关键的有：</p><ul><li>引导服务：ActivityManagerService，负责四大组件的启动、切换、调度。</li><li>引导服务：PackageManagerService，负责对APK进行安装、解析、删除、卸载等操作。</li><li>引导服务：PowerManagerService，负责计算系统中与Power相关的计算，然后决定系统该如何反应。</li><li>核心服务：BatteryService，管理电池相关的服务。</li><li>其它服务：WindowManagerService，窗口管理服务。</li><li>其它服务：InputManagerService，管理输入事件。</li></ul><p>很多系统服务的启动逻辑都是类似的，这里我以启动ActivityManagerService服务来进行举例，代码如下所示：</p><pre><code>mActivityManagerService = mSystemServiceManager.startService(        ActivityManagerService.Lifecycle.class).getService();</code></pre><p>SystemServiceManager的startService()方法启动了ActivityManagerService，该启动方法如下所示：</p><pre><code>@SuppressWarnings(&quot;unchecked&quot;)public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) {    try {        final String name = serviceClass.getName();        ...        try {            Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class);            // 1            service = constructor.newInstance(mContext);        } catch (InstantiationException ex) {        ...        // 2        startService(service);        return service;    } finally {        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);    }}</code></pre><p>在注释1处使用反射创建了ActivityManagerService实例，并在注释2处调用了另一个startService()重载方法，如下所示：</p><pre><code>public void startService(@NonNull final SystemService service) {    // Register it.    // 1    mServices.add(service);    // Start it.    long time = SystemClock.elapsedRealtime();    try {        // 2        service.onStart();    } catch (RuntimeException ex) {        throw new RuntimeException(&quot;Failed to start service &quot; + service.getClass().getName()                + &quot;: onStart threw an exception&quot;, ex);    }    warnIfTooLong(SystemClock.elapsedRealtime() - time, service, &quot;onStart&quot;);}</code></pre><p>在注释1处，首先会将ActivityManagerService添加在mServices中，它是一个存储SystemService类型的ArrayList，这样就完成了ActivityManagerService的注册。在注释2处，调用了ActivityManagerService的onStart()方法完成了启动ActivityManagerService服务。</p><p>除了使用SystemServiceManager的startService()方法来启动系统服务外，也可以直接调用服务的main()方法来启动系统服务，如PackageManagerService：</p><pre><code>mPackageManagerService = PackageManagerService.main(mSystemContext, installer,        mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</code></pre><p>这里直接调用了PackageManagerService的main()方法：</p><pre><code>public static PackageManagerService main(Context context, Installer installer,        boolean factoryTest, boolean onlyCore) {    // Self-check for initial settings.    PackageManagerServiceCompilerMapping.checkProperties();    // 1    PackageManagerService m = new PackageManagerService(context, installer,            factoryTest, onlyCore);    m.enableSystemUserPackages();    // 2    ServiceManager.addService(&quot;package&quot;, m);    // 3    final PackageManagerNative pmn = m.new PackageManagerNative();    ServiceManager.addService(&quot;package_native&quot;, pmn);    return m;}</code></pre><p>在注释1处，直接新建了一个PackageManagerService实例，并在注释2处将PackageManagerService注册到服务大管家ServiceManager中，ServiceManager用于管理系统中的各种Service，用于系统C/S架构中的Binder进程间通信，即如果Client端需要使用某个Servcie，首先应该到ServiceManager查询Service的相关信息，然后使用这些信息和该Service所在的Server进程建立通信通道，这样Client端就可以服务端进程的Service进行通信了。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>SystemService的启动流程分析至此已经完结，经过以上的分析可知，SystemService进程被创建后，主要的处理如下：</p><ul><li>1、启动Binder线程池，这样就可以与其他进程进行Binder跨进程通信。</li><li>2、创建SystemServiceManager，它用来对系统服务进行创建、启动和生命周期管理。</li><li>3、启动各种系统服务：引导服务、核心服务、其他服务，共100多种。应用开发主要关注引导服务ActivityManagerService、PackageManagerService和其他服务WindowManagerService、InputManagerService即可。</li></ul><p>下篇，将会给大家带来Android系统启动流程之Launcher进程启动的详细分析，希望大家多多支持~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android V9.0.0 源码</p><p>2、Android进阶解密第二章</p><p>3、<a href="http://gityuan.com/android/" target="_blank" rel="external">Android系统开篇</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/03/03/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E4%B9%8BSystemServer%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android系统启动流程之Zygote进程启动</title>
      <link>http://yoursite.com/2019/02/24/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</link>
      <guid>http://yoursite.com/2019/02/24/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</guid>
      <pubDate>Sun, 24 Feb 2019 10:25:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>在上一篇中，我们已经分析过Android系统启动流程中的init进程启动部分。在这一篇中，我们将继续分享Android系统启动流程中的Zygote进程启动部分。我们先看看Gityuan博客中的一幅系统启动架构图来对Android系统的启动流程有一个宏观的把控。</p><p><img src="http://gityuan.com/images/android-process/android-boot.jpg" alt="image"></p><p>这篇文章将从以下三部分来对Zygote进行分析：</p><ul><li>1、Zygote是什么？</li><li>2、Zygote启动脚本</li><li>3、Zygote进程启动流程</li></ul><h3 id="一、Zygote是什么？"><a href="#一、Zygote是什么？" class="headerlink" title="一、Zygote是什么？"></a>一、Zygote是什么？</h3><p>Zygote是在init进程启动时创建的，它又称为孵化器，它可以通过fork（复制进程）的形式来创建应用程序进程和SystemServer进程。并且，Zygote进程在启动的时候回创建DVM或者ART，因此通过fork而创建的应用程序进程和SystemServer进程可以在内部获取一个DVM或者ART的实例副本。</p><h3 id="二、Zygote启动脚本"><a href="#二、Zygote启动脚本" class="headerlink" title="二、Zygote启动脚本"></a>二、Zygote启动脚本</h3><p>init.rc文件中采用了如下所示的Import类型语句来引入Zygote启动脚本：</p><pre><code>import /init.${ro.zygote}.rc</code></pre><p>这里根据属性ro.zygote的内容来引入不同的Zygote启动脚本。从Android 5.0开始，Android开始支持64位程序，Zygote有了32/64位之别，ro.zygote属性的取值有4种：</p><ul><li>init.zygote32.rc</li><li>init.zygote32_64.rc</li><li>init.zygote64.rc</li><li>init.zygote64_32.rc</li></ul><p>注意：上面的Zygote的启动脚本都存放在system/core/rootdir目录中。</p><p>下面我们来一一分析一下上述的Zygote启动脚本。</p><h4 id="1、init-zygote32-rc"><a href="#1、init-zygote32-rc" class="headerlink" title="1、init.zygote32.rc"></a>1、init.zygote32.rc</h4><p>仅支持32位程序，脚本源码如下所示：</p><pre><code>service zygote /system/bin/app_process -Xzygote /system/bin --zygote --start-system-server    class main    priority -20    user root    group root readproc reserved_disk    socket zygote stream 660 root system    onrestart write /sys/android_power/request_state wake    onrestart write /sys/power/state on    onrestart restart audioserver    onrestart restart cameraserver    onrestart restart media    onrestart restart netd    onrestart restart wificond    writepid /dev/cpuset/foreground/tasks</code></pre><p>可以看到，它就是Android初始化语言的Service类型语句，格式如下：</p><pre><code>service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*   //&lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt;      &lt;option&gt;       //option是service的修饰词，影响什么时候、如何启动services      &lt;option&gt;      ...</code></pre><p>由此，我们可以知道Zygote进程的名字为zygote，执行程序路径为/system/bin/app_process，类名为main，上述类似“onrestart restart …”格式的语句表示如果audioserver、cameraserver、media等进程终止了，就会进行重启。</p><h4 id="2、init-zygote32-64-rc"><a href="#2、init-zygote32-64-rc" class="headerlink" title="2、init.zygote32_64.rc"></a>2、init.zygote32_64.rc</h4><p>同时支持32、64位程序，脚本源码如下所示：</p><pre><code>service zygote /system/bin/app_process32 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote    class main    priority -20    user root    group root readproc reserved_disk    socket zygote stream 660 root system    onrestart write /sys/android_power/request_state     wake    onrestart write /sys/power/state on    onrestart restart audioserver    onrestart restart cameraserver    onrestart restart media    onrestart restart netd    onrestart restart wificond    writepid /dev/cpuset/foreground/tasksservice zygote_secondary /system/bin/app_process64 -Xzygote /system/bin --zygote     --socket-name=zygote_secondary    class main    priority -20    user root    group root readproc reserved_disk    socket zygote_secondary stream 660 root system    onrestart restart zygote    writepid /dev/cpuset/foreground/tasks</code></pre><p>可以看出，这里使用了两个Service类型语句启动了两个Zygote进程，一个是名字为zygote，执行程序为app_process32的主模式Zygote进程；另一个是名字为zygote_secondary，执行程序为app_process64的辅模式Zygote进程。另外的init.zygote64.rc和init.zygote64_32.rc与上面的Zygote脚本都是类似的，这里不再多说了。</p><h3 id="三、Zygote进程启动流程"><a href="#三、Zygote进程启动流程" class="headerlink" title="三、Zygote进程启动流程"></a>三、Zygote进程启动流程</h3><p>在init启动Zygote时主要是调用app_main.cpp的main函数中的AppRuntime.start()方法来启动Zygote进程的，我们先看到app_main.cpp的main函数：</p><pre><code>int main(int argc, char* const argv[]){    ...    while (i &lt; argc) {        const char* arg = argv[i++];        // 1        if (strcmp(arg, &quot;--zygote&quot;) == 0) {            zygote = true;            niceName = ZYGOTE_NICE_NAME;        } else if (strcmp(arg, &quot;--start-system-server&quot;) == 0) {            // 2            startSystemServer = true;        } else if (strcmp(arg, &quot;--application&quot;) == 0) {            // 3            application = true;        } else if (strncmp(arg, &quot;--nice-name=&quot;, 12) == 0) {            niceName.setTo(arg + 12);        } else if (strncmp(arg, &quot;--&quot;, 2) != 0) {            className.setTo(arg);            break;        } else {            --i;            break;        }    }    ...    // 4    if (zygote) {        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);    } else if (className) {        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);    } else {        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);        app_usage();        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);    }}</code></pre><p>由前可知，Zygote进程都是通过fork自身来创建子进程的，这样Zygote进程和由它fork出来的子进程都会进入app_main.cpp的main函数中，所以在mian函数中，首先会判断当前运行在哪个进程，在注释1处，会判断参数arg中释放包含了”–zygote”，如果包含了，则说明main函数是运行在Zygote进程中的并会将zygote标记置为true。在注释2处会判断参数arg中是否包含了”–start-system-server”，如果包含了则表示当前是处在SystemServer进程中并将startSystemServer设置为true。同理在注释3处会判断参数arg是否包含”–application”，如果包含了说明当前处在应用程序进程中并将application标记置为true。最后在注释4处，当zygote标志是true的时候，也就是当前正处在Zygote进程中时，则使用AppRuntime.start()函数启动Zygote进程。</p><p>我们接着看看AndroidRuntime的start函数：</p><pre><code>void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote){    ...    /* start the virtual machine */    JniInvocation jni_invocation;    jni_invocation.Init(NULL);    JNIEnv* env;    // 1    if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) {        return;    }    onVmCreated(env);    /*     * 2、Register android functions.     */    if (startReg(env) &lt; 0) {        ALOGE(&quot;Unable to register all android natives\n&quot;);        return;    }    ...    // 3    classNameStr = env-&gt;NewStringUTF(className);    assert(classNameStr != NULL);    env-&gt;SetObjectArrayElement(strArray, 0, classNameStr);    for (size_t i = 0; i &lt; options.size(); ++i) {        jstring optionsStr = env-&gt;NewStringUTF(options.itemAt(i).string());        assert(optionsStr != NULL);        env-&gt;SetObjectArrayElement(strArray, i + 1, optionsStr);    }    /*     * Start VM.  This thread becomes the main thread of the VM, and will     * not return until the VM exits.     */    // 4    char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;);    jclass startClass = env-&gt;FindClass(slashClassName);    if (startClass == NULL) {        ALOGE(&quot;JavaVM unable to locate class &apos;%s&apos;\n&quot;, slashClassName);        /* keep going */    } else {        // 6        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;,            &quot;([Ljava/lang/String;)V&quot;);        if (startMeth == NULL) {            ALOGE(&quot;JavaVM unable to find main() in &apos;%s&apos;\n&quot;, className);            /* keep going */        } else {            // 6            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0            if (env-&gt;ExceptionCheck())                threadExitUncaughtException(env);#endif        }    }    free(slashClassName);    ...}</code></pre><p>首先，在AndroidRuntime的start函数中，会现在注释1处使用startVm函数来启动弄Java虚拟机，然后在注释2处使用startReg函数为Java虚拟机注册JNI方法。在注释3处的classNameStr是传入的参数，值为com.android.internall.os.ZygoteInit。然后在注释4处使用toSlashClassName函数将className的”.”替换为”/“，替换后的值为com/android/internal/os/ZygoteInit。接着根据这个值找到ZygoteInit并在注释5处找到ZygoteInit的main函数，最后在注释6处使用JNI调用ZygoteInit的main函数，之所以这里要使用JNI，是因为ZygoteInit是java代码。最终，Zygote就从Native层进入了Java FrameWork层。在此之前，并没有任何代码进入Java FrameWork层面，因此可以认为，Zygote开创了java FrameWork层。</p><p>接着，我们看看Zygoteinit.java中的main方法：</p><pre><code> public static void main(String argv[]) {    ...    try {        ...        // 1        zygoteServer.registerServerSocketFromEnv(socketName);        // In some configurations, we avoid preloading resources and classes eagerly.        // In such cases, we will preload things prior to our first fork.        if (!enableLazyPreload) {            bootTimingsTraceLog.traceBegin(&quot;ZygotePreload&quot;);            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,                SystemClock.uptimeMillis());            // 2            preload(bootTimingsTraceLog);            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,                SystemClock.uptimeMillis());            bootTimingsTraceLog.traceEnd(); // ZygotePreload        } else {            Zygote.resetNicePriority();        }        ...        if (startSystemServer) {            // 3            Runnable r = forkSystemServer(abiList, socketName, zygoteServer);            // {@code r == null} in the parent (zygote) process, and {@code r != null} in the            // child (system_server) process.            if (r != null) {                r.run();                return;            }        }        Log.i(TAG, &quot;Accepting command socket connections&quot;);        // The select loop returns early in the child process after a fork and        // loops forever in the zygote.        // 4        caller = zygoteServer.runSelectLoop(abiList);    } catch (Throwable ex) {        Log.e(TAG, &quot;System zygote died with exception&quot;, ex);        throw ex;    } finally {        zygoteServer.closeServerSocket();    }    // We&apos;re in the child process and have exited the select loop. Proceed to execute the    // command.    if (caller != null) {        caller.run();    }}</code></pre><p>首先，在注释1处调用了ZygoteServer的registerServerSocketFromEnv方法创建了一个名为”zygote”的Server端的Socket，它用来等待ActivityManagerService请求Zygote来创建新的应用程序进程。我首先分析下registerServerSocketFromEnv方法的处理逻辑，源码如下所示：</p><pre><code>private static final String ANDROID_SOCKET_PREFIX = &quot;ANDROID_SOCKET_&quot;;void registerServerSocketFromEnv(String socketName) {    if (mServerSocket == null) {        int fileDesc;        // 1        final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;        try {            // 2            String env = System.getenv(fullSocketName);            fileDesc = Integer.parseInt(env);        } catch (RuntimeException ex) {            throw new RuntimeException(fullSocketName + &quot; unset or invalid&quot;, ex);        }        try {            FileDescriptor fd = new FileDescriptor();            fd.setInt$(fileDesc);            // 3            mServerSocket = new LocalServerSocket(fd);            mCloseSocketFd = true;        } catch (IOException ex) {            throw new RuntimeException(                    &quot;Error binding to local socket &apos;&quot; + fileDesc + &quot;&apos;&quot;, ex);        }    }}</code></pre><p>首先，会在注释1处将Socket的名字拼接为“ANDROID_SOCKET_zygote“，在注释2处调用System.getenv()方法得到该Socket对应的环境变量中的值，然后将这个Socket环境变量值解析为int类型的文件描述符参数。接着，在注释4处，使用上面得到的文件描述符参数得到一个文件描述符，并由此新建一个服务端Socket。当Zygote进程将SystemServer进程启动红藕，就会在这个服务端Socket上等待AMS请求Zygote进程去创建新的应用程序进程。</p><p>接着，我们回到ZygoteInit的main方法，在注释2处会预加载类和资源。然后在注释3处，使用了forkSystemServer()方法去创建SystemServer进程。forkSystemServer()方法核心代码如下所示：</p><pre><code> private static Runnable forkSystemServer(String abiList, String socketName,        ZygoteServer zygoteServer) {    // 一系统创建SystemServer进程所需参数的准备工作    try {        ...        /* Request to fork the system server process */        // 3.1        pid = Zygote.forkSystemServer(                parsedArgs.uid, parsedArgs.gid,                parsedArgs.gids,                parsedArgs.runtimeFlags,                null,                parsedArgs.permittedCapabilities,                parsedArgs.effectiveCapabilities);    } catch (IllegalArgumentException ex) {        throw new RuntimeException(ex);    }    /* For child process */    if (pid == 0) {        if (hasSecondZygote(abiList)) {            waitForSecondaryZygote(socketName);        }        zygoteServer.closeServerSocket();        // 3.2        return handleSystemServerProcess(parsedArgs);    }    return null;}</code></pre><p>可以看到，forkSystemServer()方法中，注释3.1调用了Zygote的forkSystemServer()方法去创建SystemServer进程，其内部会执行nativeForkSystemServer这个Native方法，它最终会使用fork函数在当前进程创建一个SystemServer进程。如果pid等于0，即当前是处于新创建的子进程ServerServer进程中，则在注释3.2处使用handleSystemServerProcess()方法处理SystemServer进程的一些处理工作。</p><p>我们再回到Zygoteinit.java中main方法中的注释4处，这里调用了ZygoteServer的runSelectLoop方法来等等ActivityManagerService来请求创建新的应用程序进程，runSelectLoop()方法如下所示：</p><pre><code> Runnable runSelectLoop(String abiList) {    ArrayList&lt;FileDescriptor&gt; fds = new ArrayList&lt;FileDescriptor&gt;();    ArrayList&lt;ZygoteConnection&gt; peers = new ArrayList&lt;ZygoteConnection&gt;();    // 1    fds.add(mServerSocket.getFileDescriptor());    peers.add(null);    // 2、无限循环等待AMS请求创建应用程序进程    while (true) {        StructPollfd[] pollFds = new StructPollfd[fds.size()];        for (int i = 0; i &lt; pollFds.length; ++i) {            pollFds[i] = new StructPollfd();            pollFds[i].fd = fds.get(i);            pollFds[i].events = (short) POLLIN;        }        try {            Os.poll(pollFds, -1);        } catch (ErrnoException ex) {            throw new RuntimeException(&quot;poll failed&quot;, ex);        }        // 3        for (int i = pollFds.length - 1; i &gt;= 0; --i) {            if ((pollFds[i].revents &amp; POLLIN) == 0) {                continue;            }            // 4            if (i == 0) {                ZygoteConnection newPeer = acceptCommandPeer(abiList);                peers.add(newPeer);                fds.add(newPeer.getFileDesciptor());            } else {                try {                    ZygoteConnection connection = peers.get(i);                    // 5                    final Runnable command = connection.processOneCommand(this);                    if (mIsForkChild) {                        // We&apos;re in the child. We should always have a command to run at this                        // stage if processOneCommand hasn&apos;t called &quot;exec&quot;.                        if (command == null) {                            throw new IllegalStateException(&quot;command == null&quot;);                        }                        return command;                    } else {                        // We&apos;re in the server - we should never have any commands to run.                        if (command != null) {                            throw new IllegalStateException(&quot;command != null&quot;);                        }                        // We don&apos;t know whether the remote side of the socket was closed or                        // not until we attempt to read from it from processOneCommand. This shows up as                        // a regular POLLIN event in our regular processing loop.                        if (connection.isClosedByPeer()) {                            connection.closeSocket();                            peers.remove(i);                            fds.remove(i);                        }                    }                } catch (Exception e) {                    if (!mIsForkChild) {                        // We&apos;re in the server so any exception here is one that has taken place                        // pre-fork while processing commands or reading / writing from the                        // control socket. Make a loud noise about any such exceptions so that                        // we know exactly what failed and why.                        Slog.e(TAG, &quot;Exception executing zygote command: &quot;, e);                        // Make sure the socket is closed so that the other end knows immediately                        // that something has gone wrong and doesn&apos;t time out waiting for a                        // response.                        ZygoteConnection conn = peers.remove(i);                        conn.closeSocket();                        fds.remove(i);                    } else {                        // We&apos;re in the child so any exception caught here has happened post                        // fork and before we execute ActivityThread.main (or any other main()                        // method). Log the details of the exception and bring down the process.                        Log.e(TAG, &quot;Caught post-fork exception in child process.&quot;, e);                        throw e;                    }                } finally {                    // Reset the child flag, in the event that the child process is a child-                    // zygote. The flag will not be consulted this loop pass after the Runnable                    // is returned.                    mIsForkChild = false;                }            }        }    }}</code></pre><p>首先，在注释1处，会调用服务端的mServerSocket的getFileDescriptor()函数来去获得自身的fd字段值并加入fds列表中。然后，在注释2处，无限循环用来等待AMS请求Zygote进程创建新的应用程序进程。在注释3处会遍历pollFds这个fd列表，如果i等于0，则说明服务端Socket与客户端连接上了，即当前Zygote进程与AMS进程建立了连接。接着，在注释4处调用acceptCommandPeer()方法得到ZygoteConnection对象，并将其加入peers列表中。如果i不等于0，则表明AMS想Zygote进程发送了一个创建应用程序进程的请求，最后会在注释5处执行ZygoteConnection.runOnce方法去创建一个新的应用程序进程。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>从以上的分析可以得知，Zygote进程启动中承担的主要职责如下：</p><ul><li>1、创建AppRuntime，执行其start方法，启动Zygote进程。。</li><li>2、创建JVM并为JVM注册JNI方法。</li><li>3、使用JNI调用ZygoteInit的main函数进入Zygote的Java FrameWork层。</li><li>4、使用registerZygoteSocket方法创建服务器端Socket，并通过runSelectLoop方法等等AMS的请求去创建新的应用进程。</li><li>5、启动SystemServer进程。</li></ul><p>至此，Android系统启动流程之Zygote进程启动部分分析完毕，下一篇将会详细分析SystemServer进程启动相关的部分，敬请期待！</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android V9.0.0 源码</p><p>2、Android进阶解密第二章</p><p>3、<a href="http://gityuan.com/android/" target="_blank" rel="external">Android系统开篇</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/02/24/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BZygote%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android系统启动流程之init进程启动</title>
      <link>http://yoursite.com/2019/02/18/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8Binit%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</link>
      <guid>http://yoursite.com/2019/02/18/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8Binit%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/</guid>
      <pubDate>Sun, 17 Feb 2019 17:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>众所周知，Android核心源码这一块的知识一直是阻碍广大Android开发者成为高级甚至资深Android的拦路虎，因此，从这篇开始，笔者接下来将会陪大家深入分析Android中的核心源码，从而能够让我们真正地去理解Android源码背后的设计思想与艺术，真真切切地提升自己的内功。目前，这一系列的分析顺序如下：</p><h5 id="1、Android系统启动流程"><a href="#1、Android系统启动流程" class="headerlink" title="1、Android系统启动流程"></a>1、Android系统启动流程</h5><p>共分为四篇，分别为：</p><ul><li>Android系统启动流程之init进程启动</li><li>Android系统启动流程之Zygote进程启动</li><li>Android系统启动流之SystemServer进程启动</li><li>Android系统启动流程之Launcher进程启动</li></ul><h5 id="2、Binder"><a href="#2、Binder" class="headerlink" title="2、Binder"></a>2、Binder</h5><p>共分为两篇，分别为：</p><ul><li>初探Binder</li><li>深入Binder</li></ul><h5 id="3、App启动流程"><a href="#3、App启动流程" class="headerlink" title="3、App启动流程"></a>3、App启动流程</h5><p>一文全面了解App启动流程</p><h5 id="4、四大组件工作原理"><a href="#4、四大组件工作原理" class="headerlink" title="4、四大组件工作原理"></a>4、四大组件工作原理</h5><p>共分为四篇，分别为：</p><ul><li>Activity启动流程</li><li>Service启动和绑定流程</li><li>BroadcastReceiver工作流程</li><li>Content Provider启动过程</li></ul><h5 id="5、AMS"><a href="#5、AMS" class="headerlink" title="5、AMS"></a>5、AMS</h5><p>暂定为三篇，分别为：</p><ul><li>拆解ActivityManagerService（上）</li><li>拆解ActivityManagerService（中）</li><li>拆解ActivityManagerService（下）</li></ul><h5 id="6、WMS"><a href="#6、WMS" class="headerlink" title="6、WMS"></a>6、WMS</h5><p>暂定为四篇，分别为：</p><ul><li>拆解WindowManager</li><li>拆解WindowManagerService（上）</li><li>拆解WindowManagerService（中）</li><li>拆解WindowManagerService（下）</li></ul><h5 id="7、PMS"><a href="#7、PMS" class="headerlink" title="7、PMS"></a>7、PMS</h5><p>暂定为两篇，分别为：</p><ul><li>拆解PackageManagerService（上）</li><li>拆解PackageManagerService（下）</li></ul><p>接下来，笔者将会为大家介绍Android系统启动流程的相关知识，但是由于篇幅太长，这里便打算分为四部分来进行讲解。这一篇，我将首先对其中最重要的init进程启动过程进行分析。这里，先给出一幅Gityuan博客中的一幅系统启动架构图来对Android系统的启动流程有一个宏观的把控。</p><p><img src="http://gityuan.com/images/android-process/android-boot.jpg" alt="image"></p><p>下面，我们正式开始进行分析~</p><h2 id="一、启动电源以及系统启动"><a href="#一、启动电源以及系统启动" class="headerlink" title="一、启动电源以及系统启动"></a>一、启动电源以及系统启动</h2><p>当电源按下时引导芯片代码会从预定义的地方（固化在ROM）开始执行，加载引导程序BootLoader到RAM，然后执行。</p><h2 id="二、引导程序BootLoader"><a href="#二、引导程序BootLoader" class="headerlink" title="二、引导程序BootLoader"></a>二、引导程序BootLoader</h2><p>它是Android操作系统开始运行前的一个小程序，主要将操作系统OS拉起来并进行。</p><h2 id="三、Linux内核启动"><a href="#三、Linux内核启动" class="headerlink" title="三、Linux内核启动"></a>三、Linux内核启动</h2><p>当内核启动时，设置缓存、被保护存储器、计划列表、加载驱动。此外，还启动了Kernel的swapper进程（pid = 0）和kthreadd进程（pid = 2）。下面分别介绍下它们：</p><ul><li>swapper进程：又称为idle进程，系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载Binder Driver、Display、Camera Driver等相关工作。</li><li>kthreadd进程：Linux系统的内核进程，是所有内核进程的鼻祖，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。</li></ul><p>当内核完成系统设置时，它首先在系统文件中寻找init.rc文件，并启动init进程。</p><h2 id="四、init进程启动"><a href="#四、init进程启动" class="headerlink" title="四、init进程启动"></a>四、init进程启动</h2><p>init进程主要用来初始化和启动属性服务，并且启动Zygote进程。</p><h3 id="1、init进程是什么？"><a href="#1、init进程是什么？" class="headerlink" title="1、init进程是什么？"></a>1、init进程是什么？</h3><p>Linux系统的用户进程，是所有用户进程的鼻祖，进程号为1，它有许多重要的职责，比如创建Zygote孵化器和属性服务等。并且它是由多个源文件组成的，对应源码目录system/core/init中。</p><h3 id="2、init进程启动核心代码流程分析"><a href="#2、init进程启动核心代码流程分析" class="headerlink" title="2、init进程启动核心代码流程分析"></a>2、init进程启动核心代码流程分析</h3><p>init进程的启动会首先从init进程的入口函数开始，init进程的入口函数main位于system/core/init/init.cpp中，代码如下所示：</p><pre><code>int main(int argc, char** argv) {    ...    // 如果是初始化第一阶段，则需要执行下面的步骤1    if (is_first_stage) {        ...        // 清理umask        umask(0);        ...        // 1、创建和挂载启动所需的文件目录        mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;);        mkdir(&quot;/dev/pts&quot;, 0755);        mkdir(&quot;/dev/socket&quot;, 0755);        mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL);        #define MAKE_STR(x) __STRING(x)        mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, &quot;hidepid=2,gid=&quot; MAKE_STR(AID_READPROC));        ...        // 初识化Kernel的Log，获取外界的Kernel日志        InitKernelLogging(argv);        ...    }    // 初识化Kernel的Log，获取外界的Kernel日志    InitKernelLogging(argv);    ...    // 2、初始化属性相关资源    property_init();    ...    // 创建epoll句柄    epoll_fd = epoll_createl(EPOLL_CLOEXEC);    ...    // 3、设置子信号处理函数    sigchld_handler_init();    // 导入默认的环境变量    property_load_boot_defaults();    // 4、启动属性服务    start_property_service();    set_usb_controller();    ...    // 加载引导脚本    LoadBootScripts(am, sm);    ...       while (true) {        ...        if (!(waiting_for_prop || Service::is_exec_service_running())) {            // 内部会偏离执行每个action中携带的command对应的执行函数            am.ExecuteOneCommand();        }        if (!(waiting_for_prop || Service::is_exec_service_running())) {            if (!shutting_down) {                // 重启死去的子进程                auto next_process_restart_time = RestartProcesses();                ...            }            // If there&apos;s more work to do, wake up again immediately.            if (am.HasMoreCommands()) epoll_timeout_ms = 0;        }        epoll_event ev;        int nr = TEMP_FAILURE_RETRY(epoll_wait(epoll_fd, &amp;ev, 1, epoll_timeout_ms));        if (nr == -1) {            PLOG(ERROR) &lt;&lt; &quot;epoll_wait failed&quot;;        } else if (nr == 1) {            ((void (*)()) ev.data.ptr)();        }    }    return 0;}static void LoadBootScripts(ActionManager&amp;action_manager, ServiceList&amp; service_list) {    Parser parser = CreateParser(action_manager, service_list);    std::string bootscript = GetProperty(&quot;ro.boot.init_rc&quot;, &quot;&quot;);    // bootscript默认是空的    if (bootscript.empty()) {        // 5、解析init.rc配置文件        parser.ParseConfig(&quot;/init.rc&quot;);        if (!parser.ParseConfig(&quot;/system/etc/init&quot;)) {            late_import_paths.emplace_back(&quot;/system/etc/init&quot;);        }        if (!parser.ParseConfig(&quot;/product/etc/init&quot;)) {            late_import_paths.emplace_back(&quot;/product/etc/init&quot;);        }        if (!parser.ParseConfig(&quot;/odm/etc/init&quot;)) {            late_import_paths.emplace_back(&quot;/odm/etc/init&quot;);        }        if (!parser.ParseConfig(&quot;/vendor/etc/init&quot;)) {            late_import_paths.emplace_back(&quot;/vendor/etc/init&quot;);        }    } else {        parser.ParseConfig(bootscript);    }}</code></pre><h4 id="1、创建和挂载启动所需的文件目录"><a href="#1、创建和挂载启动所需的文件目录" class="headerlink" title="1、创建和挂载启动所需的文件目录"></a>1、创建和挂载启动所需的文件目录</h4><p>其中挂载了tmpsf、devpts、proc、sysfs和selinuxfs共5种文件系统（它们均是系统运行时目录）：</p><pre><code>mount(...);mkdir(...);...</code></pre><h4 id="2、对属性服务进行初始化"><a href="#2、对属性服务进行初始化" class="headerlink" title="2、对属性服务进行初始化"></a>2、对属性服务进行初始化</h4><pre><code>property_init();</code></pre><h5 id="什么是属性服务？"><a href="#什么是属性服务？" class="headerlink" title="什么是属性服务？"></a>什么是属性服务？</h5><p>Windows平台上有一个注册表管理器，注册表的内容采用键值对的形式来记录用户、软件等使用信息。如果系统或软件重启，还是能够根据这份注册表中的记录，进行相应的初识化工作。Android也提供了一个这样类型的机制，即属性服务。</p><h5 id="它具体是如何进行初始化的？"><a href="#它具体是如何进行初始化的？" class="headerlink" title="它具体是如何进行初始化的？"></a>它具体是如何进行初始化的？</h5><p>我们查看system/core/init/property_service.cpp源码中的property_init()函数：</p><pre><code>void property_init() {    mkdir(&quot;/dev/__properties__&quot;, S_IRWXU | S_IXGRP S_IXOTH);    CreateSerializedPropertyInfo();    // 关注点    if (__system_property_area_init()) {        LOG(FATAL) &lt;&lt; &quot;Failed to initialize property area&quot;;    }    if (!property_info_area.LoadDefaultPath()) {        LOG(FATAL) &lt;&lt; &quot;Failed to load serialized property info file&quot;;    }}</code></pre><p>init进程启动时会启动属性服务，并为其分配内存，用来存储这些属性，如果需要就可以直接读取，具体在代码里就是执行了property_init()函数中的__system_property_area_init()函数去初始化属性内存区域。</p><h4 id="3、设置子进程信号处理函数，如果子进程（zygote进程）异常退出，init进程会调用该函数中设定的信号处理函数来进行处理"><a href="#3、设置子进程信号处理函数，如果子进程（zygote进程）异常退出，init进程会调用该函数中设定的信号处理函数来进行处理" class="headerlink" title="3、设置子进程信号处理函数，如果子进程（zygote进程）异常退出，init进程会调用该函数中设定的信号处理函数来进行处理"></a>3、设置子进程信号处理函数，如果子进程（zygote进程）异常退出，init进程会调用该函数中设定的信号处理函数来进行处理</h4><pre><code>sigchld_handler_init();</code></pre><h5 id="sigchld-handler-init-的作用："><a href="#sigchld-handler-init-的作用：" class="headerlink" title="sigchld_handler_init()的作用："></a>sigchld_handler_init()的作用：</h5><p>防止init进程的子进程成为僵尸进程，为了防止僵尸进程的出现，系统会在子进程暂停和终止的时候发出SIGCJHLD信号，该函数就是用来接收SIGCHLD信号的，注意它仅处理进程终止的SIGCHLD信号。</p><h5 id="僵尸进程是什么？"><a href="#僵尸进程是什么？" class="headerlink" title="僵尸进程是什么？"></a>僵尸进程是什么？</h5><p>在UNIX/Linux中，父进程使用fork创建子进程，子进程终止后，如果父进程不知道子进程已经终止的话，这时子进程虽然已经退出，但是在系统进程表中还为它保留了一些信息（如进程号、运行时间、退出状态等），这个子进程就是所谓的僵尸进程。其中系统进程表是一项有限的资源，如果它被僵尸进程耗尽的话，系统可能会无法创建新的进程。</p><h5 id="如果是Zygote进程终止了，则会如何？"><a href="#如果是Zygote进程终止了，则会如何？" class="headerlink" title="如果是Zygote进程终止了，则会如何？"></a>如果是Zygote进程终止了，则会如何？</h5><p>sigchld_handler_init()函数内部会找到Zygote进程并移除所有的Zygote进程的信息，在重启Zygote服务的启动脚本（如init.zygote64.rc）中带有onrestart选项的服务。</p><h4 id="4、启动属性服务（其中会启动servicemanager-binder服务大管家-、bootanim-开机动画-等重要服务）"><a href="#4、启动属性服务（其中会启动servicemanager-binder服务大管家-、bootanim-开机动画-等重要服务）" class="headerlink" title="4、启动属性服务（其中会启动servicemanager(binder服务大管家)、bootanim(开机动画)等重要服务）"></a>4、启动属性服务（其中会启动servicemanager(binder服务大管家)、bootanim(开机动画)等重要服务）</h4><pre><code>start_property_service();</code></pre><h5 id="属性服务是如何启动的？"><a href="#属性服务是如何启动的？" class="headerlink" title="属性服务是如何启动的？"></a>属性服务是如何启动的？</h5><p>我们查看system/core/init/property_service.cpp源码中的start_property_service()函数：</p><pre><code>void start_property_service() {    selinux_callback cb;    cb.func_audit = SelinuxAuditCallback;    selinux_set_callback(SELINUX_CB_AUDIT, cb);    property_set(&quot;ro.property_service.version&quot;, &quot;2&quot;);    // 1    property_set_fd = CreateSocket(PROP_SERVICE_NAME, SOCK_STREAM | SOCK_CLOEXEC | SOCK_NONBLOCK,                                   false, 0666, 0, 0,  nullptr);    if (property_set_fd == -1) {        PLOG(FATAL) &lt;&lt; &quot;start_property_service socket creation failed&quot;;    }    // 2    listen(property_set_fd, 8);    // 3、4、5    register_epoll_handler(property_set_fd, handle_property_set_fd);}</code></pre><ul><li>1、首先，创建非阻塞式的Socket，并返回property_set_fd文件描述符。</li><li>2、使用listen()函数去监听property_set_fd，此时Socket即成为属性服务端，并且它最多同时可为8个试图设置属性的用户提供服务。</li><li>3、使用epoll()来监听property_set_fd：当property_set_fd中有数据到来时，init进程将调用handle_property_set_fd()函数进行处理。在Andorid 8.0的源码中则在handle_property_set_fd()函数中添加了handle_property_set函数做进一步封装处理。</li><li>4、系统属性分为两种属性，即普通属性和控制属性。控制属性用来执行一些命令，比如开机的动画就使用了这种属性。在handle_property_set_fd()函数中会先判断如果属性名是以”ctl.”开头的，就说明是控制属性，如果客户端权限满足，则会调用handle_control_message()函数来修改控制属性。如果是普通属性，则会在客户端全面满足的条件下调用property_set函数来修改普通属性。</li><li>5、在property_set中会先从属性存储空间中查找该属性，如果有，则更新，否则添加该属性。此外，如果名称是以”ro”开头（表示只读，不能修改），直接返回，如果名称是以”persist.”开头，则写入持久化属性。</li></ul><h5 id="epoll是什么？"><a href="#epoll是什么？" class="headerlink" title="epoll是什么？"></a>epoll是什么？</h5><p>在Linux的新内核中，epoll是用来取代select/poll的，它是Linux内核为处理大批量文件描述符的改进版poll，是Linux下多路复用I/O接口select/poll的增强版，它能显著提升程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p><h5 id="epoll和select的区别？"><a href="#epoll和select的区别？" class="headerlink" title="epoll和select的区别？"></a>epoll和select的区别？</h5><p>epoll内部用于保存事件的数据类型是红黑树，查找速度快，select采用的数组保存信息，查找速度很慢，只有当等待少量文件描述符时，epoll和select的效率才差不多。</p><h4 id="5、解析init-rc配置文件"><a href="#5、解析init-rc配置文件" class="headerlink" title="5、解析init.rc配置文件"></a>5、解析init.rc配置文件</h4><pre><code>parser.ParseConfig(&quot;/init.rc&quot;);</code></pre><h5 id="init-rc是什么？"><a href="#init-rc是什么？" class="headerlink" title="init.rc是什么？"></a>init.rc是什么？</h5><p>它是由Android初始化语言编写的一个非常重要的配置脚本文件。Android初始化语言主要包含5种类型的语句：</p><ul><li>Action（常用）</li><li>Service（常用）</li><li>Command</li><li>Option</li><li>Import</li></ul><p>这里了解下Action和Service的格式：</p><pre><code>on &lt;trigger&gt; [&amp;&amp; &lt;trigger&gt;]*     //设置触发器      &lt;command&gt;      &lt;command&gt;      //动作触发之后要执行的命令    ...service &lt;name&gt; &lt;pathname&gt; [ &lt;argument&gt; ]*   //&lt;service的名字&gt;&lt;执行程序路径&gt;&lt;传递参数&gt;      &lt;option&gt;       //option是service的修饰词，影响什么时候、如何启动services      &lt;option&gt;      ...</code></pre><p>注意：Android8.0对init.rc文件进行了拆分，每个服务对应一个rc文件。</p><h5 id="init-rc中的Action、Service语句都有相应的XXXParser类来解析，即ActionParser、ServiceParser。那么ServiceParser是如何解析Service语句的？"><a href="#init-rc中的Action、Service语句都有相应的XXXParser类来解析，即ActionParser、ServiceParser。那么ServiceParser是如何解析Service语句的？" class="headerlink" title="init.rc中的Action、Service语句都有相应的XXXParser类来解析，即ActionParser、ServiceParser。那么ServiceParser是如何解析Service语句的？"></a>init.rc中的Action、Service语句都有相应的XXXParser类来解析，即ActionParser、ServiceParser。那么ServiceParser是如何解析Service语句的？</h5><p>查看相应的XXXparser，即ServiceParser：</p><pre><code>bool ServiceParser::ParseSection(const std::vector&lt;std::string&gt;&amp; args,                                 std::string* err) {    // 判断Service是否有name和可执行程序                                 if (args.size() &lt; 3) {        *err = &quot;services must have a name and a     program&quot;;        return false;    }    const std::string&amp; name = args[1];    if (!IsValidName(name)) {        *err = StringPrintf(&quot;invalid service name     &apos;%s&apos;&quot;, name.c_str());        return false;    }    std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end());    // 1    service_ = std::make_unique&lt;Service&gt;(name, str_args);    return true;}bool ServiceParser::ParseLineSection(const std::vector&lt;std::string&gt;&amp; args,                                     const std::string&amp;  filename, int line,                                     std::string* err)  const {    // 2                                     return service_ ? service_-&gt;ParseLine(args, err) : false;}void ServiceParser::EndSection() {    if (service_) {        // 3        ServiceManager::GetInstance().AddService(std::move(service_));    }}void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) {    Service* old_service = FindServiceByName(service-&gt;name());    if (old_service) {        ERROR(&quot;ignored duplicate definition of service &apos;%s&apos;&quot;,            service-&gt;name().c_str());        return;    }    services_.emplace_back(std::move(service));//1}</code></pre><ul><li>1、先使用ParseSection()方法根据参数创建出一个Service对象。</li><li>2、再使用ParseLineSection()方法解析Service语句中的每一个子项，将其中的内容添加到Service对象中。</li><li>3、然后，在解析完所有数据后，会调用EndSection函数，内部会执行ServiceManager的AddService函数，最终将Service对象加入vector类型的Service链表中。</li></ul><h5 id="init启动Zygote流程？"><a href="#init启动Zygote流程？" class="headerlink" title="init启动Zygote流程？"></a>init启动Zygote流程？</h5><p>先看到init.rc的这部分配置代码：</p><pre><code>...on nonencrypted        exec - root -- /system/bin/update_verifier nonencrypted      // 1    class_start main             class_start late_start ...</code></pre><p>1、使用class_start这个COMMAND去启动Zygote。其中class_start对应do_class_start()函数。</p><pre><code>static Result&lt;Success&gt; do_class_start(const BuiltinArguments&amp; args) {    // Starting a class does not start services which are explicitly disabled.    // They must be started individually.    for (const auto&amp; service : ServiceList::GetInstance()) {        if (service-&gt;classnames().count(args[1])) {            // 2            if (auto result = service-&gt;StartIfNotDisabled(); !result) {                LOG(ERROR) &lt;&lt; &quot;Could not start service&apos;&quot; &lt;&lt; service-&gt;name()                           &lt;&lt; &quot;&apos; as part of class &apos;&quot; &lt;&lt;  args[1] &lt;&lt; &quot;&apos;: &quot; &lt;&lt;  result.error();            }        }    }    return Success();}</code></pre><p>2、在system/core/init/builtins.cpp的do_class_start()函数中会遍历前面的Vector类型的Service链表，找到classname为main的Zygote，并调用system/core/init/service.cpp中的startIfNotDisabled()函数。</p><pre><code>bool Service::StartIfNotDisabled() {    if (!(flags_ &amp; SVC_DISABLED)) {        return Start();    } else {        flags_ |= SVC_DISABLED_START;    }    return Success();}</code></pre><p>3、如果Service没有再其对应的rc文件中设置disabled选项，则会调用Start()启动该Service。</p><pre><code>bool Service::Start() {    ...    if (flags_ &amp; SVC_RUNNING) {        if ((flags_ &amp; SVC_ONESHOT) &amp;&amp; disabled) {            flags_ |= SVC_RESTART;        }        // 如果不是一个错误，尝试去启动一个已经启动的服务        return Success();    }    ...    // 判断需要启动的Service的对应的执行文件是否存在，不存在则不启动该Service    struct stat sb;    if (stat(args_[0].c_str(), &amp;sb) == -1) {        flags_ |= SVC_DISABLED;        return ErrnoError() &lt;&lt; &quot;Cannot find &apos;&quot; &lt;&lt; args_[0] &lt;&lt; &quot;&apos;&quot;;    }    ...    // fork函数创建子进程    pid_t pid = fork();    // 运行在子进程中    if (pid == 0) {        umask(077);        ...        // 在ExpandArgsAndExecv函数里进行了参数装配并使用了execve()执行程序        if (!ExpandArgsAndExecv(args_)) {            PLOG(ERROR) &lt;&lt; &quot;cannot execve(&apos;&quot; &lt;&lt; args_[0] &lt;&lt; &quot;&apos;)&quot;;        }         _exit(127);    }    ...    return true;}static bool ExpandArgsAndExecv(cons std::vector&lt;std::string&gt;&amp; args) {    std::vector&lt;std::string&gt; expanded_args;    std::vector&lt;char*&gt; c_strings;    expanded_args.resize(args.size());    c_strings.push_back(const_cast&lt;char*&gt;(args[0].data()));    for (std::size_t i = 1; i &lt; args.size(); ++i) {        if (!expand_props(args[i], &amp;expanded_args[i])) {            LOG(FATAL) &lt;&lt; args[0] &lt;&lt; &quot;: cannot expand &apos;&quot; &lt;&lt; args[i] &lt;&lt; &quot;&apos;&quot;;        }        c_strings.push_back(expanded_args[i].data());    }    c_strings.push_back(nullptr);    // 最终通过execve执行程序    return execv(c_strings[0], c_strings.data()) == 0;}</code></pre><p>4、在Start()函数中，如果Service已经运行，则不再启动。如果没有，则使用fork()函数创建子进程，并返回pid值。当pid为0时，则说明当前代码逻辑在子进程中运行，最然后会调用execve()函数去启动子进程，并进入该Service的main函数中，如果该Service是Zygote，则会执行Zygote的main函数。（对应frameworks/base/cmds/app_process/app_main.cpp中的main()函数）</p><pre><code>int main(int argc, char* const argv[]){    ...    if (zygote) {        runtime.start(&quot;com.android.internal.os.ZygoteInit&quot;, args, zygote);    } else if (className) {        runtime.start(&quot;com.android.internal.os.RuntimeInit&quot;, args, zygote);    } else {        fprintf(stderr, &quot;Error: no class name or --zygote supplied.\n&quot;);        app_usage();        LOG_ALWAYS_FATAL(&quot;app_process: no class name or --zygote supplied.&quot;);    }}</code></pre><p>5、最后，调用runtime的start函数启动Zygote。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>经过以上的分析，init进程的启动过程主要分为以下三部：</p><ul><li>1、创建和挂载启动所需的文件目录。</li><li>2、初始化和启动属性服务。</li><li>3、解析init.rc配置文件并启动Zygote进程。</li></ul><p>下篇，将会继续为大家讲解Android系统启动流程中的Zygote进程和SystemService启动过程，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android V9.0.0 源码</p><p>2、Android进阶解密第二章</p><p>3、<a href="http://gityuan.com/android/" target="_blank" rel="external">Android系统开篇</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/02/18/Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8Binit%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（九、深入探索EventBus源码）</title>
      <link>http://yoursite.com/2019/01/28/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%E3%80%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2EventBus%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/28/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%E3%80%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2EventBus%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 27 Jan 2019 16:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>不知不觉，Android主流三方库源码分析系列已经来到最后关头了。这一次，笔者将会对Android中的事件总线框架EventBus源码进行详细地解析，一起来和大家揭开它背后的面纱。</p><h3 id="一、简单示例"><a href="#一、简单示例" class="headerlink" title="一、简单示例"></a>一、简单示例</h3><h4 id="1、首先，定义要传递的事件实体"><a href="#1、首先，定义要传递的事件实体" class="headerlink" title="1、首先，定义要传递的事件实体"></a>1、首先，定义要传递的事件实体</h4><pre><code>public class CollectEvent { ... }</code></pre><h4 id="2、准备订阅者：声明并注解你的订阅方法"><a href="#2、准备订阅者：声明并注解你的订阅方法" class="headerlink" title="2、准备订阅者：声明并注解你的订阅方法"></a>2、准备订阅者：声明并注解你的订阅方法</h4><pre><code>@Subscribe(threadMode = ThreadMode.MAIN)public void onMessageEvent(CollectEvent event) {    LogHelper.d(&quot;OK&quot;);}</code></pre><h4 id="3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"><a href="#3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者" class="headerlink" title="3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"></a>3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者</h4><pre><code>@Overridepublic void onStart() {    super.onStart();    EventBus.getDefault().register(this);}@Overridepublic void onStop() {    super.onStop();    EventBus.getDefault().unregister(this);}</code></pre><h4 id="4、发送事件"><a href="#4、发送事件" class="headerlink" title="4、发送事件"></a>4、发送事件</h4><pre><code>EventBus.getDefault().post(new CollectEvent());</code></pre><p>在正式讲解之前，笔者觉得需要对一些基础性的概念进行详细的讲解。众所周知，EventBus没出现之前，那时候的开发者一般是使用Android四大组件中的广播进行组件间的消息传递，那么我们<strong>为什么要使用事件总线机制来替代广播</strong>呢？主要是因为：</p><ul><li>广播：耗时、容易被捕获（不安全）。</li><li>事件总线：更节省资源、更高效，能将信息传递给原生以外的各种对象。</li></ul><p>那么，话又说回来了，<strong>事件总线又是什么呢？</strong></p><p>如下图所示，事件总线机制通过记录对象、使用观察者模式来通知对象各种事件。（当然，你也可以发送基本数据类型如 int，String 等作为一个事件）</p><p><img src="https://upload-images.jianshu.io/upload_images/2276275-c20610cdd44f4c5f.png?imageMogr2/auto-orient/" alt="image"></p><p>对于<strong>事件总线EventBus</strong>而言，它的<strong>优缺点</strong>又是如何？这里简单总结下：</p><ul><li>优点：开销小，代码更优雅、简洁，解耦发送者和接收者，可动态设置事件处理线程和优先级。</li><li>缺点：每个事件必须自定义一个事件类，增加了维护成本。</li></ul><p>EventBus是基于观察者模式扩展而来的，我们先了解一下观察者模式是什么？</p><p>观察者模式又可称为<strong>发布 - 订阅模式</strong>，它定义了对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。</p><p>观察者模式有以下角色：</p><ul><li>抽象被观察者：将所有已注册的观察者对象保存在一个集合中。</li><li>具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。</li><li>抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。</li><li>具体被观察者：实现抽象观察者的更新接口。</li></ul><p>这里笔者给出一个简单的示例来让大家更深一步理解观察者模式的思想：</p><p>1、首先，创建抽象观察者</p><pre><code>public interface observer {    public void update(String message);}</code></pre><p>2、接着，创建具体观察者</p><pre><code>public class WeXinUser implements observer {    private String name;    public WeXinUser(String name) {        this.name = name;    }    @Override    public void update(String message) {        ...    }}</code></pre><p>3、然后，创建抽象被观察者</p><pre><code>public interface observable {    public void addWeXinUser(WeXinUser weXinUser);    public void removeWeXinUser(WeXinUser weXinUser);    public void notify(String message);}</code></pre><p>4、最后，创建具体被观察者</p><pre><code>public class Subscription implements observable {    private List&lt;WeXinUser&gt; mUserList = new ArrayList();    @Override    public void addWeXinUser(WeXinUser weXinUser) {        mUserList.add(weXinUser);    }    @Override    public void removeWeXinUser(WeXinUser weXinUser) {        mUserList.remove(weXinUser);    }    @Override    public void notify(String message) {        for(WeXinUser weXinUser : mUserList) {            weXinUser.update(message);        }    }}</code></pre><p>在具体使用时，我们便可以这样使用，如下所示：</p><pre><code>Subscription subscription = new Subscription();WeXinUser hongYang = new WeXinUser(&quot;HongYang&quot;);WeXinUser rengYuGang = new WeXinUser(&quot;RengYuGang&quot;);WeXinUser liuWangShu = new WeXinUser(&quot;LiuWangShu&quot;);subscription.addWeiXinUser(hongYang);subscription.addWeiXinUser(rengYuGang);subscription.addWeiXinUser(liuWangShu);subscription.notify(&quot;New article coming&quot;);</code></pre><p>在这里，hongYang、rengYuGang、liuWangShu等大神都订阅了我的微信公众号，每当我的公众号发表文章时（subscription.notify())，他们就会接收到最新的文章信息（weXinUser.update()）。（ps：当然，这一切都是YY，事实是，我并没有微信公众号-0v0-）</p><p>当然，EventBus的观察者模式和一般的观察者模式不同，它使用了扩展的观察者模式对事件进行订阅和分发，其实这里的扩展就是指的使用了EventBus来作为中介者，抽离了许多职责，如下是它的官方原理图：</p><p><img src="https://raw.githubusercontent.com/greenrobot/EventBus/master/EventBus-Publish-Subscribe.png" alt="image"></p><p>在得知了EventBus的原理之后，我们注意到，每次我们在register之后，都必须进行一次unregister，这是为什么呢？</p><ul><li>因为register是强引用，它会让对象无法得到内存回收，导致内存泄露。所以必须在unregister方法中释放对象所占的内存。</li></ul><p>有些同学可能之前使用的是EventBus2.x的版本，那么它又与EventBus3.x的版本有哪些区别呢？</p><ul><li>1、EventBus2.x使用的是运行时注解，它采用了反射的方式对整个注册的类的所有方法进行扫描来完成注册，因而会对性能有一定影响。</li><li>2、EventBus3.x使用的是编译时注解，Java文件会编译成.class文件，再对class文件进行打包等一系列处理。在编译成.class文件时，EventBus会使用EventBusAnnotationProcessor注解处理器读取@Subscribe()注解并解析、处理其中的信息，然后生成Java类来保存所有订阅者的订阅信息。这样就创建出了对文件或类的索引关系，并将其编入到apk中。</li><li>3、从EventBus3.0开始使用了对象池缓存减少了创建对象的开销。</li></ul><p>除了EventBus，其实现在比较流行的事件总线还有RxBus，那么，它与EventBus相比又如何呢？</p><ul><li>1、RxJava的Observable有onError、onComplete等状态回调。</li><li>2、Rxjava使用组合而非嵌套的方式，避免了回调地狱。</li><li>3、Rxjava的线程调度设计的更加优秀，更简单易用。</li><li>4、Rxjava可使用多种操作符来进行链式调用来实现复杂的逻辑。</li><li>5、Rxjava的信息效率高于EventBus2.x，低于EventBus3.x。</li></ul><p>在了解了EventBus和RxBus的区别之后，那么，对待新项目的事件总线选型时，我们该如何考量？</p><p>很简单，如果项目中使用了RxJava，则使用RxBus，否则使用EventBus3.x。</p><p>接下来将按以下顺序来进行EventBus的源码分析：</p><ul><li>1、订阅者：EventBus.getDefault().register(this)；</li><li>2、发布者：EventBus.getDefault().post(new CollectEvent())；</li><li>3、订阅者：EventBus.getDefault().unregister(this)。</li></ul><p>下面，我们正式开始~</p><h3 id="二、EventBus-getDefault-register-this"><a href="#二、EventBus-getDefault-register-this" class="headerlink" title="二、EventBus.getDefault().register(this)"></a>二、EventBus.getDefault().register(this)</h3><p>首先，我们从获取EventBus实例的方法getDefault()开始分析：</p><pre><code>public static EventBus getDefault() {    if (defaultInstance == null) {        synchronized (EventBus.class) {            if (defaultInstance == null) {                defaultInstance = new EventBus();            }        }    }    return defaultInstance;}</code></pre><p>在getDefault()中使用了双重校验并加锁的单例模式来创建EventBus实例。</p><p>接着，我们看到EventBus的默认构造方法中做了什么:</p><pre><code>private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();public EventBus() {    this(DEFAULT_BUILDER);}</code></pre><p>在EventBus的默认构造方法中又调用了它的另一个有参构造方法，将一个类型为EventBusBuilder的DEFAULT_BUILDER对象传递进去了。这里的EventBusBuilder很明显是一个EventBus的建造器，以便于EventBus能够添加自定义的参数和安装一个自定义的默认EventBus实例。</p><p>我们在看一下EventBusBuilder的构造方法：</p><pre><code>public class EventBusBuilder {    ...    EventBusBuilder() {    }    ...}</code></pre><p>EventBusBuilder的构造方法中什么也没有做，那我么继续查看EventBus的这个有参构造方法：</p><pre><code>private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;EventBus(EventBusBuilder builder) {    ...    // 1    subscriptionsByEventType = new HashMap&lt;&gt;();    // 2    typesBySubscriber = new HashMap&lt;&gt;();    // 3    stickyEvents = new ConcurrentHashMap&lt;&gt;();    // 4    mainThreadSupport = builder.getMainThreadSupport();    mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;    backgroundPoster = new BackgroundPoster(this);    asyncPoster = new AsyncPoster(this);    ...    // 5    subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,            builder.strictMethodVerification, builder.ignoreGeneratedIndex);    // 从builder取中一些列订阅相关信息进行赋值    ...    // 6    executorService = builder.executorService;}</code></pre><p>在注释1处，创建了一个subscriptionsByEventType对象，可以看到它是一个类型为HashMap的subscriptionsByEventType对象，并且其key为 Event 类型，value为 Subscription链表。这里的Subscription是一个订阅信息对象，它里面保存了两个重要的字段，一个是类型为 Object 的 subscriber，该字段即为注册的对象（在 Android 中时通常是 Activity对象）；另一个是 类型为SubscriberMethod 的 subscriberMethod，它就是被@Subscribe注解的那个订阅方法，里面保存了一个重要的字段eventType，它是 Class&lt;?&gt; 类型的，代表了 Event 的类型。在注释2处，新建了一个类型为 Map 的typesBySubscriber对象，它的key为subscriber对象，value为subscriber对象中所有的 Event 类型链表，日常使用中仅用于判断某个对象是否注册过。在注释3处新建了一个类型为ConcurrentHashMap的stickyEvents对象，它是专用于粘性事件处理的一个字段，key为事件的Class对象，value为当前的事件。可能有的同学不了解sticky event，这里解释下：</p><ul><li>我们都知道普通事件是先注册，然后发送事件才能收到；而粘性事件，在发送事件之后再订阅该事件也能收到。并且，粘性事件会保存在内存中，每次进入都会去内存中查找获取最新的粘性事件，除非你手动解除注册。</li></ul><p>在注释4处，新建了三个不同类型的事件发送器，这里总结下：</p><ul><li>mainThreadPoster：主线程事件发送器，通过它的mainThreadPoster.enqueue(subscription, event)方法可以将订阅信息和对应的事件进行入队，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。</li><li>backgroundPoster：后台事件发送器，通过它的enqueue() 将方法加入到后台的一个队列，最后通过线程池去执行，注意，它在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。</li><li>asyncPoster：实现逻辑类似于backgroundPoster，不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，asyncPoster则是异步运行的，可以同时接收多个任务。</li></ul><p>我们在回到注释5这行代码，这里新建了一个subscriberMethodFinder对象，这是从EventBus中抽离出的订阅方法查询的一个对象，在优秀的源码中，我们经常能看到组合优于继承的这种实现思想。在注释6处，从builder中取出了一个默认的线程池对象，它由Executors的newCachedThreadPool()方法创建，它是一个有则用、无则创建、无数量上限的线程池。</p><p>分析完这些核心的字段之后，后面的讲解就比较轻松了，接着我们查看EventBus的regist()方法：</p><pre><code>public void register(Object subscriber) {    Class&lt;?&gt; subscriberClass = subscriber.getClass();    // 1    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);    synchronized (this) {        for (SubscriberMethod subscriberMethod : subscriberMethods) {            // 2            subscribe(subscriber, subscriberMethod);        }    }}</code></pre><p>在注释1处，根据当前注册类获取 subscriberMethods这个订阅方法列表 。在注释2处，使用了增强for循环令subsciber对象 对 subscriberMethods 中每个 SubscriberMethod 进行订阅。</p><p>接着我们查看SubscriberMethodFinder的findSubscriberMethods()方法：</p><pre><code>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {    // 1    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);    if (subscriberMethods != null) {        return subscriberMethods;    }    // 2    if (ignoreGeneratedIndex) {        subscriberMethods = findUsingReflection(subscriberClass);    } else {        subscriberMethods = findUsingInfo(subscriberClass);    }    if (subscriberMethods.isEmpty()) {        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);    } else {        METHOD_CACHE.put(subscriberClass, subscriberMethods);        return subscriberMethods;    }}</code></pre><p>在注释1处，如果缓存中有subscriberClass对象对应 的订阅方法列表，则直接返回。注释2处，先详细说说这个ignoreGeneratedIndex字段， 它用来判断是否使用生成的 APT 代码去优化寻找接收事件的过程，如果开启了的话，那么将会通过 subscriberInfoIndexes 来快速得到接收事件方法的相关信息。如果我们没有在项目中接入 EventBus 的 APT，那么可以将 ignoreGeneratedIndex 字段设为 false 以提高性能。这里ignoreGeneratedIndex 默认为false，所以会执行findUsingInfo()方法，后面生成 subscriberMethods 成功的话会加入到缓存中，失败的话会 抛出异常。</p><p>接着我们查看SubscriberMethodFinder的findUsingInfo()方法：</p><pre><code>private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) {    // 1    FindState findState = prepareFindState();    findState.initForSubscriber(subscriberClass);    // 2    while (findState.clazz != null) {        findState.subscriberInfo = getSubscriberInfo(findState);        if (findState.subscriberInfo != null) {            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();            for (SubscriberMethod subscriberMethod: array) {                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {                    findState.subscriberMethods.add(subscriberMethod);                }            }        } else {             // 3             findUsingReflectionInSingleClass(findState);        }        findState.moveToSuperclass();    }    // 4    return getMethodsAndRelease(findState);}</code></pre><p>在注释1处，调用了SubscriberMethodFinder的prepareFindState()方法创建了一个新的 FindState 类，我们来看看这个方法：</p><pre><code>private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];private FindState prepareFindState() {    // 1    synchronized(FIND_STATE_POOL) {        for (int i = 0; i &lt; POOL_SIZE; i++) {            FindState state = FIND_STATE_POOL[i];            if (state != null) {                FIND_STATE_POOL[i] = null;                return state;            }        }    }    // 2    return new FindState();}</code></pre><p>在注释1处，会先从 FIND_STATE_POOL 即 FindState 池中取出可用的 FindState（这里的POOL_SIZE为4），如果没有的话，则通过注释2处的代码直接新建 一个新的 FindState 对象。</p><p>接着我们来分析下FindState这个类：</p><pre><code>static class FindState {    ....    void initForSubscriber(Class&lt;?&gt; subscriberClass) {        this.subscriberClass = clazz = subscriberClass;        skipSuperClasses = false;        subscriberInfo = null;    }    ...}</code></pre><p>它是 SubscriberMethodFinder 的内部类，这个方法主要做一个初始化、回收对象等工作。</p><p>我们接着回到SubscriberMethodFinder的注释2处的SubscriberMethodFinder()方法：</p><pre><code>private SubscriberInfo getSubscriberInfo(FindState findState) {    if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) {        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();        if (findState.clazz == superclassInfo.getSubscriberClass()) {            return superclassInfo;        }    }    if (subscriberInfoIndexes != null) {        for (SubscriberInfoIndex index: subscriberInfoIndexes) {            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);            if (info != null) {                return info;            }        }    }    return null;}</code></pre><p>在前面初始化的时候，findState的subscriberInfo和subscriberInfoIndexes 这两个字段为空，所以这里直接返回 null。</p><p>接着我们查看注释3处的findUsingReflectionInSingleClass()方法：</p><pre><code>private void findUsingReflectionInSingleClass(FindState findState) {    Method[] methods;    try {        // This is faster than getMethods, especially when subscribers are fat classes like Activities        methods = findState.clazz.getDeclaredMethods();    } catch (Throwable th) {        methods = findState.clazz.getMethods();        findState.skipSuperClasses = true;    }    for (Method method: methods) {        int modifiers = method.getModifiers();        if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {            Class&lt;?&gt; [] parameterTypes = method.getParameterTypes();            if (parameterTypes.length == 1) {                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);                if (subscribeAnnotation != null) {                    // 重点                    Class&lt;?&gt; eventType = parameterTypes[0];                    if (findState.checkAdd(method, eventType)) {                        ThreadMode threadMode = subscribeAnnotation.threadMode();                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(),  subscribeAnnotation.sticky()));                    }                }            } else if (strictMethodVerification &amp;&amp;     method.isAnnotationPresent(Subscribe.class)) {            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();            throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);            }        } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();            throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);        }    }}</code></pre><p>这个方法很长，大概做的事情是：</p><ul><li>1、通过反射的方式获取订阅者类中的所有声明方法，然后在这些方法里面寻找以 @Subscribe作为注解的方法进行处理。</li><li>2、在经过经过一轮检查，看看 findState.subscriberMethods是否存在，如果没有，将方法名，threadMode，优先级，是否为 sticky 方法等信息封装到 SubscriberMethod 对象中，最后添加到 subscriberMethods 列表中。</li></ul><p>最后，我们继续查看注释4处的getMethodsAndRelease()方法：</p><pre><code>private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) {    // 1    List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);    // 2    findState.recycle();    // 3    synchronized(FIND_STATE_POOL) {        for (int i = 0; i &lt; POOL_SIZE; i++) {            if (FIND_STATE_POOL[i] == null) {                FIND_STATE_POOL[i] = findState;                break;            }        }    }    // 4    return subscriberMethods;}</code></pre><p>在这里，首先在注释1处，从findState中取出了保存的subscriberMethods。在注释2处，将findState里的保存的所有对象进行回收。在注释3处，把findState存储在 FindState 池中方便下一次使用，以提高性能。最后，在注释4处，返回subscriberMethods。接着，在EventBus的 register() 方法的最后会调用 subscribe 方法：</p><pre><code>public void register(Object subscriber) {    Class&lt;?&gt; subscriberClass = subscriber.getClass();    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);    synchronized (this) {        for (SubscriberMethod subscriberMethod : subscriberMethods) {            subscribe(subscriber, subscriberMethod);        }    }}</code></pre><p>我们继续看看这个subscribe()方法做的事情：</p><pre><code>private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {    Class&lt;?&gt; eventType = subscriberMethod.eventType;    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);    // 1    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);    if (subscriptions == null) {        subscriptions = new CopyOnWriteArrayList &lt;&gt; ();        subscriptionsByEventType.put(eventType, subscriptions);    } else {        if (subscriptions.contains(newSubscription)) {            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType);        }    }    int size = subscriptions.size();    // 2    for (int i = 0; i &lt;= size; i++) {        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {            subscriptions.add(i, newSubscription);            break;        }    }    // 3    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);    if (subscribedEvents == null) {        subscribedEvents = new ArrayList&lt;&gt;();        typesBySubscriber.put(subscriber, subscribedEvents);    }    subscribedEvents.add(eventType);    // 4    if (subscriberMethod.sticky) {        if (eventInheritance) {            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {                Class&lt;?&gt; candidateEventType = entry.getKey();                if(eventType.isAssignableFrom(candidateEventType)) {                Object stickyEvent = entry.getValue();                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);                }            }        } else {            Object stickyEvent = stickyEvents.get(eventType);            checkPostStickyEventToSubscription(newSubscription, stickyEvent);        }    }}</code></pre><p>首先，在注释1处，会根据 subscriberMethod的eventType，在 subscriptionsByEventType 去查找一个 CopyOnWriteArrayList ，如果没有则创建一个新的 CopyOnWriteArrayList，然后将这个 CopyOnWriteArrayList 放入 subscriptionsByEventType 中。在注释2处，添加 newSubscription对象，它是一个 Subscription 类，里面包含着 subscriber 和 subscriberMethod 等信息，并且这里有一个优先级的判断，说明它是按照优先级添加的。优先级越高，会插到在当前 List 靠前面的位置。在注释3处，对typesBySubscriber 进行添加，这主要是在EventBus的isRegister()方法中去使用的，目的是用来判断这个 Subscriber对象 是否已被注册过。最后，在注释4处，会判断是否是 sticky事件。如果是sticky事件的话，会调用 checkPostStickyEventToSubscription() 方法。</p><p>我们接着查看这个checkPostStickyEventToSubscription()方法：</p><pre><code>private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {    if (stickyEvent != null) {        postToSubscription(newSubscription, stickyEvent, isMainThread());    }}</code></pre><p>可以看到最终是调用了postToSubscription()这个方法来进行粘性事件的发送，对于粘性事件的处理，我们最后再分析，接下来我们看看事件是如何post的。</p><h3 id="三、EventBus-getDefault-post-new-CollectEvent"><a href="#三、EventBus-getDefault-post-new-CollectEvent" class="headerlink" title="三、EventBus.getDefault().post(new CollectEvent())"></a>三、EventBus.getDefault().post(new CollectEvent())</h3><pre><code>public void post(Object event) {    // 1    PostingThreadState postingState = currentPostingThreadState.get();    List &lt;Object&gt; eventQueue = postingState.eventQueue;    eventQueue.add(event);    // 2    if (!postingState.isPosting) {        postingState.isMainThread = isMainThread();        postingState.isPosting = true;        if (postingState.canceled) {            throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);        }        try {            while (!eventQueue.isEmpty()) {                postSingleEvent(eventQueue.remove(0), postingState);            }        } finally {            postingState.isPosting = false;            postingState.isMainThread = false;        }    }}</code></pre><p>注释1处，这里的currentPostingThreadState 是一个 ThreadLocal 类型的对象，里面存储了 PostingThreadState，而 PostingThreadState 中包含了一个 eventQueue 和其他一些标志位，相关的源码如下：</p><pre><code>private final ThreadLocal &lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal &lt;PostingThreadState&gt; () {@Overrideprotected PostingThreadState initialValue() {    return new PostingThreadState();}};final static class PostingThreadState {    final List &lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();    boolean isPosting;    boolean isMainThread;    Subscription subscription;    Object event;    boolean canceled;}</code></pre><p>接着把传入的 event，保存到了当前线程中的一个变量 PostingThreadState 的 eventQueue 中。在注释2处，最后调用了 postSingleEvent() 方法，我们继续查看这个方法：</p><pre><code>private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {    Class&lt;?&gt; eventClass = event.getClass();    boolean subscriptionFound = false;    // 1    if (eventInheritance) {        // 2        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);        int countTypes = eventTypes.size();        for (int h = 0; h &lt; countTypes; h++) {            Class&lt;?&gt; clazz = eventTypes.get(h);            subscriptionFound |=            // 3            postSingleEventForEventType(event, postingState, clazz);        }    } else {        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);    }    if (!subscriptionFound) {        ...    }}</code></pre><p>首先，在注释1处，首先取出 Event 的 class 类型，接着会对 eventInheritance 标志位 判断，它默认为true，如果设为 true 的话，它会在发射事件的时候判断是否需要发射父类事件，设为 false，能够提高一些性能。接着，在注释2处，会调用lookupAllEventTypes() 方法，它的作用就是取出 Event 及其父类和接口的 class 列表，当然重复取的话会影响性能，所以它也做了一个 eventTypesCache 的缓存，这样就不用重复调用 getSuperclass() 方法。最后，在注释3处会调用postSingleEventForEventType()方法，我们看下这个方法：</p><pre><code>private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class &lt;?&gt; eventClass) {    CopyOnWriteArrayList &lt;Subscription&gt; subscriptions;    synchronized(this) {        subscriptions = subscriptionsByEventType.get(eventClass);    }    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {        for (Subscription subscription: subscriptions) {            postingState.event = event;            postingState.subscription = subscription;            boolean aborted = false;            try {                postToSubscription(subscription, event, postingState.isMainThread);                aborted = postingState.canceled;            } finally {                postingState.event = null;                postingState.subscription = null;                postingState.canceled = false;            }            if (aborted) {                break;            }        }        return true;    }    return false;}</code></pre><p>可以看到，这里直接根据 Event 类型从 subscriptionsByEventType 中取出对应的 subscriptions对象，最后调用了 postToSubscription() 方法。</p><p>这个时候我们在看看这个postToSubscription()方法：</p><pre><code>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {    switch (subscription.subscriberMethod.threadMode) {        case POSTING:            invokeSubscriber(subscription, event);            break;        case MAIN:            if (isMainThread) {                invokeSubscriber(subscription, event);            } else {                mainThreadPoster.enqueue(subscription, event);            }            break;        case MAIN_ORDERED:            if (mainThreadPoster != null) {                mainThreadPoster.enqueue(subscription, event);            } else {                invokeSubscriber(subscription, event);            }            break;        case BACKGROUND:            if (isMainThread) {                backgroundPoster.enqueue(subscription, event);            } else {                invokeSubscriber(subscription, event);            }            break;        case ASYNC:            asyncPoster.enqueue(subscription, event);            break;        default:            throw new IllegalStateException(&quot;Unknow thread mode: &quot; + subscription.subscriberMethod.threadMode);    }}</code></pre><p>从上面可以看出，这里通过threadMode 来判断在哪个线程中去执行方法：</p><ul><li>1、POSTING：执行 invokeSubscriber() 方法，内部直接采用反射调用。</li><li>2、MAIN：首先去判断当前是否在 UI 线程，如果是的话则直接反射调用，否则调用mainThreadPoster的enqueue()方法，即把当前的方法加入到队列之中，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。</li><li>3、MAIN_ORDERED：与MAIN类型，不过是确保是顺序执行的。</li><li>4、BACKGROUND：判断当前是否在 UI 线程，如果不是的话直接反射调用，是的话通过backgroundPoster的enqueue()方法 将方法加入到后台的一个队列，最后通过线程池去执行。注意，backgroundPoster在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。</li><li>5、ASYNC：逻辑实现类似于BACKGROUND，将任务加入到后台的一个队列，最终由Eventbus 中的一个线程池去调用，这里的线程池与 BACKGROUND 逻辑中的线程池用的是同一个，即使用Executors的newCachedThreadPool()方法创建的线程池，它是一个有则用、无则创建、无数量上限的线程池。不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，这里asyncPoster则是异步运行的，可以同时接收多个任务。</li></ul><p>分析完EventBus的post()方法值，我们接着看看它的unregister()。</p><h3 id="四、EventBus-getDefault-unregister-this"><a href="#四、EventBus-getDefault-unregister-this" class="headerlink" title="四、EventBus.getDefault().unregister(this)"></a>四、EventBus.getDefault().unregister(this)</h3><p>它的核心源码如下所示：</p><pre><code>public synchronized void unregister(Object subscriber) {    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);    if (subscribedTypes != null) {        for (Class&lt;?&gt; eventType : subscribedTypes) {            //1            unsubscribeByEventType(subscriber, eventType);        }        // 2        typesBySubscriber.remove(subscriber);    }}</code></pre><p>首先，在注释1处，unsubscribeByEventType() 方法中对 subscriptionsByEventType 移除了该 subscriber 的所有订阅信息。最后，在注释2处，移除了注册对象和其对应的所有 Event 事件链表。</p><p>最后，我们在来分析下EventBus中对粘性事件的处理。</p><h3 id="五、EventBus-getDefault-postSticky-new-CollectEvent"><a href="#五、EventBus-getDefault-postSticky-new-CollectEvent" class="headerlink" title="五、EventBus.getDefault.postSticky(new CollectEvent())"></a>五、EventBus.getDefault.postSticky(new CollectEvent())</h3><p>如果想要发射 sticky 事件需要通过 EventBus的postSticky() 方法，内部源码如下所示：</p><pre><code>public void postSticky(Object event) {    synchronized (stickyEvents) {        // 1        stickyEvents.put(event.getClass(), event);    }    // 2    post(event);}</code></pre><p>在注释1处，先将该事件放入 stickyEvents 中，接着在注释2处使用post()发送事件。前面我们在分析register()方法的最后部分时，其中有关粘性事件的源码如下：</p><pre><code>if (subscriberMethod.sticky) {    Object stickyEvent = stickyEvents.get(eventType);    if (stickyEvent != null) {        postToSubscription(newSubscription, stickyEvent, isMainThread());    }}</code></pre><p>可以看到，在这里会判断当前事件是否是 sticky 事件，如果 是，则从 stickyEvents 中拿出该事件并执行 postToSubscription() 方法。</p><p>至此，EventBus源码分析完毕。</p><h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>EventBus 的源码在Android主流三方库源码分析系列中可以说是除了ButterKnife之外，算是比较简单的了。但是，它其中的一些思想和设计是值得借鉴的。比如它使用 FindState 复用池来复用 FindState 对象，在各处使用了 synchronized 关键字进行代码块同步的一些优化操作。其中上面分析了这个多，EventBus最核心的逻辑就是利用了 subscriptionsByEventType 这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行。至此，Android主流三方库源码分析系列到此完结~</p><pre><code>结束即开始，未来的路还有很长。</code></pre><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、EventBus V3.1.1 源码</p><p>2、Android进阶之光</p><p>3、Android组件化架构</p><p>3、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243033&amp;idx=1&amp;sn=28709941e6f8821c6f5dd3fa047b1393&amp;chksm=88638eb6bf1407a034ba2184cac9e31c24f43e3ac395b1b23b18243f64220c244f2edc7dc22a&amp;scene=38#wechat_redirect" target="_blank" rel="external">EventBus设计之禅</a></p><p>4、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242621&amp;idx=1&amp;sn=cc9c31aba5ff33b20fb9fecc3b0404b2&amp;chksm=88638f52bf14064453fc09e6e53798ac5a1299d84df490b15764f9a85292732879eb4a1c0665&amp;scene=38#wechat_redirect" target="_blank" rel="external">从源码入手来学习EventBus 3事件总线机制</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/28/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B9%9D%E3%80%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2EventBus%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（八、深入探索Dagger2源码）</title>
      <link>http://yoursite.com/2019/01/20/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%E3%80%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Dagger2%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/20/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%E3%80%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Dagger2%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 20 Jan 2019 15:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>上一篇，笔者详细地分析了Android中的依赖注入框架ButterKnife，使用它帮助我们解决了重复编写findViewById和setOnclickListener的繁琐。众所周知，当项目越来越大时，类之间的调用层次会越来越深，并且有些类是Activity/Fragment，有些是单例，而且它们的生命周期也不是一致的，所以创建这些对象时要处理的各个对象的依赖关系和生命周期时的任务会很繁重，因此，为了解决这个问题Dagger2应运而生。相比ButterKnife的轻量级使用，Dagger2会显得更重量级和锋利一些，它能够掌控全局，对项目中几乎所有的依赖进行集成管理。如果有对Binder架构体系比较了解的朋友应该知道，其中的服务大管家ServiceManager负责所有的服务（引导服务、核心服务、其它服务）的管理，而Dagger2其实就是将项目中的依赖进行了集成管理。下面，笔者来跟大家一起探索Dagger2的内部实现机制，看看它是如何进行依赖管理的。</p><p>Dagger2其实同RxJava一样，是一种多平台通用的库。由于Dagger2的通用写法比较繁琐，因此，Google推出了适用于Android平台的Dagger.Android用法。本文，将基于Dagger.Android的源码对Dagger2内部的实现机制进行探索。</p><h3 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h3><p>鉴于Dagger有一定的上手成本，这里首先带大家复习一下本篇源码分析可能会涉及到的相关基础知识点，以降低阅读难度。</p><h4 id="1、-Inject"><a href="#1、-Inject" class="headerlink" title="1、@Inject"></a>1、@Inject</h4><p>告诉dagger这个字段或类需要依赖注入，然后在需要依赖的地方使用这个注解，dagger会自动生成这个构造器的实例。</p><h5 id="获取所需依赖："><a href="#获取所需依赖：" class="headerlink" title="获取所需依赖："></a>获取所需依赖：</h5><ul><li>全局变量注入</li><li>方法注入</li></ul><h5 id="提供所需实例："><a href="#提供所需实例：" class="headerlink" title="提供所需实例："></a>提供所需实例：</h5><ul><li>构造器注入（如果有多个构造函数，只能注解一个，否则编译报错）</li></ul><h4 id="2、-Module"><a href="#2、-Module" class="headerlink" title="2、@Module"></a>2、@Module</h4><p>类注解，表示此类的方法是提供依赖的，它告诉dagger在哪可以找到依赖。用于不能用@Inject提供依赖的地方，如第三方库提供的类，基本数据类型等不能修改源码的情况。</p><p>注意：<strong>Dagger2会优先在@Module注解的类上查找依赖，没有的情况才会去查询类的@Inject构造方法</strong></p><h4 id="3、-Singleton"><a href="#3、-Singleton" class="headerlink" title="3、@Singleton"></a>3、@Singleton</h4><p>声明这是一个单例，在确保只有一个Component并且不再重新build()之后，对象只会被初始化一次，之后的每次都会被注入相同的对象，它就是一个内置的作用域。</p><p>对于@Singleton，大家可能会产生一些误解，这里详细阐述下：</p><ul><li>Singleton容易给人造成一种误解就是用Singleton注解后在整个Java代码中都是单例，但实际上他和Scope一样，只是在同一个Component是单例。也就是说，如果重新调用了component的build（）方法，即使使用了Singleton注解了，但仍然获取的是不同的对象。</li><li>它表明了@Singleton注解只是声明了这是一个单例，为的只是提高代码可读性，其实真正控制对象生命周期的还是Component。同理，自定义的@ActivityScope 、@ApplicationScope也仅仅是一个声明的作用，<strong>真正控制对象生命周期的还是Component</strong>。</li></ul><h4 id="4、-Providers"><a href="#4、-Providers" class="headerlink" title="4、@Providers"></a>4、@Providers</h4><p>只在@Module中使用，用于提供构造好的实例。一般与@Singleton搭配，用单例方法的形式对外提供依赖,是一种替代@Inject注解构造方法的方式。</p><p>注意：</p><ul><li>使用了@Providers的方法应使用provide作为前缀，使用了@Module的类应使用Module作为后缀。</li><li><strong>如果@Providers方法或@Inject构造方法有参数，要保证它能够被dagger获取到</strong>，比如通过其它@Providers方法或者@Inject注解构造器的形式得到。</li></ul><h4 id="5、-Component"><a href="#5、-Component" class="headerlink" title="5、@Component"></a>5、@Component</h4><p>@Component作为Dagger2的容器总管，它拥有着@Inject与@Module的所有依赖。同时，它也是一枚注射器，用于获取所需依赖和提供所需依赖的桥梁。这里的桥梁即指@Inject和@Module（或@Inject构造方法）之间的桥梁。定义时需要列出响应的Module组成，此外，还可以使用dependencies继承父Component。</p><h5 id="Component与Module的区别："><a href="#Component与Module的区别：" class="headerlink" title="Component与Module的区别："></a>Component与Module的区别：</h5><p>Component既是注射器也是一个容器总管，而module则是作为容器总管Component的子容器，实质是一个用于提供依赖的模块。</p><h4 id="6、-Scope"><a href="#6、-Scope" class="headerlink" title="6、@Scope"></a>6、@Scope</h4><p>注解作用域，通过自定义注解<strong>限定对象作用范围，增强可读性</strong>。</p><p>@Scope有两种常用的使用场景：</p><ul><li>模拟Singleton代表全局单例，与Component生命周期关联。</li><li>模拟局部单例，如登录到退出登录期间。 </li></ul><h4 id="7、-Qualifier"><a href="#7、-Qualifier" class="headerlink" title="7、@Qualifier"></a>7、@Qualifier</h4><p>限定符，利用它定义注解类以用于区分类的不同实例。例如：2个方法返回不同的Person对象，比如说小明和小华，为了区分，使用@Qualifier定义的注解类。</p><h4 id="8、dependencies"><a href="#8、dependencies" class="headerlink" title="8、dependencies"></a>8、dependencies</h4><p>使用它表示ChildComponent依赖于FatherComponent，如下所示：</p><pre><code>@Component(modules = ChildModule.class, dependencies = FatherComponent.class)public interface ChildComponent {    ...}</code></pre><h4 id="9、-SubComponent"><a href="#9、-SubComponent" class="headerlink" title="9、@SubComponent"></a>9、@SubComponent</h4><p>表示是一个子@Component，它能将应用的不同部分封装起来，用来替代@Dependencies。</p><p>回顾完Dagger2的基础知识，下面我们要启动发动机了。。。</p><h3 id="一、简单示例（取自AwesomeWanAndroid）"><a href="#一、简单示例（取自AwesomeWanAndroid）" class="headerlink" title="一、简单示例（取自AwesomeWanAndroid）"></a>一、简单示例（取自<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">AwesomeWanAndroid</a>）</h3><h4 id="1、首先，创建一个BaseActivityComponent的Subcomponent："><a href="#1、首先，创建一个BaseActivityComponent的Subcomponent：" class="headerlink" title="1、首先，创建一个BaseActivityComponent的Subcomponent："></a>1、首先，创建一个BaseActivityComponent的Subcomponent：</h4><pre><code>@Subcomponent(modules = {AndroidInjectionModule.class})public interface BaseActivityComponent extends AndroidInjector&lt;BaseActivity&gt; {    @Subcomponent.Builder    abstract class BaseBuilder extends AndroidInjector.Builder&lt;BaseActivity&gt;{    }}</code></pre><p>这里必须要注解成@Subcomponent.Builder表示是顶级@Subcomponent的内部类。AndroidInjector.Builder的泛型指定了BaseActivity，即表示每一个继承于BaseActivity的Activity都继承于同一个子组件（BaseActivityComponent）。</p><h4 id="2、然后，创建一个将会导入Subcomponent的公有Module。"><a href="#2、然后，创建一个将会导入Subcomponent的公有Module。" class="headerlink" title="2、然后，创建一个将会导入Subcomponent的公有Module。"></a>2、然后，创建一个将会导入Subcomponent的公有Module。</h4><pre><code>// 1@Module(subcomponents = {BaseActivityComponent.class})public abstract class AbstractAllActivityModule {    @ContributesAndroidInjector(modules = MainActivityModule.class)    abstract MainActivity contributesMainActivityInjector();    @ContributesAndroidInjector(modules = SplashActivityModule.class)    abstract SplashActivity contributesSplashActivityInjector();    // 一系列的对应Activity的contributesxxxActivityInjector    ...}</code></pre><p>在注释1处用subcomponents来表示开放全部依赖给AbstractAllActivityModule，使用Subcomponent的重要原因是它将应用的不同部分封装起来了。@AppComponent负责维护共享的数据和对象，而不同处则由各自的@Subcomponent维护。</p><h4 id="3、接着，配置项目的Application。"><a href="#3、接着，配置项目的Application。" class="headerlink" title="3、接着，配置项目的Application。"></a>3、接着，配置项目的Application。</h4><pre><code>public class WanAndroidApp extends Application implements HasActivityInjector {    // 3    @Inject    DispatchingAndroidInjector&lt;Activity&gt; mAndroidInjector;    private static volatile AppComponent appComponent;    @Override    public void onCreate() {        super.onCreate();        ...        // 1        appComponent = DaggerAppComponent.builder()            .build();        // 2        appComponent.inject(this);        ...    }    ...    // 4    @Override    public AndroidInjector&lt;Activity&gt; activityInjector() {        return mAndroidInjector;    }}</code></pre><p>首先，在注释1处，使用AppModule模块和httpModule模块构建出AppComponent的实现类DaggerAppComponent。这里看一下AppComponent的配置代码：</p><pre><code>@Singleton@Component(modules = {AndroidInjectionModule.class,        AndroidSupportInjectionModule.class,        AbstractAllActivityModule.class,        AbstractAllFragmentModule.class,        AbstractAllDialogFragmentModule.class}    )public interface AppComponent {    /**     * 注入WanAndroidApp实例     *     * @param wanAndroidApp WanAndroidApp     */    void inject(WanAndroidApp wanAndroidApp);    ...}</code></pre><p>可以看到，AppComponent依赖了AndroidInjectionModule模块，它包含了一些基础配置的绑定设置，如activityInjectorFactories、fragmentInjectorFactories等等，而AndroidSupportInjectionModule模块显然就是多了一个supportFragmentInjectorFactories的绑定设置，activityInjectorFactories的内容如所示：</p><pre><code>@Beta@Modulepublic abstract class AndroidInjectionModule {    @Multibinds    abstract Map&lt;Class&lt;? extends Activity&gt;, AndroidInjector.Factory&lt;? extends Activity&gt;&gt;        activityInjectorFactories();    @Multibinds    abstract Map&lt;Class&lt;? extends Fragment&gt;, AndroidInjector.Factory&lt;? extends Fragment&gt;&gt;        fragmentInjectorFactories();    ...}</code></pre><p>接着，下面依赖的AbstractAllActivityModule、<br>AbstractAllFragmentModule、AbstractAllDialogFragmentModule则是为项目的所有Activity、Fragment、DialogFragment提供的统一基类抽象Module，这里看下AbstractAllActivityModule的配置：</p><pre><code>@Module(subcomponents = {BaseActivityComponent.class})public abstract class AbstractAllActivityModule {    @ContributesAndroidInjector(modules = MainActivityModule.class)    abstract MainActivity contributesMainActivityInjector();    @ContributesAndroidInjector(modules = SplashActivityModule.class)    abstract SplashActivity contributesSplashActivityInjector();    ...}</code></pre><p>可以看到，项目下的所有xxxActiviity都有对应的contributesxxxActivityInjector()方法提供实例注入。并且，注意到AbstractAllActivityModule这个模块依赖的<br>subcomponents为BaseActivityComponent，前面说过了，每一个继承于BaseActivity的Activity都继承于BaseActivityComponent这一个subcomponents。同理，AbstractAllFragmentModule与AbstractAllDialogFragmentModule也是类似的实现模式，如下所示：</p><pre><code>// 1@Module(c = BaseFragmentComponent.class)public abstract class AbstractAllFragmentModule {    @ContributesAndroidInjector(modules = CollectFragmentModule.class)    abstract CollectFragment contributesCollectFragmentInject();    @ContributesAndroidInjector(modules = KnowledgeFragmentModule.class)    abstract KnowledgeHierarchyFragment contributesKnowledgeHierarchyFragmentInject();    ...}// 2@Module(subcomponents = BaseDialogFragmentComponent.class)public abstract class AbstractAllDialogFragmentModule {    @ContributesAndroidInjector(modules = SearchDialogFragmentModule.class)    abstract SearchDialogFragment contributesSearchDialogFragmentInject();    @ContributesAndroidInjector(modules = UsageDialogFragmentModule.class)    abstract UsageDialogFragment contributesUsageDialogFragmentInject();}</code></pre><p>注意到注释1和注释2处的代码，AbstractAllFragmentModule和AbstractAllDialogFragmentModule的subcomponents为BaseFragmentComponent、BaseDialogFragmentComponent，很显然，同AbstractAllActivityModule的子组件BaseActivityComponent一样，它们都是作为一个通用的子组件。</p><p>然后，回到我们配置项目下的Application下面的注释2处的代码，在这里使用了第一步Dagger为我们构建的DaggerAppComponent对象将当期的Application实例注入了进去，交给了Dagger这个依赖大管家去管理。最终，Dagger2内部创建的mAndroidInjector对象会在注释3处的地方进行实例赋值。在注释4处，实现HasActivityInjector接口，重写activityInjector()方法，将我们上面得到的mAndroidInjector对象返回。这里的mAndroidInjector是一个类型为DispatchingAndroidInjector<activity>的对象，可以这样理解它：它能够执行Android框架下的核心成员如Activity、Fragment的成员注入，在我们项目下的Application中将DispatchingAndroidInjector的泛型指定为Activity就说明它承担起了所有Activity成员依赖的注入。那么，如何指定某一个Activity能被纳入DispatchingAndroidInjector这个所有Activity的依赖总管的口袋中呢？接着看使用步骤4。</activity></p><h4 id="4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。"><a href="#4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。" class="headerlink" title="4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。"></a>4、最后，将目标Activity纳入Activity依赖分配总管DispatchingAndroidInjector的囊中。</h4><p>很简单，只需在目标Activity的onCreate()方法前的super.onCreate(savedInstanceState)前配置一行代码 AndroidInjection.inject(this)，如下所示：</p><pre><code>public abstract class BaseActivity&lt;T extends AbstractPresenter&gt; extends AbstractSimpleActivity implements    AbstractView {    ...    @Inject    protected T mPresenter;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        AndroidInjection.inject(this);        super.onCreate(savedInstanceState);    }    ...}</code></pre><p>这里使用了@Inject表明了需要注入mPresenter实例，然后，我们需要在具体的Presenter类的构造方法上使用@Inject提供基于当前构造方法的mPresenter实例，如下所示：</p><pre><code>public class MainPresenter extends BasePresenter&lt;MainContract.View&gt; implements MainContract.Presenter {    ...    @Inject    MainPresenter(DataManager dataManager) {        super(dataManager);        this.mDataManager = dataManager;    }    ...}</code></pre><p>从上面的使用流程中，可以总结出三个核心部分：</p><ul><li><p>1、appComponent = DaggerAppComponent.builder().build()这句代码如何构建出DaggerAPPComponent的？</p></li><li><p>2、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？</p></li><li><p>3、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？</p></li></ul><p>下面，让我们来逐个一一地来探索其中的奥妙吧~</p><h3 id="二、DaggerAppComponent-builder-build-是如何构建出DaggerAPPComponent的？"><a href="#二、DaggerAppComponent-builder-build-是如何构建出DaggerAPPComponent的？" class="headerlink" title="二、DaggerAppComponent.builder().build()是如何构建出DaggerAPPComponent的？"></a>二、DaggerAppComponent.builder().build()是如何构建出DaggerAPPComponent的？</h3><p>首先，我们看到DaggerAppComponent的builder()方法：</p><pre><code>public static Builder builder() {    return new Builder();}</code></pre><p>里面直接返回了一个新建的Builder静态内部类对象，看看它的构造方法中做了什么：</p><pre><code>public static final class Builder {    private Builder() {}    ...}</code></pre><p>看来，Builder的默认构造方法什么也没有做，那么，真正的实现肯定在Builder对象的build()方法中，接着看到build()方法。</p><pre><code>public static final class Builder {    ...    public AppComponent build() {         return new DaggerAppComponent(this);    }    ...}</code></pre><p>在Builder的build()方法中直接返回了新建的DaggerAppComponent对象。下面，看看DaggerAppComponent的构造方法:</p><pre><code>private DaggerAppComponent(Builder builder) {    initialize(builder);}</code></pre><p>在DaggerAppComponent的构造方法中调用了initialize方法，顾名思义，它就是真正初始化项目全局依赖配置的地方了，下面，来看看它内部的实现：</p><pre><code>private void initialize(final Builder builder) {    // 1    this.mainActivitySubcomponentBuilderProvider =        new Provider&lt;            AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent                .Builder&gt;() {        @Override        public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent                .Builder            get() {                // 2                return new MainActivitySubcomponentBuilder();            }        };    // 一系列xxxActivitySubcomponentBuilderProvider的创建赋值代码块    ...}</code></pre><p>在注释1处，新建了一个mainActivit的子组件构造器实例提供者Provider。在注释2处，使用匿名内部类的方式重写了该Provider的get()方法，返回一个新创建好的MainActivitySubcomponentBuilder对象。很显然，它就是负责创建管理MAinActivity中所需依赖的Subcomponent建造者。接下来我们重点来分析下MainActivitySubcomponentBuilder这个类的作用。</p><pre><code>// 1private final class MainActivitySubcomponentBuilder  extends AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent      .Builder {    private MainActivity seedInstance;    @Override    public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent        build() {      if (seedInstance == null) {        throw new IllegalStateException(MainActivity.class.getCanonicalName() + &quot; must be set&quot;);      }      // 2      return new MainActivitySubcomponentImpl(this);    }    @Override    public void seedInstance(MainActivity arg0) {      // 3      this.seedInstance = Preconditions.checkNotNull(arg0);    }}</code></pre><p>首先，在注释1处，MainActivitySubcomponentBuilder继承了AbstractAllActivityModule_ContributesMainActivityInjector内部的子组件MainActivitySubcomponent的内部的子组件建造者类Builder，如下所示：</p><pre><code>@Subcomponent(modules = MainActivityModule.class)public interface MainActivitySubcomponent extends AndroidInjector&lt;MainActivity&gt; {    @Subcomponent.Builder    abstract class Builder extends    AndroidInjector.Builder&lt;MainActivity&gt; {}}</code></pre><p>可以看到，这个子组件建造者Builder又继承了AndroidInjector的抽象内部类Builder<mainactivity>，那么，这个AndroidInjector到底是什么呢？</mainactivity></p><p>顾名思义，AndroidInjector是一个Android注射器，它<strong>为每一个具体的子类型，即核心Android类型Activity和Fragment执行成员注入。</strong></p><p>接下来我们便来分析下AndroidInjector的内部实现，源码如下所示：</p><pre><code>public interface AndroidInjector&lt;T&gt; {    void inject(T instance);    // 1    interface Factory&lt;T&gt; {        AndroidInjector&lt;T&gt; create(T instance);    }    // 2    abstract class Builder&lt;T&gt; implements AndroidInjector.Factory&lt;T&gt; {        @Override        public final AndroidInjector&lt;T&gt; create(T instance) {            seedInstance(instance);            return build();        }        @BindsInstance        public abstract void seedInstance(T instance);        public abstract AndroidInjector&lt;T&gt; build();    }}</code></pre><p>在注释1处，使用了抽象工厂模式，用来创建一个具体的Activity或Fragment类型的AndroidInjector实例。注释2处，Builder<t>实现了AndroidInjector.Factory<t>，它是一种Subcomponent.Builder的通用实现模式，在重写的create()方法中，进行了实例保存seedInstance()和具体Android核心类型的构建。</t></t></p><p>接着，我们回到MainActivitySubcomponentBuilder类，可以看到，它实现了AndroidInjector.Builder的seedInstance()和build()方法。在注释3处首先播种了MainActivity的实例，然后<br>在注释2处新建了一个MainActivitySubcomponentImpl对象返回。我们看看MainActivitySubcomponentImpl这个类是如何将mPresenter依赖注入的，相关源码如下：</p><pre><code>private final class MainActivitySubcomponentImpl    implements AbstractAllActivityModule_ContributesMainActivityInjector    .MainActivitySubcomponent {    private MainPresenter getMainPresenter() {        // 2        return MainPresenter_Factory.newMainPresenter(        DaggerAppComponent.this.provideDataManagerProvider.get());    }    @Override    public void inject(MainActivity arg0) {        // 1        injectMainActivity(arg0);    }    private MainActivity injectMainActivity(MainActivity instance) {        // 3        BaseActivity_MembersInjector        .injectMPresenter(instance, getMainPresenter());        return instance;    }</code></pre><p>在注释1处，MainActivitySubcomponentImpl实现了AndroidInjector接口的inject()方法，在injectMainActivity()首先调用getMainPresenter()方法从MainPresenter_Factory工厂类中新建了一个MainPresenter对象。我们看看MainPresenter的newMainPresenter()方法：</p><pre><code>public static MainPresenter newMainPresenter(DataManager dataManager) {    return new MainPresenter(dataManager);}</code></pre><p>这里直接新建了一个MainPresenter。然后我们回到MainActivitySubcomponentImpl类的注释3处，继续调用了BaseActivity_MembersInjector的injectMPresenter()方法，顾名思义，可以猜到，它BaseActivity的成员注射器，继续看看injectMPresenter()内部：</p><pre><code>public static &lt;T extends AbstractPresenter&gt; void injectMPresenter(  BaseActivity&lt;T&gt; instance, T mPresenter) {    instance.mPresenter = mPresenter;}</code></pre><p>可以看到，这里直接将需要的mPresenter实例赋值给了BaseActivity的mPresenter，当然，这里其实是指的BaseActivity的子类MAinActivity，其它的xxxActivity的依赖管理机制都是如此。</p><h3 id="三、appComponent-inject-this-是如何将mAndroidInjector实例赋值给当前的Application的？"><a href="#三、appComponent-inject-this-是如何将mAndroidInjector实例赋值给当前的Application的？" class="headerlink" title="三、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？"></a>三、appComponent.inject(this)是如何将mAndroidInjector实例赋值给当前的Application的？</h3><p>我们继续查看appComponent的inject()方法：</p><pre><code>@Overridepublic void inject(WanAndroidApp wanAndroidApp) {  injectWanAndroidApp(wanAndroidApp);}</code></pre><p>在inject()方法里调用了injectWanAndroidApp()，继续查看injectWanAndroidApp()方法：</p><pre><code>private WanAndroidApp injectWanAndroidApp(WanAndroidApp instance) {    WanAndroidApp_MembersInjector.injectMAndroidInjector(        instance,        getDispatchingAndroidInjectorOfActivity());    return instance;}</code></pre><p>首先，执行getDispatchingAndroidInjectorOfActivity()方法得到了一个Activity类型的DispatchingAndroidInjector对象，继续查看getDispatchingAndroidInjectorOfActivity()方法：</p><pre><code>private DispatchingAndroidInjector&lt;Activity&gt; getDispatchingAndroidInjectorOfActivity() {    return DispatchingAndroidInjector_Factory.newDispatchingAndroidInjector(    getMapOfClassOfAndProviderOfFactoryOf());}</code></pre><p>在getDispatchingAndroidInjectorOfActivity()方法里面，首先调用了getMapOfClassOfAndProviderOfFactoryOf()方法，我们看到这个方法：</p><pre><code>private Map&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;  getMapOfClassOfAndProviderOfFactoryOf() {    return MapBuilder        .&lt;Class&lt;? extends Activity&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends Activity&gt;&gt;&gt;        newMapBuilder(8)        .put(MainActivity.class, (Provider) mainActivitySubcomponentBuilderProvider)        .put(SplashActivity.class, (Provider) splashActivitySubcomponentBuilderProvider)        .put(ArticleDetailActivity.class,            (Provider) articleDetailActivitySubcomponentBuilderProvider)        .put(KnowledgeHierarchyDetailActivity.class,            (Provider) knowledgeHierarchyDetailActivitySubcomponentBuilderProvider)        .put(LoginActivity.class, (Provider) loginActivitySubcomponentBuilderProvider)        .put(RegisterActivity.class, (Provider) registerActivitySubcomponentBuilderProvider)        .put(AboutUsActivity.class, (Provider) aboutUsActivitySubcomponentBuilderProvider)        .put(SearchListActivity.class, (Provider) searchListActivitySubcomponentBuilderProvider)        .build();}</code></pre><p>可以看到，这里新建了一个建造者模式实现的MapBuilder，并且同时制定了固定容量为8，将项目下使用了AndroidInjection.inject(mActivity)方法的8个Activity对应的xxxActivitySubcomponentBuilderProvider保存起来。</p><p>我们再回到getDispatchingAndroidInjectorOfActivity()方法，这里将上面得到的Map容器传入了DispatchingAndroidInjector_Factory的newDispatchingAndroidInjector()方法中，这里应该就是新建DispatchingAndroidInjector的地方了。我们点进去看看：</p><pre><code>public static &lt;T&gt; DispatchingAndroidInjector&lt;T&gt; newDispatchingAndroidInjector(  Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt; injectorFactories) {    return new DispatchingAndroidInjector&lt;T&gt;(injectorFactories);}</code></pre><p>在这里，果然新建了一个DispatchingAndroidInjector对象。继续看看DispatchingAndroidInjector的构造方法：</p><pre><code>@InjectDispatchingAndroidInjector(  Map&lt;Class&lt;? extends T&gt;, Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt;&gt; injectorFactories) {    this.injectorFactories = injectorFactories;}</code></pre><p>这里仅仅是将传进来的Map容器保存起来了。</p><p>我们再回到WanAndroidApp_MembersInjector的injectMAndroidInjector()方法，将上面得到的DispatchingAndroidInjector实例传入，继续查看injectMAndroidInjector()这个方法：</p><pre><code>public static void injectMAndroidInjector(  WanAndroidApp instance, DispatchingAndroidInjector&lt;Activity&gt; mAndroidInjector) {    instance.mAndroidInjector = mAndroidInjector;}</code></pre><p>可以看到，这里直接将新建好的DispatchingAndroidInjector实例赋值给了WanAndroidApp的mAndroidInjector。</p><h3 id="四、在目标Activity下的AndroidInjection-inject-this-这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？"><a href="#四、在目标Activity下的AndroidInjection-inject-this-这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？" class="headerlink" title="四、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？"></a>四、在目标Activity下的AndroidInjection.inject(this)这句代码是如何将当前Activity对象纳入依赖分配总管DispatchingAndroidInjector囊中的呢？</h3><p>首先，我们看到AndroidInjection.inject(this)这个方法：</p><pre><code>public static void inject(Activity activity) {    checkNotNull(activity, &quot;activity&quot;);    // 1    Application application = activity.getApplication();    if (!(application instanceof HasActivityInjector)) {    throw new RuntimeException(        String.format(            &quot;%s does not implement %s&quot;,            application.getClass().getCanonicalName(),             HasActivityInjector.class.getCanonicalName()));    }    // 2    AndroidInjector&lt;Activity&gt; activityInjector =        ((HasActivityInjector) application).activityInjector();    checkNotNull(activityInjector, &quot;%s.activityInjector() returned null&quot;, application.getClass());    // 3    activityInjector.inject(activity);</code></pre><p>  }</p><p>在注释1处，会先判断当前的application是否实现了HasActivityInjector这个接口，如果没有，则抛出RuntimeException。如果有，会继续在注释2处调用application的activityInjector()方法得到DispatchingAndroidInjector实例。最后，在注释3处，会将当前的activity实例传入activityInjector的inject()方法中。我们继续查看inject()方法：</p><pre><code>@Overridepublic void inject(T instance) {    boolean wasInjected = maybeInject(instance);    if (!wasInjected) {        throw new IllegalArgumentException(errorMessageSuggestions(instance));    }}</code></pre><p>DispatchingAndroidInjector的inject()方法，它的作用就是给传入的instance实例执行成员注入。具体在这个案例中，其实就是负责将创建好的Presenter实例赋值给BaseActivity对象<br>的mPresenter全局变量。在inject()方法中，又调用了maybeInject()方法，我们继续查看它：</p><pre><code>@CanIgnoreReturnValuepublic boolean maybeInject(T instance) {    // 1    Provider&lt;AndroidInjector.Factory&lt;? extends T&gt;&gt; factoryProvider =    injectorFactories.get(instance.getClass());    if (factoryProvider == null) {    return false;    }    @SuppressWarnings(&quot;unchecked&quot;)    // 2    AndroidInjector.Factory&lt;T&gt; factory = (AndroidInjector.Factory&lt;T&gt;) factoryProvider.get();    try {        // 3        AndroidInjector&lt;T&gt; injector =            checkNotNull(                factory.create(instance), &quot;%s.create(I) should not return null.&quot;, factory.getClass());        // 4        injector.inject(instance);        return true;    } catch (ClassCastException e) {        ...    }}</code></pre><p>在注释1处，我们从injectorFactories（前面得到的Map容器）中根据当前Activity实例拿到了factoryProvider对象，这里我们具体一点，看到MAinActivity对应的factoryProvider，也就是我们研究的第一个问题中的mainActivitySubcomponentBuilderProvider：</p><pre><code>private void initialize(final Builder builder) {    this.mainActivitySubcomponentBuilderProvider =        new Provider&lt;            AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent            .Builder&gt;() {        @Override        public AbstractAllActivityModule_ContributesMainActivityInjector.MainActivitySubcomponent                .Builder            get() {                return new MainActivitySubcomponentBuilder();            }        };    ...}</code></pre><p>在maybeInject()方法的注释2处，调用了mainActivitySubcomponentBuilderProvider的get()方法得到了一个新建的MainActivitySubcomponentBuilder对象。在注释3处执行了它的create方法，create()方法的具体实现在AndroidInjector的内部类Builder中：</p><pre><code>abstract class Builder&lt;T&gt; implements AndroidInjector.Factory&lt;T&gt; {    @Override    public final AndroidInjector&lt;T&gt; create(T instance) {        seedInstance(instance);        return build();    }</code></pre><p>看到这里，我相信看过第一个问题的同学已经明白是后面是怎么回事了。在create()方法中，我们首先MainActivitySubcomponentBuilder的seedInstance()将MAinActivity实例注入，然后再调用它的build()方法新建了一个MainActivitySubcomponentImpl实例返回。</p><p>最后，在注释4处，执行了MainActivitySubcomponentImpl的injecty()方法：</p><pre><code>private final class MainActivitySubcomponentImpl    implements AbstractAllActivityModule_ContributesMainActivityInjector    .MainActivitySubcomponent {    private MainPresenter getMainPresenter() {        // 2        return MainPresenter_Factory.newMainPresenter(        DaggerAppComponent.this.provideDataManagerProvider.get());    }    @Override    public void inject(MainActivity arg0) {        // 1        injectMainActivity(arg0);    }    private MainActivity injectMainActivity(MainActivity instance) {        // 3        BaseActivity_MembersInjector        .injectMPresenter(instance, getMainPresenter());        return instance;    }</code></pre><p>这里的逻辑已经在问题一的最后部分详细讲解了，最后，会在注释3处调用BaseActivity_MembersInjector的injectMPresenter()方法：</p><pre><code>public static &lt;T extends AbstractPresenter&gt; void injectMPresenter(  BaseActivity&lt;T&gt; instance, T mPresenter) {    instance.mPresenter = mPresenter;}</code></pre><p>这样，就将mPresenter对象赋值给了当前Activity对象的mPresenter全局变量中了。至此，Dagger.Android核心源码分析完毕，你是否有所收获呢？</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>相比于ButterKnife，Dagger是一个<strong>锋利的全局依赖注入管理框架</strong>，它主要用来管理对象的依赖关系和生命周期，当项目越来越大时，类之间的调用层次会越来越深，并且有些类是Activity或Fragment，有些是单例，而且它们的生命周期不一致，所以创建所需对象时需要处理的各个对象的依赖关系和生命周期时的任务会很繁重。因此，使用Dagger会大大减轻这方面的工作量。虽然它的学习成本比较高，而且需要写一定的模板类，但是，<strong>对于越大的项目来说，Dagger越值得被需要</strong>。下一篇，便是Android主流三方库源码分析系列的终结篇了，笔者将会对Android中的事件总线框架EventBus源码进行深入的分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Dagger V2.1.5 源码</p><p>2、Android进阶之光</p><p>3、<a href="https://blog.csdn.net/mq2553299/article/details/77725912" target="_blank" rel="external">告别Dagger2模板代码：DaggerAndroid原理解析</a></p><p>4、<a href="https://www.jianshu.com/p/7ee1a1100fab" target="_blank" rel="external">Android Dagger2 从零单排</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/20/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%85%AB%E3%80%81%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Dagger2%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
