<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Sun, 29 Dec 2019 10:36:49 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>深入探索Android内存优化</title>
      <link>http://yoursite.com/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 29 Dec 2019 10:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>本篇是Android内存优化的进阶篇，难度会比较大，建议对内存优化不是非常熟悉的前仔细看看在前几篇文章中，笔者曾经写过的一篇<a href="https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之内存优化</a>，其中详细分析了以下几大模块：</p><ul><li>Android的内存管理机制</li><li>优化内存的意义</li><li>避免内存泄漏</li><li>优化内存空间</li><li>图片管理模块的设计与实现</li></ul><p>如果你对以上基础内容都比较了解了，那么我们便开始接下来的Android内存优化探索之旅吧。</p><h3 id="一、内存优化相关概念"><a href="#一、内存优化相关概念" class="headerlink" title="一、内存优化相关概念"></a>一、内存优化相关概念</h3><p>Android的给每个应用进程分配的内存都是非常有限的，那么为什么不能把图片下载来都放到磁盘中呢？那是因为放在内存中，展示会更“快”，快的原因有两点：</p><ul><li>硬件快：内存本身读取、存入速度快。</li><li>复用快：解码成果有效保存，复用时，直接使用解码后对象，而不是再做一次图像解码。</li></ul><p>这里说一下解码的概念。Android系统要在屏幕上展示图片的时候只认“像素缓冲”，而这也是大多数操作系统的特征。而我们常见的jpg，png等图片格式，都是把“像素缓冲”使用不同的手段压缩后的结果，所以这些格式的图片，要在设备上展示，就必须经过一次解码，它的执行速度会受图片压缩比、尺寸等因素影响。(官方建议：把从内存淘汰的图片，降低压缩比存储到本地，以备后用，这样可以最大限度地降低以后复用时的解码开销。)</p><p>接下来，我们来了解一下内存优化的一些重要概念。</p><h4 id="手机RAM"><a href="#手机RAM" class="headerlink" title="手机RAM:"></a>手机RAM:</h4><p>手机不使用PC的DDR内存，采用的是LPDDR RAM，即”低功耗双倍数据速率内存“。</p><pre><code>LPDDR系列的带宽 = 时钟频率 ✖️内存总线位数 / 8LPDDR4 = 1600MHZ ✖️64 / 8 ✖️双倍速率 = 25.6GB/s。</code></pre><h4 id="那么内存占用是否越少越好？"><a href="#那么内存占用是否越少越好？" class="headerlink" title="那么内存占用是否越少越好？"></a>那么内存占用是否越少越好？</h4><p>当系统内存充足的时候，我们可以多用一些获得更好的性能。当系统内存不足的时候，希望可以做到”用时分配，及时释放“。</p><h4 id="内存优化的纬度"><a href="#内存优化的纬度" class="headerlink" title="内存优化的纬度"></a>内存优化的纬度</h4><p>对于Android内存优化来说又可以细分为两个维度：</p><h5 id="1、RAM优化"><a href="#1、RAM优化" class="headerlink" title="1、RAM优化"></a>1、RAM优化</h5><p>主要是降低运行时内存。它的目的如下：</p><ul><li>防止应用发生OOM。</li><li>降低应用由于内存过大被LMK机制杀死的概率。</li><li>避免不合理使用内存导致GC次数增多，从而导致应用发生卡顿。</li></ul><h5 id="2、ROM优化"><a href="#2、ROM优化" class="headerlink" title="2、ROM优化"></a>2、ROM优化</h5><p>降低应用占ROM的体积。APK瘦身。它的目的为：</p><ul><li>降低应用占用空间，避免因ROM空间不足导致程序无法安装</li></ul><h4 id="内存问题"><a href="#内存问题" class="headerlink" title="内存问题"></a>内存问题</h4><p>那么，内存问题主要是有哪几类呢？下面我来一一叙述：</p><h5 id="1、内存抖动"><a href="#1、内存抖动" class="headerlink" title="1、内存抖动"></a>1、内存抖动</h5><p>内存波动图形呈锯齿张、GC导致卡顿。</p><p>这个问题在Dalvik虚拟机上会更加明显，而ART虚拟机在内存管理跟回收策略上都做了大量优化，内存分配和GC效率相比提升了5~10倍。</p><h5 id="2、内存泄漏"><a href="#2、内存泄漏" class="headerlink" title="2、内存泄漏"></a>2、内存泄漏</h5><p>对象被持有导致无法释放或不能按照对象正常的生命周期进行释放。</p><p>可用内存减少、频繁GC，容易导致内存泄漏。</p><h5 id="3、内存溢出"><a href="#3、内存溢出" class="headerlink" title="3、内存溢出"></a>3、内存溢出</h5><p>OOM、程序异常。</p><h3 id="二、常见工具选择"><a href="#二、常见工具选择" class="headerlink" title="二、常见工具选择"></a>二、常见工具选择</h3><p>在内存优化的上一篇我们已经介绍过了相关的工具，这里再简单回忆一下。</p><h4 id="1、Memory-Profiler"><a href="#1、Memory-Profiler" class="headerlink" title="1、Memory Profiler"></a>1、Memory Profiler</h4><p>它的作用如下：</p><ul><li>实时图表展示应用内存使用量</li><li>识别内存泄漏、抖动等</li><li>提供捕获堆转储、强制GC以及根据内存分配的能力</li></ul><p>它的优点即：</p><ul><li>方便直观</li><li>线下使用</li></ul><h4 id="2、Memory-Analyzer"><a href="#2、Memory-Analyzer" class="headerlink" title="2、Memory Analyzer"></a>2、Memory Analyzer</h4><p>强大的Java Heap分析工具，查找内存泄漏及内存占用<br>生成整体报告、分析问题等。建议线下深入使用。</p><h4 id="3、LeakCanary"><a href="#3、LeakCanary" class="headerlink" title="3、LeakCanary"></a>3、LeakCanary</h4><p>自动内存泄漏检测神器。仅用于线下集成。</p><p>它的缺点比较明显，虽然使用了idleHandler与多进程，但是dumphprof的SuspendAll Thread的特性依然会导致应用卡顿。<br>在三星等手机，系统会缓存最后一个Activity，此时应该采用更严格的检测模式。</p><h4 id="4、那么如何定制线上的LeakCanary？"><a href="#4、那么如何定制线上的LeakCanary？" class="headerlink" title="4、那么如何定制线上的LeakCanary？"></a>4、那么如何定制线上的LeakCanary？</h4><p>定制LeakCanary其实就是对haha组件来进行定制。haha库是square出品的一款<strong>自动分析Android堆栈的java库</strong>。haha库的<a href="https://github.com/square/haha" target="_blank" rel="external">链接地址</a>。</p><p>它的基本用法如下所示：</p><pre><code>// 导出堆栈文件File heapDumpFile = ...Debug.dumpHprofData(heapDumpFile.getAbsolutePath());// 根据堆栈文件创建出内存映射文件缓冲区DataBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);// 根据文件缓存区创建出对应的快照Snapshot snapshot = Snapshot.createSnapshot(buffer);// 从快照中获取指定的类ClassObj someClass = snapshot.findClass(&quot;com.example.SomeClass&quot;);</code></pre><p>在实现线上版的LeakCanary的时候主要要做2个工作：</p><ul><li>1、在过程中加上对大对象的分析过程。</li><li>2、解决掉将hprof文件映射到内存中的时候可能内存暴涨的问题。</li></ul><h4 id="5、实现内存泄漏监控闭环"><a href="#5、实现内存泄漏监控闭环" class="headerlink" title="5、实现内存泄漏监控闭环"></a>5、实现内存泄漏监控闭环</h4><p>在实现了线上版的LeakCanary之后，就需要将线上版的LeakCanary与服务器和前端页面结合起来。例如，当LeakCanary上发现内存泄漏时，手机将上传内存快照至服务器，此时服务器分析Hprof，如果不是系统原因导致误报则通过git得到该最近修改人，最后将内存泄漏bug单提交给负责人。该负责人通过前端实现的bug单系统即可看到自己新增的bug。</p><h3 id="三、Android内存管理机制回顾"><a href="#三、Android内存管理机制回顾" class="headerlink" title="三、Android内存管理机制回顾"></a>三、Android内存管理机制回顾</h3><p>ART和Dalvik虚拟机使用分页和内存映射来管理内存。下面我们先从Java的内存分配开始说起。</p><h4 id="1、Java内存分配"><a href="#1、Java内存分配" class="headerlink" title="1、Java内存分配"></a>1、Java内存分配</h4><p>Java的内存分配区域为如下几部分：</p><ul><li>方法区:主要存放静态常量</li><li>虚拟机栈：Java变量引用</li><li>本地方法栈：native变量引用</li><li>堆：对象</li><li>程序计数器：计算当前线程的当前方法执行到多少行</li></ul><h4 id="2、Java内存回收算法"><a href="#2、Java内存回收算法" class="headerlink" title="2、Java内存回收算法"></a>2、Java内存回收算法</h4><h5 id="1、标记-清除算法"><a href="#1、标记-清除算法" class="headerlink" title="1、标记-清除算法"></a>1、标记-清除算法</h5><p>流程可简述为两步：</p><ul><li>标记所有需要回收的对象</li><li>统一回收所有被标记的对象</li></ul><p>它的优点实现比较简单，缺点也很明显：</p><ul><li>标记、清除效率不高</li><li>产生大量内存碎片</li></ul><h5 id="2、复制算法"><a href="#2、复制算法" class="headerlink" title="2、复制算法"></a>2、复制算法</h5><p>流程可简述为三步：</p><ul><li>将内存划分为大小相等的两块</li><li>一块内存用完之后复制存活对象到另一块</li><li>清理另一块内存</li></ul><p>它的优点为 实现简单，运行高效，每次仅需遍历标记一半的内存区域。而缺点则会浪费一半空间，代价大。</p><h5 id="3、标记-整理算法"><a href="#3、标记-整理算法" class="headerlink" title="3、标记-整理算法"></a>3、标记-整理算法</h5><p>流程可简述为三步：</p><ul><li>标记过程与”标记-清除算法“一样</li><li>存活对象往一端进行移动</li><li>清理其余内存</li></ul><p>它的优点如下：</p><ul><li>避免标记-清除导致的内存碎片</li><li>避免复制算法的空间浪费</li></ul><h5 id="4、分代收集算法"><a href="#4、分代收集算法" class="headerlink" title="4、分代收集算法"></a>4、分代收集算法</h5><p>现在主流的虚拟机一般用的比较多的还是分带收集算法，它具有如下特点：</p><ul><li>结合多种算法优势</li><li>新生代对象存活率低，复制</li><li>老年代对象存活率高，标记-整理</li></ul><h4 id="3、Android内存管理机制"><a href="#3、Android内存管理机制" class="headerlink" title="3、Android内存管理机制"></a>3、Android内存管理机制</h4><p>Android中的内存是弹性分配的，分配值与最大值受具体设备影响。</p><p>对于OOM场景其实由细分为两种，一种是内存真正不足<br>了，二另一种则是可用内存不足。要注意一下这两种的区分。</p><p>以Android中的虚拟机的角度来说，我们要清楚Dalvik与Art区别，Dalvik仅固定一种回收算法，而Art回收算法可运行期选择，并且，Art具备内存整理能力，减少内存空洞。</p><p>最后，LMK机制（Low Memory killer）保证了进程资源的合理利用，它的实现原理主要是根据进程分类和回收收益来综合决定的。</p><h3 id="四、内存抖动"><a href="#四、内存抖动" class="headerlink" title="四、内存抖动"></a>四、内存抖动</h3><p>当内存频繁分配和回收导致内存不稳定，就会出现内存抖动，它通常表现为 <strong>频繁GC、内存曲线呈锯齿状</strong>。</p><p>它的危害也很严重，通常会导致页面卡顿，甚至造成OOM。</p><h4 id="那么为什么内存抖动会导致OOM？"><a href="#那么为什么内存抖动会导致OOM？" class="headerlink" title="那么为什么内存抖动会导致OOM？"></a>那么为什么内存抖动会导致OOM？</h4><p>主要原因有两点：</p><ul><li>频繁创建对象，导致内存不足及碎片（不连续）</li><li>不连续的内存片无法被分配，导致OOM</li></ul><h4 id="内存抖动解决实战"><a href="#内存抖动解决实战" class="headerlink" title="内存抖动解决实战"></a>内存抖动解决实战</h4><p>点击按钮使用handler发送一个空消息，handler的handleMessage接收到消息后创建内存抖动：即在for循环创建100个容量为10万的strings数组并在30ms后继续发送空消息。</p><p>一般使用Memory Profiler或CPU Profiler结合代码排查即可找到内存抖动出现的地方。</p><p>通常的技巧就是着重查看循环或频繁调用的地方。</p><p>下面列举一些导致内存抖动的常见案例：</p><h5 id="1、字符串使用加号拼接："><a href="#1、字符串使用加号拼接：" class="headerlink" title="1、字符串使用加号拼接："></a>1、字符串使用加号拼接：</h5><ul><li>使用StringBuilder替代。</li><li>初始化时设置容量，减少StringBuilder的扩容。</li></ul><h5 id="2、资源复用"><a href="#2、资源复用" class="headerlink" title="2、资源复用"></a>2、资源复用</h5><ul><li>使用全局缓存池，以重用频繁申请和释放的对象。</li><li>注意结束使用后，需要手动释放对象池中的对象。</li></ul><h5 id="3、减少不合理的对象创建"><a href="#3、减少不合理的对象创建" class="headerlink" title="3、减少不合理的对象创建"></a>3、减少不合理的对象创建</h5><ul><li>ondraw、getView中对象的创建尽量进行复用。</li><li>避免在循环中不断创建局部变量。</li></ul><h5 id="4、使用合理的数据结构"><a href="#4、使用合理的数据结构" class="headerlink" title="4、使用合理的数据结构"></a>4、使用合理的数据结构</h5><p>使用SparseArray类族来替代HashMap。</p><h3 id="五、内存优化体系搭建"><a href="#五、内存优化体系搭建" class="headerlink" title="五、内存优化体系搭建"></a>五、内存优化体系搭建</h3><p>在开始我们今天正式的主题之前，我们先来回归一下内存泄漏的概念与解决技巧。</p><p>所谓的内存泄漏就是<strong>内存中存在已经没有用的对象。</strong>它的表现一般为 内存抖动、可用内存逐渐减少。<br>它的危害即会导致内存不足、GC频繁、OOM。</p><p>内存泄漏的分析一般可简述为两步：</p><ul><li>1、使用Memory Profiler初步观察。</li><li>2、通过Memory Analyzer结合代码确认。</li></ul><h4 id="1、MAT回顾"><a href="#1、MAT回顾" class="headerlink" title="1、MAT回顾"></a>1、MAT回顾</h4><h5 id="MAT查找内存泄漏"><a href="#MAT查找内存泄漏" class="headerlink" title="MAT查找内存泄漏"></a>MAT查找内存泄漏</h5><p>首先找到当前Activity，在Histogram中选择其List Objects中的 with incoming reference（哪些强引用引向了我），然后选择当前的一个Path to GC Roots/Merge to GC Roots的exclude All 弱软虚引用。最后找到最后的泄漏对象在左下角下会有一个小圆圈。</p><h5 id="MAT的关键使用细节"><a href="#MAT的关键使用细节" class="headerlink" title="MAT的关键使用细节"></a>MAT的关键使用细节</h5><p>要全面掌握MAT的用法，必须先了解下面的一些细节：</p><ul><li>善于使用Regex查找对应泄漏类。</li><li>使用group by package查找对应包下的具体类。</li></ul><p>其次，要明白with outgoing references和with incoming references的区别。</p><p>with outgoing references为它引用了哪些对象，with incoming references为哪些对象引用了它。</p><p>还需要了解Shallow Heap和Retained Heap的区别。</p><p>Shallow Heap为对象自身占用的内存，而Retained Heap则还包含对象引用的对象所占用的内存。</p><p>除此之外，MAT共有5个关键组件帮助我们去分析内存方面的问题，他们分别是Dominator_tree<br>、Histogram、thread_overview、Top Consumers、Leak Suspects。下面我们简单地了解一下它们。</p><h5 id="Dominator（支配者）："><a href="#Dominator（支配者）：" class="headerlink" title="Dominator（支配者）："></a>Dominator（支配者）：</h5><p>如果从GC Root到达对象A的路径上必须经过对象B，那么B就是A的支配者。</p><h5 id="Histogram和dominator-tree的区别："><a href="#Histogram和dominator-tree的区别：" class="headerlink" title="Histogram和dominator_tree的区别："></a>Histogram和dominator_tree的区别：</h5><ul><li>Histogram显示Shallow Heap、Retained Heap、Objects，而dominator_tree显示的是Shallow Heap、Retained Heap、Percentage。</li><li>Histogram基于类的角度，dominator_tree是基于实例的角度。Histogram不会具体显示每一个泄漏的对象，而dominator_tree会。</li></ul><h5 id="thread-overview"><a href="#thread-overview" class="headerlink" title="thread_overview"></a>thread_overview</h5><p>查看有多少线程和线程的Shallow Heap、Retained Heap、Context Class Loader与is Daemon。</p><h5 id="Top-Consumers"><a href="#Top-Consumers" class="headerlink" title="Top Consumers"></a>Top Consumers</h5><p>通过图形的形式列出占用内存比较多的对象。</p><p>在下方的Biggest Objects还可以查看其相对比较详细的信息，如Shallow Heap、Retained Heap。</p><h5 id="Leak-Suspects"><a href="#Leak-Suspects" class="headerlink" title="Leak Suspects"></a>Leak Suspects</h5><p>列出有内存泄漏的地方，点击Details可以查看其产生内存泄漏的引用链。</p><p>最后，我列举一些内存泄漏优化的技巧：</p><ul><li>1、使用类似Hack的方式修复系统内存泄漏：<br>LeakCanary的AndroidExcludeRefs列出了一些由于系统原因导致引用无法释放的例子，可使用类似Hack的方式去修复。</li><li>2、Activity的兜底内存回收策略：<br>在Activity的onDestory中递归释放其引用到的Bitmap、DrawingCache等资源，降低发生内存泄漏对应用内存的压力。</li></ul><h4 id="2、建立线上内存泄漏监控组件：使用定制化的LeakCanary"><a href="#2、建立线上内存泄漏监控组件：使用定制化的LeakCanary" class="headerlink" title="2、建立线上内存泄漏监控组件：使用定制化的LeakCanary"></a>2、建立线上内存泄漏监控组件：使用定制化的LeakCanary</h4><p>在线上也可以使用类似LeakCanary的自动化检测方案，但是需要对生成的Hprof内存快照文件做一些优化，裁剪大部分图片对应的byte数据以减少文件开销，最后使用7zip压缩，一般可节省90%大小。</p><h4 id="3、建立线上OOM监控组件：Probe"><a href="#3、建立线上OOM监控组件：Probe" class="headerlink" title="3、建立线上OOM监控组件：Probe"></a>3、建立线上OOM监控组件：Probe</h4><p>美团Android内存泄漏自动化链路分析组件Probe<br>在OOM时生成Hprof内存快照，然后通过单独进程对这个文件做进一步分析。</p><p>它的缺点比较多，具体为如下几点：</p><ul><li>在崩溃的时候生成内存快照容易导致二次崩溃。</li><li>部分手机生成Hprof快照比较耗时。</li><li>部分OOM是由虚拟内存不足导致。</li></ul><p>在实现自动化链路分析组件Probe的过程中主要要解决如下问题：</p><h5 id="1、链路分析时间过长"><a href="#1、链路分析时间过长" class="headerlink" title="1、链路分析时间过长"></a>1、链路分析时间过长</h5><ul><li>使用链路归并，将具有相同层级与结构的链路进行合并。</li><li>使用自适应扩容法，通过不断比较现有链路和新链路，结合扩容因子，逐渐完善为完整的泄漏链路。</li></ul><h5 id="2、分析进程占用内存过大"><a href="#2、分析进程占用内存过大" class="headerlink" title="2、分析进程占用内存过大"></a>2、分析进程占用内存过大</h5><p>分析进程占用的内存跟内存快照文件的大小不成正相关，而跟内存快照文件的Instance数量呈正相关。所以应该尽可能排除不需要的Instance实例。</p><h5 id="Prope分析流程"><a href="#Prope分析流程" class="headerlink" title="Prope分析流程"></a>Prope分析流程</h5><p>1、hprof 映射到内存 -&gt; 解析成Snapshot &amp; 计数压缩：</p><p>解析后的Snapshot中的Heap有四种类型，具体为：</p><ul><li>DefaultHeap</li><li>ImageHeap</li><li>App Heap：包括ClassInstance、ClassObj、ArrayInstance、RootObj。</li><li>System Heap</li></ul><p>解析完后使用了计数压缩策略，对相同的Instance使用计数，以减少占用内存。超过计数阈值的需要计入计数桶（计数桶记录了丢弃个数和每个Instance的大小）。</p><p>2、生成Dominator Tree。</p><p>3、计算RetainSize。</p><p>4、生成Reference链 &amp; 基础数据类型增强:</p><p>如果对象是基础数据类型，会将自身的RetainSize累加到父节点上，将怀疑对象替换为它的父节点。</p><p>5、链路归并。</p><p>6、计数桶补偿 &amp; 基础数据类型和父节点融合：</p><p>使用计数补偿策略计算RetainSize，主要是判断对象是否在计数桶中，如果在的话则将丢弃的个数和大小补偿到对象上，累积计算RetainSize，最后对RetainSize排序以查找可疑对象。</p><p>7、排序扩容。</p><p>8、查找泄露链路。</p><p>总体架构图如下：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/probe.jpg?raw=true" alt="image"></p><h4 id="4、实现单机版的Profile-Memory自动化内存分析"><a href="#4、实现单机版的Profile-Memory自动化内存分析" class="headerlink" title="4、实现单机版的Profile - Memory自动化内存分析"></a>4、实现单机版的Profile - Memory自动化内存分析</h4><p><a href="https://github.com/JsonChao/Chapter03" target="_blank" rel="external">项目地址点击此处</a></p><p>在配置的时候要注意两个问题：</p><ul><li>1、liballoc-lib.so在构建后工程的build-&gt;intermediates-&gt;cmake目录下。将对应的cpu abi目录拷贝到新建的libs目录下。</li><li>2、在DumpPrinter Java库的build.gradle中的jar闭包中需要加入以下代码以识别源码路径</li></ul><pre><code>sourceSets.main.java.srcDirs = [&apos;src&apos;]</code></pre><p>具体的使用步骤如下：</p><p>1、点击”开<br>始记录“按钮可以看到触发对象分配的记录，说明对象已经开始记录对象的分配。</p><pre><code>12-26 10:54:03.963 30450-30450/com.dodola.alloctrack I/AllocTracker: ====current alloc count 388=====</code></pre><p>2、然后，点击多次”生成1000个对象“按钮，当对象达到设置的最大数量的时候触发内存dump，会得到保存数据路径的日志。</p><pre><code>12-26 10:54:03.963 30450-30450/com.dodola.alloctrack I/AllocTracker: ====current alloc count 388=====12-26 10:56:45.103 30450-30450/com.dodola.alloctrack I/AllocTracker: saveARTAllocationData write file to /storage/emulated/0/crashDump/1577329005</code></pre><p>3、可以看到数据保存在sdk下的crashDump目录下。</p><p>4、此时，通过gradle task :buildAlloctracker任务编译出存放在tools/DumpPrinter-1.0.jar的dump工具，然后采用如下命令来将数据解析到dump_log.txt文件中。</p><pre><code>java -jar tools/DumpPrinter-1.0.jar dump文件路径 &gt; dump_log.txt</code></pre><p>5、最后，就可以在dump_log.txt文件中看到解析出来的数据，如下所示：</p><pre><code>Found 4949 records:tid=1 byte[] (94208 bytes)    dalvik.system.VMRuntime.newNonMovableArray (Native method)    android.graphics.Bitmap.nativeCreate (Native method)    android.graphics.Bitmap.createBitmap (Bitmap.java:975)    android.graphics.Bitmap.createBitmap (Bitmap.java:946)    android.graphics.Bitmap.createBitmap (Bitmap.java:913)    android.graphics.drawable.RippleDrawable.updateMaskShaderIfNeeded (RippleDrawable.java:776)    android.graphics.drawable.RippleDrawable.drawBackgroundAndRipples (RippleDrawable.java:860)    android.graphics.drawable.RippleDrawable.draw (RippleDrawable.java:700)    android.view.View.getDrawableRenderNode (View.java:17736)    android.view.View.drawBackground (View.java:17660)    android.view.View.draw (View.java:17467)    android.view.View.updateDisplayListIfDirty (View.java:16469)    android.view.ViewGroup.recreateChildDisplayList (ViewGroup.java:3905)    android.view.ViewGroup.dispatchGetDisplayList (ViewGroup.java:3885)    android.view.View.updateDisplayListIfDirty (View.java:16429)    android.view.ViewGroup.recreateChildDisplayList (ViewGroup.java:3905)</code></pre><h4 id="5、图片监控体系搭建"><a href="#5、图片监控体系搭建" class="headerlink" title="5、图片监控体系搭建"></a>5、图片监控体系搭建</h4><p>在介绍图片监控体系的搭建之前，首先我们来回顾下Android Bitmap内存分配的变化：</p><p><strong>在Android 3.0之前</strong></p><ul><li>Bitmap对象存放在Java Heap，而像素数据是存放在Native内存中的。</li><li>如果不手动调用recycle，Bitmap Native内存的回收完全依赖finalize函数回调，但是回调时机是不可控的。</li></ul><p><strong>Android 3.0 ~ Android 7.0</strong></p><p>将Bitmap对象和像素数据统一放到Java Heap中，即使不调用recycle，Bitmap像素数据也会随着对象一起被回收。</p><p>Bitmap全部放在Java Heap中的缺点很明显：</p><ul><li>1、Bitmap是内存消耗的大户，而Max Java Heap一般限制为256、512MB，Bitmap过大过多容易导致OOM。</li><li>2、容易引起大量GC，没有充分利用系统的可用内存。</li></ul><p><strong>Android 8.0及之后</strong></p><ul><li>使用了能够辅助回收Native内存的NativeAllocationRegistry，以实现将像素数据放到Native内存中，并且可以和Bitmap对象一起快速释放，最后，在GC的时候还可以考虑这些Bitmap内存以防止被滥用。</li><li>Android 8.0为了解决图片内存占用过多和图像绘制效率过慢的问题新增了硬件位图Hardware Bitmap。</li></ul><h5 id="那么，如何将图片内存存放在Native中呢？"><a href="#那么，如何将图片内存存放在Native中呢？" class="headerlink" title="那么，如何将图片内存存放在Native中呢？"></a>那么，如何将图片内存存放在Native中呢？</h5><ul><li>1、调用libandroid_runtime.so中的Bitmap构造函数，申请一张空的Native Bitmap。对于不同Android版本而言，这里的获取过程都有一些差异需要适配。</li><li>2、申请一张普通的Java Bitmap。</li><li>3、将Java Bitmap的内容绘制到Native Bitmap中。</li><li>4、释放Java Bitmap内存。</li></ul><p>我们都知道，当系统内存不足，LMK会根据OOM_adj开始杀进程，从后台、桌面、服务、前台，直到手机重启。并且，如果频繁申请释放Java Bitmap也很容易导致内存抖动。对于这种种问题，我们如何评估内存对应用性能的影响呢？</p><p>主要从以下两个方面进行评估：</p><ul><li>1、崩溃中异常退出和OOM的比例。</li><li>2、低内存设备更容易出现内存不足和卡顿，需要查看应用中用户的手机内存在2GB以下所占的比例。</li></ul><p>对于具体的优化策略，我们可以从以下几个方面来进行。</p><h5 id="1、设备分级"><a href="#1、设备分级" class="headerlink" title="1、设备分级"></a>1、设备分级</h5><p>内存优化首先需要根据设备环境来综合考虑，让高端设备使用更多的内存，做到针对设备性能的好坏使用不同的内存分配和回收策略。</p><p>使用类似device-year-class的策略对设备进行分级，对于低端机用户可以关闭复杂的动画或”重功能“，使用565格式的图片或更小的缓存内存等。</p><p>业务开发人员需要考虑功能是否对低端机开启，在系统资源不够时主动去做降级处理。</p><h5 id="2、建立统一的缓存管理组件"><a href="#2、建立统一的缓存管理组件" class="headerlink" title="2、建立统一的缓存管理组件"></a>2、建立统一的缓存管理组件</h5><p>建立统一的缓存管理组件，合理使用OnTrimMemory回调，根据系统不同的状态去释放相应的内存。</p><p>在实现过程中，需要解决使用static LRUCache来缓存大尺寸Bitmap等问题。</p><p>并且，在通过实际的测试后，发现onTrimMemory的ComponetnCallbacks2.TRIM_MEMORY_COMPLETE并不等价于onLowMemory，因此建议仍然要去监听onLowMemory回调。</p><h5 id="3、低端机避免使用多进程"><a href="#3、低端机避免使用多进程" class="headerlink" title="3、低端机避免使用多进程"></a>3、低端机避免使用多进程</h5><p>一个空进程也会占用10MB内存，低端机应该尽可能减少使用多进程。</p><p>针对低端机用户可以推出4MB的轻量级版本，如今日头条极速版、Facebook Lite。</p><h5 id="4、统一图片库"><a href="#4、统一图片库" class="headerlink" title="4、统一图片库"></a>4、统一图片库</h5><p>需要收拢图片的调用，避免使用Bitmap.createBitmap、BitmapFactory相关的接口创建Bitmap，应该使用自己的图片框架。</p><h5 id="5、线下大图片检测"><a href="#5、线下大图片检测" class="headerlink" title="5、线下大图片检测"></a>5、线下大图片检测</h5><p>在开发过程中，如果检测到不合规的图片使用（如图片宽度超过View的宽度甚至图片宽度），应该立刻提示图片所在的Activity和堆栈，让开发人员更快发现并解决问题。在灰度和线上环境，可以将异常信息上报到后台，还可以计算超宽率（图片超过屏幕大小所占图片总数的比例）。</p><p><strong>常规实现</strong>：</p><p>继承ImageView，重写实现计算图片大小。但是侵入性强，并且不通用。</p><p>下面介绍一下ARTHook的方案。</p><p><strong>ARTHook优雅检测大图</strong></p><p>ARTHook，即挂钩，用额外的代码勾住原有的方法，以修改执行逻辑，主要用于以下几方面：</p><ul><li>1、AOP变成</li><li>2、运行时插桩</li><li>3、性能分析</li><li>4、安全审计</li></ul><p>具体我们是使用Epic来进行Hook，Epic是一个虚拟机层面，以Java方法为粒度的运行时Hook框架。简单来说，它就是ART上的Dexposed，并且它目前支持Android 4.0~10.0。</p><p><a href="https://github.com/tiann/epic/blob/master/README_cn.md" target="_blank" rel="external">Epic github地址</a></p><p>Epic的使用可简述为：</p><p>1、在build.gradle中添加</p><pre><code>compile &apos;me.weishu:epic:0.6.0&apos;</code></pre><p>2、继承XC_MethodHook，实现Hook方法前后的逻辑。如监控Java线程的创建和销毁：</p><pre><code>class ThreadMethodHook extends XC_MethodHook{    @Override    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {        super.beforeHookedMethod(param);        Thread t = (Thread) param.thisObject;        Log.i(TAG, &quot;thread:&quot; + t + &quot;, started..&quot;);    }    @Override    protected void afterHookedMethod(MethodHookParam param) throws Throwable {        super.afterHookedMethod(param);        Thread t = (Thread) param.thisObject;        Log.i(TAG, &quot;thread:&quot; + t + &quot;, exit..&quot;);    }}</code></pre><p>3、注入Hook好的方法：</p><pre><code>DexposedBridge.findAndHookMethod(Thread.class, &quot;run&quot;, new ThreadMethodHook());</code></pre><p>知道了Epic的基本使用方法之后，我们便可以利用它来进行大图片的监控报警了。</p><p>以<a href="">Awesome-WanAndroid</a>项目为例，首先，在WanAndroidApp的onCreate方法中添加如下代码：</p><pre><code>DexposedBridge.hookAllConstructors(ImageView.class, new XC_MethodHook() {        @Override        protected void afterHookedMethod(MethodHookParam param) throws Throwable {            super.afterHookedMethod(param);        // 这里找到所有通过ImageView的setImageBitmap方法设置的切入点，        // 其中最后一个参数ImageHook对象是继承了XC_MethodHook类以便于        // 重写afterHookedMethod方法拿到相应的参数进行监控逻辑的判断        DexposedBridge.findAndHookMethod(ImageView.class, &quot;setImageBitmap&quot;, Bitmap.class, new ImageHook());        }    });</code></pre><p>接下来，我们来实现我们的ImageHook类，如下所示：</p><pre><code>public class ImageHook extends XC_MethodHook {    @Override    protected void afterHookedMethod(MethodHookParam param) throws Throwable {        super.afterHookedMethod(param);        // 实现我们的逻辑        ImageView imageView = (ImageView) param.thisObject;        checkBitmap(imageView,((ImageView) param.thisObject).getDrawable());    }    private static void checkBitmap(Object thiz, Drawable drawable) {        if (drawable instanceof BitmapDrawable &amp;&amp; thiz instanceof View) {            final Bitmap bitmap = ((BitmapDrawable) drawable).getBitmap();            if (bitmap != null) {                final View view = (View) thiz;                int width = view.getWidth();                int height = view.getHeight();                if (width &gt; 0 &amp;&amp; height &gt; 0) {                    // 图标宽高都大于view的2倍以上，则警告                    if (bitmap.getWidth() &gt;= (width &lt;&lt; 1)                        &amp;&amp;  bitmap.getHeight() &gt;= (height &lt;&lt; 1)) {                    warn(bitmap.getWidth(), bitmap.getHeight(), width, height, new RuntimeException(&quot;Bitmap size too large&quot;));                }                } else {                    // 当宽高度等于0时，说明ImageView还没有进行绘制，使用ViewTreeObserver进行大图检测的处理。                    final Throwable stackTrace = new RuntimeException();                    view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {                        @Override                        public boolean onPreDraw() {                            int w = view.getWidth();                            int h = view.getHeight();                            if (w &gt; 0 &amp;&amp; h &gt; 0) {                                if (bitmap.getWidth() &gt;= (w &lt;&lt; 1)                                    &amp;&amp; bitmap.getHeight() &gt;= (h &lt;&lt; 1)) {                                    warn(bitmap.getWidth(), bitmap.getHeight(), w, h, stackTrace);                                }                                view.getViewTreeObserver().removeOnPreDrawListener(this);                            }                            return true;                        }                    });                }            }        }    }    private static void warn(int bitmapWidth, int bitmapHeight, int viewWidth, int viewHeight, Throwable t) {        String warnInfo = &quot;Bitmap size too large: &quot; +            &quot;\n real size: (&quot; + bitmapWidth + &apos;,&apos; + bitmapHeight + &apos;)&apos; +            &quot;\n desired size: (&quot; + viewWidth + &apos;,&apos; + viewHeight + &apos;)&apos; +            &quot;\n call stack trace: \n&quot; + Log.getStackTraceString(t) + &apos;\n&apos;;        LogHelper.i(warnInfo);    }}</code></pre><p>在上面，我们重写了ImageHook的afterHookedMethod方法，拿到了当前的ImageView和要设置的Bitmap对象，如果当前ImageView的宽高大于0，我们便进行大图检测的处理：ImageView的宽高都大于View的2倍以上，则警告，如果当前ImageView的宽高等于0，则说明ImageView还没有进行绘制，则使用ImageView的ViewTreeObserer获取其宽高进行大图检测的处理。至此，我们的大图检测检测组件就实现了。</p><p><strong>ARTHook方案实现小结</strong></p><ul><li>1、无侵入性</li><li>2、通用性强</li><li>3、兼容性问题大，开源方案不能带到线上环境。</li></ul><h5 id="6、线下重复图片检测"><a href="#6、线下重复图片检测" class="headerlink" title="6、线下重复图片检测"></a>6、线下重复图片检测</h5><p><a href="完全配置好的项目请参见https://github.com/JsonChao/Chapter04">项目地址</a></p><p>首先我们来了解一下这里的重复图片所指的概念：<br>即Bitmap像素数据完全一致，但是有多个不同的对象存在。</p><p>使用内存Hprof分析工具，自动将重复Bitmap的图片和引用堆栈输出。具体实现步骤如下：</p><ul><li>1、获取 android.graphics.Bitmap 实例对象的 mBuffer 为 ArrayInstance ，通过 getValues 获取数据为 Object 类型，后面计算 md5 需要为 byte[] 类型，所以通过反射的方式调用 ArrayInstance#asRawByteArray 直接返回 byte[] 数据。</li><li>2、根据 mBuffer 的数据生成 png 图片文件，参考了 <a href="https://github.com/JetBrains/adt-tools-base/blob/master/ddmlib/src/main/java/com/android/ddmlib/BitmapDecoder.java" target="_blank" rel="external">https://github.com/JetBrains/adt-tools-base/blob/master/ddmlib/src/main/java/com/android/ddmlib/BitmapDecoder.java</a> 实现。</li><li>3、获取堆栈信息，直接使用LeakCanary获取stack的方法，使用leakcanary-analyzer-1.6.2.jar 和 leakcanary-watcher-1.6.2.jar 这两个库文件。并用反射的方式调用了HeapAnalyzer#findLeakTrace 方法。</li></ul><p>其中，获取堆栈的信息也可以直接使用haha库来进行获取。这里简单说一下使用haha库获取堆栈的流程。</p><ul><li>1、预备一个已经存在重复bitmap的hprof文件。</li><li>2、利用HAHA库上的MemoryMappedFileBuffer读取hrpof文件 [关键代码 new MemoryMappedFileBuffer(heapDumpFile) ]</li><li>3、解析生成snapshot，获取heap，这里我只获取了app heap [关键代码 snapshot.getHeaps(); heap.getName().equals(“app”) ]</li><li>4、从snapshot中根据指定class查找出所有的Bitmap Classes [关键代码snapshot.findClasses(Bitmap.class.getName()) ]</li><li>5、从heap中获得所有的Bitmap实例instance [关键代码 clazz.getHeapInstances(heap.getId()) ]</li><li>6、根据instance中获取所有的属性信息Field[]，并从Field[]查找出我们需要的”mWidth” “mHeight” “mBuffer”信息</li><li>7、通过”mBuffer”属性即可获取他们的hashcode来判断相同</li><li>8、最后通过instance中mNextInstanceToGcRoot获取整个引用链信息并打印。</li></ul><p>在实现图片内存监控的过程中，应注意一下两点：</p><ul><li>1、在线上可以按照不同的系统、屏幕分辨率等纬度去分析图片内存的占用情况。</li><li>2、在OOM崩溃时，可以将图片总内存、Top N图片占用内存写入崩溃日志。</li></ul><h5 id="7、建立全局Bitmap监控"><a href="#7、建立全局Bitmap监控" class="headerlink" title="7、建立全局Bitmap监控"></a>7、建立全局Bitmap监控</h5><p>为了建立全局的Bitmap监控，我们必须对Bitmap的分配和回收进行追踪。我们先来看看Bitmap有哪些特点：</p><ul><li>创建场景比较单一：在Java层调用Bitmap.create或BitmapFactory等方法创建，可以封装一层对Bitmap创建的接口，注意要包含调用外部库产生的Bitmap。</li><li>创建频率比较低。</li><li>和Java对象的生命周期一样服从GC，可以使用WeakReference来追踪Bitmap的销毁。</li></ul><p>根据以上特点，我们可以建立一套Bitmap的高性价比监控组件：</p><ul><li>1、首先，在接口层将所有创建出来的Bitmap放入一个WeakHashMap中，并记录创建Bitmap的数据、堆栈等信息，然后每隔一定时间查看WeakHashMap中有哪些Bitmap仍然存活来判断是否出现Bitmap滥用或泄漏。</li><li>2、这个方案性能消耗很低，可以在正式环境中进行。注意正式与测试环境需要采用不同程度的监控。</li></ul><h4 id="6、建立全局的线程监控组件"><a href="#6、建立全局的线程监控组件" class="headerlink" title="6、建立全局的线程监控组件"></a>6、建立全局的线程监控组件</h4><p>每个线程初始化都需要mmap一定的栈大小，在默认情况下初始化一个线程需要mmap 1MB左右的内存空间，在32bit的应用中有4g的vmsize，实际能使用的有3g+，这样一个进程最大能创建的线程数可以达到3000个，但是linux对每个进程可创建的线程数也有一定的限制（/proc/pid/limits），并且不同厂商也能修改这个限制，超过该限制就会OOM。</p><p>对线程数量的限制，一定程度上可以避免OOM的发生。</p><h5 id="线程监控组件的实现原理"><a href="#线程监控组件的实现原理" class="headerlink" title="线程监控组件的实现原理"></a>线程监控组件的实现原理</h5><p>在线下或灰度的环境下通过一个定时器每隔10分钟dump出应用所有的线程相关信息，当线程数超过当前阈值时，将当前的线程信息上报并预警。</p><h4 id="7、建立线上应用内存监控体系"><a href="#7、建立线上应用内存监控体系" class="headerlink" title="7、建立线上应用内存监控体系"></a>7、建立线上应用内存监控体系</h4><p>具体的相关数据获取方式如下：</p><ul><li>1、首先，ActivityManager的getProcessMemoryInfo -&gt; Debug.MemoryInfo数据。</li><li>2、通过hook Debug.MemoryInfo的getMemoryStat方法（os v23及以上）可以获得Memory Profiler中的多项数据，进而获得细分内存使用情况。</li><li>3、通过Runtime获取DalvikHeap。</li><li>4、通过Debug.getNativeHeapAllocatedSize获取NativeHeap。</li></ul><p>对于监控场景，需要划分为两大类：</p><h5 id="1、常规内存监控"><a href="#1、常规内存监控" class="headerlink" title="1、常规内存监控"></a>1、常规内存监控</h5><p>根据斐波那契数列每隔一段时间（max：30min）获取内存的使用情况。内存监控方法有多种实现方式，我们先来介绍几种常规方式。</p><p><strong>针对场景进行线上Dump内存的方式</strong>：</p><p>具体使用Debug.dumpHprofData()实现。</p><p>其实现的流程为：</p><ul><li>1、超过最大内存的80%</li><li>2、内存Dump</li><li>3、回传文件</li><li>4、MAT手动分析</li></ul><p>但是有如下缺点：</p><ul><li>1、Dump文件太大，和对象数正相关，可以进行裁剪。</li><li>2、上传失败率高，分析困难。</li></ul><p><strong>LeakCanary带到线上的方式</strong>：</p><p>预设泄漏怀疑点，一旦发现泄漏进行回传。但这种实现方式缺点比较明显：</p><ul><li>不适合所有情况，需要预设怀疑点。</li><li>分析比较耗时，容易导致OOM。</li></ul><p><strong>定制LeakCanary方式</strong></p><p>定制LeakCanary需要解决以上产生的一些问题，下面这里分别列出对应的解决方案：</p><ul><li>1、预设怀疑点-&gt;自动找怀疑点。</li><li>2、分析泄漏链路慢-&gt;分析Retain size大的对象。</li><li>3、分析OOM-&gt;对象裁剪，不全部加载到内存。</li></ul><h5 id="2、低内存监控"><a href="#2、低内存监控" class="headerlink" title="2、低内存监控"></a>2、低内存监控</h5><ul><li>利用onLowMemory、onTrimMemory监听物理内存警告。</li><li>代码设置超过虚拟内存大小最大限制的90%则直接触发内存警告。</li><li>对于监控指标，一般为：发生频率、发生时各项内存使用状况、发生时App的当前场景。</li></ul><p>并且，为了准确衡量内存性能，我们引入了内存异常率和触顶率的指标。</p><p><strong>内存异常率</strong></p><p>内存UV异常率 = PSS 超过400MB的UV / 采集UV，PSS获取：通过Debug.MemoryInfo。</p><p>如果出现新的内存使用不当或内存泄漏的场景，这个指标会有所上涨。</p><p><strong>触顶率</strong></p><p>内存UV触顶率 = Java堆占用超过最大堆限制的85%的UV / 采集UV</p><p>计算触顶率的代码如下所示：</p><pre><code>long javaMax = Runtime.maxMemory();long javaTotal = Runtime.totalMemory();long javaUsed = javaTotal - runtime.freeMemory();float proportion = (float) javaUsed / javaMax;</code></pre><p>如果超过85%最大堆限制，GC会变得更加频发，容易造成OOM和卡顿。</p><p>这里小结一下，客户端只负责上报数据，由后台来计算平均PSS、图片内存、Java内存、异常率、触顶率等指标值，这样便可以通过版本对比来监控是否有新增内存问题。因此，建立线上监控完整方案需包含以下几点：</p><ul><li>待机内存、重点模块内存、OOM率。</li><li>整体及重点模块GC次数、GC时间。</li><li>增强的LeakCanry自动化内存泄漏分析。</li><li>低内存监控模块的设置。</li></ul><h4 id="8、GC监控组件搭建"><a href="#8、GC监控组件搭建" class="headerlink" title="8、GC监控组件搭建"></a>8、GC监控组件搭建</h4><p>通过Debug.startAllocCounting来监控GC情况，注意有一定性能影响。</p><p>在Android 6.0之前可以拿到内存分配次数和大小以及GC次数，代码如下所示：</p><pre><code>long allocCount = Debug.getGlobalAllocCount();long allocSize = Debug.getGlobalAllocSize();long gcCount = Debug.getGlobalGcInvocationCount();</code></pre><p>并且，在Android 6.0后可以拿到更精准的GC信息：</p><pre><code>Debug.getRuntimeStat(&quot;art.gc.gc-count&quot;);Debug.getRuntimeStat(&quot;art.gc.gc-time&quot;);Debug.getRuntimeStat(&quot;art.gc.blocking-gc-count&quot;);Debug.getRuntimeStat(&quot;art.gc.blocking-gc-time&quot;);</code></pre><p>一般关注阻塞式GC的次数和耗时，因为它会暂停线程，可能导致应用发生卡顿。建议仅对重度场景使用。</p><h4 id="9、设置内存兜底策略"><a href="#9、设置内存兜底策略" class="headerlink" title="9、设置内存兜底策略"></a>9、设置内存兜底策略</h4><p>设置内存兜底策略的目的，是为了在用户无感知的情况下，在接近触发系统异常前，选择合适的场景杀死进程并将其重启，从而使得应用内存占用回到正常情况。</p><p>一般进行执行内存兜底策略时需要满足以下条件：</p><ul><li>是否在主界面退到后台且位于后台时间超过30min。</li><li>当前时间为早上2~5点。</li><li>不存在前台服务（通知栏、音乐播放栏等情况）。</li><li>java heap必须大于当前进程最大可分配的85% || native内存大于800MB </li><li>vmsize超过了4G（32bit）的85%。</li><li>非大量的流量消耗（不超过1M/min） &amp;&amp; 进程无大量CPU调度情况。</li></ul><p>满足以上条件则杀死当前主进程并通过push进程重新拉起及初始化。</p><h4 id="10、内存优化的一些策略"><a href="#10、内存优化的一些策略" class="headerlink" title="10、内存优化的一些策略"></a>10、内存优化的一些策略</h4><p>下面列举一些我在内存优化过程中常用的一些策略。</p><h5 id="1、使bitmap资源在native中分配："><a href="#1、使bitmap资源在native中分配：" class="headerlink" title="1、使bitmap资源在native中分配："></a>1、使bitmap资源在native中分配：</h5><p>对于Android 2.x系统，使用反射将BitmapFactory.Options里面隐藏的inNativeAlloc打开。</p><p>对于Android 4.x系统，使用Fresco将bitmap资源在native中分配。</p><h5 id="2、使用inSampleSize避免不必要的大图加载。"><a href="#2、使用inSampleSize避免不必要的大图加载。" class="headerlink" title="2、使用inSampleSize避免不必要的大图加载。"></a>2、使用inSampleSize避免不必要的大图加载。</h5><h5 id="3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try-catch将其捕获，然后清除图片cache，尝试降低bitmap-format（ARGB8888、RGB565、ARGB4444、ALPHA8）。"><a href="#3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try-catch将其捕获，然后清除图片cache，尝试降低bitmap-format（ARGB8888、RGB565、ARGB4444、ALPHA8）。" class="headerlink" title="3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try catch将其捕获，然后清除图片cache，尝试降低bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。"></a>3、使用Glide、Fresco等图片加载库，通过定制，在加载bitmap时，若发生OOM，则使用try catch将其捕获，然后清除图片cache，尝试降低bitmap format（ARGB8888、RGB565、ARGB4444、ALPHA8）。</h5><h5 id="4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80-）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。"><a href="#4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80-）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。" class="headerlink" title="4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。"></a>4、前台每隔3分钟去获取当前应用内存占最大内存的比例，超过设定的危险阈值（如80%）则主动释放应用cache（Bitmap为大头），并且显示地除去应用的memory，以加速内存收集的过程。</h5><p>计算当前应用内存占最大内存的比例的代码如下：</p><pre><code>max = Runtime.getRuntime().maxMemory();available = Runtime.getRuntime.totalMemory() - Runtime.getFreeMemory();ratio =available / max;</code></pre><p>显示地除去应用的memory，以加速内存收集的过程的代码如下：</p><pre><code>WindowManagerGlobal.getInstance().startTrimMemory(TRIM_MEMORY_COMPLETE);</code></pre><h5 id="5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。"><a href="#5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。" class="headerlink" title="5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。"></a>5、由于webview存在内存系统泄漏，还有图库占用内存过多的问题，可以采用单独的进程。</h5><h5 id="6、应用发生OOM时，需要上传更加详细的内存相关信息。"><a href="#6、应用发生OOM时，需要上传更加详细的内存相关信息。" class="headerlink" title="6、应用发生OOM时，需要上传更加详细的内存相关信息。"></a>6、应用发生OOM时，需要上传更加详细的内存相关信息。</h5><h5 id="7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。"><a href="#7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。" class="headerlink" title="7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。"></a>7、当应用使用的Service不再使用时应该销毁它，建议使用IntentServcie。</h5><h5 id="8、当UI隐藏时释放内存"><a href="#8、当UI隐藏时释放内存" class="headerlink" title="8、当UI隐藏时释放内存"></a>8、当UI隐藏时释放内存</h5><p>当用户切换到其它应用并且你的应用UI不再可见时，应该释放应用UI所占用的所有内存资源。这能够显著增加系统缓存进程的能力，能够提升用户体验。</p><p>在所有UI组件都隐藏的时候会接收到Activity的onTrimMemory()回调并带有参数TRIM_MEMORY_UI_HIDDEN。</p><h5 id="9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。"><a href="#9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。" class="headerlink" title="9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。"></a>9、谨慎使用第三方库，避免为了使用其中一两个功能而导入一个大而全的解决方案。</h5><h3 id="六、线下Native内存泄漏监控搭建"><a href="#六、线下Native内存泄漏监控搭建" class="headerlink" title="六、线下Native内存泄漏监控搭建"></a>六、线下Native内存泄漏监控搭建</h3><p>在Android 8.0之后，可以使用Address Sanitizer、Malloc调试和Malloc钩子进行native内存分析，参见<a href="https://source.android.com/devices/tech/debug/native-memory" target="_blank" rel="external">native_memory</a></p><p>对于线下Native内存泄漏监控的建立，主要针对是否能重编so的情况来进行记录分配的内存信息。</p><h4 id="针对无法重编so的情况"><a href="#针对无法重编so的情况" class="headerlink" title="针对无法重编so的情况"></a>针对无法重编so的情况</h4><ul><li>使用PLT Hook拦截库的内存分配函数，然后重定向到我们自己的实现后去记录分配的内存地址、大小、来源so库路径等信息。</li><li>定期扫描分配与释放释放配对，对于不配对的分配输出上述记录的信息。</li></ul><h4 id="针对可重编的so情况"><a href="#针对可重编的so情况" class="headerlink" title="针对可重编的so情况"></a>针对可重编的so情况</h4><ul><li>通过GCC的”-finstrument-functions“参数给所有函数插桩，然后在桩中模拟调用栈的入栈与出栈操作。</li><li>通过ld的”–warp“参数拦截内存分配和释放函数，重定向到我们自己的实现后记录分配的内存地址、大小、来源so以及插桩调用栈此刻的内容。</li><li>定期扫描分配与释放是否配对，对于不配对的分配输出我们记录的信息。</li></ul><h3 id="七、内存优化演进"><a href="#七、内存优化演进" class="headerlink" title="七、内存优化演进"></a>七、内存优化演进</h3><h4 id="1、自动化测试阶段"><a href="#1、自动化测试阶段" class="headerlink" title="1、自动化测试阶段"></a>1、自动化测试阶段</h4><p>内存达到阈值后自动触发Hprof Dump，将得到的Hprof存档后由人工通过MAT进行分析。</p><h4 id="2、LeakCanary"><a href="#2、LeakCanary" class="headerlink" title="2、LeakCanary"></a>2、LeakCanary</h4><p>检测和分析报告都在一起，批量自动化测试和事后分析不太方便。</p><h4 id="3、使用基于LeakCannary的改进版ResourceCanary"><a href="#3、使用基于LeakCannary的改进版ResourceCanary" class="headerlink" title="3、使用基于LeakCannary的改进版ResourceCanary"></a>3、使用基于LeakCannary的改进版ResourceCanary</h4><p>它的主要特点如下：</p><h5 id="1、分离检测和分析两部分流程"><a href="#1、分离检测和分析两部分流程" class="headerlink" title="1、分离检测和分析两部分流程"></a>1、分离检测和分析两部分流程</h5><p>自动化测试由测试平台进行，分析则由监控平台的服务端离线完成，再通知相关开发解决问题。</p><h5 id="2、裁剪Hprof文件，以降低后台存储Hprof的开销"><a href="#2、裁剪Hprof文件，以降低后台存储Hprof的开销" class="headerlink" title="2、裁剪Hprof文件，以降低后台存储Hprof的开销"></a>2、裁剪Hprof文件，以降低后台存储Hprof的开销</h5><p>获取需要的类和对象相关的字符串信息即可，其它数据都可以在客户端裁剪，一般能Hprof大小会减小至原来的1/10左右。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>在研发阶段需要不断实现更多的工具和组件，以此系统化地提升自动化程度，以最终提升发现问题的效率。</p><h3 id="八、内存优化工具"><a href="#八、内存优化工具" class="headerlink" title="八、内存优化工具"></a>八、内存优化工具</h3><p>除了常用的内存分析工具Memory Profiler、MAT、LeakCanary之外，还有一些其它的内存分析工具，下面我将一一为大家进行介绍。</p><h4 id="1、top"><a href="#1、top" class="headerlink" title="1、top"></a>1、top</h4><p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用、内存使用和执行时间对任务进行排序。</p><p>接下来，我们输入以下命令查看top命令的用法：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell top --helpusage: top [-Hbq] [-k FIELD,] [-o FIELD,] [-s SORT] [-n NUMBER] [-d SECONDS] [-p PID,] [-u USER,]Show process activity in real time.-H    Show threads-k    Fallback sort FIELDS (default -S,-%CPU,-ETIME,-PID)-o    Show FIELDS (def PID,USER,PR,NI,VIRT,RES,SHR,S,%CPU,%MEM,TIME+,CMDLINE)-O    Add FIELDS (replacing PR,NI,VIRT,RES,SHR,S from default)-s    Sort by field number (1-X, default 9)-b    Batch mode (no tty)-d    Delay SECONDS between each cycle (default 3)-n    Exit after NUMBER iterations-p    Show these PIDs-u    Show these USERs-q    Quiet (no header lines)Cursor LEFT/RIGHT to change sort, UP/DOWN move list, space to forceupdate, R to reverse sort, Q to exit.</code></pre><p>这里使用top仅显示一次进程信息，以便来讲解进程信息中各字段的含义。</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/top.png?raw=true" alt="image"></p><p>前四行是当前系统情况整体的统计信息区。下面我们看每一行信息的具体意义。</p><p>第一行，Tasks — 任务（进程），具体信息说明如下：</p><p>系统现在共有729个进程，其中处于运行中的有1个，715个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有8个。</p><p>第二行,内存状态，具体信息如下：</p><p>5847124k total — 物理内存总量（5.8GB）</p><p>5758016k used — 使用中的内存总量（5.7GB）</p><p>89108k free — 空闲内存总量（89MB）</p><p>112428k buffers — 缓存的内存量 （112M）</p><p>第三行，swap交换分区信息，具体信息说明如下：</p><p>2621436k total — 交换区总量（2.6GB）</p><p>612572k used — 使用的交换区总量（612MB）</p><p>2008864k free — 空闲交换区总量（2GB）</p><p>2657696k cached — 缓冲的交换区总量（2.6GB）</p><p>第四行，cpu状态信息，具体属性说明如下：</p><p>800%cpu - 8核CPU。</p><p>39%user - 39%CPU被用户进程使用。</p><p>0%nice - 优先值为负的进程占0%。</p><p>42%sys — 内核空间占用CPU的百分比为42%。</p><p>712%idle - 除IO等待时间以外的其它等待时间为712%。</p><p>0%iow - IO等待时间占0%。</p><p>0%irq - 硬中断时间占0%。</p><p>6%sirq - 软中断时间占0%。</p><p>对于内存监控，在top里我们要时刻监控第三行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</p><p>在第五行及以下，就是各进程（任务）的状态监控，项目列信息说明如下：</p><p>PID — 进程id。</p><p>USER — 进程所有者。</p><p>PR — 进程优先级。</p><p>NI — nice值。负值表示高优先级，正值表示低优先级。</p><p>VIRT — 进程使用的虚拟内存总量。VIRT = SWAP + RES。</p><p>RES — 进程使用的、未被换出的物理内存大小。RES = CODE + DATA。</p><p>SHR — 共享内存大小。</p><p>S — 进程状态。D=不可中断的睡眠状态、R=运行、 S=睡眠、T=跟踪/停止、Z=僵尸进程。</p><p>%CPU — 上次更新到现在的CPU时间占用百分比。</p><p>%MEM — 进程使用的物理内存百分比。</p><p>TIME+ — 进程使用的CPU时间总计，单位1/100秒。</p><p>ARGS — 进程名称（命令名/命令行）。</p><p>这里可以看到第一行的就是Awesome-WanAndroid这个应用的进程，它的进程名称为json.chao.com.w+，PID为23104，进程所有者USER为u0_a714，进程优先级PR为10，nice置NI为-10。进程使用的虚拟内存总量VIRT为4.3GB，进程使用的、未被换出的物理内存大小RES为138M，共享内存大小SHR为66M，进程状态S是睡眠状态，上次更新到现在的CPU时间占用百分比%CPU为21.2。进程使用的物理内存百分比%MEM为2.4%，进程使用的CPU时间TIME+为1:47.58/100小时。</p><h4 id="2、dumpsys-meminfo"><a href="#2、dumpsys-meminfo" class="headerlink" title="2、dumpsys meminfo"></a>2、dumpsys meminfo</h4><p>在讲解dumpsys meminfo命令之前，我们必须先了解下Android中的几个内存指标的概念：</p><table><thead><tr><th>内存指标</th><th>英文全称</th><th>含义</th><th>等价 </th></tr></thead><tbody><tr><td>USS</td><td>Unique Set Size</td><td>物理内存</td><td>进程独占的内存</td></tr><tr><td>PSS</td><td>Proportional Set Size</td><td>物理内存</td><td>PSS = USS + 按比例包含共享库</td></tr><tr><td>RSS</td><td>Resident Set Size</td><td>物理内存</td><td>RSS= USS+ 包含共享库</td></tr><tr><td>VSS</td><td>Virtual Set Size</td><td>虚拟内存</td><td>VSS= RSS+ 未分配实际物理内存</td></tr></tbody></table><p>从上可知，它们之间内存的大小关系为VSS &gt;= RSS &gt;= PSS &gt;= USS。</p><p>RSS与PSS相似，也包含进程共享内存，但比较麻烦的是RSS并没有把共享内存大小全都平分到使用共享的进程头上，以至于所有进程的RSS相加会超过物理内存很多。而VSS是虚拟地址，它的上限与进程的可访问地址空间有关，和当前进程的内存使用关系并不大。比如有很多的map内存也被算在其中，我们都知道，file的map内存对应的可能是一个文件或硬盘，或者某个奇怪的设备，它与进程使用内存并没有多少关系。</p><p>而PSS、USS最大的不同在于“共享内存“（比如两个App使用MMAP方式打开同一个文件，那么打开文件而使用的这部分内存就是共享的），USS不包含进程间共享的内存，而PSS包含。这也造成了USS因为缺少共享内存，所有进程的USS相加要小于物理内存大小的原因。</p><p>最早的时候官方就推荐使用PSS曲线图来衡量App的物理内存占用，而Android 4.4之后才加入USS。但是PSS，有个很大的问题，就是”共享内存“，考虑一种情况，如果A进程与B进程都会使用一个共享SO库，那么so库中初始化所用掉的那部分内存就会平分到A与B的头上。但是A是在B之后启动的，那么对于B的PSS曲线而言，在A启动的那一刻，即使B没有做任何事情，也会出现一个比较大的阶梯状下滑，这会给用曲线图分析软件内存的行为造成致命的麻烦。</p><p>USS虽然没有这个问题，但是由于Dalvik虚拟机申请内存牵扯到GC时延和多种GC策略，这些都会影响到曲线的异常波动。比如异步GC是Android 4.0以上系统很重要的特性，但是GC什么时候结束？曲线什么时候”降低“？就无法预计了。还有GC策略，什么时候开始增加Dalvik虚拟机的预申请内幕才能大小（Dalvik启动时是由一个标称的start内存大小的,为Java代码运行时预留，避免Java运行时再申请而造成卡顿），但是这个预申请大小是动态变化的，这一点也会造成USS忽大忽小。</p><p>了解完Android内存的性能指标之后，下面我们便来说说dumpsys meminfo这个命令的用法，首先我们输入adb shell dumpsys meminfo -h查看它的帮助文档：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfo -hmeminfo dump options: [-a] [-d] [-c] [-s] [--oom] [process]-a: include all available information for each process.-d: include dalvik details.-c: dump in a compact machine-parseable representation.-s: dump only summary of application memory usage.-S: dump also SwapPss.--oom: only show processes organized by oom adj.--local: only collect details locally, don&apos;t call process.--package: interpret process arg as package, dumping all            processes that have loaded that package.--checkin: dump data for a checkinIf [process] is specified it can be the name orpid of a specific process to dump.</code></pre><p>接着，我们之间输入adb shell dumpsys meminfo命令：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfoApplications Memory Usage (in Kilobytes):Uptime: 257501238 Realtime: 257501238// 根据进程PSS占用值从大到小排序Total PSS by process:    308,049K: com.tencent.mm (pid 3760 / activities)    225,081K: system (pid 2088)    189,038K: com.android.systemui (pid 2297 / activities)    188,877K: com.miui.home (pid 2672 / activities)    176,665K: com.plan.kot32.tomatotime (pid 22744 / activities)    175,231K: json.chao.com.wanandroid (pid 23104 / activities)    126,918K: com.tencent.mobileqq (pid 23741)    ...// 以oom来划分，会详细列举所有的类别的进程Total PSS by OOM adjustment:    432,013K: Native        76,700K: surfaceflinger (pid 784)        59,084K: android.hardware.camera.provider@2.4-service (pid 743)        26,524K: transport (pid 23418)        25,249K: logd (pid 597)        11,413K: media.codec (pid 1303)        10,648K: rild (pid 1304)        9,283K: media.extractor (pid 1297)        ...    661,294K: Persistent        225,081K: system (pid 2088)        189,038K: com.android.systemui (pid 2297 / activities)        103,050K: com.xiaomi.finddevice (pid 3134)        39,098K: com.android.phone (pid 2656)        25,583K: com.miui.daemon (pid 3078)        ...    219,795K: Foreground        175,231K: json.chao.com.wanandroid (pid 23104 / activities)        44,564K: com.miui.securitycenter.remote (pid 2986)    246,529K: Visible        71,002K: com.sohu.inputmethod.sogou.xiaomi (pid 4820)        52,305K: com.miui.miwallpaper (pid 2579)        40,982K: com.miui.powerkeeper (pid 3218)        24,604K: com.miui.systemAdSolution (pid 7986)        14,198K: com.xiaomi.metoknlp (pid 3506)        13,820K: com.miui.voiceassist:core (pid 8722)        13,222K: com.miui.analytics (pid 8037)        7,046K: com.miui.hybrid:entrance (pid 7922)        5,104K: com.miui.wmsvc (pid 7887)        4,246K: com.android.smspush (pid 8126)    213,027K: Perceptible        89,780K: com.eg.android.AlipayGphone (pid 8238)        49,033K: com.eg.android.AlipayGphone:push (pid 8204)        23,181K: com.android.thememanager (pid 11057)        13,253K: com.xiaomi.joyose (pid 5558)        10,292K: com.android.updater (pid 3488)        9,807K: com.lbe.security.miui (pid 23060)        9,734K: com.google.android.webview:sandboxed_process0 (pid 11150)        7,947K: com.xiaomi.location.fused (pid 3524)    308,049K: Backup        308,049K: com.tencent.mm (pid 3760 / activities)    74,250K: A Services        59,701K: com.tencent.mm:push (pid 7234)        9,247K: com.android.settings:remote (pid 27053)        5,302K: com.xiaomi.drivemode (pid 27009)    199,638K: Home        188,877K: com.miui.home (pid 2672 / activities)        10,761K: com.miui.hybrid (pid 7945)    53,934K: B Services        35,583K: com.tencent.mobileqq:MSF (pid 14119)        6,753K: com.qualcomm.qti.autoregistration (pid 8786)        4,086K: com.qualcomm.qti.callenhancement (pid 26958)        3,809K: com.qualcomm.qti.StatsPollManager (pid 26993)        3,703K: com.qualcomm.qti.smcinvokepkgmgr (pid 26976)    692,588K: Cached        176,665K: com.plan.kot32.tomatotime (pid 22744 / activities)        126,918K: com.tencent.mobileqq (pid 23741)        72,928K: com.tencent.mm:tools (pid 18598)        68,208K: com.tencent.mm:sandbox (pid 27333)        55,270K: com.tencent.mm:toolsmp (pid 18842)        24,477K: com.android.mms (pid 27192)        23,865K: com.xiaomi.market (pid 27825)        ...// 按内存的类别来进行划分Total PSS by category:    957,931K: Native    284,006K: Dalvik    199,750K: Unknown    193,236K: .dex mmap    191,521K: .art mmap    110,581K: .oat mmap    101,472K: .so mmap    94,984K: EGL mtrack    87,321K: Dalvik Other    84,924K: Gfx dev    77,300K: GL mtrack    64,963K: .apk mmap    17,112K: Other mmap    12,935K: Ashmem     3,364K: Stack     2,343K: .ttf mmap     1,375K: Other dev     1,071K: .jar mmap        20K: Cursor         0K: Other mtrack// 手机整体内存使用情况Total RAM: 5,847,124K (status normal)Free RAM: 3,711,324K (  692,588K cached pss + 2,428,616K cached kernel +   117,492K cached ion +   472,628K free)Used RAM: 2,864,761K (2,408,529K used pss +   456,232K kernel)Lost RAM:   184,330K    ZRAM:   174,628K physical used for   625,388K in swap (2,621,436K total swap)Tuning: 256 (large 512), oom   322,560K, restore limit   107,520K (high-end-gfx)</code></pre><p>根据dumpsys meminfo的输出结果，可归结为如下表格：</p><table><thead><tr><th>划分类型</th><th>排序指标</th><th>含义</th></tr></thead><tbody><tr><td>process</td><td>PSS</td><td>以进程的PSS从大到小依次排序显示，每行显示一个进程，一般用来做初步的竞品分析</td></tr><tr><td>OOM adj</td><td>PSS</td><td>展示当前系统内部运行的所有Android进程的内存状态和被杀顺序，越靠近下方的进程越容易被杀，排序按照一套复杂的算法，算法涵盖了前后台、服务或节目、可见与否、老化等 </td></tr><tr><td>category</td><td>PSS</td><td>以Dalvik/Native/.art mmap/.dex map等划分并按降序列出各类进程的总PSS分布情况</td></tr><tr><td>total</td><td>-</td><td>总内存、剩余内存、可用内存、其他内存 </td></tr></tbody></table><p>此外，为了查看单个App进程的内存信息，我们可以输入如下命令：</p><pre><code>dumpsys meminfo &lt;pid&gt; // 输出指定pid的某一进程dumpsys meminfo --package &lt;packagename&gt; // 输出指定包名的进程，可能包含多个进程</code></pre><p>这里我们输入adb shell dumpsys meminfo 23104这条命令，其中23104为Awesome-WanAndroid App的pid，结果如下所示：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys meminfo 23104Applications Memory Usage (in Kilobytes):Uptime: 258375231 Realtime: 258375231** MEMINFO in pid 23104 [json.chao.com.wanandroid] **                Pss  Private  Private  SwapPss     Heap     Heap     Heap                Total    Dirty    Clean    Dirty     Size    Alloc     Free                ------   ------   ------   ------   ------   ------   ------Native Heap    46674    46620        0      164    80384    60559    19824Dalvik Heap     6949     6912       16       23    12064     6032     6032Dalvik Other     7672     7672        0        0       Stack      108      108        0        0      Ashmem      134      132        0        0     Gfx dev    16036    16036        0        0   Other dev       12        0       12        0   .so mmap     3360      228     1084       27  .jar mmap        8        8        0        0  .apk mmap    28279    11328    11584        0  .ttf mmap      295        0       80        0  .dex mmap     7780       20     4908        0  .oat mmap      660        0       92        0  .art mmap     8509     8028      104       69 Other mmap      982        8      848        0 EGL mtrack    29388    29388        0        0  GL mtrack    14864    14864        0        0    Unknown     2532     2500        8       20      TOTAL   174545   143852    18736      303    92448    66591    25856App Summary                   Pss(KB)                    ------       Java Heap:    15044     Native Heap:    46620            Code:    29332           Stack:      108        Graphics:    60288   Private Other:    11196          System:    11957           TOTAL:   174545       TOTAL SWAP PSS:      303Objects           Views:      171         ViewRootImpl:        1     AppContexts:        3           Activities:        1          Assets:       18        AssetManagers:        6   Local Binders:       32        Proxy Binders:       27   Parcel memory:       11         Parcel count:       45Death Recipients:        1      OpenSSL Sockets:        0        WebViews:        0SQL        MEMORY_USED:      371 PAGECACHE_OVERFLOW:       72          MALLOC_SIZE:      117DATABASES    pgsz     dbsz   Lookaside(b)          cache  Dbname        4       60            109      151/32/18  /data/user/0/json.chao.com.wanandroid/databases/bugly_db_        4       20             19         0/15/1  /data/user/0/json.chao.com.wanandroid/databases/aws_wan_android.db</code></pre><p>该命令输出的进程内存概括，我们应该着重关注几个点，下面我将进行一一讲解。</p><h5 id="1、查看Native-Heap的Heap-Alloc与Dalvik-Heap的Heap-Alloc"><a href="#1、查看Native-Heap的Heap-Alloc与Dalvik-Heap的Heap-Alloc" class="headerlink" title="1、查看Native Heap的Heap Alloc与Dalvik Heap的Heap Alloc"></a>1、查看Native Heap的Heap Alloc与Dalvik Heap的Heap Alloc</h5><p>我们可以查看Native Heap的Heap Alloc的数值变化，它表示native的内存占用，如果持续上升，则可能有泄漏，而Dalvik Heap的Heap Alloc则表示Java层的内存占用。</p><h5 id="2、查看Views、Activities、AppContexts数量变化情况"><a href="#2、查看Views、Activities、AppContexts数量变化情况" class="headerlink" title="2、查看Views、Activities、AppContexts数量变化情况"></a>2、查看Views、Activities、AppContexts数量变化情况</h5><p>如果Views与Activities、AppContexts持续上升，则表明有内存泄漏的风险。</p><h5 id="3、SQL的MEMORY-USED与PAGECACHE-OVERFLOW"><a href="#3、SQL的MEMORY-USED与PAGECACHE-OVERFLOW" class="headerlink" title="3、SQL的MEMORY_USED与PAGECACHE_OVERFLOW"></a>3、SQL的MEMORY_USED与PAGECACHE_OVERFLOW</h5><p>SQL的MEMOERY_USED表示数据库使用的内存，而PAGECACHE_OVERFLOW则表示溢出也使用的缓存，这个数值越小越好。</p><h5 id="4、查看DATABASES信息"><a href="#4、查看DATABASES信息" class="headerlink" title="4、查看DATABASES信息"></a>4、查看DATABASES信息</h5><p>其中pgsz表示数据库分页大小，这里全是4KB；Lookaside(b)表示使用了多少个Lookaside的slots，可理解为内存占用的大小；而cache一栏中的 151/32/18  则分别表示分页缓存命中次数/未命中次数/分页缓存个数，这里的未命中次数不应该大于命中次数。</p><h4 id="3、LeakInspector"><a href="#3、LeakInspector" class="headerlink" title="3、LeakInspector"></a>3、LeakInspector</h4><p>LeakInspector是腾讯内部的使用的一站式内存泄漏解决方案，它是Android手机经过长期积累和提炼、集内存泄漏检测、自动修复系统Bug、自动回收已泄露Activity内资源、自动分析GC链、白名单过滤等功能于一体，并深度对接研发流程、自动分析责任人并提缺陷单的全链路体系。</p><h5 id="那么LeakInspector与LeakCanary又有什么不同呢？"><a href="#那么LeakInspector与LeakCanary又有什么不同呢？" class="headerlink" title="那么LeakInspector与LeakCanary又有什么不同呢？"></a>那么LeakInspector与LeakCanary又有什么不同呢？</h5><p>它们之间主要有四个方面的不同：</p><p>一、检测能力与原理方面不同</p><p>1、检测能力</p><p>它们都支持对Activity、Fragment及其它自定义类的泄漏检测，但是LeakInspector还增加了Btiamp的检测能力：</p><ul><li>检测有没有在View上decode超过该View尺寸的图片，若有则上报出现问题的Activity及与其对应的View id，并记录它的个数与平均占用内存的大小。</li><li>检测图片尺寸是否超过所有手机屏幕大小，违规则报警。</li></ul><p>这一个部分的实现原理，主要是采用ARTHook来实现，还不清楚的朋友请再仔细看看大图检测的部分。</p><p>2、检测原理</p><p>两个工具的泄漏检测原理都是在onDestroy时检查弱引用，不同之处在于LeakInspector直接使用WeakReference来检测对象是否已经被释放，而LeakCanary则使用ReferenceQueue，两者效果是一样的。</p><p>并且针对Activity，我们通常都会使用Application的registerActivityLifecycleCallbacks来注册Activity的生命周期，以重写onActivityDestroyed方法实现。但是在Android 4.0以下，系统并没有提供这个方法，为了避免手动在每一个Activity的onDestroy中去添加这份代码，我们可以使用发射Instrumentation来截获onDestory，以降低接入成本。代码如下所示：</p><pre><code>Class&lt;?&gt; clazz = Class.forName(&quot;android.app.ActivityThread&quot;);Method method = clazz.getDeclaredMethod(&quot;currentActivityThread&quot;, null);method.setAccessible(true);sCurrentActivityThread = method.invoke(null, null);Field field = sCurrentActivityThread.getClass().getDeclaredField(&quot;mInstumentation&quot;);field.setAccessible(true);field.set(sCurrentActivityThread, new MonitorInstumentation());</code></pre><p>二、泄漏现场处理方面不同</p><p>1、dump采集</p><p>两者都能采集dump，但是LeakInspector提供了回调方法，我们可以增加更多的自定义信息，如运行时Log、trace、dumpsys meminfo等信息，以辅助分析定位问题。</p><p>2、白名单定义</p><p>这里的白名单是为了处理一些系统引起的泄漏问题，以及一些因为业务逻辑要开后门的情形而设置的。分析时如果碰到白名单上标识的类，则不对这个泄漏做后续的处理。二者的配置差异如下所示：</p><p>（1）LeakInspector的白名单以XML配置的形式存放在服务器上。</p><ul><li>优点：跟产品甚至不同版本的应用绑定，我们可以很方便地修改相应的配置。</li><li>缺点：白名单里的类不区分系统版本一刀切。</li></ul><p>而LeakCanary的白名单是直接写死在其源码的AndroidExcludedRefs类里。</p><ul><li>优点：定义非常详细，并区分系统版本。</li><li>缺点：每次修改必定得重新编译。</li></ul><p>（2）LeakCanary的系统白名单里定义的类比LeakInspector中定义的多很多，因为它没有自动修复系统泄漏功能。</p><p>3、自动修复系统泄漏</p><p>针对系统泄漏，LeakInspector通过反射自动修复了目前碰到的一些系统泄漏，只要在onDestory里面调研一个修复系统泄漏的方法即可。而LeakCanary虽然能识别系统泄漏，但是它仅仅对该类问题给出了分析，没有提供实际可用的解决方案。</p><p>4、回收资源</p><p>如果检测到发生了内存泄漏，LeakInspector会对整个Activity的View进行遍历，把图片资源等一些占内存的数据释放掉，保证此次泄漏只会泄漏一个Activity的空壳，尽量减少对内存的影响。代码大致如下所示：</p><pre><code>if (View instanceof ImageView) {    // ImageView ImageButton处理    recycleImageView(app, (ImageView) view);} else if (view instanceof TextView) {    // 释放TextView、Button周边图片资源    recycleTextView((TextView) view);} else if (View instanceof ProgressBar) {    recycleProgressBar((ProgressBar) view);} else {    if (view instancof android.widget.ListView) {        recycleListView((android.widget.ListView) view);    } else if (view instanceof android.support.v7.widget.RecyclerView) {        recycleRecyclerView((android.support.v7.widget.RecyclerView) view);    } else if (view instanceof FrameLayout) {        recycleFrameLayout((FrameLayout) view);    } else if (view instanceof LinearLayout) {        recycleLinearLayout((LinearLayout) view);    }    if (view instanceof ViewGroup) {        recycleViewGroup(app, (ViewGroup) view);    }}</code></pre><p>这里以recycleTextView为例，它回收资源的方式如下所示：</p><pre><code>private static void recycleTextView(TextView tv) {    Drawable[] ds = tv.getCompoundDrawables();    for (Drawable d : ds) {        if (d != null) {            d.setCallback(null);        }    }    tv.setCompoundDrawables(null, null, null, null);    // 取消焦点，让Editor$Blink这个Runnable不再被post，解决内存泄漏。    tv.setCursorVisible(false);}</code></pre><p>三、后期处理不同</p><p>1、分析与展示</p><p>采集dump之后，LeakInspector会上传dump文件，并调用MAT命令行来进行分析，得到这次泄漏的GC链；而LeakCanary则用开源组件HAHA来分析得到一个GC链。但是LeakCanary得到的GC链包含被hold主的类对象，一般都不需要用MAT打开Hporf即可解决问题；而LeakInpsector得到的GC链李只有类名，还需要MAT打开Hprof才能具体去定位问题，不是很方便。</p><p>2、后续跟进闭环</p><p>LeakInspector在dump分析结束之后，会提交缺陷单，并且把缺陷单分配给对应类的负责人；如果发现重复的问题则更新旧单，同时具备重新打开单等状态转换罗家。而LeakCanary仅会在通知栏提醒用户，需要用户自己记录该问题并做后续处理。</p><p>四、配合自动化测试方面不同</p><p>LeakInspector跟自动化测试可以无缝结合，当自动化脚本执行中发现内存泄漏，可以由它采集dump并发送到服务进行分析，最后提单，整个流程是不需要人力介入的。而LeakCanary则把分析结果通过通知栏告知用户，需要人工介入才能进入下一个流程。</p><h4 id="4、JHat"><a href="#4、JHat" class="headerlink" title="4、JHat"></a>4、JHat</h4><p>JHat是Oracle推出的一款Hprof分析软件，它和MAT并称为Java内存静态分析利器。不同于MAT的单人界面式分析，jHat使用多人界面式分析。它被内置在JDK中，在命令行中输入jhat命令可查看没有有相应的命令。</p><pre><code>quchao@quchaodeMacBook-Pro ~ % jhatERROR: No arguments suppliedUsage:  jhat [-stack &lt;bool&gt;] [-refs &lt;bool&gt;] [-port &lt;port&gt;] [-baseline &lt;file&gt;] [-debug &lt;int&gt;] [-version] [-h|-help] &lt;file&gt;    -J&lt;flag&gt;          Pass &lt;flag&gt; directly to the runtime system. For            example, -J-mx512m to use a maximum heap size of 512MB    -stack false:     Turn off tracking object allocation call stack.    -refs false:      Turn off tracking of references to objects    -port &lt;port&gt;:     Set the port for the HTTP server.  Defaults to 7000    -exclude &lt;file&gt;:  Specify a file that lists data members that should            be excluded from the reachableFrom query.    -baseline &lt;file&gt;: Specify a baseline object dump.  Objects in            both heap dumps with the same ID and same class will            be marked as not being &quot;new&quot;.    -debug &lt;int&gt;:     Set debug level.                0:  No debug output                1:  Debug hprof file parsing                2:  Debug hprof file parsing, no server    -version          Report version number    -h|-help          Print this help and exit    &lt;file&gt;            The file to readFor a dump file that contains multiple heap dumps,you may specify which dump in the fileby appending &quot;#&lt;number&gt;&quot; to the file name, i.e. &quot;foo.hprof#3&quot;.</code></pre><p>如上，则表明存在jhat命令。它的使用很简单，直在命令行输入jhat xxx.hprof即可：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % jhat Documents/heapdump/new-33.hprofSnapshot read, resolving...Resolving 408200 objects...Chasing references, expect 81 dots.................................................................................Eliminating duplicate references.................................................................................Snapshot resolved.Started HTTP server on port 7000Server is ready.</code></pre><p>jHat的执行过程是解析Hprof文件，然后启动httpsrv服务，默认是在7000端口监听Web客户端链接，维护Hprof解析后数据，以持续供给Web客户端的查询操作。</p><p>启动服务器后，我们打开入口地址127.0.0.1:7000即可查看All Classes界面：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/all_classes.png?raw=true" alt="image"></p><p>jHat还有两个比较重要的功能：</p><h5 id="1、统计表"><a href="#1、统计表" class="headerlink" title="1、统计表"></a>1、统计表</h5><p>打开127.0.0.1:7000/histo/:</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/heap_histogram.png?raw=true" alt="image"></p><h5 id="2、OQL查询"><a href="#2、OQL查询" class="headerlink" title="2、OQL查询"></a>2、OQL查询</h5><p>OQL是一种模仿SQL语句的查询语句，通常用来查询某个类的实例数量，打开127.0.0.1:7000/oql/并输入java.lang.String查询String实例的数量，如下所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/oql.png?raw=true" alt="image"></p><p>JHat比MAT更加灵活，且符合大型团队安装简单、团队协作的需求你，并不适合中小型高效沟通型团队使用。</p><h4 id="5、GC-Log"><a href="#5、GC-Log" class="headerlink" title="5、GC Log"></a>5、GC Log</h4><p>GC Log分为Dalvik和ART的GC日志，关于Dalvik的GC日志，在前篇<a href="https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之内存优化</a>已经详细讲解过了，接下来我们说说ART的GC日志。</p><p>ART的日志与Dalvik的日志差距非常大，除了格式不同之外，打印的时间也不同，非要在慢GC时才打印除了。下面我们看看这条ART GC Log：</p><table><thead><tr><th>Explicit</th><th>（full）</th><th>concurrent mark sweep GC</th><th>freed 104710 （7MB） AllocSpace objects,</th><th>21（416KB） LOS objects，</th><th>33% free,25MB/38MB</th><th>paused 1.230ms total 67.216ms </th></tr></thead><tbody><tr><td>GC产生的原因</td><td>GC类型</td><td>采集方法</td><td>释放的数量和占用的空间</td><td>释放的大对象数量和所占用的空间</td><td>堆中空闲空间的百分比和（对象的个数）/（堆的总空间）</td><td>暂停耗时 </td></tr></tbody></table><p>GC产生的原因如下：</p><ul><li>Concurrent、Alloc、Explicit跟Dalvik的基本一样，这里就不重复介绍了。</li><li>NativeAlloc：Native内存分配时，比如为Bitmaps或者RenderScript分配对象， 这会导致Native内存压力，从而触发GC。</li><li>Background:后台GC，触发是为了给后面的内存申请预留更多空间。</li><li>CollectorTransition：由堆转换引起的回收，这是运行时切换GC而引起的。收集器转换包括将所有对象从空闲列表空间复制到碰撞指针空间（反之亦然）。当前，收集器转换仅在以下情况下出现：在内存较小的设备上，App将进程状态从可察觉的暂停状态变更为可察觉的非暂停状态（反之亦然）。</li><li>HomogeneousSpaceCompact：齐性空间压缩是指空闲列表到压缩的空闲列表空间，通常发生在当App已经移动到可察觉的暂停进程状态。这样做的主要原因是减少了内存使用并对堆内存进行碎片整理。</li><li>DisableMovingGc：不是真正的触发GC原因，发生并发堆压缩时，由于使用了 </li><li>GetPrimitiveArrayCritical，收集会被阻塞。一般情况下，强烈建议不要使用 </li><li>GetPrimitiveArrayCritical，因为它在移动收集器方面具有限制。</li><li>HeapTrim：不是触发GC原因，但是请注意，收集会一直被阻塞，直到堆内存整理完毕。</li></ul><p>GC类型如下：</p><ul><li>Full：与Dalvik的FULL GC差不多。</li><li>Partial：跟Dalvik的局部GC差不多，策略时不包含Zygote Heap。</li><li>Sticky：另外一种局部中的局部GC，选择局部的策略是上次垃圾回收后新分配的对象。</li></ul><p>GC采集的方法如下：</p><ul><li>mark sweep：先记录全部对象，然后从GC ROOT开始找出间接和直接的对象并标注。利用之前记录的全部对象和标注的对象对比，其余的对象就应该需要垃圾回收了。</li><li>concurrent mark sweep：使用mark sweep采集器的并发GC。</li><li>mark compact：在标记存活对象的时候，所有的存活对象压缩到内存的一端，而另一端可以更加高效地被回收。</li><li>semispace：在做垃圾扫描的时候，把所有引用的对象从一个空间移到另外一个空间，然后直接GC剩余在旧空间中的对象即可。</li></ul><p>通过GC日志，我们可以知道GC的量和它对卡顿的影响，也可以初步定位一些如主动调用GC、可分配的内存不足、过多使用Weak Reference等问题。</p><h4 id="6、自带防泄漏功能的线程池组件"><a href="#6、自带防泄漏功能的线程池组件" class="headerlink" title="6、自带防泄漏功能的线程池组件"></a>6、自带防泄漏功能的线程池组件</h4><p>我们在做子线程操作的时候，喜欢使用匿名内部类Runnable来操作,但是,如果某个Activity放在线程池中的任务不能及时执行完毕，在Activity销毁时很容易导致内存泄漏。因为这个匿名内部类Runnable类持有一个指向Outer类的引用，这样一来如果Activity里面的Runnable不能及时执行，就会使它外围的Activity无法释放，产生内存泄漏。从上面的分析可知，只要在Activity退出时没有这个引用即可，那我们就通过反射，在Runnable进入线程池前先干掉它，代码如下所示：</p><pre><code>Field f = job.getClass().getDeclaredField(&quot;this$0&quot;);f.setAccessible(true);f.set(job, null);</code></pre><p>这个任务就是我们的Runnable对象，而”this$0“就是上面所指的外部类的引用了。这里注意使用WeakReference装起来，要执行了先get一下，如果是null则说明Activity已经回收，任务就放弃执行。</p><h4 id="7、Chrome-Devtool"><a href="#7、Chrome-Devtool" class="headerlink" title="7、Chrome Devtool"></a>7、Chrome Devtool</h4><p>对于HTML5页面而言，抓取JavaScript的内存需要使用Chrome Devtools来进行远程调试。方式有如下两种：</p><ul><li>直接把URL抓取出来放到Chrome里访问。</li><li>用Android H5远程调试。</li></ul><h5 id="纯H5"><a href="#纯H5" class="headerlink" title="纯H5"></a>纯H5</h5><p>1、手机安装Chrome，打开USB调试模式，通过USB连上电脑，在Chrome里打开一个页面，比如百度页面。然后在PC Chrome地址栏里访问Chrome://inspect，如下图所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/chrome_dev1.png?raw=true" alt="image"></p><p>2、最后，直接点击Chrome下面的inspect选项即可弹出开发者工具界面。如下图所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/chrome_dev2.png?raw=true" alt="image"></p><h5 id="默认Hybrid-H5调试"><a href="#默认Hybrid-H5调试" class="headerlink" title="默认Hybrid H5调试"></a>默认Hybrid H5调试</h5><p>Android 4.4及以上系统的原生浏览器就是Chrome浏览器，可以使用Chrome Devtool远程调试WebView，前提是需要在App的代码里把调试开关打开，如下代码所示：</p><pre><code>if (Build.VERSION_SDK_INT &gt;= Build.VERSION_CODES.KITKAT &amp;&amp; 是debug模式) {    WebView.setWebContentsDebuggingEnabled(ture);}</code></pre><p>打开后的调试方法跟纯H5页面调试方法一样，直接在App中打开H5页面，再到PC Chrome的inpsector页面就可以看到调试目标页面。</p><p>这里总结一下JS中几种常见的内存问题点：</p><ul><li>closure闭包函数。</li><li>事件监听。</li><li>变量作用域使用不当，全局变量的引用导致无法释放。</li><li>DOM节点的泄漏。</li></ul><p>若想更深入地学习Chrome开发者工具的使用方法，请查看<a href="https://github.com/CN-Chrome-DevTools/CN-Chrome-DevTools" target="_blank" rel="external">《Chrome开发者工具中文手册》</a>。</p><h3 id="九、内存问题总结"><a href="#九、内存问题总结" class="headerlink" title="九、内存问题总结"></a>九、内存问题总结</h3><p>在我们进行内存优化的过程中，有许多内存问题都可以归结为一类问题，为了便于以后快速地解决类似的内存问题，我将它们归结成了以下的多个要点：</p><h4 id="1、内类时有危险的编码方式"><a href="#1、内类时有危险的编码方式" class="headerlink" title="1、内类时有危险的编码方式"></a>1、内类时有危险的编码方式</h4><p>说道内类就不得不提到”this$0“，它是一种奇特的内类成员，每个类实例都具有一个this$0，当它的内类需要访问它的成员时，内类就会持有外类的this$0，通过this$0就可以访问外部类所有的成员。</p><p>解决方案是在Activity关闭时，触发onDestory时解除内类和外部的引用关系。</p><h4 id="2、普通Hanlder内部类的问题"><a href="#2、普通Hanlder内部类的问题" class="headerlink" title="2、普通Hanlder内部类的问题"></a>2、普通Hanlder内部类的问题</h4><p>这也是一个this$0间接引用的问题，对于Handler的解决方案一般博阿凯如下三个要点：</p><ul><li>1、把内类声明成static，来断绝this$0的引用。因为static描述的内类从Java编译原理的角度看，”内类“与”外类“相互怒独立，互相都没有访问对方成员变量的能力。</li><li>2、使用WeakReference来引用外部类的实例。</li><li>3、在外部类（如Activity）销毁的时候使用removeCallbackAndMessages来移除回调和消息。</li></ul><p>这里需要在使用过程中注意对WeakReference进行判空。</p><h4 id="3、登录界面的内存问题"><a href="#3、登录界面的内存问题" class="headerlink" title="3、登录界面的内存问题"></a>3、登录界面的内存问题</h4><p>如果在闪屏页跳转到登录界面时没有调用finish()，则会造成闪屏页的内存泄漏，在碰到这种”过渡界面“的情况时，需要注意不要产生这样的内存Bug。</p><h4 id="4、使用系统服务时产生的内存问题"><a href="#4、使用系统服务时产生的内存问题" class="headerlink" title="4、使用系统服务时产生的内存问题"></a>4、使用系统服务时产生的内存问题</h4><p>我们通常都会使用getSystemService方法来获取系统服务，但是当在Activity中调用时，会默认把Activity的Context传给系统服务，在某些不确定的情况下，某些系统服务内部会产生异常，从而hold住外界传入的Context。</p><p>解决方案是直接使用Applicaiton的Context去获取系统服务。</p><h4 id="5、把WebView类型的泄漏装进垃圾桶进程"><a href="#5、把WebView类型的泄漏装进垃圾桶进程" class="headerlink" title="5、把WebView类型的泄漏装进垃圾桶进程"></a>5、把WebView类型的泄漏装进垃圾桶进程</h4><p>我们都知道，对应WebView来说，其网络延时、引擎Session管理、Cookies管理、引擎内核线程、HTML5调用系统声音、视频播放组件等产生的引用链条无法及时打断，造成的内存问题基本上可以用”无解“来形容。</p><p>解决方案是我们可以把WebView装入另一个进程。<br>在AndroidManifest中对当前的Activity设置android:process属性即可，最后再Activity的onDestory中退出进程，这样即可基本上终结WebView造成的泄漏。</p><h4 id="6、在适当的时候对组件进行注销"><a href="#6、在适当的时候对组件进行注销" class="headerlink" title="6、在适当的时候对组件进行注销"></a>6、在适当的时候对组件进行注销</h4><p>我们在平常开发过程中经常需要在Activity创建的时候去注册一些组件，如广播、定时器、事件总线等等。这个时候我们应该在适当的时候对组件进行注销，如onPause或onDestory方法中。</p><h4 id="7、Handler-FrameLayout的postDelyed方法触发的内存问题"><a href="#7、Handler-FrameLayout的postDelyed方法触发的内存问题" class="headerlink" title="7、Handler/FrameLayout的postDelyed方法触发的内存问题"></a>7、Handler/FrameLayout的postDelyed方法触发的内存问题</h4><p>不仅在使用Handler的sendMessage方法时，我们需要在onDestory中使用removeCallbackAndMessage移除回调和消息，在使用到Handlerh/FrameLayout的postDelyed方法时,我们需要调用removeCallbacks去移除实现控件内部的延时器对Runnable内类的持有。</p><h4 id="8、图片放错资源目录也会有内存问题"><a href="#8、图片放错资源目录也会有内存问题" class="headerlink" title="8、图片放错资源目录也会有内存问题"></a>8、图片放错资源目录也会有内存问题</h4><p>在做资源适配的时候，因为需要考虑到APK的瘦身问题，无法为每张图片在每个drawable/mipmap目录下安置一张适配图片的副本。很多同学不知道图片应该放哪个目录，如果放到分辨率低的目录如hdpi目录，则可能会造成内存问题，这个时候建议尽量问设计人员要高品质图片然后往高密度目录下方，如xxhdpi目录，这样在低密屏上”放大倍数“是小于1的，在保证画质的前提下，内存也是可控的。也可以使用Drawable.createFromSream替换getResources().getDrawable来加载，这样便可以绕过Android的默认适配规则。</p><p>对于已经被用户使用物理“返回键”退回到后台的进程，如果包含了以下几点，则不会被轻易杀死。</p><ul><li>进程包含了服务startService，而服务本身调用了startForeground（需通过反射调用）。</li><li>主Activity没有实现onSaveInstanceState接口。</li></ul><p>但建议在运行一段时间（如3小时）后主动保存界面进程，然后重启它，这样可以有效地降低内存负载。</p><h3 id="十、内存优化常见问题"><a href="#十、内存优化常见问题" class="headerlink" title="十、内存优化常见问题"></a>十、内存优化常见问题</h3><h4 id="1、你们内存优化项目的过程是怎么做的？"><a href="#1、你们内存优化项目的过程是怎么做的？" class="headerlink" title="1、你们内存优化项目的过程是怎么做的？"></a>1、你们内存优化项目的过程是怎么做的？</h4><h5 id="1、分析现状、确认问题"><a href="#1、分析现状、确认问题" class="headerlink" title="1、分析现状、确认问题"></a>1、分析现状、确认问题</h5><p>我们发现我们的APP在内存方面可能存在很大的问题，第一方面的原因是我们的线上的OOM率比较高。第二点呢，我们经常会看到在我们的Android Studio的Profiler工具中内存的抖动比较频繁。这是我一个初步的现状，然后在我们知道了这个初步的现状之后，进行了问题的确认，我们经过一系列的调研以及深入研究，我们最终发现我们的项目中存在以下几点大问题，比如说：内存抖动、内存溢出、内存泄漏，还有我们的Bitmap使用非常粗犷。</p><h5 id="2、针对性优化"><a href="#2、针对性优化" class="headerlink" title="2、针对性优化"></a>2、针对性优化</h5><p>比如内存抖动的解决 -&gt; Memory Profiler工具的使用（呈现了锯齿张图形） -&gt; 分析到具体代码存在的问题（频繁被调用的方法中出现了日志字符串的拼接），也可以说说内存泄漏或内存溢出的解决。</p><h5 id="3、效率提升"><a href="#3、效率提升" class="headerlink" title="3、效率提升"></a>3、效率提升</h5><p>为了不增加业务同学的工作量，我们使用了一些工具类或ARTHook这样的大图检测方案,没有任何的侵入性,同时,我们将这些技术教给了大家,然后让大家一起进行工作效率上的提升。</p><p>我们对内存优化工具Memory Profiler、MAT的使用比较熟悉，因此针对一系列不同问题的情况，我们写了一系列解决方案的文档，分享给大家。这样，我们整个团队成员的内存优化意识就变强了。</p><h4 id="2、你做了内存优化最大的感受是什么？"><a href="#2、你做了内存优化最大的感受是什么？" class="headerlink" title="2、你做了内存优化最大的感受是什么？"></a>2、你做了内存优化最大的感受是什么？</h4><h6 id="1、磨刀不误砍柴工"><a href="#1、磨刀不误砍柴工" class="headerlink" title="1、磨刀不误砍柴工"></a>1、磨刀不误砍柴工</h6><p>我们一开始并没有直接去分析项目中代码哪些地方存在内存问题，而是先去学习了Google官方的一些文档，比如说学习了Memory Profiler工具的使用、学习了MAT工具的使用，在我们将这些工具学习熟练之后，当在我们的项目中遇到内存问题时，我们就能够很快地进行排查定位问题进行解决。</p><h5 id="2、技术优化必须结合业务代码"><a href="#2、技术优化必须结合业务代码" class="headerlink" title="2、技术优化必须结合业务代码"></a>2、技术优化必须结合业务代码</h5><p>一开始，我们做了整体APP运行阶段的一个内存上报，然后，我们在一些重点的内存消耗模块进行了一些监控，但是后面发现这些监控并没有紧密地结合我们的业务代码，比如说在梳理完项目之后，发现我们项目中存在使用多个图片库的情况，多个图片库的内存缓存肯定是不公用的，所以导致我们整个项目的内存使用量非常高。所以进行技术优化时必须结合我们的业务代码。</p><h5 id="3、系统化完善解决方案"><a href="#3、系统化完善解决方案" class="headerlink" title="3、系统化完善解决方案"></a>3、系统化完善解决方案</h5><p>我们在做内存优化的过程中，不仅做了Android端的优化工作，还将我们Android端一些数据的采集上报到了我们的服务器，然后传到我们的后台，这样，方便我们的无论是Bug跟踪人员或者是Crash跟踪人员进行一系列问题的解决。</p><h4 id="3、如何检测所有不合理的地方？"><a href="#3、如何检测所有不合理的地方？" class="headerlink" title="3、如何检测所有不合理的地方？"></a>3、如何检测所有不合理的地方？</h4><p>比如说大图片的检测，我们最初的一个方案是通过继承ImageView，重写它的onDraw方法来实现。但是，我们在推广它的过程中，发现很多开发人员并不接受，因为很多ImageView之前已经写过了，你现在让他去替换，工作成本是比较高的。所以说，后来我们就想，有没有一种方案可以免替换，最终我们就找到了ARTHook这样一个Hook的方案。</p><h3 id="十一、总结"><a href="#十一、总结" class="headerlink" title="十一、总结"></a>十一、总结</h3><p>对于内存优化的专项优化而言，我们要着重注意两点，即优化大方向和优化细节。</p><p>对于优化的大方向，我们应该优先去做见效快的地方，主要有以下三部分：</p><ul><li>1、内存泄漏</li><li>2、内存抖动</li><li>3、Bitmap</li></ul><p>对于优化细节，我们应该注意一些系统属性或内存回调的使用等等，如下：</p><ul><li>1、LargeHeap属性</li><li>2、onTrimMemory</li><li>3、使用优化过后的集合：如SparseArray</li><li>4、谨慎使用SharedPreference</li><li>5、谨慎使用外部库</li><li>6、业务架构设计合理</li></ul><p>在本篇文章，我们除了建立了内存的监控闭环这一核心体系之外，还是实现了以下组件：</p><ul><li>1、实现了线下的native内存泄漏监控。</li><li>2、根据设备分级来使用不同的内存和分配回收策略。</li><li>3、针对低端机做了功能或图片加载格式的降级处理。</li><li>4、针对缓存滥用的问题实现了统一的缓存管理组件。</li><li>5、实现了大图监控和重复图片的监控。</li><li>6、在前台每隔一定时间去获取当前应用内存占最大内存的比例，当超过设定阈值时则主动释放应用cache。</li><li>7、当UI隐藏时释放内存以增加系统缓存应用进程的能力。</li><li>8、高效实现了应用全局内的Bitmap监控。</li><li>9、实现了全局的线程监控</li><li>10、针对内存使用的重度场景实现了GC监控。</li></ul><p>最后，当监控到应用内存超过阈值时，是否定制了完善的兜底策略来重启应用进程。</p><p>从性能分类的纬度来看，除了内存监控方面外，是否也同样建立了卡顿、缓存、电量、异常流量、布局、包体积、IO、存储相关的监控与优化体系。总的来说，要想实现更健全的功能、更深层次的定位问题、线上问题快速准确的发现，还是有很多事情可以做的。</p><pre><code>路漫漫其修远兮，吾将上下而求索。</code></pre><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第四章 内存优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/71277" target="_blank" rel="external">极客时间之Android开发高手课 内存优化</a></p><p>3、<a href="https://mp.Aweixin.qq.com/s/KtGfi5th-4YHOZsEmTOsjg?" target="_blank" rel="external">微信 Android 终端内存优化实践</a></p><p>4、<a href="https://static001.geekbang.org/con/19/pdf/593bc30c21689.pdf" target="_blank" rel="external">GMTC－Android内存泄漏自动化链路分析组件Probe.key</a></p><p>5、<a href="https://developer.android.com/topic/performance/memory#monitor" target="_blank" rel="external">Manage your app’s memory</a></p><p>6、<a href="https://developer.android.com/topic/performance/memory-overview.html" target="_blank" rel="external">Overview of memory management</a></p><p>7、<a href="https://mp.weixin.qq.com/s/Z7oMv0IgKWNkhLon_hFakg" target="_blank" rel="external">Android内存优化杂谈</a></p><p>8、<a href="http://hukai.me/android-performance-memory/" target="_blank" rel="external">Android性能优化之内存篇</a></p><p>9、<a href="http://hukai.me/android-training-managing_your_app_memory/" target="_blank" rel="external">管理应用的内存</a></p><p>10、《Android移动性能实战》第二章 内存</p><p>11、<a href="https://www.cnblogs.com/peida/archive/2012/12/24/2831353.html" target="_blank" rel="external">每天一个linux命令（44）：top命令</a></p><p>12、<a href="http://gityuan.com/2016/01/02/memory-analysis-command/" target="_blank" rel="external">Android内存分析命令</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android稳定性优化</title>
      <link>http://yoursite.com/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 24 Nov 2019 14:45:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h3><h2 id="一、正确认识"><a href="#一、正确认识" class="headerlink" title="一、正确认识"></a>一、正确认识</h2><ul><li>稳定性很重要，Crash是P0优先级</li><li>稳定性可优化的面很广</li></ul><h3 id="1-1-稳定性纬度"><a href="#1-1-稳定性纬度" class="headerlink" title="1.1 稳定性纬度"></a>1.1 稳定性纬度</h3><ul><li>Crash纬度</li><li>性能纬度：启动速度、内存、绘制等等优化方向，相对于Crash来说是次要的</li><li>业务高可用纬度</li></ul><h3 id="1-2-稳定性优化概述"><a href="#1-2-稳定性优化概述" class="headerlink" title="1.2 稳定性优化概述"></a>1.2 稳定性优化概述</h3><ul><li>重在预防、监控必不可少</li><li>思考更深一层、重视隐含信息：如解决Crash问题时思考是否会引发同一类问题</li><li>长效保持需要科学流程</li></ul><h3 id="1-3-Crash相关指标"><a href="#1-3-Crash相关指标" class="headerlink" title="1.3 Crash相关指标"></a>1.3 Crash相关指标</h3><h4 id="1-3-1-UV、PV"><a href="#1-3-1-UV、PV" class="headerlink" title="1.3.1 UV、PV"></a>1.3.1 UV、PV</h4><ul><li>PV（Page View）：访问量</li><li>UV（Unique Visitor）：独立访客，0 - 24小时内的同一终端只计算一次</li></ul><h4 id="1-3-2-UV、PV、启动Crash率"><a href="#1-3-2-UV、PV、启动Crash率" class="headerlink" title="1.3.2 UV、PV、启动Crash率"></a>1.3.2 UV、PV、启动Crash率</h4><ul><li>UV Crash率：针对用户使用量的统计，统计一段时间内所有用户发生崩溃的占比</li><li>Crash UV / DAU：评估Crash率的影响范围，结合PV</li></ul><p>注意：沿用同一指标</p><ul><li>PV Crash率：评估相关Crash影响的严重程度</li><li>启动Crash率：影响最严重的Crash，对用户伤害最大，无法通过热修复拯救，需结合客户端容灾</li><li>增量、存量Crash率：增量Crash是新版本重点，存量Crash是需要持续啃的硬骨头，优先解决增量、持续跟进存量</li></ul><h4 id="1-4-Crash率评价"><a href="#1-4-Crash率评价" class="headerlink" title="1.4 Crash率评价"></a>1.4 Crash率评价</h4><ul><li>必须在千分之二以下</li><li>万分位为优秀</li></ul><h4 id="1-5-Crash关键问题"><a href="#1-5-Crash关键问题" class="headerlink" title="1.5 Crash关键问题"></a>1.5 Crash关键问题</h4><p>尽可能还原Crash现场:</p><ul><li>堆栈、设备、OS版本、进程、线程名、Logcat<br>前后台、使用时长、App版本、小版本、渠道<br>CPU架构、内存信息、线程数、资源包信息、用户行为日志</li><li>Crash现场信息、Crash Top机型、OS版本、分布版本、区域<br>Crash起始版本、上报趋势、是否新增、持续、量级<br>根据以上信息决定Crash是否需要立马解决以及在哪个版本进行解决</li><li>参考Bugly平台的APM后台聚合展示</li></ul><h4 id="1-6-APM-Crash部分整体架构"><a href="#1-6-APM-Crash部分整体架构" class="headerlink" title="1.6 APM Crash部分整体架构"></a>1.6 APM Crash部分整体架构</h4><h5 id="采集层"><a href="#采集层" class="headerlink" title="采集层"></a>采集层</h5><ul><li>错误堆栈</li><li>设备信息</li><li>行为日志</li><li>其它信息</li></ul><h5 id="处理层"><a href="#处理层" class="headerlink" title="处理层"></a>处理层</h5><ul><li>数据清洗</li><li>数据聚合</li><li>纬度分类</li><li>趋势对比</li></ul><h5 id="展示层"><a href="#展示层" class="headerlink" title="展示层"></a>展示层</h5><ul><li>数据还原</li><li>纬度信息</li><li>起始版本</li><li>其它信息</li></ul><h5 id="报警层"><a href="#报警层" class="headerlink" title="报警层"></a>报警层</h5><ul><li>环比：期与上一期进行对比</li><li>同比：如本月10号与上月10号</li><li>邮件</li><li>IM</li><li>电话</li></ul><h5 id="责任归属"><a href="#责任归属" class="headerlink" title="责任归属"></a>责任归属</h5><ul><li>设立专项小组轮值</li><li>自动匹配责任人</li><li>处理流程全纪录</li></ul><h2 id="二、Crash优化"><a href="#二、Crash优化" class="headerlink" title="二、Crash优化"></a>二、Crash优化</h2><h3 id="2-1-单个Crash处理方案"><a href="#2-1-单个Crash处理方案" class="headerlink" title="2.1 单个Crash处理方案"></a>2.1 单个Crash处理方案</h3><p>1、根据堆栈及现场信息找答案</p><ul><li>解决90%问题</li><li>解决完后需考虑产生Crash深层次的原因</li></ul><p>2、找共性：机型、OS、实验开关、资源包，考虑影响范围</p><p>3、线下复现、远程调试</p><h3 id="2-2-Crash率治理方案"><a href="#2-2-Crash率治理方案" class="headerlink" title="2.2 Crash率治理方案"></a>2.2 Crash率治理方案</h3><ul><li>1、解决线上常规Crash</li><li>2、系统级Crash尝试Hook绕过</li><li>3、疑难Crash重点突破或更换方案</li></ul><h3 id="2-3-Java-Crash"><a href="#2-3-Java-Crash" class="headerlink" title="2.3 Java Crash"></a>2.3 Java Crash</h3><p>出现未捕获异常，导致出现异常退出</p><pre><code>Thread.setDefaultUncaughtExceptionHandler()；</code></pre><p>我们通过设置自定义的UncaughtExceptionHandler，就可以在崩溃发生的时候获取到现场信息。注意，这个钩子是针对单个进程而言的，在多进程的APP中，监控哪个进程，就需要在哪个进程中设置一遍ExceptionHandler。</p><p>获取主线程的堆栈信息：</p><pre><code>Looper.getMainLooper().getThread().getStackTrace();</code></pre><p>获取当前线程的堆栈信息：</p><pre><code>Thread.currentThread().getStackTrace();</code></pre><p>获取全部线程的堆栈信息：</p><pre><code>Thread.getAllStackTraces();</code></pre><p>第三方Crash监控工具如Fabric、腾讯Bugly，都是以字符串拼接的方式将数组StackTraceElement[]转换成字符串形式，进行保存、上报或者展示。</p><h4 id="2-3-1-如何反混淆上传的堆栈信息？"><a href="#2-3-1-如何反混淆上传的堆栈信息？" class="headerlink" title="2.3.1 如何反混淆上传的堆栈信息？"></a>2.3.1 如何反混淆上传的堆栈信息？</h4><ul><li>每次打包生成混淆APK的时候，需要把Mapping文件保存并上传到监控后台；</li><li>Android原生的反混淆的工具包是retrace.jar，在监控后台用来实时解析每个上报的崩溃时。它会将Mapping文件进行文本解析和对象实例化，这个过程比较耗时。因此可以将Mapping对象实例进行内存缓存，但为了防止内存泄露和内存过多占用，需要增加定期自动回收的逻辑。</li></ul><h4 id="2-3-2-获取logcat方法"><a href="#2-3-2-获取logcat方法" class="headerlink" title="2.3.2 获取logcat方法"></a>2.3.2 获取logcat方法</h4><p>logcat日志流程是这样的，应用层 –&gt; liblog.so –&gt; logd，底层使用ring buffer来存储数据。获取的方式有以下三种：</p><h5 id="1-通过logcat命令获取。"><a href="#1-通过logcat命令获取。" class="headerlink" title="1. 通过logcat命令获取。"></a>1. 通过logcat命令获取。</h5><ul><li>优点：非常简单，兼容性好。</li><li>缺点：整个链路比较长，可控性差，失败率高，特别是堆破坏或者堆内存不足时，基本会失败。</li></ul><h5 id="2-hook-liblog-so实现。通过hook-liblog-so-中-android-log-buf-write-方法，将内容重定向到自己的buffer中。"><a href="#2-hook-liblog-so实现。通过hook-liblog-so-中-android-log-buf-write-方法，将内容重定向到自己的buffer中。" class="headerlink" title="2. hook liblog.so实现。通过hook liblog.so 中__android_log_buf_write 方法，将内容重定向到自己的buffer中。"></a>2. hook liblog.so实现。通过hook liblog.so 中__android_log_buf_write 方法，将内容重定向到自己的buffer中。</h5><ul><li>优点：简单，兼容性相对还好。</li><li>缺点：要一直打开。</li></ul><h5 id="3-自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。"><a href="#3-自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。" class="headerlink" title="3. 自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。"></a>3. 自定义获取代码。通过移植底层获取logcat的实现，通过socket直接跟logd交互。</h5><ul><li>优点：比较灵活，预先分配好资源，成功率也比较高。</li><li>缺点：实现非常复杂</li></ul><h4 id="2-3-3-获取Java-堆栈"><a href="#2-3-3-获取Java-堆栈" class="headerlink" title="2.3.3 获取Java 堆栈"></a>2.3.3 获取Java 堆栈</h4><p>native崩溃时，通过unwind只能拿到Native堆栈。我们希望可以拿到当时各个线程的Java堆栈。</p><h5 id="1-Thread-getAllStackTraces-。"><a href="#1-Thread-getAllStackTraces-。" class="headerlink" title="1. Thread.getAllStackTraces()。"></a>1. Thread.getAllStackTraces()。</h5><p>优点：简单，兼容性好。</p><p>缺点：</p><ul><li>成功率不高，依靠系统接口在极端情况也会失败。</li><li>7.0之后这个接口是没有主线程堆栈。</li><li>使用Java层的接口需要暂停线程。</li></ul><h5 id="2-hook-libart-so。通过hook-ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。"><a href="#2-hook-libart-so。通过hook-ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。" class="headerlink" title="2. hook libart.so。通过hook ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。"></a>2. hook libart.so。通过hook ThreadList和Thread的函数，获得跟ANR一样的堆栈。为了稳定性，需要在fork的子进程中执行。</h5><ul><li>优点：信息很全，基本跟ANR的日志一样，有native线程状态，锁信息等等。</li><li>缺点：黑科技的兼容性问题，失败时可以用Thread.getAllStackTraces()兜底</li></ul><h4 id="2-3-4-Java-Crash处理流程"><a href="#2-3-4-Java-Crash处理流程" class="headerlink" title="2.3.4 Java Crash处理流程"></a>2.3.4 Java Crash处理流程</h4><p>借用Gityuan流程图如下所示：</p><p><img src="http://gityuan.com/images/stability/app_crash.jpg" alt="image"></p><p>1、首先发生crash所在进程，在创建之初便准备好了defaultUncaughtHandler，用来来处理Uncaught Exception，并输出当前crash基本信息；</p><p>2、调用当前进程中的AMP.handleApplicationCrash；经过binder ipc机制，传递到system_server进程；</p><p>3、接下来，进入system_server进程，调用binder服务端执行AMS.handleApplicationCrash；</p><p>4、从mProcessNames查找到目标进程的ProcessRecord对象；并将进程crash信息输出到目录/data/system/dropbox；</p><p>5、执行makeAppCrashingLocked：</p><ul><li>创建当前用户下的crash应用的error receiver，并忽略当前应用的广播；</li><li>停止当前进程中所有activity中的WMS的冻结屏幕消息，并执行相关一些屏幕相关操作；</li></ul><p>6、再执行handleAppCrashLocked方法：</p><ul><li>当1分钟内同一进程连续crash两次时，且非persistent进程，则直接结束该应用所有activity，并杀死该进程以及同一个进程组下的所有进程。然后再恢复栈顶第一个非finishing状态的activity;</li><li>当1分钟内同一进程连续crash两次时，且persistent进程，，则只执行恢复栈顶第一个非finishing状态的activity;</li><li>当1分钟内同一进程未发生连续crash两次时，则执行结束栈顶正在运行activity的流程。</li></ul><p>7、通过mUiHandler发送消息SHOW_ERROR_MSG，弹出crash对话框；</p><p>8、到此，system_server进程执行完成。回到crash进程开始执行杀掉当前进程的操作；</p><p>9、当crash进程被杀，通过binder死亡通知，告知system_server进程来执行appDiedLocked()；</p><p>10、最后，执行清理应用相关的activity/service/ContentProvider/receiver组件信息。</p><h5 id="补充：binder-死亡通知原理"><a href="#补充：binder-死亡通知原理" class="headerlink" title="补充：binder 死亡通知原理"></a>补充：binder 死亡通知原理</h5><p>流程图如下：</p><p><img src="http://gityuan.com/images/stability/binder_died.jpg" alt="image"></p><p>由于Crash进程中拥有一个Binder服务端ApplicationThread，而应用进程在创建过程调用attachApplicationLocked()，从而attach到system_server进程，在system_server进程内有一个ApplicationThreadProxy，这是相对应的Binder客户端。当Binder服务端ApplicationThread所在进程(即Crash进程)挂掉后，则Binder客户端能收到相应的死亡通知，从而进入binderDied流程。</p><h3 id="2-4-Native-Crash"><a href="#2-4-Native-Crash" class="headerlink" title="2.4 Native Crash"></a>2.4 Native Crash</h3><p>特点:</p><ul><li>访问非法地址</li><li>地址对齐出错</li><li>发送程序主动abort</li></ul><p>上述都会产生相应的signal信号，导致程序异常退出</p><h4 id="2-4-1-合格的异常捕获组件"><a href="#2-4-1-合格的异常捕获组件" class="headerlink" title="2.4.1 合格的异常捕获组件"></a>2.4.1 合格的异常捕获组件</h4><ul><li>支持在crash时进行更多扩张操作</li><li>打印logcat和日志</li><li>上报crash次数</li><li>对不同crash做不同恢复措施</li><li>可以针对业务不断改进的适应</li></ul><h4 id="2-4-2-现有方案"><a href="#2-4-2-现有方案" class="headerlink" title="2.4.2 现有方案"></a>2.4.2 现有方案</h4><h5 id="Google-Breakpad"><a href="#Google-Breakpad" class="headerlink" title="Google Breakpad"></a>Google Breakpad</h5><ul><li>优点：权威、跨平台</li><li>缺点：代码体量较大</li></ul><h5 id="Logcat"><a href="#Logcat" class="headerlink" title="Logcat"></a>Logcat</h5><ul><li>优点：利用安卓系统实现</li><li>缺点：需要在crash时启动新进程过滤logcat日志，不可靠</li></ul><h5 id="coffeecatch"><a href="#coffeecatch" class="headerlink" title="coffeecatch"></a>coffeecatch</h5><ul><li>优点：实现简洁、改动容易</li><li>缺点：有兼容性问题</li></ul><h4 id="2-4-3-Native崩溃捕获流程"><a href="#2-4-3-Native崩溃捕获流程" class="headerlink" title="2.4.3 Native崩溃捕获流程"></a>2.4.3 Native崩溃捕获流程</h4><h5 id="1、编译端"><a href="#1、编译端" class="headerlink" title="1、编译端"></a>1、编译端</h5><p>编译C/C++需将带符号信息的文件保留下来。</p><h5 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h5><p>捕获到崩溃时，将收集到尽可能多的有用信息写入日志文件，然后选择合适的时机上传到服务器。</p><h5 id="3、服务端"><a href="#3、服务端" class="headerlink" title="3、服务端"></a>3、服务端</h5><p>读取客户端上报的日志文件，寻找合适的符号文件，生成可读的C/C++调用栈。</p><h4 id="2-4-4-Native崩溃捕获的难点"><a href="#2-4-4-Native崩溃捕获的难点" class="headerlink" title="2.4.4 Native崩溃捕获的难点"></a>2.4.4 Native崩溃捕获的难点</h4><p>核心：如何确保客户端在各种极端情况下依然可以生成崩溃日志。</p><h5 id="1、文件句柄泄漏，导致创建日志文件失败？"><a href="#1、文件句柄泄漏，导致创建日志文件失败？" class="headerlink" title="1、文件句柄泄漏，导致创建日志文件失败？"></a>1、文件句柄泄漏，导致创建日志文件失败？</h5><p>提前申请文件句柄fd预留。</p><h5 id="2、栈溢出导致日志生成失败？"><a href="#2、栈溢出导致日志生成失败？" class="headerlink" title="2、栈溢出导致日志生成失败？"></a>2、栈溢出导致日志生成失败？</h5><ul><li>使用额外的栈空间signalstack，避免栈溢出导致进程没有空间创建调用栈执行处理函数。（signalstack：系统会在危险情况下把栈指针指向这个地方，使得可以在一个新的栈上运行信号处理函数）</li><li>特殊请求需直接替换当前栈，所以应在堆中预留部分空间。</li></ul><h5 id="3、堆内存耗尽导致日志生产失败？"><a href="#3、堆内存耗尽导致日志生产失败？" class="headerlink" title="3、堆内存耗尽导致日志生产失败？"></a>3、堆内存耗尽导致日志生产失败？</h5><p>参考Breakpad重新封装Linux Syscall Support的做法以避免直接调用libc去分配堆内存。</p><h5 id="4、堆破坏或二次崩溃导致日志生成失败？"><a href="#4、堆破坏或二次崩溃导致日志生成失败？" class="headerlink" title="4、堆破坏或二次崩溃导致日志生成失败？"></a>4、堆破坏或二次崩溃导致日志生成失败？</h5><p>Breakpad使用了fork子进程甚至孙进程的方式去收集崩溃现场，即便出现二次崩溃，也只是这部分信息丢失。</p><p>这里说下Breakpad缺点：</p><ul><li>生成的minidump文件时二进制的，包含过多不重要的信息，导致文件数MB。但minidump可以使用gdb调试、看到传入参数。</li></ul><p>未来Chromium会使用Crashpad替代Breakpad。</p><h5 id="5、想要遵循Android的文本格式并添加更多重要的信息？"><a href="#5、想要遵循Android的文本格式并添加更多重要的信息？" class="headerlink" title="5、想要遵循Android的文本格式并添加更多重要的信息？"></a>5、想要遵循Android的文本格式并添加更多重要的信息？</h5><p>改造Breakpad，增加Logcat信息，Java调用栈信息、其它有用信息。</p><h4 id="2-4-5-Native崩溃捕获注册"><a href="#2-4-5-Native崩溃捕获注册" class="headerlink" title="2.4.5 Native崩溃捕获注册"></a>2.4.5 Native崩溃捕获注册</h4><p>一个Native Crash log信息如下：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/native_crash_log.png" alt="image"></p><p>堆栈信息中 pc 后面跟的内存地址，就是当前函数的栈地址，我们可以通过下面的命令行得出出错的代码行数</p><pre><code>arm-linux-androideabi-addr2line -e 内存地址</code></pre><p>下面列出全部的信号量以及所代表的含义：</p><pre><code>#define SIGHUP 1  // 终端连接结束时发出(不管正常或非正常)#define SIGINT 2  // 程序终止(例如Ctrl-C)#define SIGQUIT 3 // 程序退出(Ctrl-\)#define SIGILL 4 // 执行了非法指令，或者试图执行数据段，堆栈溢出#define SIGTRAP 5 // 断点时产生，由debugger使用#define SIGABRT 6 // 调用abort函数生成的信号，表示程序异常#define SIGIOT 6 // 同上，更全，IO异常也会发出#define SIGBUS 7 // 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数#define SIGFPE 8 // 计算错误，比如除0、溢出#define SIGKILL 9 // 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略#define SIGUSR1 10 // 未使用，保留#define SIGSEGV 11 // 非法内存操作，与 SIGBUS不同，他是对合法地址的非法访问，    比如访问没有读权限的内存，向没有写权限的地址写数据#define SIGUSR2 12 // 未使用，保留#define SIGPIPE 13 // 管道破裂，通常在进程间通信产生#define SIGALRM 14 // 定时信号,#define SIGTERM 15 // 结束程序，类似温和的 SIGKILL，可被阻塞和处理。通常程序如    果终止不了，才会尝试SIGKILL#define SIGSTKFLT 16  // 协处理器堆栈错误#define SIGCHLD 17 // 子进程结束时, 父进程会收到这个信号。#define SIGCONT 18 // 让一个停止的进程继续执行#define SIGSTOP 19 // 停止进程,本信号不能被阻塞,处理或忽略#define SIGTSTP 20 // 停止进程,但该信号可以被处理和忽略#define SIGTTIN 21 // 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号#define SIGTTOU 22 // 类似于SIGTTIN, 但在写终端时收到#define SIGURG 23 // 有紧急数据或out-of-band数据到达socket时产生#define SIGXCPU 24 // 超过CPU时间资源限制时发出#define SIGXFSZ 25 // 当进程企图扩大文件以至于超过文件大小资源限制#define SIGVTALRM 26 // 虚拟时钟信号. 类似于SIGALRM,     但是计算的是该进程占用的CPU时间.#define SIGPROF 27 // 类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间#define SIGWINCH 28 // 窗口大小改变时发出#define SIGIO 29 // 文件描述符准备就绪, 可以开始进行输入/输出操作#define SIGPOLL SIGIO // 同上，别称#define SIGPWR 30 // 电源异常#define SIGSYS 31 // 非法的系统调用</code></pre><p>一般关注SIGILL, SIGABRT, SIGBUS, SIGFPE, SIGSEGV, SIGSTKFLT, SIGSYS即可。</p><p>要订阅异常发生的信号，最简单的做法就是直接用一个循环遍历所有要订阅的信号，对每个信号调用sigaction()。</p><p>注意：</p><ul><li>JNI_OnLoad是最适合安装信号初识函数的地方。</li><li>建议在上报时调用Java层的方法统一上报。Native崩溃捕获注册。</li></ul><h4 id="2-4-6-崩溃分析流程"><a href="#2-4-6-崩溃分析流程" class="headerlink" title="2.4.6 崩溃分析流程"></a>2.4.6 崩溃分析流程</h4><p>首先，应收集崩溃现场的一些信息，如下：</p><h5 id="1、崩溃信息"><a href="#1、崩溃信息" class="headerlink" title="1、崩溃信息"></a>1、崩溃信息</h5><ul><li>进程名、线程名</li><li>崩溃堆栈和类型</li><li>有时候也需要知道主线程的调用栈</li></ul><h5 id="2、系统信息"><a href="#2、系统信息" class="headerlink" title="2、系统信息"></a>2、系统信息</h5><ul><li>系统运行日志</li></ul><pre><code>/system/etc/event-log-tags</code></pre><ul><li>机型、系统、厂商、CPU、ABI、Linux版本等</li></ul><p>注意寻找共性问题</p><ul><li>设备状态</li><li>是否root</li><li>是否是模拟器</li></ul><h5 id="3、内存信息"><a href="#3、内存信息" class="headerlink" title="3、内存信息"></a>3、内存信息</h5><p><strong>系统剩余内存</strong></p><pre><code>/proc/meminfo</code></pre><p>当系统可用内存小于MemTotal的10%时，OOM、大量GC、系统频繁自杀拉起等问题非常容易出现</p><p><strong>应用使用内存</strong></p><p>包括Java内存、RSS、PSS</p><p>PSS和RSS通过/proc/self/smap计算，可以得到apk、dex、so等更详细的分类统计。</p><p><strong>虚拟内存</strong></p><p>大小：</p><pre><code>/proc/self/status</code></pre><p>具体分布情况：</p><pre><code>/proc/self/maps</code></pre><p>注意：</p><p>对于32位进程，32位CPU，虚拟内存达到3GB就可能会引起内存失败的问题。如果是64位的CPU，虚拟内存一般在3~4GB。如果支持64位进程，虚拟内存就不会成为问题。</p><h5 id="4、资源信息"><a href="#4、资源信息" class="headerlink" title="4、资源信息"></a>4、资源信息</h5><p>如果应用堆内存和设备内存比较充足，但还出现内存分配失败，则可能跟资源泄漏有关。</p><p><strong>文件句柄fd</strong></p><p>限制数：</p><pre><code>/proc/self/limits</code></pre><p>一般单个进程允许打开的最大句柄个数为1024，如果超过800需将所有fd和文件名输出日志进行排查。</p><p><strong>线程数</strong></p><p>大小：</p><pre><code>/proc/self/status</code></pre><p>一个线程一般占2MB的虚拟内存，线程数超过400个比较危险，需要将所有tid和线程名输出到日志进行排查。</p><p><strong>JNI</strong></p><p>容易出现引用失效、引用爆表等崩溃。</p><p>通过DumpReferenceTables统计JNI的引用表，进一步分析是否出现JNI泄漏等问题。</p><p><strong>补充：dumpReferenceTables的出处</strong></p><p>在dalvik.system.VMDebug类中，是一个native方法，亦是static方法；在JNI中可以这么调用</p><pre><code>jclass vm_class = env-&gt;FindClass(&quot;dalvik/system/VMDebug&quot;);jmethodID dump_mid = env-&gt;GetStaticMethodID( vm_class, &quot;dumpReferenceTables&quot;, &quot;()V&quot; );env-&gt;CallStaticVoidMethod( vm_class, dump_mid );</code></pre><h5 id="5、应用信息"><a href="#5、应用信息" class="headerlink" title="5、应用信息"></a>5、应用信息</h5><ul><li>崩溃场景</li><li>关键操作路径</li><li>其它跟自身应用相关的自定义信息：运行时间、是否加载补丁、是否全新安装或升级。</li></ul><p>接下来进行崩溃分析：</p><h5 id="1、确定重点"><a href="#1、确定重点" class="headerlink" title="1、确定重点"></a>1、确定重点</h5><ul><li>确认严重程度</li><li>优先解决Top崩溃或对业务有重大影响的崩溃：如启动、支付过程的崩溃</li><li>Java崩溃：如果是OOM，需进一步查看日志中的内存信息和资源信息</li><li>Native崩溃：查看signal、code、fault addr以及崩溃时的Java堆栈</li></ul><p>常见的崩溃类型有</p><p>SIGSEGV：空指针、非法指针等<br>SIGABRT：ANR、调用abort推出等</p><p>如果是ANR，先看主线程堆栈、是否因为锁等待导致，然后看ANR日志中的iowait、CPU、GC、systemserver等信息，确定是I/O问题或CPU竞争问题还是大量GC导致的ANR。</p><p>注意：</p><p>当从一条崩溃日志中无法看出问题原因时，需要查看相同崩溃点下的更多崩溃日志，或者也可以查看内存信息、资源信息等进行异常排查。</p><h5 id="2、查找共性"><a href="#2、查找共性" class="headerlink" title="2、查找共性"></a>2、查找共性</h5><p>机型、系统、ROM、厂商、ABI这些信息都可以作为共性参考，对于下一步复现问题有明确指引。</p><h5 id="3、尝试复现"><a href="#3、尝试复现" class="headerlink" title="3、尝试复现"></a>3、尝试复现</h5><p>复现之后再增加日志或使用Debugger、GDB进行调试。如不能复现，可以采用一些高级手段，如xlog日志、远程诊断、动态分析等等。</p><p>补充：系统崩溃解决方式</p><ul><li>1、通过共性信息查找可能的原因</li><li>2、尝试使用其它使用方式规避</li><li>3、Hook解决</li></ul><h4 id="2-4-7-实战：使用Breakpad捕获native崩溃"><a href="#2-4-7-实战：使用Breakpad捕获native崩溃" class="headerlink" title="2.4.7 实战：使用Breakpad捕获native崩溃"></a>2.4.7 实战：使用Breakpad捕获native崩溃</h4><p>首先，这里给出《Android开发高手课》张绍文老师写的<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter01" target="_blank" rel="external">crash捕获示例工程</a>，工程里面已经集成了Breakpad 来获取发生 native crash 时候的系统信息和线程堆栈信息。下面来详细介绍下使用Breakpad来分析native崩溃的流程：</p><p>1、示例工程是采用cmake的构建方式，所以需要先到Android Studio中SDK Manager中的SDK Tools下下载NDK和cmake。</p><p>2、安装实例工程后，点击CRASH按钮产生一个native崩溃。生成的 crash信息，如果授予Sdcard权限会优先存放在/sdcard/crashDump下，便于我们做进一步的分析。反之会放到目录 /data/data/com.dodola.breakpad/files/crashDump中。</p><p>3、使用adb pull命令将抓取到的crash日志文件放到电脑本地目录中：</p><pre><code>adb pull /sdcard/crashDump/***.dmp &gt; ~/Documents/crash_log.dmp</code></pre><p>4、下载并编译Breakpad源码，在src/processor目录下找到minidump_stackwalk，使用这个工具将dmp文件转换为txt文件：</p><pre><code>// 在项目目录下clone Breakpad仓库git clone https://github.com/google/breakpad.git// 切换到Breakpad根目录进行配置、编译cd breakpad./configure &amp;&amp; make// 使用src/processor目录下的minidump_stackwalk工具将dmp文件转换为txt文件./src/processor/minidump_stackwalk ~/Documents/crashDump/crash_log.dmp &gt;crash_log.txt </code></pre><p>5、打开crash_log.txt，可以得到如下内容：</p><pre><code>Operating system: Android                  0.0.0 Linux 4.4.78-perf-g539ee70 #1 SMP PREEMPT Mon Jan 14 17:08:14 CST 2019 aarch64CPU: arm64     8 CPUsGPU: UNKNOWNCrash reason:  SIGSEGV /SEGV_MAPERRCrash address: 0x0Process uptime: not availableThread 0 (crashed) 0  libcrash-lib.so + 0x650</code></pre><p>其中我们需要的关键信息为CPU是arm64的，并且crash的地址为0x650。接下来我们需要将这个地址转换为代码中对应的行。</p><p>6、ndk 中提供的addr2line来根据地址进行一个符号反解的过程。</p><p>如果是arm64的so使用 $NDKHOME/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line。</p><p>如果是arm的so使用 $NDKHOME/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-addr2line。</p><p>由crash_log.txt的信息可知，我们机器的cpu架构是arm64的，因此需要使用aarch64-linux-android-addr2line这个命令行工具。该命令的一般使用格式如下：<br>    // 注意：在mac下 ./ 代表执行文件    ./aarch64-linux-android-addr2line -e 对应的.so 需要解析的地址</p><p>上述中对应的.so文件在项目编译之后，会出现在Chapter01-master/sample/build/intermediates/merged_native_libs/debug/out/lib/arm64-v8a/libcrash-lib.so这个位置，由于我的手机CPU架构是arm64的，所以这里选择的是arm64-v8a中的libcrash-lib.so。接下来我们使用aarch64-linux-android-addr2line这个命令：</p><pre><code>./aarch64-linux-android-addr2line -f -C -e ~/Documents/open-project/Chapter01-master/sample/build/intermediates/merged_native_libs/debug/out/lib/arm64-v8a/libcrash-lib.so 0x650参数含义：-e --exe=&lt;executable&gt;：指定需要转换地址的可执行文件名。-f --functions：在显示文件名、行号输出信息的同时显示函数名信息。-C --demangle[=style]：将低级别的符号名解码为用户级别的名字。</code></pre><p>结果输出为：</p><pre><code>Crash()/Users/quchao/Documents/open-project/Chapter01-master/sample/src/main/cpp/crash.cpp:10</code></pre><p>由此，我们得出crash的代码行为crahs.cpp文件中的第10行，接下来根据项目具体情况进行相应的修改即可。</p><p>Tips：这是从事NDK开发（音视频、图像处理、OpenCv、热修复框架开发）同学调试native层错误时经常要使用的技巧，强烈建议熟练掌握。</p><h4 id="2-4-8-疑难Crash解决方案"><a href="#2-4-8-疑难Crash解决方案" class="headerlink" title="2.4.8 疑难Crash解决方案"></a>2.4.8 疑难Crash解决方案</h4><h5 id="问题1：如何解决Android-7-0-Toast-BadTokenException？"><a href="#问题1：如何解决Android-7-0-Toast-BadTokenException？" class="headerlink" title="问题1：如何解决Android 7.0 Toast BadTokenException？"></a>问题1：如何解决Android 7.0 Toast BadTokenException？</h5><p>参考Android 8.0 try catch的做法，代理Toast里的mTN（handler）就可以实现捕获异常。</p><h5 id="问题2：如果解决-SharedPreference-apply-引起的-ANR-问题"><a href="#问题2：如果解决-SharedPreference-apply-引起的-ANR-问题" class="headerlink" title="问题2：如果解决 SharedPreference apply 引起的 ANR 问题"></a>问题2：如果解决 SharedPreference apply 引起的 ANR 问题</h5><p><strong>apply为什么会引起ANR</strong>？</p><p>SP 调用 apply 方法，会创建一个等待锁放到 QueuedWork 中，并将真正数据持久化封装成一个任务放到异步队列中执行，任务执行结束会释放锁。Activity onStop 以及 Service 处理 onStop，onStartCommand 时，执行 QueuedWork.waitToFinish() 等待所有的等待锁释放。</p><p><strong>如何解决？</strong></p><p>所有此类 ANR 都是经由 QueuedWork.waitToFinish() 触发的，只要在调用此函数之前，将其中保存的队列手动清空即可。</p><p>具体是Hook ActivityThrad的Handler变量，拿到此变量后给其设置一个Callback，Handler 的 dispatchMessage 中会先处理 callback。最后在 Callback<br>中调用队列的清理工作，注意队列清理需要反射调用 QueuedWork。</p><p>注意：</p><p>apply 机制本身的失败率就比较高（1.8%左右），清理等待锁队列对持久化造成的影响不大。</p><h5 id="问题3：如何解决TimeoutExceptin异常？"><a href="#问题3：如何解决TimeoutExceptin异常？" class="headerlink" title="问题3：如何解决TimeoutExceptin异常？"></a>问题3：如何解决TimeoutExceptin异常？</h5><p>它是由系统的FinalizerWatchdogDaemon抛出来的。</p><p>这里首先介绍下看门狗 WatchDog，它 的作用是监控重要服务的运行状态，当重要服务停止时，发生 Timeout 异常崩溃，WatchDog 负责将应用重启。而当关闭 WatchDog（执行stop（）方法）后，当重要服务停止时，也不会发生 Timeout 异常，是一种通过非正常手段防止异常发生的方法。</p><p><strong>规避方案：</strong></p><p>stop方法，在Android 6.0之前会有线程同步问题。<br>因为6.0之前调用threadToStop的interrupt方法是没有加锁的，所以可能会有线程同步的问题。</p><p>注意：Stop的时候有一定概率导致即使没有超时也会报timeoutexception。</p><p>缺点：</p><p>只是为了避免上报异常采取的一种hack方案，并没有真正解决引起finialize超市的问题。</p><h5 id="问题4：如何解决输入法的内存泄漏？"><a href="#问题4：如何解决输入法的内存泄漏？" class="headerlink" title="问题4：如何解决输入法的内存泄漏？"></a>问题4：如何解决输入法的内存泄漏？</h5><p>通过反射将输入法的两个View置空。</p><h4 id="2-4-9-进程保活"><a href="#2-4-9-进程保活" class="headerlink" title="2.4.9 进程保活"></a>2.4.9 进程保活</h4><p>请参考<a href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android启动速度优化</a>一文。</p><p>这里补充一个方案，利用SyncAdapter提高进程优先级，它是Android系统提供一个账号同步机制，它属于核心进程级别，而使用了SyncAdapter的进程优先级本身也会提高，使用方式请Google，关联SyncAdapter后，进程的优先级变为1，仅低于前台正在运行的进程，因此可以降低应用被系统杀掉的概率。</p><h3 id="2-5-总结"><a href="#2-5-总结" class="headerlink" title="2.5 总结"></a>2.5 总结</h3><ul><li>重在预防：重视应用的整个流程、包括开发人员的培训、编译检查、静态扫描、规范的测试、灰度、发布流程等</li><li>不应该随意使用try catch去隐藏问题，而应该从源头入手，了解崩溃的本质原因，保证后面的运行流程。</li><li>解决崩溃的过程应该由点到面，考虑一类崩溃怎么解决。</li><li>崩溃与内存、卡顿、I/O内存紧密相关</li></ul><h2 id="三、ANR优化"><a href="#三、ANR优化" class="headerlink" title="三、ANR优化"></a>三、ANR优化</h2><h3 id="3-1-ANR监控实现方式"><a href="#3-1-ANR监控实现方式" class="headerlink" title="3.1 ANR监控实现方式"></a>3.1 ANR监控实现方式</h3><h4 id="1、使用FileObserver监听-data-anr-traces-txt的变化"><a href="#1、使用FileObserver监听-data-anr-traces-txt的变化" class="headerlink" title="1、使用FileObserver监听 /data/anr/traces.txt的变化"></a>1、使用FileObserver监听 /data/anr/traces.txt的变化</h4><p>缺点：高版本ROM需要root权限</p><p>解决方案：海外Google Play服务、国内Hardcoder</p><h4 id="2、监控消息队列的运行时间（WatchDog）"><a href="#2、监控消息队列的运行时间（WatchDog）" class="headerlink" title="2、监控消息队列的运行时间（WatchDog）"></a>2、监控消息队列的运行时间（WatchDog）</h4><h5 id="卡顿监控原理："><a href="#卡顿监控原理：" class="headerlink" title="卡顿监控原理："></a>卡顿监控原理：</h5><p>利用主线程的消息队列处理机制，应用发生卡顿，一定是在dispatchMessage中执行了耗时操作。我们通过给主线程的Looper设置一个Printer，打点统计dispatchMessage方法执行的时间，如果超出阀值，表示发生卡顿，则dump出各种信息，提供开发者分析性能瓶颈。</p><p>为卡顿监控代码增加ANR的线程监控，在发送消息时，在ANR线程中保存一个状态，主线程消息执行完后再Reset标志位。如果在ANR线程中收到发送消息后，超过一定时间没有复位，就可以任务发生了ANR。</p><p>缺点：</p><ul><li>无法准确判断是否真正出现ANR，只能说明APP发生了UI阻塞，需要进行二次校验。校验的方式就是等待手机系统出现发生了Error的进程，并且Error类型是NOT_RESPONDING（值为2）。<br>在每次出现ANR弹框前，Native层都会发出signal为SIGNAL_QUIT（值为3）的信号事件，也可以监听此信号。</li><li>无法得到完整ANR日志</li><li>隶属于卡顿优化的方式</li></ul><h4 id="需要考虑应用退出场景"><a href="#需要考虑应用退出场景" class="headerlink" title="需要考虑应用退出场景"></a>需要考虑应用退出场景</h4><ul><li>主动自杀</li><li>Process.killProcess()、exit()等。</li><li>崩溃</li><li>系统重启</li><li>系统异常、断电、用户重启等：通过比较应用开机运行时间是否比之前记录的值更小。</li><li>被系统杀死</li><li>被LMK杀死、从系统的任务管理器中划掉等。</li></ul><p>注意：由于traces.txt上传比较耗时，所以一般线下采用，线上建议综合ProcessErrorStateInfo和出现ANR时的堆栈信息来实现ANR的实时上传。</p><h3 id="3-2-ANR优化"><a href="#3-2-ANR优化" class="headerlink" title="3.2 ANR优化"></a>3.2 ANR优化</h3><p>ANR发生原因：没有在规定的时间内完成要完成的事情。</p><h4 id="3-2-1-ANR分类"><a href="#3-2-1-ANR分类" class="headerlink" title="3.2.1 ANR分类"></a>3.2.1 ANR分类</h4><h5 id="发生场景"><a href="#发生场景" class="headerlink" title="发生场景"></a>发生场景</h5><ul><li>Activity onCreate方法或Input事件超过5s没有完成</li><li>BroadcastReceiver前台10s，后台60s</li><li>ContentProvider 在publish过超时10s;</li><li>Service前台20s，后台200s</li></ul><h5 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h5><ul><li>主线程有耗时操作</li><li>复杂布局</li><li>IO操作</li><li>被子线程同步锁block</li><li>被Binder对端block</li><li>Binder被占满导致主线程无法和SystemServer通信</li><li>得不到系统资源（CPU/RAM/IO）</li></ul><p>从进程角度看发生原因有：</p><ul><li>当前进程：主线程本身耗时或者主线程的消息队列存在耗时操作、主线程被本进程的其它子线程所blocked</li><li>远端进程：binder call、socket通信</li></ul><p>Andorid系统监测ANR的核心原理是消息调度和超时处理。</p><h4 id="3-2-2-ANR排查流程"><a href="#3-2-2-ANR排查流程" class="headerlink" title="3.2.2 ANR排查流程"></a>3.2.2 ANR排查流程</h4><h5 id="1、Log获取"><a href="#1、Log获取" class="headerlink" title="1、Log获取"></a>1、Log获取</h5><p>1、抓取bugreport</p><pre><code>adb shell bugreport &gt; bugreport.txt</code></pre><p>2、直接导出/data/anr/traces.txt文件</p><pre><code>adb pull /data/anr/traces.txt trace.txt</code></pre><h5 id="2、搜索“ANR-in”处log关键点解读"><a href="#2、搜索“ANR-in”处log关键点解读" class="headerlink" title="2、搜索“ANR in”处log关键点解读"></a>2、搜索“ANR in”处log关键点解读</h5><ul><li>发生时间（可能会延时10-20s）</li><li>pid：当pid=0，说明在ANR之前，进程就被LMK杀死或出现了Crash，所以无法接受到系统的广播或者按键消息，因此会出现ANR</li><li><p>cpu负载Load: 7.58 / 6.21 / 4.83</p><p>  代表此时一分钟有平均有7.58个进程在等待<br>  1、5、15分钟内系统的平均负荷<br>  当系统负荷持续大于1.0，必须将值降下来<br>  当系统负荷达到5.0，表面系统有很严重的问题</p></li><li><p>cpu使用率</p></li></ul><pre><code>CPU usage from 18101ms to 0ms ago28% 2085/system_server: 18% user + 10% kernel / faults: 8689 minor 24 major11% 752/android.hardware.sensors@1.0-service: 4% user + 6.9% kernel / faults: 2 minor9.8% 780/surfaceflinger: 6.2% user + 3.5% kernel / faults: 143 minor 4 major</code></pre><p>上述表示Top进程的cpu占用情况。</p><p>注意：如果CPU使用量很少，说明主线程可能阻塞。</p><h5 id="3、在bugreport-txt中根据pid和发生时间搜索到阻塞的log处"><a href="#3、在bugreport-txt中根据pid和发生时间搜索到阻塞的log处" class="headerlink" title="3、在bugreport.txt中根据pid和发生时间搜索到阻塞的log处"></a>3、在bugreport.txt中根据pid和发生时间搜索到阻塞的log处</h5><pre><code>----- pid 10494 at 2019-11-18 15:28:29 -----</code></pre><h5 id="4、往下翻找到“main”线程则可看到对应的阻塞log"><a href="#4、往下翻找到“main”线程则可看到对应的阻塞log" class="headerlink" title="4、往下翻找到“main”线程则可看到对应的阻塞log"></a>4、往下翻找到“main”线程则可看到对应的阻塞log</h5><pre><code>&quot;main&quot; prio=5 tid=1 Sleeping| group=&quot;main&quot; sCount=1 dsCount=0 flags=1 obj=0x746bf7f0 self=0xe7c8f000| sysTid=10494 nice=-4 cgrp=default sched=0/0 handle=0xeb6784a4| state=S schedstat=( 5119636327 325064933 4204 ) utm=460 stm=51 core=4 HZ=100| stack=0xff575000-0xff577000 stackSize=8MB| held mutexes=</code></pre><p>关键字段含义：</p><ul><li>tid：线程号</li><li>sysTid：主进程线程号和进程号相同</li><li>Waiting/Sleeping：各种线程状态</li><li>nice：nice值越小，则优先级越高，-17~16</li><li>schedstat：Running、Runable时间(ns)与Switch次数</li><li>utm：该线程在用户态的执行时间(jiffies)</li><li>stm：该线程在内核态的执行时间(jiffies)</li><li>sCount：该线程被挂起的次数</li><li>dsCount：该线程被调试器挂起的次数</li><li>self：线程本身的地址</li></ul><h5 id="其它分析方法：Java线程调用分析方法"><a href="#其它分析方法：Java线程调用分析方法" class="headerlink" title="其它分析方法：Java线程调用分析方法"></a>其它分析方法：Java线程调用分析方法</h5><ul><li>先使用jps命令列出当前系统中运行的所有Java虚拟机进程，拿到应用进程的pid。</li><li>然后再使用jstack命令查看该进程中所有线程的状态以及调用关系，以及一些简单的分析结果。</li></ul><h5 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h5><p>1、sp调用apply导致anr问题？</p><p>虽然apply并不会阻塞主线程，但是会将等待时间转嫁到主线程。</p><p>2、检测运行期间是否发生过异常退出？</p><p>在应用启动时设定一个标志，在主动自杀或崩溃后更新标志 ，下次启动时检测此标志即可判断。</p><h3 id="3-2-4-理解ANR的触发流程"><a href="#3-2-4-理解ANR的触发流程" class="headerlink" title="3.2.4 理解ANR的触发流程"></a>3.2.4 理解ANR的触发流程</h3><p>broadcast跟service超时机制大抵相同，但有一个非常隐蔽的技能点，那就是通过静态注册的广播超时会受SharedPreferences(简称SP)的影响。</p><p>当SP有未同步到磁盘的工作，则需等待其完成，才告知系统已完成该广播。并且只有XML静态注册的广播超时检测过程会考虑是否有SP尚未完成，动态广播并不受其影响。</p><ul><li><p>对于Service, Broadcast, Input发生ANR之后,最终都会调用AMS.appNotResponding;</p></li><li><p>对于provider,在其进程启动时publish过程可能会出现ANR, 则会直接杀进程以及清理相应信息,而不会弹出ANR的对话框.</p></li><li><p>对于输入事件发生ANR，首先会调用InputMonitor.notifyANR，最终也会调用AMS.appNotResponding。</p></li></ul><h4 id="3-2-4-1-AMS-appNotResponding流程"><a href="#3-2-4-1-AMS-appNotResponding流程" class="headerlink" title="3.2.4.1 AMS.appNotResponding流程"></a>3.2.4.1 AMS.appNotResponding流程</h4><ul><li>输出ANR Reason信息到EventLog. 也就是说ANR触发的时间点最接近的就是EventLog中输出的am_anr信息;</li><li>收集并输出重要进程列表中的各个线程的traces信息，该方法较耗时; </li><li>输出当前各个进程的CPU使用情况以及CPU负载情况;</li><li>将traces文件和 CPU使用情况信息保存到dropbox，即data/system/dropbox目录（ANR信息最为重要的信息）</li><li>根据进程类型,来决定直接后台杀掉,还是弹框告知用户.</li></ul><h4 id="3-2-4-2-AMS-dumpStackTraces流程"><a href="#3-2-4-2-AMS-dumpStackTraces流程" class="headerlink" title="3.2.4.2 AMS.dumpStackTraces流程"></a>3.2.4.2 AMS.dumpStackTraces流程</h4><p>1、收集firstPids进程的stacks：</p><ul><li>第一个是发生ANR进程；</li><li>第二个是system_server；</li><li>其余的是mLruProcesses中所有的persistent进程。</li></ul><p>2、收集Native进程的stacks。(dumpNativeBacktraceToFile)</p><ul><li>依次是mediaserver,sdcard,surfaceflinger进程。</li></ul><p>3、收集lastPids进程的stacks：</p><ul><li>依次输出CPU使用率top 5的进程；</li></ul><p>注意：</p><p>上述导出每个进程trace时，进程之间会休眠200ms。</p><h2 id="四、移动端业务高可用方案建设"><a href="#四、移动端业务高可用方案建设" class="headerlink" title="四、移动端业务高可用方案建设"></a>四、移动端业务高可用方案建设</h2><h3 id="2-3-1-业务高可用重要性"><a href="#2-3-1-业务高可用重要性" class="headerlink" title="2.3.1 业务高可用重要性"></a>2.3.1 业务高可用重要性</h3><ul><li>高可用</li><li>性能</li><li>业务</li><li>侧重于用户功能完整可用</li><li>真实影响收入</li></ul><h3 id="2-3-2-业务高可用方案建设"><a href="#2-3-2-业务高可用方案建设" class="headerlink" title="2.3.2 业务高可用方案建设"></a>2.3.2 业务高可用方案建设</h3><ul><li>数据采集</li><li>梳理项目主流程、核心路径、关键节点</li><li>Aop自动采集、统一上报</li><li>报警策略：阈值报警、趋势报警、特定指标报警、直接上报（或底阈值）</li><li>异常监控</li><li>单点追查：需要针对性分析的特定问题，全量日志回捞，专项分析</li><li>兜底策略</li><li>配置中心、功能开关</li><li>跳转分发中心（组件化路由）</li></ul><h3 id="2-3-3-移动端容灾方案"><a href="#2-3-3-移动端容灾方案" class="headerlink" title="2.3.3 移动端容灾方案"></a>2.3.3 移动端容灾方案</h3><p>灾包括：</p><ul><li>性能异常</li><li>业务异常</li></ul><p>传统流程：</p><p>用户反馈、重新打包、渠道更新、不可接受。</p><h4 id="2-3-3-1-容灾方案建设："><a href="#2-3-3-1-容灾方案建设：" class="headerlink" title="2.3.3.1 容灾方案建设："></a>2.3.3.1 容灾方案建设：</h4><p><strong>功能开关</strong></p><p>配置中心，服务端下发配置控制</p><p>针对场景：</p><ul><li>功能新增</li><li>代码改动</li></ul><p><strong>统跳中心</strong></p><ul><li>界面切换通过路由，路由决定是否重定向</li><li>Native Bug不能热修复则跳转到临时H5页面</li></ul><p><strong>动态化修复</strong></p><ul><li>热修复能力，可监控、灰度、回滚、清除</li></ul><p><strong>推拉结合、多场景调用保证到达率</strong></p><p><strong>Weex、RN增量更新</strong></p><p><strong>安全模式</strong></p><p>微信读书、蘑菇街、淘宝、天猫等“重运营”的APP都使用了安全模式保障客户端启动流程，启动失败后给用户自救机会。先介绍一下它的核心特点：</p><ul><li>根据Crash信息自动恢复，多次启动失败重置应用为安装初始状态</li><li>严重Bug可阻塞性热修复</li></ul><p><strong>安全模式设计</strong></p><p>配置后台：统一的配置后台，具备灰度发布机制</p><p>1、客户端能力：</p><ul><li>在APP连续Crash的情况下具备分级、无感自修复能力</li><li>具备同步热修复能力</li><li>具备指定触发某项特定功能的能力</li><li>具体功能注册能力，方便后期扩展安全模式</li></ul><p>2、数据统计及告警</p><ul><li>统一的数据平台</li><li>监控告警功能，及时发现问题</li><li>查看热修复成功率等数据</li></ul><p>3、快速测试</p><ul><li>优化预发布环境下测试</li><li>优化回归验证安全模式难点等</li></ul><p><strong>天猫安全模式原理</strong></p><p>1、如何判断异常退出？</p><p>APP启动时记录一个flag值，满足以下条件时，将flag值清空</p><ul><li>APP正常启动10秒</li><li>用户正常退出应用</li><li>用户主动从前台切换到后台</li></ul><p>如果在启动阶段发生异常，则flag值不会清空，通过flag值就可以判断客户端是否异常退出，每次异常退出，flag值都+1。</p><p>2、安全模式的分级执行策略</p><p>分为两级安全模式，连续Crash 2次为一级安全模式，连续Crash 2次及以上为二级安全模式。</p><p>业务线可以在一级安全模式中注册行为，比如清空缓存数据，再进入该模式时，会使用注册行为尝试修复客户端<br>如果一级安全模式无法修复APP，则进入二级安全模式将APP恢复到初次安装状态，并将Document、Library、Cache三个根目录清空。</p><p>3、热修复执行策略</p><p>只要发现配置中需要热修复，APP就会同步阻塞进行热修复,保证修复的及时性</p><p>4、灰度方案</p><p>灰度时，配置中会包含灰度、正式两份配置及其灰度概率<br>APP根据特定算法算出自己是否满足灰度条件，则使用灰度配置</p><p><strong>易用性考量</strong></p><p>1、接入成本</p><p>完善文档、接口简洁</p><p>2、统一配置后台</p><p>可按照APP、版本配置</p><p>3、定制性</p><p>支持定制功能，让接入方来决定具体行为</p><p>4、灰度机制</p><p>5、数据分析</p><p>采用统一数据平台，为安全模式改进提供依据</p><p>6、快速测试</p><p>创建更多的针对性测试案例，如模拟连续Crash</p><p><strong>异常熔断</strong></p><ul><li>多次请求失败则可让网络库主动拒绝请求</li></ul><p><strong>容灾方案集合路径</strong></p><p>功能开关 -&gt; 统跳中心 -&gt; 动态修复 -&gt; 安全模式</p><h2 id="五、稳定性长效治理"><a href="#五、稳定性长效治理" class="headerlink" title="五、稳定性长效治理"></a>五、稳定性长效治理</h2><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><ul><li>统一编码规范、增强编码功底、技术评审、CodeReview机制</li><li>架构优化</li><li>能力收敛</li><li>统一容错：如在网络库utils中统一对返回信息进行预校验，如不合法就直接不走接下来的流程。</li></ul><h3 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h3><ul><li>功能测试、自动化测试、回归测试、覆盖安装</li><li>特殊场景、机型等边界测试：如服务端返回异常数据、服务端宕机</li><li>云测平台：提供更全面的机型进行测试</li></ul><h3 id="合码阶段"><a href="#合码阶段" class="headerlink" title="合码阶段"></a>合码阶段</h3><ul><li>编译检测、静态扫描</li><li>预编译流程、主流程自动回归</li></ul><h3 id="发布阶段"><a href="#发布阶段" class="headerlink" title="发布阶段"></a>发布阶段</h3><ul><li>多轮灰度</li><li>分场景、纬度全面覆盖</li></ul><h3 id="运维阶段"><a href="#运维阶段" class="headerlink" title="运维阶段"></a>运维阶段</h3><ul><li>灵敏监控</li><li>回滚、降级策略</li><li>热修复、本地容灾方案</li></ul><h2 id="六、稳定性优化问题"><a href="#六、稳定性优化问题" class="headerlink" title="六、稳定性优化问题"></a>六、稳定性优化问题</h2><h3 id="1、你们做了哪些稳定性方面的优化？"><a href="#1、你们做了哪些稳定性方面的优化？" class="headerlink" title="1、你们做了哪些稳定性方面的优化？"></a>1、你们做了哪些稳定性方面的优化？</h3><ul><li>Crash专项优化</li><li>性能稳定性优化</li><li>业务稳定性优化</li></ul><p>根据以上三方面的优化我们搭建了移动端的高可用平台。</p><h3 id="2、性能稳定性是怎么做的？"><a href="#2、性能稳定性是怎么做的？" class="headerlink" title="2、性能稳定性是怎么做的？"></a>2、性能稳定性是怎么做的？</h3><ul><li>全面的性能优化：启动速度、内存优化、绘制优化</li><li>线下发现问题、优化为主</li><li>线上监控为主</li><li>Crash专项优化</li></ul><h3 id="3、业务稳定性如何保障？"><a href="#3、业务稳定性如何保障？" class="headerlink" title="3、业务稳定性如何保障？"></a>3、业务稳定性如何保障？</h3><ul><li>数据采集 + 报警</li><li>需要对项目的主流程与核心路径进行埋点监控，</li><li>同时还需知道每一步发生了多少异常，这样，我们就知道了所有业务流程的转换率以及相应界面的转换率</li><li>结合大盘，如果转换率低于某个值，进行报警</li><li>异常监控 + 单点追查</li><li>兜底策略</li></ul><h3 id="4、如果发送了异常情况，怎么快速止损？"><a href="#4、如果发送了异常情况，怎么快速止损？" class="headerlink" title="4、如果发送了异常情况，怎么快速止损？"></a>4、如果发送了异常情况，怎么快速止损？</h3><ul><li>功能开关</li><li>统跳中心</li><li>动态修复：热修复、资源包更新</li><li>自主修复：安全模式</li></ul><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>Android稳定性优化是一个需要长期投入，持续运营和维护的一个过程，上文中我们不仅深入探讨了Java Crash、Native Crash和ANR的解决流程及方案，还分析了其内部实现原理和监控流程。到这里，可以看到，要想做好稳定性优化，我们必须对虚拟机运行、Linux信号处理和内存分配有一定程度的了解，只有深入了解这些底层知识，我们才能比别人设计出更好的稳定性优化方案。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、《Android性能优化最佳实践》第五章 稳定性优化 </p><p>2、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">慕课网之国内Top团队大牛带你玩转Android性能分析与优化 第十一章 App稳定性优化</a></p><p>3、<a href="https://time.geekbang.org/column/article/70966" target="_blank" rel="external">极客时间之Android开发高手课 崩溃优化</a> </p><p>4、<a href="https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?" target="_blank" rel="external">Android 平台 Native 代码的崩溃捕获机制及实现</a></p><p>5、<a href="https://mp.weixin.qq.com/s__biz=MzUxMzcxMzE5Ng==&amp;mid=2247488429&amp;idx=1&amp;sn=448b414a0424d06855359b3eb2ba8569&amp;source=41#wechat_redirect" target="_blank" rel="external">安全模式：天猫App启动保护实践</a></p><p>6、<a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651748107&amp;idx=1&amp;sn=55dff1b286e92cfb6aaee776df8ec89e&amp;chksm=bd12ae468a652750a7624c30eca56f6f83347b16cdfb9153b647c6e5229a822b16724a1bbd9d&amp;scene=38#wechat_redirect" target="_blank" rel="external">美团外卖Android Crash治理之路</a> （进阶）</p><p>7、<a href="https://mp.weixin.qq.com/s/PoWPWy3cXFlG1nohgJTJgw" target="_blank" rel="external">海神平台Crash监控SDK（Android）开发经验总结</a> </p><p>8、<a href="https://mp.weixin.qq.com/s?__biz=MzAxNzMxNzk5OQ==&amp;mid=2649485876&amp;idx=1&amp;sn=29ead87814c62a9b3e80cd6ada51e13c&amp;chksm=83f83b34b48fb2225db860a290b4e7ee3b30475d887c2b38e8e29881b297c3cdb5c6d44deaed&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android Native Crash 收集</a> </p><p>9、<a href="http://gityuan.com/2016/06/24/app-crash/" target="_blank" rel="external">理解Android Crash处理流程</a></p><p>10、<a href="https://www.jianshu.com/p/30c1a5ad63a3" target="_blank" rel="external">Android应用ANR分析</a> </p><p>11、<a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="external">理解Android ANR的触发原理</a></p><p>12、<a href="http://gityuan.com/2017/01/01/input-anr/" target="_blank" rel="external">Input系统—ANR原理分析</a></p><p>13、<a href="https://www.jianshu.com/p/ad1a84b6ec69" target="_blank" rel="external">ANR监测机制</a> </p><p>14、<a href="http://gityuan.com/2016/07/02/android-anr/" target="_blank" rel="external">理解Android ANR的触发原理</a> </p><p>15、<a href="http://gityuan.com/2016/12/02/app-not-response/" target="_blank" rel="external">理解Android ANR的信息收集过程</a> </p><p>16、<a href="https://www.jianshu.com/p/18f16aba79dd" target="_blank" rel="external">应用与系统稳定性第一篇—ANR问题分析的一般套路</a></p><p>17、<a href="https://www.jianshu.com/p/545e5e7bbf94" target="_blank" rel="external">巧妙定位ANR问题</a> </p><p>18、<a href="https://mp.weixin.qq.com/s/IFgXvPdiEYDs5cDriApkxQ" target="_blank" rel="external">剖析 SharedPreference apply 引起的 ANR 问题</a> </p><p>19、<a href="https://www.mkssoftware.com/docs/man5/siginfo_t.5.asp" target="_blank" rel="external">Linux错误信号</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android启动速度优化</title>
      <link>http://yoursite.com/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 10 Nov 2019 14:11:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h3 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h3 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h3><h2 id="一、启动优化的意义"><a href="#一、启动优化的意义" class="headerlink" title="一、启动优化的意义"></a>一、启动优化的意义</h2><p>如果我们去一家餐厅吃饭，在点餐的时候等了半天都没有服务人员过来，可能就没有耐心等待直接走了。</p><p>对于App来说，也是同样如此，如果用户点击App后，App半天都打不开，用户就可能失去耐心卸载应用。</p><p>启动速度是用户对我们App的第一体验，打开应用后才能去使用其中提供的强大功能，就算我们应用的内部界面设计的再精美，功能再强大，如果启动速度过慢，用户第一印象就会很差。</p><p>因此，拯救App的启动速度，迫在眉睫。下面，我们来逐步深入探索提升Android App启动速度的奥秘。</p><h2 id="二、应用启动流程"><a href="#二、应用启动流程" class="headerlink" title="二、应用启动流程"></a>二、应用启动流程</h2><h3 id="1-、应用启动的类型"><a href="#1-、应用启动的类型" class="headerlink" title="1 、应用启动的类型"></a>1 、应用启动的类型</h3><h4 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h4><p>从点击应用图标到UI界面完全显示且用户可操作的全部过程。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><p>耗时最多，衡量标准</p><h5 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h5><p>Click Event    -&gt;     IPC     -&gt;     Process.start     -&gt;      ActivityThread -&gt;    bindApplication      -&gt;      LifeCycle    -&gt;     ViewRootImpl</p><h4 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h4><p>因为会从已有的应用进程启动，所以不会再创建和初始化Application，只会重新创建并初始化Activity。</p><h5 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h5><p>耗时较少</p><h5 id="启动流程-1"><a href="#启动流程-1" class="headerlink" title="启动流程"></a>启动流程</h5><p>LifeCycle    -&gt;     ViewRootImpl</p><h5 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h5><p>ViewRoot是GUI管理系统与GUI呈现系统之间的桥梁。每一个ViewRootImpl关联一个Window，<br>ViewRootImpl最终会通过它的setView方法绑定Window所对应的View，并通过其performTraversals方法对View进行布局、测量和绘制。</p><h2 id="三、启动耗时检测"><a href="#三、启动耗时检测" class="headerlink" title="三、启动耗时检测"></a>三、启动耗时检测</h2><h3 id="1、查看Logcat"><a href="#1、查看Logcat" class="headerlink" title="1、查看Logcat"></a>1、查看Logcat</h3><p>在Android Studio Logcat中过滤关键字“Displayed”，可以看到对应的冷启动耗时日志。</p><h3 id="2、adb-shell"><a href="#2、adb-shell" class="headerlink" title="2、adb shell"></a>2、adb shell</h3><p>使用adb shell获取应用的启动时间</p><pre><code>// 其中的AppstartActivity全路径可以省略前面的packageNameadb shell am start -W [packageName]/[AppstartActivity全路径]</code></pre><p>执行后会得到三个时间：ThisTime、TotalTime和WaitTime，详情如下：</p><h4 id="ThisTime"><a href="#ThisTime" class="headerlink" title="ThisTime"></a>ThisTime</h4><p>最后一个Activity启动耗时。</p><h4 id="TotalTime"><a href="#TotalTime" class="headerlink" title="TotalTime"></a>TotalTime</h4><p>所有Activity启动耗时。</p><h4 id="WaitTime"><a href="#WaitTime" class="headerlink" title="WaitTime"></a>WaitTime</h4><p>AMS启动Activity的总耗时。</p><p>一般查看得到的TotalTime，即应用的启动时间，包括创建进程 + Application初始化 + Activity初始化到界面显示的过程。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>1、线下使用方便，不能带到线上。</li><li>2、非严谨、精确时间。</li></ul><h3 id="3、代码打点（函数插桩）"><a href="#3、代码打点（函数插桩）" class="headerlink" title="3、代码打点（函数插桩）"></a>3、代码打点（函数插桩）</h3><p>可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：</p><ul><li>在上传数据到服务器时建议根据用户ID的尾号来抽样上报。</li><li>在项目中核心基类的关键回调函数和核心方法中加入打点。</li></ul><p>代码如下：</p><pre><code>/*** 耗时监视器对象，记录整个过程的耗时情况，可以用在很多需要统计的地方，比如Activity的启动耗时和Fragment的启动耗时。*/public class TimeMonitor {    private final String TAG = TimeMonitor.class.getSimpleName();    private int mMonitord = -1;    // 保存一个耗时统计模块的各种耗时，tag对应某一个阶段的时间    private HashMap&lt;String, Long&gt; mTimeTag = new HashMap&lt;&gt;();    private long mStartTime = 0;    public TimeMonitor(int mMonitorId) {        Log.d(TAG, &quot;init TimeMonitor id: &quot; + mMonitorId);        this.mMonitorId = mMonitorId;    }    public int getMonitorId() {        return mMonitorId;    }    public void startMonitor() {        // 每次重新启动都把前面的数据清除，避免统计错误的数据        if (mTimeTag.size() &gt; 0) {        mTimeTag.clear();        }        mStartTime = System.currentTimeMillis();    }    /**    * 每打一次点，记录某个tag的耗时    */    public void recordingTimeTag(String tag) {        // 若保存过相同的tag，先清除        if (mTimeTag.get(tag) != null) {            mTimeTag.remove(tag);        }        long time = System.currentTimeMillis() - mStartTime;        Log.d(TAG, tag + &quot;: &quot; + time);        mTimeTag.put(tag, time);    }    public void end(String tag, boolean writeLog) {        recordingTimeTag(tag);        end(writeLog);    }    public void end(boolean writeLog) {        if (writeLog) {            //写入到本地文件        }    }    public HashMap&lt;String, Long&gt; getTimeTags() {        return mTimeTag;    }}</code></pre><p>为了使代码更好管理，定义一个打点配置类：</p><pre><code>/*** 打点配置类，用于统计各阶段的耗时，便于代码的维护和管理。*/public final class TimeMonitorConfig {    // 应用启动耗时    public static final int TIME_MONITOR_ID_APPLICATION_START = 1;}</code></pre><p>因为，耗时统计可能会在多个模块和类中需要打点，所以需要一个单例类来管理各个耗时统计的数据：</p><pre><code>/*** 采用单例管理各个耗时统计的数据。*/public class TimeMonitorManager {    private static TimeMonitorManager mTimeMonitorManager = null;private HashMap&lt;Integer, TimeMonitor&gt; mTimeMonitorMap = null;    public synchronized static TimeMonitorManager getInstance() {        if (mTimeMonitorManager == null) {            mTimeMonitorManager = new TimeMonitorManager();        }        return mTimeMonitorManager;    }    public TimeMonitorManager() {        this.mTimeMonitorMap = new HashMap&lt;Integer, TimeMonitor&gt;();    }    /**     * 初始化打点模块    */    public void resetTimeMonitor(int id) {        if (mTimeMonitorMap.get(id) != null) {            mTimeMonitorMap.remove(id);        }        getTimeMonitor(id);    }    /**    * 获取打点器    */    public TimeMonitor getTimeMonitor(int id) {        TimeMonitor monitor = mTimeMonitorMap.get(id);        if (monitor == null) {            monitor = new TimeMonitor(id);            mTimeMonitorMap.put(id, monitor);        }        return monitor;    }}</code></pre><p>主要在以下几个方面需要打点：</p><ul><li>应用程序的生命周期节点。</li><li>启动时需要初始化的重要方法，如数据库初始化，读取本地的一些数据。</li><li>其他耗时的一些算法。</li></ul><p>例如，启动时在Application和第一个Activity加入打点统计：</p><p><strong>Application：</strong></p><pre><code>@Overrideprotected void attachBaseContext(Context base) {    super.attachBaseContext(base);    TimeMonitorManager.getInstance().resetTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START);}@Overridepublic void onCreate() {    super.onCreate();    SoLoader.init(this, /* native exopackage */ false);    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;Application-onCreate&quot;);}</code></pre><p><strong>第一个Activity：</strong></p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;SplashActivity-onCreate&quot;);    super.onCreate(savedInstanceState);    initData();    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;SplashActivity-onCreate-Over&quot;);}@Overrideprotected void onStart() {    super.onStart();    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).end(&quot;SplashActivity-onStart&quot;, false);}</code></pre><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>精确，可带到线上，推荐使用。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><p>在上传数据到服务器时建议根据用户ID的尾号来抽样上报。</p></li><li><p>onWindowFocusChanged只是首帧时间，App启动完成的结束点应该是真实数据展示出来的时候，如列表第一条数据展示，记得使用getViewTreeObserver().addOnPreDrawListener()，它会把任务延迟到列表显示后再执行。</p></li></ul><h4 id="AOP-Aspect-Oriented-Programming-打点"><a href="#AOP-Aspect-Oriented-Programming-打点" class="headerlink" title="AOP(Aspect Oriented Programming)打点"></a>AOP(Aspect Oriented Programming)打点</h4><p>面向切面编程，通过预编译和运行期动态代理实现程序功能统一维护的一种技术。</p><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合性降低，提高程序的可重用性，同时大大提高了开发效率。</p><h5 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h5><p>1、横切关注点</p><p>对哪些方法进行拦截，拦截后怎么处理。</p><p>2、切面（Aspect）</p><p>类是对物体特征的抽象，切面就是对横切关注点的抽象。</p><p>3、连接点（JoinPoint）</p><p>被拦截到的点（方法、字段、构造器）。</p><p>4、切入点（PointCut）</p><p>对JoinPoint进行拦截的定义。</p><p>5、通知（Advice）</p><p>拦截到JoinPoint后要执行的代码，分为前置、后置、环绕三种类型。</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>首先，为了在Android使用AOP埋点需要引入AspectJ，在项目根目录的build.gradle下加入：</p><pre><code>classpath &apos;com.hujiang.aspectjx:gradle-android-plugin- aspectjx:2.0.0&apos;</code></pre><p>然后，在app目录下的build.gradle下加入：</p><pre><code>apply plugin: &apos;android-aspectjx&apos;implement &apos;org.aspectj:aspectjrt:1.8.+&apos;</code></pre><h5 id="AOP埋点实战"><a href="#AOP埋点实战" class="headerlink" title="AOP埋点实战"></a>AOP埋点实战</h5><p>JoinPoint一般定位在如下位置</p><ul><li>1、函数调用</li><li>2、获取、设置变量</li><li>3、类初始化</li></ul><p>使用PointCut对我们指定的连接点进行拦截，通过Advice，就可以拦截到JoinPoint后要执行的代码。Advice通常有以下几种类型：</p><ul><li>1、Before：PointCut之前执行</li><li>2、After：PointCut之后执行</li><li>3、Around：PointCut之前、之后分别执行</li></ul><p>首先，我们举一个小栗子：</p><pre><code>@Before(&quot;execution(* android.app.Activity.on**(..))&quot;)public void onActivityCalled(JoinPoint joinPoint) throws Throwable {...}</code></pre><p>在execution中的是一个匹配规则，第一个*代表匹配任意的方法返回值，后面的语法代码匹配所有Activity中on开头的方法。</p><p>处理Join Point的类型：</p><ul><li>1、call：插入在函数体里面</li><li>2、execution：插入在函数体外面</li></ul><p><strong>如何统计Application中的所有方法耗时？</strong></p><pre><code>@Aspectpublic class ApplicationAop {    @Around(&quot;call (* com.json.chao.application.BaseApplication.**(..))&quot;)    public void getTime(ProceedingJoinPoint joinPoint) {    Signature signature = joinPoint.getSignature();    String name = signature.toShortString();    long time = System.currentTimeMillis();    try {        joinPoint.proceed();    } catch (Throwable throwable) {        throwable.printStackTrace();    }    Log.i(TAG, name + &quot; cost&quot; +     (System.currentTimeMillis() - time));    }}</code></pre><p><strong>注意</strong></p><p>当Action为Before、After时，方法入参为JoinPoint。<br>当Action为Around时，方法入参为ProceedingPoint。</p><p><strong>Around和Before、After的最大区别:</strong></p><p>ProceedingPoint不同于JoinPoint，其提供了proceed方法执行目标方法。</p><p><strong>总结AOP特性：</strong></p><ul><li>1、无侵入性</li><li>2、修改方便</li></ul><h3 id="4、启动速度分析工具-—-TraceView"><a href="#4、启动速度分析工具-—-TraceView" class="headerlink" title="4、启动速度分析工具 — TraceView"></a>4、启动速度分析工具 — TraceView</h3><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><ul><li>1、代码中添加：Debug.startMethodTracing()、检测方法、Debug.stopMethodTracing()。（需要使用adb pull将生成的**.trace文件导出到电脑，然后使用Android Studio的Profiler加载）</li><li>2、打开Profiler  -&gt;  CPU   -&gt;    点击 Record   -&gt;  点击 Stop  -&gt;  查看Profiler下方Top Down/Bottom Up 区域找出耗时的热点方法。</li></ul><h4 id="Profile-CPU"><a href="#Profile-CPU" class="headerlink" title="Profile CPU"></a>Profile CPU</h4><h5 id="1、Trace-types"><a href="#1、Trace-types" class="headerlink" title="1、Trace types"></a>1、Trace types</h5><p><strong>Trace Java Methods</strong></p><p>会记录每个方法的时间、CPU信息。对运行时性能影响较大。</p><p><strong>Sample Java Methods</strong></p><p>相比于Trace Java Methods会记录每个方法的时间、CPU信息，它会在应用的Java代码执行期间频繁捕获应用的调用堆栈，对运行时性能的影响比较小，能够记录更大的数据区域。</p><p><strong>Sample C/C++ Functions</strong></p><p>需部署到Android 8.0及以上设备，内部使用simpleperf跟踪应用的native代码，也可以命令行使用simpleperf。</p><p><strong>Trace System Calls</strong></p><ul><li>检查应用与系统资源的交互情况。</li><li>查看所有核心的CPU瓶。</li><li>内部采用systrace，也可以使用systrace命令。</li></ul><h5 id="2、Event-timeline"><a href="#2、Event-timeline" class="headerlink" title="2、Event timeline"></a>2、Event timeline</h5><p>显示应用程序中在其生命周期中转换不同状态的活动，如用户交互、屏幕旋转事件等。</p><h5 id="3、CPU-timeline"><a href="#3、CPU-timeline" class="headerlink" title="3、CPU timeline"></a>3、CPU timeline</h5><p>显示应用程序实时CPU使用率、其它进程实时CPU使用率、应用程序使用的线程总数。</p><h5 id="4、Thread-activity-timeline"><a href="#4、Thread-activity-timeline" class="headerlink" title="4、Thread activity timeline"></a>4、Thread activity timeline</h5><p>列出应用程序进程中的每个线程，并使用了不同的颜色在其时间轴上指示其活动。</p><ul><li>绿色：线程处于活动状态或准备好使用CPU。</li><li>黄色：线程正等待IO操作。（重要）</li><li>灰色：线程正在睡眠，不消耗CPU时间。</li></ul><h5 id="Profile提供的检查跟踪数据窗口有四种"><a href="#Profile提供的检查跟踪数据窗口有四种" class="headerlink" title="Profile提供的检查跟踪数据窗口有四种"></a>Profile提供的检查跟踪数据窗口有四种</h5><p><strong>1、Call Chart</strong></p><p>提供函数跟踪数据的图形表示形式。</p><ul><li>水平轴：表示调用的时间段和时间。</li><li>垂直轴：显示被调用方。</li><li>橙色：系统API。</li><li>绿色：应用自有方法</li><li>蓝色：第三方API（包括Java API）</li></ul><p>提示：右键点击Jump to source跳转至指定函数。</p><p><strong>2、Flame Chart</strong></p><p>将具有相同调用方顺序的完全相同的方法收集起来。</p><ul><li>水平轴：执行每个方法的相对时间量。</li><li>垂直轴：显示被调用方。</li></ul><p><strong>注意：看顶层的哪个函数占据的宽度最大（平顶），可能存在性能问题。</strong></p><p><strong>3、Top Down</strong></p><ul><li>递归调用列表，提供self、children、total时间和比率来表示被调用的函数信息。</li><li>Flame Chart是Top Down列表数据的图形化。</li></ul><p><strong>4、Bottom Up</strong> </p><ul><li>展开函数会显示其调用方。</li><li>按照消耗CPU时间由多到少的顺序对函数排序。</li></ul><p><strong>注意点：</strong></p><ul><li>Wall Clock Time：程序执行时间。</li><li>Thread Time：CPU执行的时间。</li></ul><h4 id="TraceView小结"><a href="#TraceView小结" class="headerlink" title="TraceView小结"></a>TraceView小结</h4><h5 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h5><ul><li>1、图形的形式展示执行时间、调用栈等。</li><li>2、信息全面，包含所有线程。</li><li>3、运行时开销严重，整体都会变慢，得出的结果并不真实。</li><li>4、找到最耗费时间的路径：Flame Chart、Top Down。</li><li>5、找到最耗费时间的节点：Bottom Up。</li></ul><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><p>主要做热点分析，得到两种数据：</p><ul><li>单次执行最耗时的方法。</li><li>执行次数最多的方法。</li></ul><h3 id="5、启动速度分析工具-—-Systrace"><a href="#5、启动速度分析工具-—-Systrace" class="headerlink" title="5、启动速度分析工具 — Systrace"></a>5、启动速度分析工具 — Systrace</h3><h4 id="使用方式：代码插桩"><a href="#使用方式：代码插桩" class="headerlink" title="使用方式：代码插桩"></a>使用方式：代码插桩</h4><p>定义Trace静态工厂类，将Trace.begainSection()，Trace.endSection()封装成i、o方法，然后再在想要分析的方法前后进行插桩即可。</p><p>在命令行下执行systrace.py脚本：</p><pre><code>python /Users/quchao/Library/Android/sdk/platform-tools/systrace/systrace.py -t 20 sched gfx view wm am app webview -a &quot;com.wanandroid.json.chao&quot; -o ~/Documents/open-project/systrace_data/wanandroid_start_1.html</code></pre><p>具体参数含义如下：</p><ul><li>-t：指定统计时间为20s。</li><li>shced：cpu调度信息。</li><li>gfx：图形信息。</li><li>view：视图。</li><li>wm：窗口管理。</li><li>am：活动管理。</li><li>app：应用信息。</li><li>webview：webview信息。</li><li>-a：指定目标应用程序的包名。</li><li>-o：生成的systrace.html文件。</li></ul><h5 id="如何查看数据？"><a href="#如何查看数据？" class="headerlink" title="如何查看数据？"></a>如何查看数据？</h5><p>在UIThread一栏可以看到核心的系统方法时间区域和我们自己使用代码插桩捕获的方法时间区域。</p><h4 id="Systrace原理"><a href="#Systrace原理" class="headerlink" title="Systrace原理"></a>Systrace原理</h4><ul><li>在系统的一些关键链路（如SystemServcie、虚拟机、Binder驱动）插入一些信息（Label）;</li><li>通过Label的开始和结束来确定某个核心过程的执行时间;<br>把这些Label信息收集起来得到系统关键路径的运行时间信息，最后得到整个系统的运行性能信息;</li><li>Android Framework里面一些重要的模块都插入了label信息，用户App中可以添加自定义的Lable。</li></ul><h4 id="Systrace小结"><a href="#Systrace小结" class="headerlink" title="Systrace小结"></a>Systrace小结</h4><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>结合Android内核的数据，生成Html报告。</li><li>系统版本越高，Android Framework中添加的系统可用Label就越多，能够支持和分析的系统模块也就越多。</li><li>必须手动缩小范围，会帮助你加速收敛问题的分析过程，进而快速地定位和解决问题。</li></ul><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><ul><li>主要用于分析绘制性能方面的问题。</li><li>分析系统关键方法和应用方法耗时。</li></ul><h3 id="6、启动监控"><a href="#6、启动监控" class="headerlink" title="6、启动监控"></a>6、启动监控</h3><h4 id="1、实验室监控：视频录制"><a href="#1、实验室监控：视频录制" class="headerlink" title="1、实验室监控：视频录制"></a>1、实验室监控：视频录制</h4><ul><li>80%绘制</li><li>图像识别</li></ul><h5 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h5><p>覆盖高中低端机型不同的场景。</p><h4 id="2、线上监控"><a href="#2、线上监控" class="headerlink" title="2、线上监控"></a>2、线上监控</h4><h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>需要准确地统计启动耗时。</p><h5 id="1、启动结束的统计时机"><a href="#1、启动结束的统计时机" class="headerlink" title="1、启动结束的统计时机"></a>1、启动结束的统计时机</h5><p>是否是使用界面显示且用户真正可以操作的时间作为启动结束时间。</p><h5 id="2、启动时间扣除逻辑"><a href="#2、启动时间扣除逻辑" class="headerlink" title="2、启动时间扣除逻辑"></a>2、启动时间扣除逻辑</h5><p>闪屏、广告和新手引导这些时间都应该从启动时间里扣除。</p><h5 id="3、启动排除逻辑"><a href="#3、启动排除逻辑" class="headerlink" title="3、启动排除逻辑"></a>3、启动排除逻辑</h5><p>Broadcast、Server拉起，启动过程进入后台都需要排除统计。</p><h5 id="4、使用什么指标来衡量启动速度的快慢？"><a href="#4、使用什么指标来衡量启动速度的快慢？" class="headerlink" title="4、使用什么指标来衡量启动速度的快慢？"></a>4、使用什么指标来衡量启动速度的快慢？</h5><p><strong>平均启动时间的问题</strong></p><p>一些体验很差的用户很可能被平均了。</p><p><strong>建议的指标</strong></p><p>1、快开慢开比</p><p>如2s快开比，5s慢开比，可以看到有多少比例的用户体验好，多少比例的用户比较糟糕。</p><p>2、90%用户的启动时间</p><p>如果90%用户的启动时间都小于5s，那么90%区间的启动耗时就是5s。</p><h5 id="5、启动的类型有哪几种？"><a href="#5、启动的类型有哪几种？" class="headerlink" title="5、启动的类型有哪几种？"></a>5、启动的类型有哪几种？</h5><ul><li>首次安装启动</li><li>覆盖安装启动</li><li>冷启动（指标）</li><li>热启动（反映程序的活跃或保活能力）</li></ul><p>借鉴Facebook的profilo工具原理，对启动整个流程的耗时监控，在后台对不同的版本做自动化对比，监控新版本是否有新增耗时的函数。</p><h2 id="四、启动优化常规方案"><a href="#四、启动优化常规方案" class="headerlink" title="四、启动优化常规方案"></a>四、启动优化常规方案</h2><h3 id="启动过程中的常见问题"><a href="#启动过程中的常见问题" class="headerlink" title="启动过程中的常见问题"></a>启动过程中的常见问题</h3><ul><li>点击图标很久都不响应：预览窗口被禁用或设置为透明。</li><li>首页显示太慢：初始化任务太多。</li><li>首页显示后无法进行操作：太多延迟初始化任务占用主线程CPU时间片。</li></ul><h3 id="优化区域"><a href="#优化区域" class="headerlink" title="优化区域"></a>优化区域</h3><p>Application、Activity创建以及回调等过程。</p><h3 id="1、主题切换"><a href="#1、主题切换" class="headerlink" title="1、主题切换"></a>1、主题切换</h3><p>使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list），在启动后，在Activity的onCreate()方法中的super.onCreate()前再setTheme(R.style.AppTheme)。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>使用简单。</li><li>避免了启动白屏和点击启动图标不响应的情况。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>治标不治本，表面上产生一种快的感觉。</li><li>对于中低端机，总的闪屏时间会更长，建议只在Android6.0/7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验。</li></ul><h3 id="2、第三方库懒加载"><a href="#2、第三方库懒加载" class="headerlink" title="2、第三方库懒加载"></a>2、第三方库懒加载</h3><p>按需初始化，如图片库的初始化等等。</p><h3 id="3、异步初始化预备知识-线程优化"><a href="#3、异步初始化预备知识-线程优化" class="headerlink" title="3、异步初始化预备知识-线程优化"></a>3、异步初始化预备知识-线程优化</h3><h4 id="1、Android线程调度原理剖析"><a href="#1、Android线程调度原理剖析" class="headerlink" title="1、Android线程调度原理剖析"></a>1、Android线程调度原理剖析</h4><h5 id="线程调度原理"><a href="#线程调度原理" class="headerlink" title="线程调度原理"></a>线程调度原理</h5><ul><li>任意时刻，只有一个线程占用CPU，处于运行状态。</li><li>多线程并发，轮流获取CPU使用权。</li><li>JVM负责线程调度，按照特定机制分配CPU使用权。</li></ul><h5 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h5><p><strong>1、分时调度模型</strong></p><p>轮流获取、均分CPU。</p><p><strong>2、抢占式调度模型</strong></p><p>优先级高的获取。</p><h5 id="如何干预线程调度？"><a href="#如何干预线程调度？" class="headerlink" title="如何干预线程调度？"></a>如何干预线程调度？</h5><p>设置线程优先级。</p><h5 id="Android线程调度"><a href="#Android线程调度" class="headerlink" title="Android线程调度"></a>Android线程调度</h5><p><strong>1、nice值</strong></p><ul><li>Process中定义。</li><li>值越小，优先级越高。</li><li>默认是THREAD_PRIORITY_DEFAUT，0。</li></ul><p><strong>2、cgroup</strong></p><ul><li>更严格的群组调度策略。</li><li>后台group。</li><li>前台group，保证前台线程可以获取到更多的CPU</li></ul><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>线程过多会导致CPU频繁切换，降低线程运行效率。</li><li>正确认识任务重要性决定哪种优先级。</li><li>优先级具有继承性。</li></ul><h4 id="2、Android异步方式"><a href="#2、Android异步方式" class="headerlink" title="2、Android异步方式"></a>2、Android异步方式</h4><h5 id="1、Thread"><a href="#1、Thread" class="headerlink" title="1、Thread"></a>1、Thread</h5><ul><li>最简单、常见的异步方式。</li><li>不易复用，频繁创建及销毁开销大。</li><li>复杂场景不易使用。</li></ul><h5 id="2、HandlerThread"><a href="#2、HandlerThread" class="headerlink" title="2、HandlerThread"></a>2、HandlerThread</h5><ul><li>自带消息循环的线程。</li><li>串行执行。</li><li>长时间运行，不断从队列中获取任务。</li></ul><h5 id="3、IntentService"><a href="#3、IntentService" class="headerlink" title="3、IntentService"></a>3、IntentService</h5><ul><li>继承自Service在内部创建HandlerThread。</li><li>异步，不占用主线程。</li><li>优先级较高，不易被系统Kill。</li></ul><h5 id="4、AsyncTask"><a href="#4、AsyncTask" class="headerlink" title="4、AsyncTask"></a>4、AsyncTask</h5><ul><li>Android提供的工具类。</li><li>无需自己处理线程切换。</li><li>需注意版本不一致问题（API 14以上解决）</li></ul><h5 id="5、线程池"><a href="#5、线程池" class="headerlink" title="5、线程池"></a>5、线程池</h5><ul><li>Java提供的线程池。</li><li>易复用，减少频繁创建、销毁的时间。</li><li>功能强大，如定时、任务队列、并发数控制等。</li></ul><h5 id="6、RxJava"><a href="#6、RxJava" class="headerlink" title="6、RxJava"></a>6、RxJava</h5><p>由强大的Scheduler集合提供。</p><p>不同类型的Scheduler：</p><ul><li>IO</li><li>Computation</li></ul><h5 id="异步方式总结"><a href="#异步方式总结" class="headerlink" title="异步方式总结"></a>异步方式总结</h5><ul><li>推荐度：从后往前排列。</li><li>正确场景选择正确的方式。</li></ul><h4 id="3、Android线程优化实战"><a href="#3、Android线程优化实战" class="headerlink" title="3、Android线程优化实战"></a>3、Android线程优化实战</h4><h5 id="线程使用准则"><a href="#线程使用准则" class="headerlink" title="线程使用准则"></a>线程使用准则</h5><ul><li>1、严禁使用new Thread方式。</li><li>2、提供基础线程池供各个业务线使用，避免各个业务线各自维护一套线程池，导致线程数过多。</li><li>3、根据任务类型选择合适的异步方式：优先级低，长时间执行，HandlerThread；定时执行耗时任务，线程池。</li><li>4、创建线程必须命名，以方便定位线程归属，在运行期Thread.currentThread().setName修改名字。</li><li>5、关键异步任务监控，注意异步不等于不耗时，建议使用AOP的方式来做监控。</li><li>6、重视优先级设置（根据任务具体情况），Process.setThreadPriority();可以设置多次。</li></ul><h4 id="4、如何锁定线程创建者"><a href="#4、如何锁定线程创建者" class="headerlink" title="4、如何锁定线程创建者"></a>4、如何锁定线程创建者</h4><h5 id="锁定线程创建背景"><a href="#锁定线程创建背景" class="headerlink" title="锁定线程创建背景"></a>锁定线程创建背景</h5><ul><li>项目变大之后收敛线程。</li><li>项目源码、三方库、aar中都有线程的创建。</li></ul><h5 id="锁定线程创建方案"><a href="#锁定线程创建方案" class="headerlink" title="锁定线程创建方案"></a>锁定线程创建方案</h5><p>特别适合Hook手段，找Hook点：构造函数或者特定方法，如Thread的构造函数。</p><h5 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h5><p>在attachBaseContext中调用DexposedBridge.hookAllConstructors方法，如下所示：</p><pre><code>DexposedBridge.hookAllConstructors(Thread.class, new XC_MethodHook() {     @Override protected void afterHookedMethod（MethodHookParam param）throws Throwable {                                 super.afterHookedMethod(param);         Thread thread = (Thread) param.thisObject;         LogUtils.i(&quot;stack &quot; + Log.getStackTraceString(new Throwable());    });</code></pre><p>从log找到线程创建信息，根据堆栈信息跟相关业务方沟通解决方案。</p><h4 id="5、线程收敛优雅实践初步"><a href="#5、线程收敛优雅实践初步" class="headerlink" title="5、线程收敛优雅实践初步"></a>5、线程收敛优雅实践初步</h4><h5 id="线程收敛常规方案"><a href="#线程收敛常规方案" class="headerlink" title="线程收敛常规方案"></a>线程收敛常规方案</h5><ul><li>根据线程创建堆栈考量合理性，使用同一线程库。</li><li>各业务线下掉自己的线程库。</li></ul><h5 id="问题：基础库怎么使用线程？"><a href="#问题：基础库怎么使用线程？" class="headerlink" title="问题：基础库怎么使用线程？"></a>问题：基础库怎么使用线程？</h5><p>直接依赖线程库。</p><p><strong>缺点：</strong></p><ul><li>线程库更新可能会导致基础库更新。</li></ul><h5 id="基础库优雅使用线程"><a href="#基础库优雅使用线程" class="headerlink" title="基础库优雅使用线程"></a>基础库优雅使用线程</h5><ul><li>基础库内部暴露API：setExecutor。</li><li>初始化的时候注入统一的线程库。</li></ul><h5 id="统一线程库时区分任务类型"><a href="#统一线程库时区分任务类型" class="headerlink" title="统一线程库时区分任务类型"></a>统一线程库时区分任务类型</h5><ul><li>IO密集型：IO密集型任务不消耗CPU，核心池可以很大。</li><li>CPU密集型：核心池大小和CPU核心数相关。</li></ul><h4 id="6、线程优化核心问题"><a href="#6、线程优化核心问题" class="headerlink" title="6、线程优化核心问题"></a>6、线程优化核心问题</h4><h5 id="1、线程使用为什么会遇到问题？"><a href="#1、线程使用为什么会遇到问题？" class="headerlink" title="1、线程使用为什么会遇到问题？"></a>1、线程使用为什么会遇到问题？</h5><p>项目发展阶段忽视基础设施建设，没有采用统一的线程池，导致线程数量过多。</p><p><strong>表现形式：</strong></p><p>异步任务执行太耗时，导致主线程卡顿。</p><p><strong>问题原因：</strong></p><ul><li>Java线程调度是抢占式的，线程优先级比较重要，需要区分。</li><li>没有区分IO和CPU密集型任务，导致主线程抢不到CPU。</li></ul><h5 id="2、怎么在项目中对线程进行优化？"><a href="#2、怎么在项目中对线程进行优化？" class="headerlink" title="2、怎么在项目中对线程进行优化？"></a>2、怎么在项目中对线程进行优化？</h5><p><strong>核心：线程收敛</strong></p><ul><li>通过Hook方式找到对应线程的堆栈信息，和业务方讨论是否应该单独起一个线程，尽可能使用统一线程池。</li><li>每个基础库都暴露一个设置线程池的方法，以避免线程库更新导致基础库需要更新的问题。</li><li>统一线程池应注意IO、CPU密集型任务区分</li><li>其它细节：重要异步任务统计耗时、注重异步任务优先级和线程名的设置。</li></ul><h3 id="4、异步初始化"><a href="#4、异步初始化" class="headerlink" title="4、异步初始化"></a>4、异步初始化</h3><h4 id="1、核心思想"><a href="#1、核心思想" class="headerlink" title="1、核心思想"></a>1、核心思想</h4><p>子线程分担主线程任务，并行减少时间。</p><h4 id="2、异步优化注意点"><a href="#2、异步优化注意点" class="headerlink" title="2、异步优化注意点"></a>2、异步优化注意点</h4><ul><li>1、不符合异步要求。</li><li>2、需要在某个阶段完成（采用CountDownLatch确保异步任务完成后才到下一个阶段）。</li><li>3、如出现主线程要使用时还没初始化则在此次使用前初始化。</li><li>4、区分CPU密集型和IO密集型任务。</li></ul><h4 id="3、异步初始化方案演进"><a href="#3、异步初始化方案演进" class="headerlink" title="3、异步初始化方案演进"></a>3、异步初始化方案演进</h4><ul><li>1、new Thread</li><li>2、IntentService</li><li>3、线程池（合理配置并选择CPU密集型和IO密集型线程池）</li><li>4、异步启动器</li></ul><h4 id="4、异步优化最优解：异步启动器"><a href="#4、异步优化最优解：异步启动器" class="headerlink" title="4、异步优化最优解：异步启动器"></a>4、异步优化最优解：异步启动器</h4><h5 id="常规异步优化痛点："><a href="#常规异步优化痛点：" class="headerlink" title="常规异步优化痛点："></a>常规异步优化痛点：</h5><ul><li>1、代码不优雅。</li><li>2、场景不好处理（依赖关系）。</li><li>3、维护成本高。</li></ul><h5 id="核心思想："><a href="#核心思想：" class="headerlink" title="核心思想："></a>核心思想：</h5><p>充分利用CPU多核，自动梳理任务顺序。</p><h5 id="启动器流程"><a href="#启动器流程" class="headerlink" title="启动器流程"></a>启动器流程</h5><ul><li>任务Task化，启动逻辑抽象成Task。</li><li>根据所有任务依赖关系排序生成一个有向无环图。</li><li>多线程按照排序后的优先级依次执行。</li></ul><h3 id="5、延迟初始化"><a href="#5、延迟初始化" class="headerlink" title="5、延迟初始化"></a>5、延迟初始化</h3><h4 id="1、常规方案：利用闪屏页的停留时间进行部分初始化"><a href="#1、常规方案：利用闪屏页的停留时间进行部分初始化" class="headerlink" title="1、常规方案：利用闪屏页的停留时间进行部分初始化"></a>1、常规方案：利用闪屏页的停留时间进行部分初始化</h4><ul><li>new Handler().postDelayed()。</li><li>界面UI展示后调用。</li></ul><h4 id="2、常规初始化痛点"><a href="#2、常规初始化痛点" class="headerlink" title="2、常规初始化痛点"></a>2、常规初始化痛点</h4><ul><li>时机不容易控制。</li><li>导致界面UI卡顿。</li></ul><h4 id="3、延迟优化最优解：延迟启动器"><a href="#3、延迟优化最优解：延迟启动器" class="headerlink" title="3、延迟优化最优解：延迟启动器"></a>3、延迟优化最优解：延迟启动器</h4><h5 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h5><p>利用IdleHandler特性，在CPU空闲时执行，对延迟任务进行分批初始化。</p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li>执行时机明确。</li><li>缓解界面UI卡顿。</li><li>真正提升用户体验。</li></ul><h3 id="6、Multidex预加载优化"><a href="#6、Multidex预加载优化" class="headerlink" title="6、Multidex预加载优化"></a>6、Multidex预加载优化</h3><h4 id="1、优化步骤："><a href="#1、优化步骤：" class="headerlink" title="1、优化步骤："></a>1、优化步骤：</h4><ul><li>1、启动时单独开一个进程去异步进行Multidex的第一次加载，即Dex提取和Dexopt操作。</li><li>2、此时，主进程Application进入while循环，不断检测Multidex操作是否完成。</li><li>3、执行到Multidex时，则已经发现提取并优化好了Dex，直接执行。MultiDex执行完之后主进程Application继续执行ContentProvider初始化和Application的onCreate方法。</li></ul><p><strong>注意：</strong></p><p>5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了，无需优化，所以应判断只有在主进程及SDK 5.0以下才进行Multidex的预加载。</p><h4 id="2、dex-opt过程是怎样的？"><a href="#2、dex-opt过程是怎样的？" class="headerlink" title="2、dex-opt过程是怎样的？"></a>2、dex-opt过程是怎样的？</h4><p>主要包括inline以及quick指令的优化。</p><h5 id="inline是什么？"><a href="#inline是什么？" class="headerlink" title="inline是什么？"></a>inline是什么？</h5><p>使编译器在函数调用处用函数体代码代替函数调用指令。</p><h5 id="inline的作用？"><a href="#inline的作用？" class="headerlink" title="inline的作用？"></a>inline的作用？</h5><p>函数调用的转移操作有一定的时间和空间方面的开销，特别是对于一些函数体不大且频繁调用的函数，解决其效率问题更为重要，引入inline函数就是为了解决这一问题。</p><h5 id="inline是如何进行优化的？"><a href="#inline是如何进行优化的？" class="headerlink" title="inline是如何进行优化的？"></a>inline是如何进行优化的？</h5><p>inline函数至少在三个方面提升了程序的时间性能：</p><ul><li>1、避免了函数调用必须执行的压栈出栈等操作。</li><li>2、由于函数体代码被移到函数调用处，编译器可以获得更多的上下文信息，并根据这些信息对函数体代码和被调用者代码进行更进一步的优化。</li><li>3、若不使用inline函数，程序执行至函数调用处，需要转而去执行函数体所在位置的代码。一般函数调用位置和函数代码所在位置在代码段中并不相近，这样很容易形成操作系统的缺页中断。操作系统需要把缺页地址的代码从硬盘移入内存，所需时间将成数量级增加。而使用inline函数则可以减少缺页中断发生的机会。</li></ul><h5 id="inline使用时应注意的问题？"><a href="#inline使用时应注意的问题？" class="headerlink" title="inline使用时应注意的问题？"></a>inline使用时应注意的问题？</h5><ul><li>由于inline函数在函数调用处插入函数体代码代替函数调用，若该函数在程序的很多位置被调用，有可能造成内存空间的浪费。</li><li>一般程序的压栈出栈操作也需要一定的代码，这段代码完成栈指针调整、参数传递、现场保护和恢复等操作。<br>若函数的函数体代码量小于编译器生成的函数压栈出栈代码，则可以放心地定义为inline，这个时候占用内存空间反而会减小。而当函数体代码大于函数压栈出栈代码时，将函数定义为inline就会增加内存空间的使用。</li><li>C++程序应该根据应用的具体场景、函数体大小、调用位置多少、函数调用的频率、应用场景对时间性能的要求，应用场景对内存性能的要求等各方面因素合理决定是否定义inline函数。</li><li>inline函数内不允许用循环语句和开关语句。</li></ul><h5 id="3、预加载SharedPreferences"><a href="#3、预加载SharedPreferences" class="headerlink" title="3、预加载SharedPreferences"></a>3、预加载SharedPreferences</h5><p>可以利用MultiDex预加载期间的这段CPU去预加载SharedPreferences。</p><p><strong>注意：</strong></p><p>需重写getApplicationContext返回this，否则此时可能获取不到context。</p><h3 id="7、类预加载优化"><a href="#7、类预加载优化" class="headerlink" title="7、类预加载优化"></a>7、类预加载优化</h3><p>在Application中提前异步加载初始化耗时较长的类。</p><h4 id="如何找到耗时较长的类？"><a href="#如何找到耗时较长的类？" class="headerlink" title="如何找到耗时较长的类？"></a>如何找到耗时较长的类？</h4><p>替换系统的ClassLoader，打印类加载的时间，按需选取需要异步加载的类。</p><p><strong>注意：</strong></p><ul><li>Class.forName()只加载类本身及其静态变量的引用类。</li><li>new 类实例 可以额外加载类成员变量的引用类。</li></ul><h3 id="8、WebView启动优化"><a href="#8、WebView启动优化" class="headerlink" title="8、WebView启动优化"></a>8、WebView启动优化</h3><ul><li>1、WebView首次创建比较耗时，需要预先创建WebView提前将其内核初始化。</li><li>2、使用WebView缓存池，用到WebView的时候都从缓存池中拿，注意内存泄漏问题。</li><li>3、本地离线包，即预置静态页面资源。</li></ul><h3 id="9、页面数据预加载"><a href="#9、页面数据预加载" class="headerlink" title="9、页面数据预加载"></a>9、页面数据预加载</h3><p>在主页空闲时，将其它页面的数据加载好保存到内存或数据库，等到打开该页面时，判断已经预加载过，就直接从内存或数据库取数据并显示。</p><h3 id="10、启动阶段不启动子进程"><a href="#10、启动阶段不启动子进程" class="headerlink" title="10、启动阶段不启动子进程"></a>10、启动阶段不启动子进程</h3><p>子进程会共享CPU资源，导致主进程CPU紧张。此外，在多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作。</p><p><strong>注意启动顺序：</strong></p><p>App onCreate之前是ContentProvider初始化。</p><h3 id="11、闪屏页与主页的绘制优化"><a href="#11、闪屏页与主页的绘制优化" class="headerlink" title="11、闪屏页与主页的绘制优化"></a>11、闪屏页与主页的绘制优化</h3><ul><li>1、布局优化。</li><li>2、过渡绘制优化。</li></ul><p>关于绘制优化可以参考<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>。</p><h2 id="五、启动优化黑科技"><a href="#五、启动优化黑科技" class="headerlink" title="五、启动优化黑科技"></a>五、启动优化黑科技</h2><h3 id="1、启动阶段抑制GC"><a href="#1、启动阶段抑制GC" class="headerlink" title="1、启动阶段抑制GC"></a>1、启动阶段抑制GC</h3><p>启动时CG抑制，允许堆一直增长，直到手动或OOM停止GC抑制。（空间换时间）</p><h4 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h4><ul><li>1、设备厂商没有加密内存中的Dalvik库文件。</li><li>2、设备厂商没有改动Google的Dalvik源码。</li></ul><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li>在源码级别找到抑制GC的修改方法，例如改变跳转分支。</li><li>在二进制代码里找到 A 分支条件跳转的”指令指纹”，以及用于改变分支的二进制代码，假设为 override_A。</li><li>应用启动后扫描内存中的 libdvm.so，根据”指令指纹”定位到修改位置，然后用 override_A 覆盖。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>白名单覆盖所有设备，但维护成本高。</p><h3 id="2、CPU锁频"><a href="#2、CPU锁频" class="headerlink" title="2、CPU锁频"></a>2、CPU锁频</h3><p>在Android系统中，CPU相关的信息存储在/sys/devices/system/cpu目录的文件中，通过对该目录下的特定文件进行写值，实现对CPU频率等状态信息的更改。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>暴力拉伸CPU频率，导致耗电量增加。</p><h4 id="CPU工作模式"><a href="#CPU工作模式" class="headerlink" title="CPU工作模式"></a>CPU工作模式</h4><ul><li>performance：最高性能模式，即使系统负载非常低，cpu也在最高频率下运行。</li><li>powersave：省电模式，与performance模式相反，cpu始终在最低频率下运行。</li><li>ondemand：CPU频率跟随系统负载进行变化。</li><li>userspace：可以简单理解为自定义模式，在该模式下可以对频率进行设定。</li></ul><h4 id="CPU的工作频率范围"><a href="#CPU的工作频率范围" class="headerlink" title="CPU的工作频率范围"></a>CPU的工作频率范围</h4><p>对应的文件有：</p><ul><li>cpuinfo_max_freq</li><li>cpuinfo_min_freq</li><li>scaling_max_freq</li><li>scaling_min_freq</li></ul><h3 id="3、IO优化"><a href="#3、IO优化" class="headerlink" title="3、IO优化"></a>3、IO优化</h3><ul><li>1、启动过程不建议出现网络IO。</li><li>2、为了只解析启动过程中用到的数据，应选择合适的数据结构，如将ArrayMap改造成支持随机读写、延时解析的数据存储结构以替代SharePreference。</li></ul><p>注意：考虑重度用户的使用场景。</p><h4 id="Linux-IO知识补充"><a href="#Linux-IO知识补充" class="headerlink" title="Linux IO知识补充"></a>Linux IO知识补充</h4><h5 id="1、磁盘高速缓存技术"><a href="#1、磁盘高速缓存技术" class="headerlink" title="1、磁盘高速缓存技术"></a>1、磁盘高速缓存技术</h5><p>利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</p><p>其内存中分为两种形式：</p><ul><li>在内存中开辟一个单独的存储空间作为磁速缓存，大小固定。</li><li>把未利用的内存空间作为一个缓沖池，供请求分页系统和磁盘I/O时共享。</li></ul><h5 id="2、分页"><a href="#2、分页" class="headerlink" title="2、分页"></a>2、分页</h5><ul><li>存储器管理的一种技术。</li><li>可以使电脑的主存使用存储在辅助存储器中的数据。</li><li>操作系统会将辅助存储器（通常是磁盘）中的数据分区成固定大小的区块，称为“页”（pages）。<br>当不需要时，将分页由主存（通常是内存）移到辅助存储器；当需要时，再将数据取回，加载主存中。</li><li>相对于分段，分页允许存储器存储于不连续的区块以维持文件系统的整齐。</li><li>分页是磁盘和内存间传输数据块的最小单位。</li></ul><h5 id="3、高速缓存-缓冲器"><a href="#3、高速缓存-缓冲器" class="headerlink" title="3、高速缓存/缓冲器"></a>3、高速缓存/缓冲器</h5><ul><li>都是介于高速设备和低速设备之间。</li><li>高速缓存存放的是低速设备中某些数据的复制数据，而缓冲器则可同时存储高低速设备之间的数据。</li><li>高速缓存存放的是高速设备经常要访问的数据。</li></ul><h5 id="4、linux同步IO：sync、fsync、fdatasync"><a href="#4、linux同步IO：sync、fsync、fdatasync" class="headerlink" title="4、linux同步IO：sync、fsync、fdatasync"></a>4、linux同步IO：sync、fsync、fdatasync</h5><p><strong>为什么要使用同步IO？</strong></p><p>当数据写入文件时，内核通常先将该数据复制到缓冲区高速缓存或页面缓存中，如果该缓冲区尚未写满，则不会将其排入输入队列，而是等待其写满或内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，最后等待其到达队首时，才进行实际的IO操作—延迟写。</p><p>延迟写减少了磁盘读写次数，但是却降低了文件内容的更新速度，可能会造成文件更新内容的丢失。为了保证数据一致性，则需使用同步IO。</p><p><strong>sync</strong></p><ul><li>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际磁盘写操作结束再返回。</li><li>通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。</li></ul><p><strong>fsync</strong></p><ul><li>fsync函数只对文件描述符filedes指定的单一文件起作用，并且等待磁盘IO写结束后再返回。通常应用于需要确保将修改内容立即写到磁盘的应用如数据库。</li><li>文件的数据和metadata通常存放在硬盘的不同地方，因此fsync至少需要两次IO操作。</li></ul><p><strong>补充：msync</strong></p><p>如果当前硬盘的平均寻道时间是3-15ms，7200RPM硬盘的平均旋转延迟大约为4ms，因此一次IO操作的耗时大约为10ms。</p><p>如果使用内存映射文件的方式进行文件IO（mmap），将文件的page cache直接映射到进程的地址空间，这时需要使用msync系统调用确保修改的内容完全同步到硬盘之上。</p><p><strong>fdatasync</strong></p><ul><li>fdatasync函数类似于fsync，但它只影响文件的数据部分。而fsync还会同步更新文件的属性。</li><li>仅仅只在必要（如文件尺寸需要立即同步）的情况下才会同步metadata，因此可以减少一次IO操作。</li></ul><p><strong>日志文件都是追加性的，文件尺寸一致在增大，如何利用好fdatasync减少日志文件的同步开销？</strong></p><p>创建每个log文件时先写文件的最后一个page，将log文件扩展为10MB大小，这样便可以使用fdatasync，每写10MB只有一次同步metadata的开销。</p><h5 id="5、网络IO和磁盘IO"><a href="#5、网络IO和磁盘IO" class="headerlink" title="5、网络IO和磁盘IO"></a>5、网络IO和磁盘IO</h5><p><strong>磁盘IO（缓存IO）</strong></p><p>标准IO，大多数文件系统默认的IO操作。</p><ul><li>数据先从磁盘复制到内核空间的缓冲区，然后再从内核空间中的缓冲区复制到应用程序的缓冲区。</li><li>读操作：操作系统检查内核的缓冲区有没有需要的数据，如果已经有缓存了，那么直接从缓存中返回；否则，从磁盘中返回，再缓存在操作系统的磁盘中。</li><li>写操作：将数据从用户空间复制到内核空间中的缓冲区中，这时对用户来说写操作就已经完成，至于什么时候写到磁盘中，由操作系统决定，除非显示地调用了sync同步命令。</li></ul><p><strong>优点</strong></p><ul><li>在一定程度上分离了内核空间和用户空间，保护系统本身安全。</li><li>可以减少磁盘IO的读写次数，从而提高性能。</li></ul><p><strong>缺点</strong></p><p>DMA方式可以将数据直接从磁盘读到页缓存中，或者将数据从页缓存中写回到磁盘，而不能在应用程序地址空间和磁盘之间进行数据传输，这样，数据在传输过程中需要在应用程序地址空间（用户空间）和缓存（内核空间）中进行多次数据拷贝操作，这带来的CPU以及内存开销是非常大的。</p><p><strong>磁盘IO主要的延时（15000RPM硬盘为例）</strong></p><p>机械转动延时（平均2ms）+ 寻址延时（2~3ms）+ 块传输延时（0.1ms左右）=&gt; 平均5ms</p><p><strong>网络IO主要延时</strong></p><p>服务器响应延时 + 带宽限制 + 网络延时 + 跳转路由延时 + 本地接收延时（一般为几十毫秒到几千毫秒，受环境影响极大）</p><h5 id="6、PIO与DMA"><a href="#6、PIO与DMA" class="headerlink" title="6、PIO与DMA"></a>6、PIO与DMA</h5><p><strong>PIO</strong></p><p>很早之前，磁盘和内存之间的数据传输是需要CPU控制的，也就是读取磁盘文件到内存中时，数据会经过CPU存储转发，这种方式称为PIO。</p><p><strong>DMA（直接内存访问，Direct Memory Access）</strong></p><ul><li>可以不经过CPU而直接进行磁盘和内存的数据交换。</li><li>CPU只需要向DMA控制器下达指令，让DMA控制器来处理数据的传送即可。</li><li>DMA控制器通过系统总线来传输数据，传送完毕再通知CPU，这样就在很大程度上降低了CPU占用率，大大节省了系统资源，而它的传输速度与PIO的差异并不明显，而这主要取决于慢速设备的速度。</li></ul><h5 id="7、直接IO与异步IO"><a href="#7、直接IO与异步IO" class="headerlink" title="7、直接IO与异步IO"></a>7、直接IO与异步IO</h5><p><strong>直接IO</strong></p><p>应用程序直接访问磁盘数据，而不经过内核缓冲区。以减少从内核缓冲区到用户数据缓存的数据复制。</p><p><strong>异步IO</strong></p><p>当访问数据的线程发出请求后，线程会接着去处理其它事情，而不是阻塞等待。</p><h5 id="8、VFS（虚拟文件系统，Virtual-File-System）"><a href="#8、VFS（虚拟文件系统，Virtual-File-System）" class="headerlink" title="8、VFS（虚拟文件系统，Virtual File System）"></a>8、VFS（虚拟文件系统，Virtual File System）</h5><p>可以为访问文件系统的系统调用提供一个统一的抽象接口。</p><h3 id="4、数据重排"><a href="#4、数据重排" class="headerlink" title="4、数据重排"></a>4、数据重排</h3><p>Dex文件用到的类和APK里面各种资源文件都比较小，读取频繁，且磁盘地址分布范围比较广。我们可以利用Linux文件IO流程中的page cache机制将它们按照读取顺序重新排列在一起，以减少真实的磁盘IO次数。</p><h4 id="1、类重排"><a href="#1、类重排" class="headerlink" title="1、类重排"></a>1、类重排</h4><p>使用Facebook的ReDex的Interdex调整类在Dex中的排列顺序。</p><h4 id="2、资源文件重排"><a href="#2、资源文件重排" class="headerlink" title="2、资源文件重排"></a>2、资源文件重排</h4><ul><li>最佳方案是修改内核源码，实现统计、度量、自动化。</li><li>其次可以使用Hook框架进行统计得出资源加载顺序列表。</li><li>最后，调整apk文件列表需要修改7zip源码以支持传入文件列表顺序。</li></ul><h4 id="技术视野："><a href="#技术视野：" class="headerlink" title="技术视野："></a>技术视野：</h4><ul><li>所谓的创新，不一定是要创造前所未有的东西，也可以将已有的方案移植到新的平台，并结合该平台的特性落地，就是一个很大的创新。</li><li>当我们足够熟悉底层的知识时，可以利用系统的特性去做更加深层次的优化。</li></ul><h4 id="3、Hook框架"><a href="#3、Hook框架" class="headerlink" title="3、Hook框架"></a>3、Hook框架</h4><h5 id="Xposed框架是什么？"><a href="#Xposed框架是什么？" class="headerlink" title="Xposed框架是什么？"></a>Xposed框架是什么？</h5><p>一个可以不修改APK就影响程序运行的Hook框架。</p><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>用自身实现的app_process替换掉系统/system/bin/app_process，加载一个额外的XposedBridge的jar包，用于将入口osZygoteInit.main()替换成XposedBridge.main()。之后，创建的Zygote进程和其子进程都是Hook过的了。</p><p>使用具体细节参见<a href="https://blog.csdn.net/coder_pig/article/details/80031285" target="_blank" rel="external">Xposed教程</a>。</p><h3 id="5、类加载优化（Dalvik）"><a href="#5、类加载优化（Dalvik）" class="headerlink" title="5、类加载优化（Dalvik）"></a>5、类加载优化（Dalvik）</h3><h4 id="1、类预加载原理"><a href="#1、类预加载原理" class="headerlink" title="1、类预加载原理"></a>1、类预加载原理</h4><p>对象第一次创建的时候，JVM首先检查对应的Class对象是否已经加载。如果没有加载，JVM会根据类名查找.class文件，将其Class对象载入。同一个类第二次new的时候就不需要加载类对象，而是直接实例化，创建时间就缩短了。</p><h4 id="2、类加载优化过程"><a href="#2、类加载优化过程" class="headerlink" title="2、类加载优化过程"></a>2、类加载优化过程</h4><ul><li>在Dalvik VM加载类的时候会有一个类校验过程，它需要校验方法的每一个指令。</li><li>通过Hook去掉verify步骤 -&gt; 几十ms的优化</li><li>最大优化场景在于首次安装和覆盖安装时，在Dalvik平台上，一个2MB的Dex正常需要350ms，将classVerifyMode设为VERIFY_MODE_NONE后，只需150ms，节省超过50%时间。</li></ul><p>ART比较复杂，Hook需要兼容几个版本。而且在安装时，大部分Dex已经优化好了，去掉ART平台的verify只会对动态加载的Dex带来一些好处。所以暂时不建议在ART平台使用。</p><h4 id="3、延伸：插件化和热修复"><a href="#3、延伸：插件化和热修复" class="headerlink" title="3、延伸：插件化和热修复"></a>3、延伸：插件化和热修复</h4><p>在设计上都存在大量的Hook和私有API调用</p><p><strong>缺点：</strong></p><p>1、稳定性较差</p><p>由于厂商的兼容性、安装失败、ART加载时dex2oat失败等原因，还是会有一些代码和资源的异常。Android P推出的non-sdk-interface调用限制，以后适配只会越来越难，成本越来越高。</p><p>2、性能问题</p><p>用到一些黑科技导致底层Runtime的优化享受不到。如Tinker加载补丁后，启动速度会降低5%~10%。</p><h5 id="1、各项热补丁技术的优缺点"><a href="#1、各项热补丁技术的优缺点" class="headerlink" title="1、各项热补丁技术的优缺点"></a>1、各项热补丁技术的优缺点</h5><p><strong>缺点：</strong></p><ul><li>只针对单一客户端版本，随着版本差异变大补丁体积也会变大。</li><li>不支持所有修改，如AndroidManifest。</li><li>对代码和资源的更新成功率无法达到100%。</li></ul><p><strong>优点：</strong></p><ul><li>降低开发成本，轻量而快速地升级。发布补丁等同于发布版本，也应该完整地执行测试与上线流程。</li><li>远端调试，只为特定用户发送补丁。</li><li>数据统计，对同一批用户更换补丁版本，能够更好地进行ABTest，得到更精确的数据。</li></ul><h5 id="2、InstanceRun实现机制"><a href="#2、InstanceRun实现机制" class="headerlink" title="2、InstanceRun实现机制"></a>2、InstanceRun实现机制</h5><p>Android官方使用热补丁技术实现InstantRun。</p><p><strong>应用构建流程：</strong></p><p>构建 -&gt; 部署 -&gt; 安装 -&gt; 重启app -&gt; 重启activity</p><p><strong>实现目标：</strong></p><p>尽可能多的剔除不必要的步骤，然后提升必要步骤的速度。</p><p><strong>InstantRun构建的三种方式：</strong></p><p><strong>1、HotSwap</strong></p><p>增量构建 -&gt; 改变部署</p><p><strong>场景：</strong></p><p>适用于多数简单的改变（包括一些方法实现的修改，或者变量值修改）。</p><p><strong>2、Warm Swap</strong></p><p>增量构建 -&gt; 改变部署 -&gt; activity重启</p><p><strong>场景：</strong></p><p>一般是修改了resources。</p><p><strong>3、Cold Swap</strong></p><p>增量构建 -&gt; 改变部署 -&gt; 应用重启 -&gt; activity重启</p><p><strong>场景：</strong></p><p>涉及结构性变化，如修改了继承规则或方法签名。</p><p><strong>补充：apk打包流程</strong></p><p>manifest文件合并、打包，和res一起被AAPT合并到APK中，同时项目代码被编译成字节码，然后转换成.dex文件，也被合并到APK中。</p><p><strong>Android打包流程回顾，最后对于release签名apk需要进行zipalign优化，它是指什么？</strong></p><p>概念补充：内存对齐（DSA，Data Structure Alignment）</p><p>各种类型的数据按照一定的规则在内存空间上排列，这就是对齐。</p><p><strong>优势：</strong></p><p>基于效率考虑，空间换时间，减少数据存取指令周期。</p><p><strong>编译器内存字节对齐的原则是什么？</strong></p><ul><li>1、数据类型的自身对齐值就是其长度（64位 OS）。</li><li>2、结构体或类的自身对齐值就是成员中自身对齐值最大的那个。需要起始地址必须是其相应有效对齐值的整数，并要求结构体的大小也为该结构体有效对齐值的整数倍。</li></ul><p>zipalign优化的最根本目的是<strong>帮助操作系统更高效地根据请求索引资源，使用resource-handling code统一将DSA限定为4byte。</strong></p><p><strong>手动执行Align优化</strong></p><p>利用build-tools文件夹下对应Android版本中的zipalign工具：</p><pre><code>zipalign -v 4 source.apk androidres.apk</code></pre><p>检查当前APK是否已经执行过Align优化：</p><pre><code>zipalign -c -v 4 androidres.apk</code></pre><p>其中：</p><ul><li>-c：检查。</li><li>-v：代表详细输出。</li><li>4：代表对齐为4个字节。</li></ul><p><strong>首次运行Instant Run，Gradle执行的操作</strong></p><ul><li>在有Instant Run的环境下：一个新的App Server会被注入到App中，与Bytecode instrumentation协同监控代码的变化。</li><li>同时会有一个新的Application类，它注入了一个自定义类加载器。同时该Application会启动我们所需的新注入的App Server。于是，AndroidManifest会被修改来确保我们能使用这个新的Application。</li><li>使用的时候，它会通过决策，合理运用冷温热拔插来协助我们大量地缩短构建程序的时间。</li></ul><p><strong>HotSwap原理</strong></p><p>Android Studio monitors<br>运行着Gradle任务来生成增量.dex文件（dex对应着开发中的修改类），AS会提取这些.dex文件发送到App Server，然后部署到App。因为原来版本的类都装载在运行中的程序了，Gradle会解释更新好这些.dex文件，发送到App Server的时候，交给自定义的类加载器来加载.dex文件。<br>App Server会不断地监听是否需要重写类文件，如果需要，任务会被立马执行，新的更改便能立即被响应。</p><p><strong>注意：</strong></p><p>此时Instant Run是不能回退的，必须重启应用响应修改。</p><p><strong>WarmSwap原理</strong></p><p>因为资源文件是在Activity创建时加载，所以必须重启Activity加载资源文件。</p><p><strong>注意：</strong></p><p>AndroidManifest的值是在APK安装的时候被读取的，所以需要触发一个完整的应用构建和部署。</p><p>ColdSwap原理</p><p>应用部署的时候，会把工程拆分成十个部分，每个部分都拥有自己的.dex文件，然后所有的类会根据包名被分配给相应的.dex文件。当ColdSwap开启时，修改过的类所对应的的.dex文件，会重组生成新的.dex文件，然后再部署到设备上。</p><p><strong>注意：</strong></p><p>应用多进程会被降级为ColdSwap。</p><h5 id="3、AndFix"><a href="#3、AndFix" class="headerlink" title="3、AndFix"></a>3、AndFix</h5><p><strong>实现原理：</strong></p><p>native hook -&gt; dalvik_repleaceMethod -&gt; 无法支持新增或删除filed的情况 -&gt; 需修复特定问题</p><p><strong>优点：</strong></p><ul><li>立即生效</li><li>补丁较小</li></ul><p><strong>缺点：</strong></p><ul><li>兼容性不佳</li><li>开发不透明</li></ul><h5 id="4、Qzone"><a href="#4、Qzone" class="headerlink" title="4、Qzone"></a>4、Qzone</h5><p>基于Android Dex分包方案。</p><p>将多个dex文件放入到app的classloader中，但是android dex拆包方案中的类是没有重复的，如果classes.dex和classes1.dex中有重复的类，<strong>当用到这个重复的类时，系统会选择哪个类进行加载呢？</strong></p><p>一个ClassLoader可以包含多个dex文件，每个dex文件是一个Elements，多个dex文件排列成有序的dexElements，当找类的时候，会按顺序遍历dex文件，然后从当前遍历的dex文件中找类，如果找到则返回，如果找不到从下一个dex文件继续查找。</p><p>所以，如果在不同的dex中有相同的类存在，那么会优先选择排在前面的dex文件的类。</p><p>Qzone热补丁方案就是把有问题的类打包到一个dex（patch.dex）中去，然后把这个dex插入到Elements的最前面。</p><p><strong>实现中遇到的问题</strong></p><p><strong>当其它dex文件中的类引用了patch.dex中的类时，会出现校验错误。拆分dex的很多类都不是在同一个dex内的，怎么没有问题？</strong></p><p>因为这个校验有个前提，当引用类被打上了CLASS_ISPREVERIFIED标志，那么就会进行dex的校验。</p><p><strong>CLASS_ISPREVERIFIED标志是什么时候被打上去的？</strong></p><ul><li>在dex转换成odex（dexopt过程）时，当apk在安装的时候，apk中的classes.dex会被虚拟机（dexopt）优化成odex文件，然后才会拿去执行。</li><li>虚拟机在启动的时候，会有许多的启动参数，其中一项就是verify选项，当verify选项被打开时，doVerify变量为true，那么就会执行dvmVerifyClass进行类的校验，如果校验成功，这个类会被打上CLASS_ISPREVERIFIED标志。</li></ul><p><strong>具体的校验过程是怎么样的？</strong></p><p>有两步验证：</p><p>1、验证clazz -&gt; directMethods方法，其包含以下方法：</p><ul><li>static方法</li><li>private方法</li><li>构造函数</li></ul><p>2、clazz -&gt; virtualMethods</p><ul><li>虚函数 = override方法</li></ul><p>如果以上方法中直接引用到的类（第一层级关系，不会进行递归搜索）和clazz<strong>都在同一个dex中</strong>的话，那么这个类就会被打上CLASS_ISPREVERIFED标志。</p><p>为了解决补丁方案中遇到的问题，所以必须从这些方法中入手，防止类被打上CLASS_ISPREVERIFIED标志。空间的方案是往所有类的构造函数里面插入一段代码：</p><pre><code>If (ClassVerifier.PREVENT_VERIFY) {    System.out.println(AntilazyLoad.class);}</code></pre><p>其中AntilazyLoad类会被打包成单独的hack.dex，这样当安装apk的时候，classes.dex中的类都会引用一个在不同dex中的AntilazyLoad类，这样就防止类被打上了CLASS_ISPREVERIFILED标志，只要没被打上这个标志的类都可以进行打补丁操作。</p><p><strong>注意：</strong></p><ul><li>1、在应用启动进行加载时，AntilazyLoad类所在的dex包必须先加载进来，不然AntilazyLoad类会被标记为不存在，即使后续加载了hack.dex包，那么它也是不存在的。</li><li>2、当在Application的onCreate中加载hack.dex时，Application不能插入上述代码。</li></ul><p><strong>为什么要选择构造函数？</strong></p><p>因为他不增加方法数，一个类即使没有显示的构造函数，也有一个隐式的默认构造函数。</p><p><strong>如何更高效地插入上述代码？</strong></p><p>可以使用ASM/javaassist库来进行字节码插入代码。</p><p><strong>Art的处理</strong></p><p>Art采用了新的方式，插桩对代码的执行效率没有影响。但是补丁中的类出现修改类变量或者方法，可能会导致出现内存地址错乱的情况。</p><p><strong>原因：</strong></p><p>dex2oat时fast*已经将类能确定的各个地址写死。如果运行时补丁包的地址出现改变，原始类去调用时就会出现地址错乱。</p><p><strong>解决方法：</strong></p><p>将其父类以及调用类的所有类都加入到补丁包中。</p><p><strong>虚拟机在安装期间为类打上CLASS_ISPREVERIFIED标志是为了什么</strong>？</p><p>为了提高性能。</p><p><strong>禁用CLASS_ISPREVERIFIED是否会影响APP的性能</strong>？</p><p>由于现在很多App都使用了MultiDex分包方案，这导致了很多类都没有被打上这个标志，所以此时禁用所有类打上CLASS_ISPREVERIFIED标志对性能的影响不是很大。</p><p><strong>如何有效地生成补丁包</strong>？</p><ul><li>1、在正式版本发布的时候，会生成一份缓存文件，里面记录了所有class文件的MD5值，还有一份mapping混淆文件。</li><li>2、在后续的版本中使用-applaymapping选项，应用正式版本的mapping文件，然后计算编译完成的class文件的MD5和正式版本进行比较，把不相同的class文件打包成补丁包。</li></ul><p><strong>Qzone方案缺点：</strong></p><p>在补丁包大小与性能损耗上有一定的局限性。</p><h5 id="5、补充：ASM字节码插桩"><a href="#5、补充：ASM字节码插桩" class="headerlink" title="5、补充：ASM字节码插桩"></a>5、补充：ASM字节码插桩</h5><p>插桩就是将一段代码插入或者替换原本的代码。<br>字节码插桩就是在我们的代码编译成字节码（Class）后，在Android下生成dex之前修改Class文件，修改或者增强原有代码逻辑的操作。</p><p><strong>原理：</strong></p><p>利用注解来标记需要插桩的方法，结合编译后操作字节码来帮助我们自动插入，当不需要时，关闭插桩即可。</p><p>除了Javassist框架外，还有一个应用更为广泛的ASM框架同样也是字节码操作框架，Instant Run包括AspectJ就是借助ASM来实现各自的功能。</p><p>JSON对于GSON就类似于字节码Class对于Javassist/ASM。</p><p><strong>Android ASM自动埋点方案实践</strong></p><p><strong>原理：</strong></p><p>Android 1.5.0版本以后提供了Transform API，允许第三方Plugin在打包dex文件之前的编译过程中操作.class文件，我们做的就是实现Transform进行.class文件遍历拿到所有方法，修改完成后对文件进行替换。</p><p><strong>流程：</strong></p><p><strong>1、自动埋点追踪，遍历所有文件更换字节码</strong></p><pre><code>AutoTransform -&gt; transform -&gt; inputs.each {TransformInput input -&gt; input.jarInput.each { JarInput jarInput -&gt; … } input.directoryInputs.each { DirectoryInput directoryInput -&gt; … }}</code></pre><p><strong>2、Gradle插件实现</strong></p><pre><code>PluginEntry -&gt; apply -&gt; def android = project.extensions.getByType(AppExtension)registerTransform(android) -&gt; AutoTransform transform = new AutoTransformandroid.registerTransform(transform)</code></pre><p><strong>3、使用ASM进行字节码编写</strong></p><p><strong>ASM框架核心类</strong></p><ul><li>ClassReader：读取编译后的.class文件。</li><li>ClassWriter：重新构建编译后的类。</li><li>ClassVisitor：拜访类成员信息。</li><li>AdviceAdapter：实现MethodVisitor接口，拜访方法的信息。</li></ul><p>1、visit -&gt; 在ClassVisitor中根据判断是否是实现View$OnClickListener接口的类，只有满足条件的类才会遍历其中的方法进行操作。</p><p>2、在MethodVisitor中对该方法进行修改</p><pre><code>visitAnnotation -&gt; onMethodEnter -&gt; onMethodExit</code></pre><p>3、先在java文件中编写要插入的代码，然后使用ASM插件查看对应的字节码，根据其用ASM提供的Api一一对应地把代码填进来。</p><h5 id="6、Tinker"><a href="#6、Tinker" class="headerlink" title="6、Tinker"></a>6、Tinker</h5><p><strong>原理：</strong></p><ul><li>全量替换新的Dex</li><li>在编译时通过新旧两个Dex生成差异patch.dex。在运行时，将差异patch.dex重新跟原始安装包的旧Dex还原为新的Dex。由于比较耗费时间与内存，放在后台进程:patch中，为了补丁包尽可能小，微信自研了DexDiff算法，它深度利用Dex的格式来减少差异的大小。</li></ul><p>DexDiff的粒度是Dex格式的每一项，BsDiff的粒度是文件，AndFix/Qzone的粒度为class。</p><p><strong>缺点：</strong></p><ul><li>1、占用Rom体积，1.5倍所修改Dex大小 = Dex.jar + dexopt文件。</li><li>2、一个额外的合成过程，合成时间长短和额外的内存消耗也会影响最终的成功率。</li></ul><p><strong>热补丁方案对比</strong></p><p>若不care性能损耗与补丁包大小，Qzone是最简单且成功率最高的方案。</p><h5 id="7、完善的热补丁系统构建"><a href="#7、完善的热补丁系统构建" class="headerlink" title="7、完善的热补丁系统构建"></a>7、完善的热补丁系统构建</h5><p>一、网络通道</p><p>负责将补丁包交付给用户，包括特定用户和全量用户。</p><p>1、pull通道</p><p>在登录/24小时等时机，通过pull方式查询后台是否有对应的补丁包更新。</p><p>2、指定版本的push通道</p><p>在紧急情况下，我们可以在一个小时内向所有用户下发补丁包更新。</p><p>3、指定特定用户的push通道</p><p>对特定用户或用户组做远程调试。</p><p>二、上线与管理平台</p><p>快速上线，管理历史记录，以及监控补丁的运行情况。</p><h3 id="6、保活"><a href="#6、保活" class="headerlink" title="6、保活"></a>6、保活</h3><h4 id="1、厂商合作"><a href="#1、厂商合作" class="headerlink" title="1、厂商合作"></a>1、厂商合作</h4><h4 id="2、微信Hardcoder"><a href="#2、微信Hardcoder" class="headerlink" title="2、微信Hardcoder"></a>2、微信Hardcoder</h4><p>构建了App与系统（ROM）之间可靠的通信框架，让系统知道App的需求。</p><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><ul><li>让App跨过Framework直接跟厂商ROM通信。</li><li>分为Client端和Server端，Server端由厂商系统侧自行实现。</li><li>它们直接采用LocalSocket方式，Hardcoder是Native实现的，使用了Linux的Socket接口实现了一套自己的LocalSocket。</li></ul><h5 id="性能提升有多少？"><a href="#性能提升有多少？" class="headerlink" title="性能提升有多少？"></a>性能提升有多少？</h5><p>平均10%~30%。</p><h4 id="3、OPPO-Hyper-Boost加速引擎"><a href="#3、OPPO-Hyper-Boost加速引擎" class="headerlink" title="3、OPPO Hyper Boost加速引擎"></a>3、OPPO Hyper Boost加速引擎</h4><p>一种优化资源调度的技术。</p><h5 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h5><p>让应用程序与系统资源实现实时”双向对话”。当来自应用和游戏程序的不同场景和用户行为被Hyper Boost识别后，手机会智能地匹配到合理的系统资源，让手机SoC的CPU、GPU、ISP、DSP提供的运算资源更加合理地利用，从而让用户使用手机更加流畅。</p><h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h3 id="1、优化总方针"><a href="#1、优化总方针" class="headerlink" title="1、优化总方针"></a>1、优化总方针</h3><ul><li>异步、延迟、懒加载</li><li>技术、业务相结合</li></ul><h3 id="2、注意事项"><a href="#2、注意事项" class="headerlink" title="2、注意事项"></a>2、注意事项</h3><h4 id="1、cpu-time和wall-time"><a href="#1、cpu-time和wall-time" class="headerlink" title="1、cpu time和wall time"></a>1、cpu time和wall time</h4><ul><li>wall time（代码执行时间）与cpu time（代码消耗CPU时间），锁冲突会造成两者时间差距过大。</li><li>cpu time才是优化方向，应尽力按照systrace的cpu time和wall time跑满cpu。</li></ul><h4 id="2、监控的完善"><a href="#2、监控的完善" class="headerlink" title="2、监控的完善"></a>2、监控的完善</h4><ul><li>线上监控多阶段时间（App、Activity、生命周期间隔时间）。</li><li>处理聚合看趋势。</li><li>收敛启动代码修改权限。</li><li>结合CI修改启动代码需要Review通知。</li></ul><h4 id="3、常见问题"><a href="#3、常见问题" class="headerlink" title="3、常见问题"></a>3、常见问题</h4><h5 id="1、启动优化是怎么做的？"><a href="#1、启动优化是怎么做的？" class="headerlink" title="1、启动优化是怎么做的？"></a>1、启动优化是怎么做的？</h5><ul><li>分析现状、确认问题</li><li>针对性优化（先概括，引导其深入）</li><li>长期保持优化效果</li></ul><h5 id="2、是怎么异步的，异步遇到问题没有？"><a href="#2、是怎么异步的，异步遇到问题没有？" class="headerlink" title="2、是怎么异步的，异步遇到问题没有？"></a>2、是怎么异步的，异步遇到问题没有？</h5><ul><li>体现演进过程</li><li>详细介绍启动器</li></ul><h5 id="3、启动优化有哪些容易忽略的注意点？"><a href="#3、启动优化有哪些容易忽略的注意点？" class="headerlink" title="3、启动优化有哪些容易忽略的注意点？"></a>3、启动优化有哪些容易忽略的注意点？</h5><ul><li>cpu time与wall time</li><li>注意延迟初始化的优化</li><li>介绍下黑科技</li></ul><h5 id="4、版本迭代导致的启动变慢有好的解决方式吗？"><a href="#4、版本迭代导致的启动变慢有好的解决方式吗？" class="headerlink" title="4、版本迭代导致的启动变慢有好的解决方式吗？"></a>4、版本迭代导致的启动变慢有好的解决方式吗？</h5><ul><li>启动器</li><li>结合CI</li><li>监控完善</li></ul><p>至此，探索Android启动速度优化的旅途也应该告一段落了，如果你耐心读到最后的话，会发现要想极致地提升App的性能，需要有一定的广度，如我们<strong>引入了始于后端的AOP编程来实现无侵入式的函数插桩</strong>，也需要有一定的深度，从前面的探索之旅来看，<strong>我们先后涉及了Framework层、Native层、Dalvik虚拟机、甚至是Linux IO和文件系统相关的原理</strong>。因此，我想说，Android开发并不简单，即使是App层面的性能优化这一知识体系，也是需要我们不断地加深自身知识的深度和广度。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://time.geekbang.org/column/article/73651" target="_blank" rel="external">Android开发高手课之启动优化</a></p><p>2、<a href="https://yq.aliyun.com/articles/672750" target="_blank" rel="external">支付宝客户端架构解析：Android<br>客户端启动速度优化之「垃圾回收」</a></p><p>3、<a href="https://yq.aliyun.com/articles/680526" target="_blank" rel="external">支付宝 App 构建优化解析：通过安装包重排布优化 Android 端启动性能</a></p><p>4、<a href="https://github.com/facebook/redex" target="_blank" rel="external">Facebook Redex字节码优化工具</a></p><p>5、<a href="https://blog.csdn.net/tencent_bugly/article/details/51821722" target="_blank" rel="external">微信Android热补丁实践演进之路</a></p><p>6、<a href="https://zhuanlan.zhihu.com/p/20308548" target="_blank" rel="external">安卓App热补丁动态修复技术介绍</a></p><p>7、<a href="https://blog.csdn.net/fishmai/article/details/52398485" target="_blank" rel="external">Dalvik Optimization and Verification With dexopt</a></p><p>8、<a href="https://github.com/Tencent/Hardcoder" target="_blank" rel="external">微信在Github开源了Hardcoder，对Android开发者有什么影响？</a></p><p>9、<a href="http://mobile.yesky.com/433/311567433.shtml" target="_blank" rel="external">历时三年研发，OPPO 的 Hyper Boost 引擎如何对系统、游戏和应用实现加速？</a></p><p>10、<a href="https://blog.csdn.net/coder_pig/article/details/80031285" target="_blank" rel="external">抱歉，Xposed真的可以为所欲为</a></p><p>11、<a href="https://blog.csdn.net/balian8/article/details/53319580" target="_blank" rel="external">墙上时钟时间 ，用户cpu时间 ，系统cpu时间的理解</a>  </p><p>12、《Android应用性能优化最佳实践》</p><p>13、<a href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ?" target="_blank" rel="external">必知必会 | Android 性能优化的方面方面都在这儿</a></p><p>14、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">极客时间之Top团队大牛带你玩转Android性能分析与优化</a></p><p>15、<a href="https://github.com/zeshaoaaa/LaunchStarter" target="_blank" rel="external">启动器源码</a></p><p>16、<a href="https://github.com/lanshifu/MultiDexTest" target="_blank" rel="external">MultiDex优化源码</a></p><p>17、<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter07" target="_blank" rel="external">使用gradle自动化增加Trace Tag</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android性能优化之内存优化</title>
      <link>http://yoursite.com/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 18 Aug 2019 14:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。本篇，笔者将带领大家一起来系统地学习Android中的内存优化。</p><p>可能有不少读者都知道，在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面自动分配和释放内存，因此不需要像使用C/C++一样在代码中分配和释放某一块内存。Android系统的内存管理类似于JVM，通过new关键字来为对象分配内存，内存的释放由GC来回收。并且Android系统在内存管理上有一个Generational Heap Memory模型，当内存达到某一个阈值时，系统会根据不同的规则自动释放可以释放的内存。即便有了内存管理机制，但是，如果不合理地使用内存，也会造成一系列的性能问题，比如内存泄漏、内存抖动、短时间内分配大量的内存对象等等。下面，我就先谈谈Android的内存管理机制。</p><h3 id="一、Android内存管理机制"><a href="#一、Android内存管理机制" class="headerlink" title="一、Android内存管理机制"></a>一、Android内存管理机制</h3><p>我们都知道，应用程序的内存分配和垃圾回收都是由Android虚拟机完成的，在Android 5.0以下，使用的是Dalvik虚拟机，5.0及以上，则使用的是ART虚拟机。</p><h4 id="1-1、Java对象生命周期"><a href="#1-1、Java对象生命周期" class="headerlink" title="1.1、Java对象生命周期"></a>1.1、Java对象生命周期</h4><p>Java代码编译后生成的字节码.class文件从从文件系统中加载到虚拟机之后，便有了JVM上的Java对象，Java对象在JVM上运行有7个阶段，如下：</p><ul><li>Created</li><li>InUse</li><li>Invisible</li><li>Unreachable</li><li>Collected</li><li>Finalized</li><li>Deallocated</li></ul><h5 id="1、Created（创建）"><a href="#1、Created（创建）" class="headerlink" title="1、Created（创建）"></a>1、Created（创建）</h5><p>Java对象的创建分为如下几步：</p><ul><li>1、为对象分配存储空间。</li><li>2、构造对象。</li><li>3、从超类到子类对static成员进行初始化，类的static成员的初始化在ClassLoader加载该类时进行。</li><li>4、超类成员变量按顺序初始化，递归调用超类的构造方法。</li><li>5、子类成员变量按顺序初始化，一旦对象被创建，子类构造方法就调用该对象并为某些变量赋值。</li></ul><h5 id="2、InUse（应用）"><a href="#2、InUse（应用）" class="headerlink" title="2、InUse（应用）"></a>2、InUse（应用）</h5><p>此时对象至少被一个强引用持有。</p><h5 id="3、Invisible（不可见）"><a href="#3、Invisible（不可见）" class="headerlink" title="3、Invisible（不可见）"></a>3、Invisible（不可见）</h5><p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该对象仍然是存在的。简单的例子就是程序的执行已经超出了该对象的作用域了。但是，该对象仍可能被虚拟机下的某些已装载的静态变量线程或JNI等强引用持有，这些特殊的强引用称为“GC Root”。被这些GC Root强引用的对象会导致该对象的内存泄漏，因而无法被GC回收。</p><h5 id="4、Unreachable（不可达）"><a href="#4、Unreachable（不可达）" class="headerlink" title="4、Unreachable（不可达）"></a>4、Unreachable（不可达）</h5><p>该对象不再被任何强引用持有。</p><h5 id="5、Collected（收集）"><a href="#5、Collected（收集）" class="headerlink" title="5、Collected（收集）"></a>5、Collected（收集）</h5><p>当GC已经对该对象的内存空间重新分配做好准备时，对象进入收集阶段，如果该对象重写了finalize()方法，则执行它。</p><h5 id="6、Finalized（终结）"><a href="#6、Finalized（终结）" class="headerlink" title="6、Finalized（终结）"></a>6、Finalized（终结）</h5><p>等待垃圾回收器回收该对象空间。</p><h5 id="7、Deallocated（对象空间重新分配）"><a href="#7、Deallocated（对象空间重新分配）" class="headerlink" title="7、Deallocated（对象空间重新分配）"></a>7、Deallocated（对象空间重新分配）</h5><p>GC对该对象所占用的内存空间进行回收或者再分配，则该对象彻底消失。</p><h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul><li>1、不需要使用该对象时，及时置空。</li><li>2、访问本地变量优于访问类中的变量。</li></ul><h4 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h4><p>在Android系统中，堆实际上就是一块匿名共享内存。Android虚拟机仅仅只是把它封装成一个mSpace，由底层C库来管理，并且仍然使用libc提供的函数malloc和free来分配和释放内存。</p><p>大多数静态数据会被映射到一个共享的进程中。常见的静态数据包括Dalvik Code、app resources、so文件等等。</p><p>在大多数情况下，Android通过显示分配共享内存区域（如ashmem或者gralloc）来实现动态RAM区域能够在不同进程之间共享的机制。例如，Window Surface在App和Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider和Clients之间共享内存。</p><p>上面说过，对于Android Runtime有两种虚拟机，Dalvik和ART，它们分配的内存区域块是不同的：</p><h5 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h5><ul><li>Linear Alloc</li><li>Zygote Space</li><li>Alloc Space</li></ul><h5 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h5><ul><li>Non Moving Space</li><li>Zygote Space</li><li>Alloc Space</li><li>Image Space</li><li>Large Obj Space</li></ul><p>不管是Dlavik还是ART，运行时堆都分为LinearAlloc（类似于ART的Non Moving Space）、Zygote Space和Alloc Space。Dalvik中的Linear Alloc是一个线性内存空间，是一个只读区域，主要用来存储虚拟机中的类，因为类加载后只需要读的属性，并且不会改变它。把这些只读属性以及在整个进程的生命周期都不能结束的永久数据放到线性分配器中管理，能很好地减少堆混乱和GC扫描，提升内存管理的性能。Zygote Space在Zygote进程和应用程序进程之间共享，Allocation Space则是每个进程独占。Android系统的第一个虚拟机由Zygote进程创建并且只有一个Zygote Space。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用的那部分堆内存划分为一部分，还没有使用的堆内存划分为另一部分，也就是Allocation Space。但无论是应用程序进程，还是Zygote进程，当他们需要分配对象时，都是在各自的Allocation Space堆上进行。</p><p>当在ART运行时，还有另外两个区块，即ImageSpace和Large Object Space。</p><ul><li>Image Space：存放一些预加载类，类似于Dalvik中的Linear Alloc。与Zygote Space一样，在Zygote进程和应用程序进程之间共享。 </li><li>Large Object Space：离散地址的集合，分配一些大对象，用于提高GC的管理效率和整体性能。</li></ul><p>注意：Image Space的对象只创建一次，而Zygote Space的对象需要在系统每次启动时，根据运行情况都重新创建一遍。</p><h4 id="1-3、内存回收机制"><a href="#1-3、内存回收机制" class="headerlink" title="1.3、内存回收机制"></a>1.3、内存回收机制</h4><p>在Android的高级系统版本中，针对Heap空间有一个Generational Heap Memory的模型，其中将整个内存分为三个区域：</p><ul><li>Young Generation（年轻代）</li><li>Old Generation（年老代）</li><li>Permanent Generation（持久代）</li></ul><p>模型示意图如下所示：</p><p><img src="http://www.jcodecraeer.com/uploads/20150920/1442716389944246.jpg" alt="image"></p><h5 id="1、Young-Generation"><a href="#1、Young-Generation" class="headerlink" title="1、Young Generation"></a>1、Young Generation</h5><p>由一个Eden区和两个Survivor区组成，程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当次Survivor区满时，此区存活的对象又被复制到另一个Survivor区，当这个Survivor区也满时，会将其中存活的对象复制到年老代。</p><h5 id="2、Old-Generation"><a href="#2、Old-Generation" class="headerlink" title="2、Old Generation"></a>2、Old Generation</h5><p>一般情况下，年老代中的对象生命周期都比较长。</p><h5 id="3、Permanent-Generation"><a href="#3、Permanent-Generation" class="headerlink" title="3、Permanent Generation"></a>3、Permanent Generation</h5><p>用于存放静态的类和方法，持久代对垃圾回收没有显著影响。</p><h5 id="总结：内存对象的处理过程如下："><a href="#总结：内存对象的处理过程如下：" class="headerlink" title="总结：内存对象的处理过程如下："></a>总结：内存对象的处理过程如下：</h5><ul><li>1、对象创建后在Eden区。</li><li>2、执行GC后，如果对象仍然存活，则复制到S0区。</li><li>3、当S0区满时，该区域存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换。</li><li>4、当第3步达到一定次数（系统版本不同会有差异）后，存活对象将被复制到Old Generation。</li><li>5、当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。</li></ul><p>系统在Young Generation、Old Generation上采用不同的回收机制。每一个Generation的内存区域都有固定的大小。随着新的对象陆续被分配到此区域，当对象总的大小临近这一级别内存区域的阈值时，会触发GC操作，以便腾出空间来存放其他新的对象。</p><p>执行GC占用的时间与Generation和Generation中的对象数量有关：</p><ul><li>Young Generation &lt; Old Generation &lt; Permanent Generation</li><li>Gener中的对象数量与执行时间成正比。</li></ul><h5 id="4、Young-Generation-GC"><a href="#4、Young-Generation-GC" class="headerlink" title="4、Young Generation GC"></a>4、Young Generation GC</h5><p>由于其对象存活时间短，因此基于Copying算法（扫描出存活的对象，并复制到一块新的完全未使用的控件中）来回收。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在Young Generation区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。</p><h5 id="5、Old-Generation-GC"><a href="#5、Old-Generation-GC" class="headerlink" title="5、Old Generation GC"></a>5、Old Generation GC</h5><p>由于其对象存活时间较长，比较稳定，因此采用Mark（标记）算法（扫描出存活的对象，然后再回收未被标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的效率损耗）来回收。</p><h3 id="1-4、GC类型"><a href="#1-4、GC类型" class="headerlink" title="1.4、GC类型"></a>1.4、GC类型</h3><p>在Android系统中，GC有三种类型：</p><ul><li>kGcCauseForAlloc：分配内存不够引起的GC，会Stop World。由于是并发GC，其它线程都会停止，直到GC完成。</li><li>kGcCauseBackground：内存达到一定阈值触发的GC，由于是一个后台GC，所以不会引起Stop World。</li><li>kGcCauseExplicit：显示调用时进行的GC，当ART打开这个选项时，使用System.gc时会进行GC。</li></ul><p>接下来，我们来学会如何分析Android虚拟机中的GC日志，日志如下：</p><pre><code>D/dalvikvm(7030)：GC_CONCURRENT freed 1049K, 60% free 2341K/9351K, external 3502K/6261K, paused 3ms 3ms</code></pre><p>GC_CONCURRENT是当前GC时的类型，GC日志中有以下几种类型：</p><ul><li>GC_CONCURRENT：当应用程序中的Heap内存占用上升时（分配对象大小超过384k），避免Heap内存满了而触发的GC。如果发现有大量的GC_CONCURRENT出现，说明应用中可能一直有大于384k的对象被分配，而这一般都是一些临时对象被反复创建，可能是<strong>对象复用不够所导致的</strong>。</li><li>GC_FOR_MALLOC：这是由于Concurrent GC没有及时执行完，而应用又需要分配更多的内存，这时不得不停下来进行Malloc GC。</li><li>GC_EXTERNAL_ALLOC：这是为external分配的内存执行的GC。</li><li>GC_HPROF_DUMP_HEAP：创建一个HPROF profile的时候执行。</li><li>GC_EXPLICIT：显示调用了System.GC()。（尽量避免）</li></ul><p>再回到上面打印的日志:</p><ul><li>freed 1049k 表明在这次GC中回收了多少内存。</li><li>60% free 2341k/6261K 表明回收后60%的Heap可用，存活的对象大小为2341kb，heap大小是9351kb。</li><li>external 3502/6261K 是Native Memory的数据。存放Bitmap Pixel Data（位图数据）或者堆以外内存（NIO Direct Buffer）之类的。第一个值说明在Native Memory中已分配3502kb内存，第二个值是一个浮动的GC阈值，当分配内存达到这个值时，会触发一次GC。</li><li>paused 3ms 3ms 表明GC的暂停时间，如果是Concurrent GC，会看到两个时间，一个开始，一个结束，且时间很短，如如果是其他类型的GC，很可能只会看到一个时间，且这个时间是相对比较长的。并且，越大的Heap Size在GC时导致暂停的时间越长。</li></ul><p>注意：在ART模式下，多了一个Large Object Space，这部分内存并不是分配在堆上，但还是属于应用程序的内存空间。</p><p>在Dalvik虚拟机下，GC的操作都是并发的，也就意味着每次触发GC都会导致其它线程暂停工作（包括UI线程）。而在ART模式下，GC时不像Dalvik仅有一种回收算法，ART在不同的情况下会选择不同的回收算法，比如Alloc内存不够时会采用非并发GC，但在Alloc后，发现内存达到一定阈值时又会触发并发GC。所以在ART模式下，并不是所有的GC都是非并发的。</p><p>总体来看，在GC方面，与Dalvik相比，ART更为高效，不仅仅是GC的效率，大大地缩短了Pause时间，而且在内存分配上对大内存分配单独的区域，还能有算法在后台做内存整理，减少内存碎片。因此，在ART虚拟机下，可以避免较多的类似GC导致的卡顿问题。</p><h3 id="二、优化内存的意义"><a href="#二、优化内存的意义" class="headerlink" title="二、优化内存的意义"></a>二、优化内存的意义</h3><ul><li>减少OOM，提高应用稳定性。</li><li>减少卡顿，提高应用流畅度。</li><li>减少内存占用，提高应用后台运行时的存活率。</li><li>减少异常发生和代码逻辑隐患。</li></ul><p>注意：出现OOM是因为内存溢出导致，这种情况不一定会发生在相同的代码，也不一定是出现OOM的代码使用内存有问题，而是刚好执行到这段代码。</p><h3 id="三、避免内存泄漏"><a href="#三、避免内存泄漏" class="headerlink" title="三、避免内存泄漏"></a>三、避免内存泄漏</h3><h4 id="3-1-内存泄漏定义"><a href="#3-1-内存泄漏定义" class="headerlink" title="3.1 内存泄漏定义"></a>3.1 内存泄漏定义</h4><p>Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小。</p><h4 id="3-2-使用MAT来查找内存泄漏"><a href="#3-2-使用MAT来查找内存泄漏" class="headerlink" title="3.2 使用MAT来查找内存泄漏"></a>3.2 使用MAT来查找内存泄漏</h4><p>MAT工具可以帮助开发者定位导致内存泄漏的对象，以及发现大的内存对象，然后解决内存泄漏并通过优化内存对象，达到减少内存消耗的目的。</p><h5 id="3-2-1-使用步骤"><a href="#3-2-1-使用步骤" class="headerlink" title="3.2.1 使用步骤"></a>3.2.1 使用步骤</h5><p>1、在<a href="https://eclipse.org/mat/downloads.php下载MAT客户端。" target="_blank" rel="external">https://eclipse.org/mat/downloads.php下载MAT客户端。</a></p><p>2、从Android Studio进入Profile的Memory视图，选择需要分析的应用进程，对应用进行怀疑有内存问题的操作，结束操作后，主动GC几次，最后export dump文件。</p><p>3、因为Android Studio保存的是Android Dalvik/ART格式的.hprof文件，所以需要转换成J2SE HPROF格式才能被MAT识别和分析。Android SDK自带了一个转换工具在SDK的platform-tools下，其中转换语句为：</p><pre><code>./hprof-conv file.hprof converted.hprof</code></pre><p>4、通过MAT打开转换后的HPROF文件。</p><h5 id="3-2-2-MAT视图"><a href="#3-2-2-MAT视图" class="headerlink" title="3.2.2 MAT视图"></a>3.2.2 MAT视图</h5><p>在MAT窗口上，OverView是一个总体概览，显示总体的内存消耗情况和疑似问题。MAT提供了多种分析维度，其中Histogram、Dominator Tree、Top Consumers和Leak Suspects的分析维度不同。下面分别介绍下：</p><p>1、Histogram</p><p>列出内存中的所有实例类型对象和其个数以及大小，并在顶部的regex区域支持正则表达式查找。</p><p>2、Dominator Tree</p><p>列出最大的对象及其依赖存活的Object。相比Histogram，能更方便地看出引用关系。</p><p>3、Top Consumers</p><p>通过图像列出最大的Object。</p><p>4、Leak Suspects</p><p>通过MAT自动分析内存泄漏的原因和泄漏的一份总体报告。</p><p>分析内存最常用的是Histogram和Dominator Tree两个视图，视图中一共有四列：</p><ul><li>Class Name：类名。</li><li>Objects：对象实例个数。</li><li>Shallow Heap：对象自身占用的内存大小，不包括它引用的对象。非数组的常规对象的Shallow Heap Size由其成员变量的数量和类型决定，数组的Shallow Heap Size由数组元素的类型（对象类型、基本类型）和数组长度决定。真正的内存都在堆上，看起来是一堆原生的byte[]、char[]、int[]，对象本身的内存都很小。因此Shallow Heap对分析内存泄漏意义不是很大。</li><li>Retained Heap：是当前对象大小与当前对象可直接或间接引用到的对象的大小总和，包括被递归释放的。即：Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存大小。</li></ul><h5 id="3-2-3-查找内存泄漏具体位置"><a href="#3-2-3-查找内存泄漏具体位置" class="headerlink" title="3.2.3 查找内存泄漏具体位置"></a>3.2.3 查找内存泄漏具体位置</h5><p>常规方式：</p><ul><li>按照包名类型分类进行实例筛选或直接使用顶部Regex选取特定实例。</li><li>右击选中被怀疑的实例对象，选择Merge Shortest Paths to GC Root-&gt;exclude all phantom/weak/soft etc references。(显示GC Roots最短路径的强引用)</li><li>分析引用链或通过代码逻辑找出原因。 </li></ul><p>还有一种更快速的方法就是对比泄漏前后的HPROF数据：</p><ul><li>在两个HPROF文件中，把Histogram或者Dominator Tree增加到Compare Basket。</li><li>在Compare Basket中单击 ! ，生成对比结果视图。这样就可以对比相同的对象在不同阶段的对象实例个数和内存占用大小，如明显只需要一个实例的对象，或者不应该增加的对象实例个数却增加了，说明发生了内存泄漏，就需要去代码中定位具体的原因并解决。</li></ul><p>注意：如果目标不太明确，可以直接定位当RetainedHeap最大的Object，通过Select incoming references查看引用链，定位到可疑的对象，然后通过Path to GC Roots分析引用链。</p><p>此外，我们知道，当Hash集合中过多的对象返回相同的Hash值时，会严重影响性能，这时可以用Map Collision Ratio查找导致Hash集合的碰撞率较高的罪魁祸首。</p><p>在本人平时的项目开发中，一般会使用如下两种方式来快速对指定页面进行内存泄漏的检测：</p><ul><li><p>1、shell命令+LeakCanary+MAT：运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发GC，然后使用adb shell dumpsys meminfo packagename -d命令查看退出界面后Objects下的Views和Activities数目是否为0，如果不是则通过LeakCanary检查可能存在内存泄露的地方，最后通过MAT分析，如此反复，改善满意为止。</p></li><li><p>2、Profile MEMORY：运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面5次，然后收到GC（点击Profile MEMORY左上角的垃圾桶图标），如果此时total内存还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击Profile MEMORY左上角的垃圾桶图标旁的heap dump按钮查看当前的内存堆栈情况，选择按包名查找，找到当前测试的Activity，如果引用了多个实例，则表明发生了内存泄露。</p></li></ul><h4 id="3-3-常见内存泄漏场景"><a href="#3-3-常见内存泄漏场景" class="headerlink" title="3.3 常见内存泄漏场景"></a>3.3 常见内存泄漏场景</h4><h5 id="1、资源性对象未关闭"><a href="#1、资源性对象未关闭" class="headerlink" title="1、资源性对象未关闭"></a>1、资源性对象未关闭</h5><p>对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后在置为null。</p><h5 id="2、注册对象未注销"><a href="#2、注册对象未注销" class="headerlink" title="2、注册对象未注销"></a>2、注册对象未注销</h5><h5 id="3、类的静态变量持有大数据对象"><a href="#3、类的静态变量持有大数据对象" class="headerlink" title="3、类的静态变量持有大数据对象"></a>3、类的静态变量持有大数据对象</h5><h5 id="4、非静态内部类的静态实例"><a href="#4、非静态内部类的静态实例" class="headerlink" title="4、非静态内部类的静态实例"></a>4、非静态内部类的静态实例</h5><p>该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。</p><p>解决方案：</p><p>将内部类设为静态内部类或将内部类抽取来作为一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。</p><h5 id="5、Handler临时性内存泄漏"><a href="#5、Handler临时性内存泄漏" class="headerlink" title="5、Handler临时性内存泄漏"></a>5、Handler临时性内存泄漏</h5><p>Message发出之后存储在MessageQueue中，在Message中存在一个target，它是Handler的一个引用，Message在Queue中存在的时间过长，就会导致Handler无法被回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。并且消息队列是在一个Looper线程中不断地轮询处理消息，当这个Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中的Message持有Handler实例的引用，Handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。</p><p>解决方案：</p><ul><li>1、使用一个静态Handler内部类，然后对Handler持有的对象（一般是Activity）使用弱引用，这样在回收时，也可以回收Handler持有的对象。</li><li>2、在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。</li></ul><p>注意：AsyncTask内部也是Handler机制，同样存在内存泄漏风险，当其一般是临时性的。</p><h5 id="6、容器中的对象没清理造成的内存泄漏"><a href="#6、容器中的对象没清理造成的内存泄漏" class="headerlink" title="6、容器中的对象没清理造成的内存泄漏"></a>6、容器中的对象没清理造成的内存泄漏</h5><h5 id="7、WebView"><a href="#7、WebView" class="headerlink" title="7、WebView"></a>7、WebView</h5><p>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。</p><p>解决方案：</p><p>为WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。</p><h4 id="3-4-内存泄漏监控"><a href="#3-4-内存泄漏监控" class="headerlink" title="3.4 内存泄漏监控"></a>3.4 内存泄漏监控</h4><p>一般使用LeakCanary进行内存泄漏的监控即可，具体使用和原理分析请参见我之前的文章<a href="https://jsonchao.github.io/2019/01/06/Android主流三方库源码分析（六、深入理解Leakcanary源码）/" target="_blank" rel="external">Android主流三方库源码分析（六、深入理解Leakcanary源码）</a>。</p><p>除了基本使用外，我们还可以自定义处理结果，首先，继承DisplayLeakService实现一个自定义的监控处理Service，代码如下：</p><pre><code>public class LeakCnaryService extends DisplayLeakServcie {    private final String TAG = “LeakCanaryService”；    @Override    protected void afterDefaultHandling(HeapDump heapDump， AnalysisResult result， String leakInfo) {        ...    }}</code></pre><p>重写afterDefaultHanding方法，在其中处理需要的数据，三个参数的定义如下：</p><ul><li>heapDump：堆内存文件，可以拿到完成的hprof文件，以使用MAT分析。</li><li>result：监控到的内存状态，如是否泄漏等。</li><li>leakInfo：leak trace详细信息，除了内存泄漏对象，还有设备信息。</li></ul><p>然后在install时，使用自定义的LeakCanaryService即可，代码如下：</p><pre><code>public class BaseApplication extends Application {    @Override    public void onCreate() {        super.onCreate();        mRefWatcher = LeakCanary.install(this, LeakCanaryService.calss, AndroidExcludedRefs.createAppDefaults().build());    }    ...}</code></pre><p>经过这样的处理，就可以在LeakCanaryService中实现自己的处理方式，如丰富的提示信息，把数据保存在本地、上传到服务器进行分析。</p><p>注意：LeakCanaryService需要在AndroidManifest中注册。</p><h3 id="四、优化内存空间"><a href="#四、优化内存空间" class="headerlink" title="四、优化内存空间"></a>四、优化内存空间</h3><h4 id="4-1-对象引用"><a href="#4-1-对象引用" class="headerlink" title="4.1 对象引用"></a>4.1 对象引用</h4><p>从Java 1.2版本开始引入了三种对象引用方式：SoftReference、WeakReference和PhantomReference三个引用类，引用类的主要功能就是能够引用但仍可以被垃圾回收器回收的对象。在引入引用类之前，只能使用Strong Reference，如果没有指定对象引用类型，默认是强引用。</p><h5 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h5><p>如果一个对象具有强引用，GC就绝对不会回收它。当内存空间不足时，JVM会抛出OOM错误。</p><h5 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h5><p>如果一个对象只具有软引用，则内存空间足够，GC时就不会回收它；如果内存不足，就会回收这些对象的内存。可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个ReferenceQueue（引用队列）联合使用，如果软引用引用的对象被垃圾回收器回收，JVM会把这个软引用加入与之关联的引用队列中。</p><h5 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h5><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>注意：可能需要运行多次GC，才能找到并释放弱引用对象。</p><h5 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h5><p>只能用于跟踪即将对被引用对象进行的收集。虚拟机必须与ReferenceQueue类联合使用。因为它能够充当通知机制。</p><h4 id="4-2-减少不必要的内存开销"><a href="#4-2-减少不必要的内存开销" class="headerlink" title="4.2 减少不必要的内存开销"></a>4.2 减少不必要的内存开销</h4><h5 id="1、AutoBoxing"><a href="#1、AutoBoxing" class="headerlink" title="1、AutoBoxing"></a>1、AutoBoxing</h5><p>自动装箱的核心就是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。如int只占4字节，而Integer对象有16字节，特别是HashMap这类容器，进行增、删、改、查操作时，都会产生大量的自动装箱操作。</p><p>检测方式：使用TraceView查看耗时，如果发现调用了大量的integer.value，就说明发生了AutoBoxing。</p><h5 id="2、内存复用"><a href="#2、内存复用" class="headerlink" title="2、内存复用"></a>2、内存复用</h5><ul><li>资源复用：通用的字符串、颜色定义、简单页面布局的复用。</li><li>视图复用：可以使用ViewHolder实现ConvertView复用。</li><li>对象池：显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间。</li><li>Bitmap对象的复用：使用inBitmap属性可以告知Bitmap解码器尝试使用已经存在的内存区域，新解码的bitmap会尝试使用之前那张bitmap在heap中占据的pixel data内存区域。</li></ul><h4 id="4-3-使用最优的数据类型的"><a href="#4-3-使用最优的数据类型的" class="headerlink" title="4.3 使用最优的数据类型的"></a>4.3 使用最优的数据类型的</h4><h5 id="1、HashMap与ArrayMap"><a href="#1、HashMap与ArrayMap" class="headerlink" title="1、HashMap与ArrayMap"></a>1、HashMap与ArrayMap</h5><p>HashMap是一个散列链表，向HashMap中put元素时，先根据key的HashCode重新计算hash值，根据hash值得到这个元素在数组中的位置，如果数组该位置上已经存放有其它元素了，那么这个位置上的元素将以链表的形式存放，新加入的放在链头，最后加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。也就是说，向HashMap插入一个对象前，会给一个通向Hash阵列的索引，在索引的位置中，保存了这个Key对象的值。这意味着需要考虑的一个最大问题是冲突，当多个对象散列于阵列相同位置时，就会有散列冲突的问题。因此，HashMap会配置一个大的数组来减少潜在的冲突，并且会有其他逻辑防止链接算法和一些冲突的发生。</p><p>ArrayMap提供了和HashMap一样的功能，但避免了过多的内存开销，方法是使用两个小数组，而不是一个大数组。并且ArrayMap在内存上是连续不间断的。</p><p>总体来说，在ArrayMap中执行插入或者删除操作时，从性能角度上看，比HashMap还要更差一些，但如果只涉及很小的对象数，比如1000以下，就不需要担心这个问题了。因为此时ArrayMap不会分配过大的数组。</p><h5 id="2、枚举类型"><a href="#2、枚举类型" class="headerlink" title="2、枚举类型"></a>2、枚举类型</h5><p>使用枚举类型的dex size是普通常量定义的dex size的13倍以上，同时，运行时的内存分配，一个enum值的声明会消耗至少20bytes。</p><p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：IntDef和StringDef，用来提供编译期的类型检查。</p><p>注意：使用IntDef和StringDef需要在Gradle配置中引入相应的依赖包：</p><pre><code>compile &apos;com.android.support:support-annotations:22.0.0&apos;</code></pre><h5 id="3、LruCache"><a href="#3、LruCache" class="headerlink" title="3、LruCache"></a>3、LruCache</h5><p>最近最少使用缓存，使用强引用保存需要缓存的对象，它内部维护了一个由LinkedHashMap组成的双向列表，不支持线程安全，LruCache对它进行了封装，添加了线程安全操作。当其中的一个值被访问时，它被放到队列的尾部，当缓存将满时，队列头部的值（最近最少被访问的）被丢弃，之后可以被GC回收。</p><p>除了普通的get/set方法之外，还有sizeOf方法，它用来返回每个缓存对象的大小。此外，还有entryRemoved方法，当一个缓存对象被丢弃时调用的方法，当第一个参数为true：表明环处对象是为了腾出空间而被清理时。否则，表明缓存对象的entry被remove移除或者被put覆盖时。</p><p>注意：分配LruCache大小时应考虑应用剩余内存有多大。</p><h5 id="4、图片内存优化"><a href="#4、图片内存优化" class="headerlink" title="4、图片内存优化"></a>4、图片内存优化</h5><p>在Android默认情况下，当图片文件解码成位图时，会被处理成32bit/像素。红色、绿色、蓝色和透明通道各8bit，即使是没有透明通道的图片，如JEPG隔世是没有透明通道的，但然后会处理成32bit位图，这样分配的32bit中的8bit透明通道数据是没有任何用处的，这完全没有必要，并且在这些图片被屏幕渲染之前，它们首先要被作为纹理传送到GPU，这意味着每一张图片会同时占用CPU内存和GPU内存。</p><p>减少内存开销常用方式如下：</p><ul><li>1、设置位图的规格：当显示小图片或对图片质量要求不高时可以考虑使用RGB_565，用户头像或圆角图片一般可以尝试ARGB_4444。通过设置inPreferredConfig参数来实现不同的位图规格，代码如下所示：</li></ul><pre><code>BitmapFactory.Options options = new BitmapFactory.Options();options.inPreferredConfig = Bitmap.Config.RGB_565;BitmapFactory.decodeStream(is, null, options);</code></pre><ul><li>2、inSampleSize：位图功能对象中的inSampleSize属性实现了位图的缩放功能，代码如下所示：</li></ul><pre><code>BitampFactory.Options options = new BitmapFactory.Options();// 设置为4就是1/4大小的图片。因此，图片大小总会比原始图片小一倍以上。options.inSampleSize = 4;BitmapFactory.decodeSream(is, null, options);</code></pre><ul><li>3、inScaled，inDensity和inTargetDensity实现更细的缩放图片：当inScaled设置为true时，系统会按照现有的密度来划分目标密度，代码如下所示：</li></ul><pre><code>BitampFactory.Options options = new BitampFactory.Options();options.inScaled = true;options.inDensity = srcWidth;options.inTargetDensity = dstWidth;BitmapFactory.decodeStream(is, null, options);</code></pre><p>上述三种方案的缺点：使用了过多的算法，导致图片显示过程需要更多的时间开销，如果图片很多的话，就影响到图片的显示效果。最好的方案是结合这两个方法，达到最佳的性能结合，首先使用inSampleSize处理图片，转换为接近目标的2次幂，然后用inDensity和inTargetDensity生成最终想要的准确大小，因为inSampleSize会减少像素的数量，而基于输出密码的需要对像素重新过滤。但获取资源图片的大小，需要设置位图对象的inJustDecodeBounds值为true，然后继续解码图片文件，这样才能生产图片的宽高数据，并允许继续优化图片。总体的代码如下所示：</p><pre><code>BitmapFactory.Options options = new BitampFactory.Options();options.inJustDecodeBounds = true;BitmapFactory.decodeStream(is, null, options);options.inScaled = true;options.inDensity = options.outWidth;options.inSampleSize = 4;Options.inTargetDensity = desWith * options.inSampleSize;options.inJustDecodeBounds = false;BitmapFactory.decodeStream(is, null, options);</code></pre><h5 id="4、inBitmap"><a href="#4、inBitmap" class="headerlink" title="4、inBitmap"></a>4、inBitmap</h5><p>可以结合LruCache来实现，在LruCache移除超出cache size的图片时，暂时缓存Bitamp到一个软引用集合，需要创建新的Bitamp时，可以从这个软用用集合中找到最适合重用的Bitmap，来重用它的内存区域。</p><p>注意：新申请的Bitmap与旧的Bitmap必须有相同的解码格式，并且在Android 4.4之前，只能重用相同大小的Bitamp的内存区域，而Android 4.4之后可以重用任何bitmap的内存区域。</p><h3 id="五、图片管理模块设计与实现"><a href="#五、图片管理模块设计与实现" class="headerlink" title="五、图片管理模块设计与实现"></a>五、图片管理模块设计与实现</h3><p>在设计一个模块时，需要考虑以下几点：</p><ul><li>1、单一职责</li><li>2、避免不同功能之间的耦合</li><li>3、接口隔离</li></ul><p>在编写代码前先画好UML图，确定每一个对象、方法、接口的功能，首先尽量做到功能单一原则，在这个基础上，再明确模块与模块的直接关系，最后使用代码实现。</p><h4 id="5-1-实现异步加载功能"><a href="#5-1-实现异步加载功能" class="headerlink" title="5.1 实现异步加载功能"></a>5.1 实现异步加载功能</h4><h5 id="1-实现网络图片显示"><a href="#1-实现网络图片显示" class="headerlink" title="1.实现网络图片显示"></a>1.实现网络图片显示</h5><p>ImageLoader是实现图片加载的基类，其中ImageLoader有一个内部类BitmapLoadTask是继承AsyncTask的异步下载管理类，负责图片的下载和刷新，MiniImageLoader是ImageLoader的子类，维护类一个ImageLoader的单例，并且实现了基类的网络加载功能，因为具体的下载在应用中有不同的下载引擎，抽象成接口便于替换。代码如下所示：</p><pre><code>public abstract class ImageLoader {    private boolean mExitTasksEarly = false;   //是否提前结束    protected boolean mPauseWork = false;    private final Object mPauseWorkLock = new   Object();    protected ImageLoader() {    }    public void loadImage(String url, ImageView imageView) {        if (url == null) {            return;        }        BitmapDrawable bitmapDrawable = null;        if (bitmapDrawable != null) {            imageView.setImageDrawable(bitmapDrawable);        } else {            final BitmapLoadTask task = new BitmapLoadTask(url, imageView);            task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);        }    }    private class BitmapLoadTask extends AsyncTask&lt;Void, Void, Bitmap&gt; {        private String mUrl;        private final WeakReference&lt;ImageView&gt; imageViewWeakReference;        public BitmapLoadTask(String url, ImageView imageView) {            mUrl = url;            imageViewWeakReference = new WeakReference&lt;ImageView&gt;(imageView);        }        @Override        protected Bitmap doInBackground(Void... params) {            Bitmap bitmap = null;            BitmapDrawable drawable = null;            synchronized (mPauseWorkLock) {                while (mPauseWork &amp;&amp; !isCancelled()) {                    try {                        mPauseWorkLock.wait();                    } catch (InterruptedException e) {                        e.printStackTrace();                    }                }            }            if (bitmap == null                    &amp;&amp; !isCancelled()                    &amp;&amp; imageViewWeakReference.get() != null                    &amp;&amp; !mExitTasksEarly) {                bitmap = downLoadBitmap(mUrl);            }            return bitmap;        }        @Override        protected void onPostExecute(Bitmap bitmap) {            if (isCancelled() || mExitTasksEarly) {                bitmap = null;            }            ImageView imageView = imageViewWeakReference.get();            if (bitmap != null &amp;&amp; imageView != null) {                setImageBitmap(imageView, bitmap);            }        }        @Override        protected void onCancelled(Bitmap bitmap) {            super.onCancelled(bitmap);            synchronized (mPauseWorkLock) {                mPauseWorkLock.notifyAll();            }        }    }    public void setPauseWork(boolean pauseWork) {        synchronized (mPauseWorkLock) {            mPauseWork = pauseWork;            if (!mPauseWork) {                mPauseWorkLock.notifyAll();            }        }    }    public void setExitTasksEarly(boolean exitTasksEarly) {        mExitTasksEarly = exitTasksEarly;        setPauseWork(false);    }    private void setImageBitmap(ImageView imageView, Bitmap bitmap) {        imageView.setImageBitmap(bitmap);    }    protected abstract Bitmap downLoadBitmap(String    mUrl);}</code></pre><p>setPauseWork方法是图片加载线程控制接口，pauseWork控制图片模块的暂停和继续工作，一般在listView等控件中，滑动时停止加载图片，保证滑动流畅。另外，具体的图片下载和解码是和业务强相关的，因此在ImageLoader中不做具体的实现，只是定义类一个抽象方法。</p><p>MiniImageLoader是一个单例，保证一个应用只维护一个ImageLoader，减少对象开销，并管理应用中所有的图片加载。MiniImageLoader代码如下所示：</p><pre><code>public class MiniImageLoader extends ImageLoader {    private volatile static MiniImageLoader sMiniImageLoader = null;    private ImageCache mImageCache = null;    public static MiniImageLoader getInstance() {        if (null == sMiniImageLoader) {            synchronized (MiniImageLoader.class) {                MiniImageLoader tmp = sMiniImageLoader;                if (tmp == null) {                    tmp = new MiniImageLoader();                }                sMiniImageLoader = tmp;            }        }        return sMiniImageLoader;    }    public MiniImageLoader() {        mImageCache = new ImageCache();    }    @Override    protected Bitmap downLoadBitmap(String mUrl) {        HttpURLConnection urlConnection = null;        InputStream in = null;        try {            final URL url = new URL(mUrl);            urlConnection = (HttpURLConnection) url.openConnection();            in = urlConnection.getInputStream();            Bitmap bitmap = decodeSampledBitmapFromStream(in, null);            return bitmap;        } catch (MalformedURLException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if (urlConnection != null) {                urlConnection.disconnect();                urlConnection = null;            }            if (in != null) {                try {                    in.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }        return null;    }    public Bitmap decodeSampledBitmapFromStream(InputStream is, BitmapFactory.Options options) {        return BitmapFactory.decodeStream(is, null, options);    }}</code></pre><p>其中，volatile保证了对象从主内存加载。并且，上面的try …cache层级太多，Java中有一个Closeable接口，该接口标识类一个可关闭的对象，因此可以写如下的工具类：</p><pre><code>public class CloseUtils {    public static void closeQuietly(Closeable closeable) {        if (null != closeable) {            try {                closeable.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}</code></pre><p>改造后如下所示：</p><pre><code>finally {    if  (urlConnection != null) {        urlConnection.disconnect();        }    CloseUtil.closeQuietly(in);}</code></pre><p>同时，为了使ListView在滑动过程中更流畅，在滑动时暂停图片加载，减少系统开销，代码如下所示：</p><pre><code>listView.setOnScrollListener(new AbsListView.OnScrollListener() {    @Override    public void onScrollStateChanged(AbsListView absListView, int scrollState) {        if (scorllState == AbsListView.OnScrollListener.SCROLL_STAE_FLING) {            MiniImageLoader.getInstance().setPauseWork(true);        } else {            MiniImageLoader.getInstance().setPauseWork(false);        }    }}</code></pre><h5 id="2-单个图片内存优化"><a href="#2-单个图片内存优化" class="headerlink" title="2 单个图片内存优化"></a>2 单个图片内存优化</h5><p>这里使用一个BitmapConfig类来实现参数的配置，代码如下所示:</p><pre><code>public class BitmapConfig {    private int mWidth, mHeight;    private Bitmap.Config mPreferred;    public BitmapConfig(int width, int height) {        this.mWidth = width;        this.mHeight = height;        this.mPreferred = Bitmap.Config.RGB_565;    }    public BitmapConfig(int width, int height, Bitmap.Config preferred) {        this.mWidth = width;        this.mHeight = height;        this.mPreferred = preferred;    }    public BitmapFactory.Options getBitmapOptions() {        return getBitmapOptions(null);    }    // 精确计算，需要图片is流现解码，再计算宽高比    public BitmapFactory.Options getBitmapOptions(InputStream is) {        final BitmapFactory.Options options = new BitmapFactory.Options();        options.inPreferredConfig = Bitmap.Config.RGB_565;        if (is != null) {            options.inJustDecodeBounds = true;            BitmapFactory.decodeStream(is, null, options);            options.inSampleSize = calculateInSampleSize(options, mWidth, mHeight);        }        options.inJustDecodeBounds = false;        return options;    }    private static int calculateInSampleSize(BitmapFactory.Options    options, int mWidth, int mHeight) {        final int height = options.outHeight;        final int width = options.outWidth;        int inSampleSize = 1;        if (height &gt; mHeight || width &gt; mWidth) {            final int halfHeight = height / 2;            final int halfWidth = width / 2;            while ((halfHeight / inSampleSize) &gt; mHeight                    &amp;&amp; (halfWidth / inSampleSize) &gt; mWidth) {                inSampleSize *= 2;            }        }        return inSampleSize;    }}</code></pre><p>然后，调用MiniImageLoader的downLoadBitmap方法，增加获取BitmapFactory.Options的步骤：</p><pre><code>final URL url = new URL(urlString);urlConnection = (HttpURLConnection) url.openConnection();in = urlConnection.getInputStream();final BitmapFactory.Options options =    mConfig.getBitmapOptions(in);in.close();urlConnection.disconnect();urlConnection = (HttpURLConnection)    url.openConnection();in = urlConnection.getInputStream();Bitmap bitmap = decodeSampledBitmapFromStream(in,    options);</code></pre><p>优化后仍存在一些问题：</p><ul><li>1.相同的图片，每次都要重新加载；</li><li>2.整体内存开销不可控，虽然减少了单个图片开销，但是在片非常多的情况下，没有合理管理机制仍然对性能有严重影的。</li></ul><p>为了解决这两个问题，就需要有内存池的设计理念，通过内存池控制整体图片内存，不重新加载和解码已经显示过的图片。</p><h4 id="5-2-实现三级缓存"><a href="#5-2-实现三级缓存" class="headerlink" title="5.2 实现三级缓存"></a>5.2 实现三级缓存</h4><p>内存–本地–网络</p><h5 id="1、内存缓存"><a href="#1、内存缓存" class="headerlink" title="1、内存缓存"></a>1、内存缓存</h5><p>使用软引用和弱引用（SoftReference or WeakReference）来实现内存池是以前的常用做法，但是现在不建议。从API 9起（Android 2.3）开始，Android系统垃圾回收器更倾向于回收持有软引用和弱引用的对象，所以不是很靠谱，从Android 3.0开始（API 11）开始，图片的数据无法用一种可遇见的方式将其释放，这就存在潜在的内存溢出风险。<br>使用LruCache来实现内存管理是一种可靠的方式，它的主要算法原理是把最近使用的对象用强引用来存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。使用LruCache实现一个图片的内存缓存的代码如下所示：</p><pre><code>public class MemoryCache {    private final int DEFAULT_MEM_CACHE_SIZE = 1024 * 12;    private LruCache&lt;String, Bitmap&gt; mMemoryCache;    private final String TAG = &quot;MemoryCache&quot;;    public MemoryCache(float sizePer) {        init(sizePer);    }    private void init(float sizePer) {        int cacheSize = DEFAULT_MEM_CACHE_SIZE;        if (sizePer &gt; 0) {            cacheSize = Math.round(sizePer * Runtime.getRuntime().maxMemory() / 1024);        }        mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {            @Override            protected int sizeOf(String key, Bitmap value) {                final int bitmapSize = getBitmapSize(value) / 1024;                return bitmapSize == 0 ? 1 : bitmapSize;            }            @Override            protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {               super.entryRemoved(evicted, key, oldValue, newValue);            }        };    }    @TargetApi(Build.VERSION_CODES.KITKAT)    public int getBitmapSize(Bitmap bitmap) {        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {            return bitmap.getAllocationByteCount();        }        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) {            return bitmap.getByteCount();        }        return bitmap.getRowBytes() * bitmap.getHeight();    }    public Bitmap getBitmap(String url) {        Bitmap bitmap = null;        if (mMemoryCache != null) {            bitmap = mMemoryCache.get(url);        }        if (bitmap != null) {            Log.d(TAG, &quot;Memory cache exiet&quot;);        }        return bitmap;    }    public void addBitmapToCache(String url, Bitmap bitmap) {        if (url == null || bitmap == null) {            return;        }        mMemoryCache.put(url, bitmap);    }    public void clearCache() {        if (mMemoryCache != null) {            mMemoryCache.evictAll();        }    }}</code></pre><p>上述代码中cacheSize百分比占比多少合适？可以基于以下几点来考虑：</p><ul><li>1.应用中内存的占用情况，除了图片以外，是否还有大内存的数据需要缓存到内存。</li><li>2.在应用中大部分情况要同时显示多少张图片，优先保证最大图片的显示数量的缓存支持。</li><li>3.Bitmap的规格，计算出一张图片占用的内存大小。</li><li>4.图片访问的频率。</li></ul><p>在应用中，如果有一些图片的访问频率要比其它的大一些，或者必须一直显示出来，就需要一直保持在内存中，这种情况可以使用多个LruCache对象来管理多组Bitmap，对Bitmap进行分级，不同级别的Bitmap放到不同的LruCache中。</p><h5 id="2、bitmap内存复用"><a href="#2、bitmap内存复用" class="headerlink" title="2、bitmap内存复用"></a>2、bitmap内存复用</h5><p>从Android3.0开始Bitmap支持内存复用，也就是BitmapFactoy.Options.inBitmap属性，如果这个属性被设置有效的目标用对象，decode方法就在加载内容时重用已经存在的bitmap，这意味着Bitmap的内存被重新利用，这可以减少内存的分配回收，提高图片的性能。代码如下所示：</p><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {        mReusableBitmaps = Collections.synchronizedSet(newHashSet&lt;SoftReference&lt;Bitmap&gt;&gt;());}</code></pre><p>因为inBitmap属性在Android3.0以后才支持，在entryRemoved方法中加入软引用集合，作为复用的源对象，之前是直接删除，代码如下所示：</p><pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {    mReusableBitmaps.add(new SoftReference&lt;Bitmap&gt;(oldValue));}</code></pre><p>同样在3.0以上判断，需要分配一个新的bitmap对象时，首先检查是否有可复用的bitmap对象：</p><pre><code>public static Bitmap decodeSampledBitmapFromStream(InputStream is, BitmapFactory.Options options, ImageCache cache) {     if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {         addInBitmapOptions(options, cache);     }     return BitmapFactory.decodeStream(is, null, options); }@TargetApi(Build.VERSION_CODES.HONEYCOMB)private static void addInBitmapOptions(BitmapFactory.Options options, ImageCache cache) {     options.inMutable = true;     if (cache != null) {         Bitmap inBitmap = cache.getBitmapFromReusableSet(options);         if (inBitmap != null) {             options.inBitmap = inBitmap;         }     } }</code></pre><p>接着，我们使用cache.getBitmapForResubleSet方法查找一个合适的bitmap赋值给inBitmap。代码如下所示：</p><pre><code>// 获取inBitmap,实现内存复用public Bitmap getBitmapFromReusableSet(BitmapFactory.Options options) {    Bitmap bitmap = null;    if (mReusableBitmaps != null &amp;&amp; !mReusableBitmaps.isEmpty()) {        final Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator = mReusableBitmaps.iterator();        Bitmap item;        while (iterator.hasNext()) {            item = iterator.next().get();            if (null != item &amp;&amp; item.isMutable()) {                if (canUseForInBitmap(item, options)) {                    Log.v(&quot;TEST&quot;, &quot;canUseForInBitmap!!!!&quot;);                    bitmap = item;                    // Remove from reusable set so it can&apos;t be used again                    iterator.remove();                    break;                }            } else {                // Remove from the set if the reference has been cleared.                iterator.remove();            }        }    }    return bitmap;}</code></pre><p>上述方法从软引用集合中查找规格可利用的Bitamp作为内存复用对象，因为使用inBitmap有一些限制，在Android 4.4之前，只支持同等大小的位图。因此使用了canUseForInBitmap方法来判断该Bitmap是否可以复用，代码如下所示：</p><pre><code>@TargetApi(Build.VERSION_CODES.KITKAT)private static boolean canUseForInBitmap(        Bitmap candidate, BitmapFactory.Options targetOptions) {    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) {        return candidate.getWidth() == targetOptions.outWidth                &amp;&amp; candidate.getHeight() == targetOptions.outHeight                &amp;&amp; targetOptions.inSampleSize == 1;    }    int width = targetOptions.outWidth / targetOptions.inSampleSize;    int height = targetOptions.outHeight / targetOptions.inSampleSize;    int byteCount = width * height * getBytesPerPixel(candidate.getConfig());    return byteCount &lt;= candidate.getAllocationByteCount();}</code></pre><h5 id="3、磁盘缓存"><a href="#3、磁盘缓存" class="headerlink" title="3、磁盘缓存"></a>3、磁盘缓存</h5><p>由于磁盘读取时间是不可预知的，所以图片的解码和文件读取都应该在后台进程中完成。DisLruCache是Android提供的一个管理磁盘缓存的类。</p><ul><li>1、首先调用DiskLruCache的open方法进行初始化，代码如下：</li></ul><pre><code>public static DiskLruCache open(File directory, int appVersion, int valueCou9nt, long maxSize)</code></pre><p>directory一般建议缓存到SD卡上。appVersion发生变化时，会自动删除前一个版本的数据。valueCount是指Key与Value的对应关系，一般情况下是1对1的关系。maxSize是缓存图片的最大缓存数据大小。初始化DiskLruCache的代码如下所示：</p><pre><code>private void init(final long cacheSize,final File cacheFile) {    new Thread(new Runnable() {        @Override        public void run() {            synchronized (mDiskCacheLock) {                if(!cacheFile.exists()){                    cacheFile.mkdir();                }                MLog.d(TAG,&quot;Init DiskLruCache cache path:&quot; + cacheFile.getPath() + &quot;\r\n&quot; + &quot;Disk Size:&quot; + cacheSize);                try {                    mDiskLruCache = DiskLruCache.open(cacheFile, MiniImageLoaderConfig.VESION_IMAGELOADER, 1, cacheSize);                    mDiskCacheStarting = false;                    // Finished initialization                    mDiskCacheLock.notifyAll();                     // Wake any waiting threads                }catch(IOException e){                    MLog.e(TAG,&quot;Init err:&quot; + e.getMessage());                }            }        }    }).start();}</code></pre><p>如果在初始化前就要操作写或者读会导致失败，所以在整个DiskCache中使用的Object的wait/notifyAll机制来避免同步问题。</p><ul><li>2、写入DiskLruCache</li></ul><p>首先，获取Editor实例，它需要传入一个key来获取参数，Key必须与图片有唯一对应关系，但由于URL中的字符可能会带来文件名不支持的字符类型，所以取URL的MD4值作为文件名，实现Key与图片的对应关系，通过URL获取MD5值的代码如下所示:</p><pre><code>private String hashKeyForDisk(String key) {    String cacheKey;    try {        final MessageDigest mDigest = MessageDigest.getInstance(&quot;MD5&quot;);        mDigest.update(key.getBytes());        cacheKey = bytesToHexString(mDigest.digest());    } catch (NoSuchAlgorithmException e) {        cacheKey = String.valueOf(key.hashCode());    }    return cacheKey;}private String bytesToHexString(byte[] bytes) {    StringBuilder sb = new StringBuilder();    for (int i = 0; i &lt; bytes.length; i++) {        String hex = Integer.toHexString(0xFF &amp; bytes[i]);        if (hex.length() == 1) {            sb.append(&apos;0&apos;);        }        sb.append(hex);    }    return sb.toString();}</code></pre><p>然后，写入需要保存的图片数据，图片数据写入本地缓存的整体代码如下所示：</p><pre><code> public void saveToDisk(String imageUrl, InputStream in) {    // add to disk cache    synchronized (mDiskCacheLock) {        try {            while (mDiskCacheStarting) {                try {                    mDiskCacheLock.wait();                } catch (InterruptedException e) {}            }            String key = hashKeyForDisk(imageUrl);            MLog.d(TAG,&quot;saveToDisk get key:&quot; + key);            DiskLruCache.Editor editor = mDiskLruCache.edit(key);            if (in != null &amp;&amp; editor != null) {                // 当 valueCount指定为1时，index传0即可                OutputStream outputStream = editor.newOutputStream(0);                MLog.d(TAG, &quot;saveToDisk&quot;);                if (FileUtil.copyStream(in,outputStream)) {                    MLog.d(TAG, &quot;saveToDisk commit start&quot;);                    editor.commit();                    MLog.d(TAG, &quot;saveToDisk commit over&quot;);                } else {                    editor.abort();                    MLog.e(TAG, &quot;saveToDisk commit abort&quot;);                }            }            mDiskLruCache.flush();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><p>接着，读取图片缓存，通过DiskLruCache的get方法实现，代码如下所示：</p><pre><code>public Bitmap  getBitmapFromDiskCache(String imageUrl,BitmapConfig bitmapconfig) {    synchronized (mDiskCacheLock) {        // Wait while disk cache is started from background thread        while (mDiskCacheStarting) {            try {                mDiskCacheLock.wait();            } catch (InterruptedException e) {}        }        if (mDiskLruCache != null) {            try {                String key = hashKeyForDisk(imageUrl);                MLog.d(TAG,&quot;getBitmapFromDiskCache get key:&quot; + key);                DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);                if(null == snapShot){                    return null;                }                InputStream is = snapShot.getInputStream(0);                if(is != null){                    final BitmapFactory.Options options = bitmapconfig.getBitmapOptions();                    return BitmapUtil.decodeSampledBitmapFromStream(is, options);                }else{                    MLog.e(TAG,&quot;is not exist&quot;);                }            }catch (IOException e){                MLog.e(TAG,&quot;getBitmapFromDiskCache ERROR&quot;);            }        }    }    return null;}</code></pre><p>最后，要注意读取并解码Bitmap数据和保存图片数据都是有一定耗时的IO操作。所以这些方法都是在ImageLoader中的doInBackground方法中调用，代码如下所示：</p><pre><code>@Overrideprotected Bitmap doInBackground(Void... params) {    Bitmap bitmap = null;    synchronized (mPauseWorkLock) {        while (mPauseWork &amp;&amp; !isCancelled()) {            try {                mPauseWorkLock.wait();            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }    if (bitmap == null &amp;&amp; !isCancelled()            &amp;&amp; imageViewReference.get() != null &amp;&amp; !mExitTasksEarly) {        bitmap = getmImageCache().getBitmapFromDisk(mUrl, mBitmapConfig);    }    if (bitmap == null &amp;&amp; !isCancelled()            &amp;&amp; imageViewReference.get() != null &amp;&amp; !mExitTasksEarly) {        bitmap = downLoadBitmap(mUrl, mBitmapConfig);    }    if (bitmap != null) {        getmImageCache().addToCache(mUrl, bitmap);    }    return bitmap;}</code></pre><h4 id="5-3-图片加载三方库"><a href="#5-3-图片加载三方库" class="headerlink" title="5.3 图片加载三方库"></a>5.3 图片加载三方库</h4><p>目前使用最广泛的有Picasso、Glide和Fresco。Glide和Picasso比较相似，但是Glide相对于Picasso来说，功能更多，内部实现更复杂，对Glide有兴趣的同学可以阅读这篇文章<a href="https://jsonchao.github.io/2018/12/16/Android主流三方库源码分析（三、深入理解Glide源码）" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>。Fresco最大的亮点在与它的内存管理，特别实在低端机和Android 5.0以下的机器上的优势更加明显，而使用Fresco将很好地解决图片占用内存大的问题。因为，Fresco会将图片放到一个特别的内存区域，当图片不再显示时，占用的内存会自动释放。以下总结以下其优点：</p><ul><li>1、内存管理。</li><li>2、渐进式呈现：先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片。</li><li>3、支持更多的图片格式:如Gif和Webp。</li><li>4、图像加载策略丰富：其中的Image Pipeline可以为同一个图片指定不同的远程路径，比如先显示已经存在本地缓存中的图片，等高清图下载完成之后在显示高清图集。</li></ul><p>缺点：</p><ul><li>安装包过大，所以对图片加载和显示要求不是比较高的情况下建议使用Glide。</li></ul><h4 id="六、内存优化"><a href="#六、内存优化" class="headerlink" title="六、内存优化"></a>六、内存优化</h4><p>对于内存泄漏，其本质可理解为无法回收无用的对象。这里我总结了我在项目中遇到的一些常见的内存泄漏案例（包含解决方案）和常见的内存优化技术。</p><h5 id="6-1、常见的内存泄漏案例-完善3-3小节）："><a href="#6-1、常见的内存泄漏案例-完善3-3小节）：" class="headerlink" title="6.1、常见的内存泄漏案例(完善3.3小节）："></a>6.1、常见的内存泄漏案例(完善3.3小节）：</h5><ul><li>1、单例造成的内存泄漏（使用Application的Context）</li><li>2、非静态内部类创建静态实例造成的内存泄漏（将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，就使用Application的Context）</li><li>3、Handler造成的内存泄漏（将Handler类独立出来或者使用静态内部类）</li><li>4、线程造成的内存泄漏（将AsyncTask和Runnable类独立出来或者使用静态内部类）</li><li>5、BraodcastReceiver、Bitmap等资源未关闭造成的内存泄漏（应该在Activity销毁时及时关闭或者注销）</li><li>6、使用ListView时造成的内存泄漏（在构造Adapter时，使用缓存的convertView）</li><li>7、集合容器中的内存泄露（在退出程序之前，将集合里的东西clear，然后置为null，再退出程序）</li><li>8、WebView造成的泄露（为WebView另外开启一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放）</li></ul><h5 id="6-2、常见的内存优化点："><a href="#6-2、常见的内存优化点：" class="headerlink" title="6.2、常见的内存优化点："></a>6.2、常见的内存优化点：</h5><p>1、只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。</p><p>2、图片优化：</p><ul><li>颜色模式：RGB_8888-&gt;RGB_565</li><li>降低图片大小</li><li>降低采样率</li></ul><p>3、在App退到后台内存紧张即将被Kill掉时选择重写onTrimMemory()方法去释放掉图片缓存、静态缓存来自保。</p><p>4、item被回收不可见时释放掉对图片的引用：</p><ul><li>ListView：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。</li><li>RecyclerView：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。</li></ul><p>5、集合优化：Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p><p>6、避免创作不必要的对象：字符串拼接使用StringBuffer，StringBuilder。</p><p>7、onDraw方法里面不要执行对象的创建。</p><p>8、使用static final 优化成员变量。</p><p>9、使用增强型for循环语法。</p><p>10、在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。</p><p>11、适当采用软引用和弱引用。</p><p>12、采用内存缓存和磁盘缓存。</p><p>13、尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。</p><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>对于内存优化，一般都是通过使用MAT等工具来进行检查和使用LeakCanary等内存泄漏监控工具来进行监控，以此来发现问题，再分析问题原因，解决发现的问题或者对当前的实现逻辑进行优化，优化完后在进行检查，直到达到预定的性能指标。下一篇，将会深入分析一下Android系统的存储优化相关技术，尽请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android应用性能优化最佳实践</p><p>2、<a href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ?" target="_blank" rel="external">必知必会 | Android 性能优化的方面方面都在这儿</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android性能优化之绘制优化</title>
      <link>http://yoursite.com/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/</link>
      <guid>http://yoursite.com/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/</guid>
      <pubDate>Sun, 28 Jul 2019 10:07:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>我们都知道，造成绘制不流畅最大的罪魁祸首就是卡顿，而卡顿的主要场景有很多，按场景可以分成4类：UI绘制、应用启动、页面跳转、事件响应，其中又可细分为如下：</p><h5 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h5><ul><li>绘制</li><li>刷新</li></ul><h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul><li>安装启动</li><li>冷启动</li><li>热启动</li></ul><h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><ul><li>页面间跳转</li><li>前后台切换</li></ul><h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul><li>按键</li><li>系统事件</li><li>滑动</li></ul><p>造成其根本原因可以分为两大类：</p><h5 id="界面绘制"><a href="#界面绘制" class="headerlink" title="界面绘制"></a>界面绘制</h5><ul><li>绘制层级深</li><li>页面复杂</li><li>刷新不合理</li></ul><h5 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h5><ul><li>数据处理在UI线程</li><li>占用CPU高，导致主线程拿不到时间片</li><li>内存增加导致GC频繁，从而引起卡顿</li></ul><h3 id="一、Android系统显示原理"><a href="#一、Android系统显示原理" class="headerlink" title="一、Android系统显示原理"></a>一、Android系统显示原理</h3><p>Android的显示过程可以简单概括为：Android应用程序把经过测量、布局、绘制后的surface缓存数据、通过SurfaceFlinger把数据渲染到显示屏幕上，通过Android的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕。</p><h4 id="1-1、绘制原理"><a href="#1-1、绘制原理" class="headerlink" title="1.1、绘制原理"></a>1.1、绘制原理</h4><h5 id="1、应用层"><a href="#1、应用层" class="headerlink" title="1、应用层"></a>1、应用层</h5><p>在Android的每个View都会经过Measure和Layout来确定当前需要绘制的View所在的大小和位置，通过绘制到surface，在Android系统中整体的绘制源码是在ViewRootImpl类的performTraversals()方法，通过这个方法可以看出Measure和Layout都是递归来获取View的大小和位置，并且以深度作为优先级。显然，层级越深，元素越多，耗时就越长。</p><p>对于绘制，Android支持两种绘制方式：</p><ul><li>软件绘制（CPU）</li><li>硬件绘制（GPU）</li></ul><p>硬件加速从Android 3.0开始支持，它在UI显示和绘制效率方面远高于软件绘制。但它的局限如下：</p><ul><li>耗电：GPU功耗高于CPU。</li><li>兼容性：不兼容某些接口和函数。</li><li>内存大：使用OpenGL的接口需要占用内存8MB。</li></ul><h5 id="2、系统层"><a href="#2、系统层" class="headerlink" title="2、系统层"></a>2、系统层</h5><p>将数据渲染到屏幕上是通过系统级进程中的SurfaceFlinger服务来实现的，它的主要工作流程如下：</p><ul><li>1、响应客户端事件，创建Layer与客户端的Surface建立连接。</li><li>2、接收客户端数据和属性，修改Layer属性，如尺寸、颜色、透明度等。</li><li>3、将创建的Layer内容刷新到屏幕上。</li><li>4、维持Layer的序列，并对Layer最终输出做出裁剪计算。</li></ul><p>其中，SurfaceFlinger系统进程和应用进程使用了匿名共享内存SharedClient，并且，每一个应用和SurfaceFlinger之间都会创建一个SharedClient，并且，每个SharedClient中，最多可以创建31个SharedBufferStack，每一个SharedBufferStack对应一个Surface，即一个window。（其中包含了两个（小于4.1版本）或者三个（4.1及以上版本）缓冲区）</p><p>因此，从上可知，一个Android应用程序最多可以包含31个窗口。最后，显示的整体流程如下：</p><ul><li>应用层绘制到缓冲区</li><li>SurfaceFlinger把缓冲区数据渲染到屏幕，其中使用了Android匿名共享内存SharedClient缓存需要显示的数据来达到目的。</li></ul><p>绘制的过程首先是CPU准备数据，通过Driver层把数据交给CPU渲染，其中CPU主要负责Measure、Layout、Record、Execute的数据计算工作，GPU负责Rasterization（栅格化）、渲染。因为图形API不允许CPU直接和GPU通信，所以要通过一个图形驱动的中间层来进行连接。图形驱动里面维护了一个队列，CPU把display list（待显示的数据列表）添加到队列中，GPU从这个队列中取出数据进行绘制，最终才在显示屏上显示出来。</p><p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的60FPS。</p><h4 id="1-2-刷新机制"><a href="#1-2-刷新机制" class="headerlink" title="1.2 刷新机制"></a>1.2 刷新机制</h4><p>4.1版本的Project Butter对Android Display系统进行了重构，引入了三个核心元素：VSYNC（Vertical Synchronization）、Triple Buffer、Choreographer。其中作为Project Buffer核心的VSYNC，即垂直同步可认为是一种定时中断。而Choreographer起调度的作用，将绘制工作统一到VSYNC的某个时间点上，使应用的绘制工作有序。</p><h5 id="为什么要推出Project-Butter？"><a href="#为什么要推出Project-Butter？" class="headerlink" title="为什么要推出Project Butter？"></a>为什么要推出Project Butter？</h5><p>解决刷新不同步的问题。</p><h5 id="为什么要使用双缓冲技术？"><a href="#为什么要使用双缓冲技术？" class="headerlink" title="为什么要使用双缓冲技术？"></a>为什么要使用双缓冲技术？</h5><p>在Linux上通常使用Framebuffer来做显示输出，当用户进程更新Framebuffer中的数据后，显示驱动会把FrameBuffer中每个像素点的值更新到屏幕，但是如果上一帧数据还没显示完，Framebuffer中的数据又更新了，就会带来残影的问题，用户会觉得有闪烁感，所以采用了双缓冲技术。</p><h5 id="双缓冲的含义？"><a href="#双缓冲的含义？" class="headerlink" title="双缓冲的含义？"></a>双缓冲的含义？</h5><p>双缓冲意味着要使用两个缓冲区（在上文提及的SharedBufferStack中），其中一个称为Front Buffer，另一个称为Back Buffer。UI总是先在Back Buffer中绘制，然后再和Front Buffer交换，渲染到显示设备中。即只有当另一个buffer的数据准备好后，通过io_ctl来通知显示设备切换Buffer。</p><h5 id="Choreographer的作用是什么？"><a href="#Choreographer的作用是什么？" class="headerlink" title="Choreographer的作用是什么？"></a>Choreographer的作用是什么？</h5><p>当收到VSYNC信号时，调用用户设置的回调函数。回调类型的优先级从高到低为CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL。</p><h5 id="当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？"><a href="#当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？" class="headerlink" title="当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？"></a>当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？</h5><p>因为只有两个Buffer；所以4.1版本后，出现了第三个缓冲区：Triple Buffer。它利用CPU/GPU的空闲等待时间提前准备好数据，并不一定会使用。</p><p><strong>注意</strong>：除非必要，大部分情况下只是用到双缓冲。而且，缓冲区并不是越多越好，要做到平衡到最佳效果。</p><h5 id="Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？"><a href="#Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？" class="headerlink" title="Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？"></a>Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？</h5><p>因为VSync 中断处理的线程优先级一定要最高，否则即使接收到VSync中断，不能及时处理，也是徒劳无功。</p><h4 id="1-3、卡顿的根本原因"><a href="#1-3、卡顿的根本原因" class="headerlink" title="1.3、卡顿的根本原因"></a>1.3、卡顿的根本原因</h4><ul><li>绘制任务太重、绘制一帧内容耗时太长。</li><li>主线程太忙，导致VSync信号来时还没有准备好数据导致丢帧。</li></ul><h3 id="二、性能分析工具"><a href="#二、性能分析工具" class="headerlink" title="二、性能分析工具"></a>二、性能分析工具</h3><p>Android常用的性能优化工具一般有如下几种：</p><ul><li>Hierarchy View：查看Layout层次</li><li>Android Studio自带的Profile工具</li><li>静态代码检查工具Lint</li><li>TraceView</li><li>Systrace</li></ul><h4 id="2-1、卡顿检测工具Profile-GPU-Rendering"><a href="#2-1、卡顿检测工具Profile-GPU-Rendering" class="headerlink" title="2.1、卡顿检测工具Profile GPU Rendering"></a>2.1、卡顿检测工具Profile GPU Rendering</h4><p>它是Android手机上自带的一个辅助工具，打开Profile GPU Rendering后可以看到实时刷新的彩色图，其中每一根竖线表示一帧，由多个颜色组成，不同颜色的解释如下：</p><ul><li>每一条柱状图都由红、黄、蓝、紫组成，分别对应每一帧在不同阶段的实际耗时。</li><li>蓝色：测量绘制的时间，需要多长时间去创建和更新DisplayList。在蓝色的线很高时，有可能是因为需要重新绘制，或者自定义视图的onDraw函数处理事情太多。</li><li>红色：Android进行2D渲染Display List的执行的时间。当红色的线非常高时，可能是由于重新提交了视图导致的。</li><li>橙色：处理时间或CPU告诉GPU渲染一帧的地方，如果柱状图很高，就意味着GPU太繁忙了。</li><li>紫色：将资源转移到渲染线程的时间。（4.0版本以上提供）</li></ul><p>并且，从Android M开始变成了渲染八步骤：</p><h5 id="1、橙色-Swap-Buffers"><a href="#1、橙色-Swap-Buffers" class="headerlink" title="1、橙色-Swap Buffers"></a>1、橙色-Swap Buffers</h5><p>表示GPU处理任务的时间。</p><h5 id="2、红色-Command-Issue"><a href="#2、红色-Command-Issue" class="headerlink" title="2、红色-Command Issue"></a>2、红色-Command Issue</h5><p>进行2D渲染显示列表的时间，越高表示需要绘制的视图越多。</p><h5 id="3、浅蓝-Sync-amp-Upload"><a href="#3、浅蓝-Sync-amp-Upload" class="headerlink" title="3、浅蓝-Sync&amp;Upload"></a>3、浅蓝-Sync&amp;Upload</h5><p>准备有待绘制的图片所耗费的时间，越高表示图片数量越多或图片越大。</p><h5 id="4、深蓝-Draw"><a href="#4、深蓝-Draw" class="headerlink" title="4、深蓝-Draw"></a>4、深蓝-Draw</h5><p>测量和绘制视图所需的时间，越高表示视图越多或onDraw方法有耗时操作。</p><h5 id="5、一级绿-Measure-Layout"><a href="#5、一级绿-Measure-Layout" class="headerlink" title="5、一级绿-Measure/Layout"></a>5、一级绿-Measure/Layout</h5><p>onMeasure与onLayout所花费的时间。</p><h5 id="6、二级绿-Animation"><a href="#6、二级绿-Animation" class="headerlink" title="6、二级绿-Animation"></a>6、二级绿-Animation</h5><p>执行动画所需要花费的时间。越高表示使用了非官方动画工具或执行中有读写操作。</p><h5 id="7、三级绿-Input-Handling"><a href="#7、三级绿-Input-Handling" class="headerlink" title="7、三级绿-Input Handling"></a>7、三级绿-Input Handling</h5><p>系统处理输入事件所耗费的时间。</p><h5 id="8、四级绿-Misc-Time-Vsync-Delay"><a href="#8、四级绿-Misc-Time-Vsync-Delay" class="headerlink" title="8、四级绿-Misc Time/Vsync Delay"></a>8、四级绿-Misc Time/Vsync Delay</h5><p>主线程执行了太多任务，导致UI渲染跟不上vSync的信号而出现掉帧。</p><p>此外，可通过如下adb命令将具体的耗时输出到日志中来分析：</p><pre><code>adb shell dumpsys gfxinfo com.**.** </code></pre><h4 id="2-2、TraceView"><a href="#2-2、TraceView" class="headerlink" title="2.2、TraceView"></a>2.2、TraceView</h4><p>它主要用来分析函数的调用过程，可以对Android的应用程序以及Framework层代码进行性能分析。</p><p>使用TraceView查看耗时，主要关注Calls + Recur Calls / Total和（该方法调用次数+递归次数）和Cpu Time / Call（该方法耗时）这两个值，然后优化这些方法的逻辑和调用次数，减少耗时。</p><p><strong>注意</strong>：RealTime（实际时长）的实际执行时间要比CPU Time要长，因为它包括了CPU的上下文切换、阻塞、GC等。</p><h4 id="2-3、Systrace-UI性能分析"><a href="#2-3、Systrace-UI性能分析" class="headerlink" title="2.3、Systrace UI性能分析"></a>2.3、Systrace UI性能分析</h4><p>Systrace是Android 4.1及以上版本提供的性能数据采样和分析工具，它的作用有：</p><ul><li>收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务、View系统等）的运行信息，这样可以更直观地分析系统瓶颈，改进性能。</li><li>跟踪系统的I/0操作、内核工作队列、CPU负载等，在UI显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上。</li></ul><p><strong>注意：Systrace是以系统的角度返回一些信息，并不能定位到具体耗时的方法，建议使用TraceView。</strong></p><h5 id="1、Systrace使用方法"><a href="#1、Systrace使用方法" class="headerlink" title="1、Systrace使用方法"></a>1、Systrace使用方法</h5><p>使用事项如下：</p><ul><li>支持4.1版本及以上。</li><li>4.3以前的系统版本需要打开Setting&gt;Developer options&gt;Monitoring&gt;Enable traces。</li></ul><p>一般我们使用命令行来得到输出的html表单，在4.3版本及以上可以省略设置跟踪类别标签来获取默认值。命令如下：</p><pre><code>cd android-sdk/platform-tools/systracepython systrace.py --time=10 -o mynewtrace.html sched gfx view wm</code></pre><p>其中，常用的几个参数命令如下：</p><ul><li>-o <file>：保存的文件名。</file></li><li>-t N, –time=N：多少秒内的数据，默认为5s，以当前时间点往后倒N秒时间。</li></ul><p>其余标签用法请<a href="http://developer.android.com/intl/zh-cn/tools/help/systrace.html" target="_blank" rel="external">参见此处</a>。</p><p>此外，我们可以使用代码插桩的方式，在Android 4.3及以上版本可以使用Trace类的Trace.beginSection()与Trace.endSection()方法来进行追踪。其中需要注意：</p><ul><li>保证beginSection和endSection的调用次数要匹配。</li><li>Trace的begin与end必须在同一线程中执行。</li></ul><h5 id="2、分析Systrace报告"><a href="#2、分析Systrace报告" class="headerlink" title="2、分析Systrace报告"></a>2、分析Systrace报告</h5><p>使用Chrome打开文件后，其中和UI绘制关系最密切的是Alerts和Frame两个数据：</p><ul><li>Alerts：标记了性能有问题的点，单击该点可以查看详细信息，右侧的Alerts框还可以看到每个类型的Alerts的数量。</li><li>Frame：每个应用都有一行专门显示frame，每一帧就显示为一个绿色的圆圈。当显示为黄色或者红色时，它的渲染时间超过了16.6ms。</li></ul><p>这里，列出Systrace有用的快捷键：</p><ul><li>W：放大</li><li>S：缩小</li><li>A：左移</li><li>D：右移</li></ul><h3 id="三、布局优化"><a href="#三、布局优化" class="headerlink" title="三、布局优化"></a>三、布局优化</h3><h4 id="3-1、布局优化方法"><a href="#3-1、布局优化方法" class="headerlink" title="3.1、布局优化方法"></a>3.1、布局优化方法</h4><h5 id="1、减少层级"><a href="#1、减少层级" class="headerlink" title="1、减少层级"></a>1、减少层级</h5><ul><li>合理使用RelativeLayout和LinearLayout。</li><li>合理使用Merge。</li></ul><p>RelativeLayout也存在性能低的问题，原因是RelativeLayout会对子View做两次测量。但如果在LinearLayout中有weight属性，也需要进行两次测量，因为没有更多的依赖关系，所以仍然会比RelativeLayout的效率高。</p><p><strong>注意：由于Android的碎片化程度很高，所以使用RelativeLayout能使构建的布局适应性更强。</strong></p><p>merge的原理：在Android布局的源码中，如果是Merge标签，那么直接将其中的子元素添加到Merge标签Parent中。</p><p>注意：</p><ul><li>Merge只能用在布局XML文件的根元素。</li><li>使用merge来加载一个布局时，必须指定一个ViewGroup作为其父元素，并且要设置加载的attachToRoot参数为true。</li><li>不能在ViewStub中使用Merge标签。原因就是ViewStub的inflate方法中根本没有attachToRoot的设置。</li></ul><h5 id="2、提供显示速度"><a href="#2、提供显示速度" class="headerlink" title="2、提供显示速度"></a>2、提供显示速度</h5><p>ViewStub是一个轻量级的View，它是一个看不见的，并且不占布局位置，占用资源非常小的视图对象。可以为ViewStub指定一个布局，加载布局时，只有ViewStub会被初始化，然后当ViewStub被设置为可见时，或是调用了ViewStub.inflate()时，ViewStub所指向的布局会被加载和实例化，然后ViewStub的布局属性都会传给它指向的布局。</p><p>注意：</p><ul><li>ViewStub只能加载一次，之后ViewStub对象会被置为空。所以它不适用于需要按需显示隐藏的情况。</li><li>ViewStub只能用来加载一个布局文件，而不是某个具体的View。</li><li>ViewStub中不能嵌套Merge标签。</li></ul><h5 id="3、布局复用"><a href="#3、布局复用" class="headerlink" title="3、布局复用"></a>3、布局复用</h5><p>Android的布局复用可以通过<include>标签来实现。</include></p><p>一些优化总结：</p><ul><li>使用<viewstub>标签加载一些不常用的布局。</viewstub></li><li>尽可能少用wrap_content，wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content。</li><li>使用TextView替换RL、LL。</li><li>使用低端机进行优化，以发现性能瓶颈。</li><li>使用TextView的行间距替换多行文本：lineSpacingExtra/lineSpacingMultiplier。</li><li>使用Spannable/Html.fromHtml替换多种不同规格文字。</li><li>尽可能使用LinearLayout自带的分割线。</li><li>使用Space添加间距。</li><li>多利用lint + alibaba规约修复问题点。</li><li>嵌套层级过多可以考虑使用约束布局。</li></ul><h3 id="四、避免过度绘制"><a href="#四、避免过度绘制" class="headerlink" title="四、避免过度绘制"></a>四、避免过度绘制</h3><p>导致过度绘制的主要原因是：</p><ul><li>XML布局：控件有重叠且都有设置背景。</li><li>View自绘：View.OnDraw里面同一个区域被绘制多次。</li></ul><h4 id="4-1、过度绘制检测工具"><a href="#4-1、过度绘制检测工具" class="headerlink" title="4.1、过度绘制检测工具"></a>4.1、过度绘制检测工具</h4><p>打开手机开发者选项中的Show GPU Overdraw选项，会有不同的颜色来表示过度绘制次数，依次是无、蓝、绿、淡红、深红，分别对应0-4次过度绘制。</p><h4 id="4-2、如何避免过度绘制"><a href="#4-2、如何避免过度绘制" class="headerlink" title="4.2、如何避免过度绘制"></a>4.2、如何避免过度绘制</h4><h5 id="1、布局上的优化"><a href="#1、布局上的优化" class="headerlink" title="1、布局上的优化"></a>1、布局上的优化</h5><ul><li>移除XML中非必需的背景，或根据条件设置。</li><li>有选择性地移除窗口背景：getWindow().setBackgroundDrawable(null)。</li><li>按需显示占位背景图片。</li></ul><p>比如：在获取Avatar的图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到时，才设置对应的Background占位图片。</p><h5 id="2、自定义View优化"><a href="#2、自定义View优化" class="headerlink" title="2、自定义View优化"></a>2、自定义View优化</h5><p>通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制。并且，它还可以节约CPU和GPU资源，在clipRect区域之外的绘制指令都不会被执行。</p><p>在绘制一个单元之前，首先判断该单元的区域是否在Canvas的剪切域内。若不在，直接返回，避免CPU和GPU的计算和渲染工作。</p><h3 id="五、合理的刷新机制"><a href="#五、合理的刷新机制" class="headerlink" title="五、合理的刷新机制"></a>五、合理的刷新机制</h3><h4 id="5-1-减少刷新次数"><a href="#5-1-减少刷新次数" class="headerlink" title="5.1 减少刷新次数"></a>5.1 减少刷新次数</h4><ul><li>控制刷新频率</li><li>避免没有必要的刷新</li></ul><h4 id="5-2-避免后台线程的影响"><a href="#5-2-避免后台线程的影响" class="headerlink" title="5.2 避免后台线程的影响"></a>5.2 避免后台线程的影响</h4><p>如通过监听ListView的onScrollStateChanged事件，在滚动时暂停图片下载线程工作，结束后再开始，可以提高ListView的滚动平滑度。</p><h4 id="5-3-缩小刷新区域"><a href="#5-3-缩小刷新区域" class="headerlink" title="5.3 缩小刷新区域"></a>5.3 缩小刷新区域</h4><p>如自定义View一般采用invalidate方法刷新，可以用以下重载方法刷新要刷新的区域：</p><ul><li>invalidate(Rect dirty);</li><li>invalidate(int left, int top, int right, int bottom);</li></ul><h3 id="六、提升动画性能"><a href="#六、提升动画性能" class="headerlink" title="六、提升动画性能"></a>六、提升动画性能</h3><p>提升动画性能主要从以下三个纬度着手：</p><ul><li>流畅度：控制每一帧动画在16m内完成。</li><li>内存：避免内存泄漏，减小内存开销。</li><li>耗电：减小运算量，优化算法，减小CPU占用。</li></ul><h4 id="6-1-帧动画"><a href="#6-1-帧动画" class="headerlink" title="6.1 帧动画"></a>6.1 帧动画</h4><p>消耗资源最多，效果最差，能不用就不用。</p><h4 id="6-2-补间动画"><a href="#6-2-补间动画" class="headerlink" title="6.2 补间动画"></a>6.2 补间动画</h4><p>使用补间动画实现导致View重绘非常频繁，更新DisplayList的次数过多，且有以下缺点：</p><ul><li>只能用于View对象。</li><li>只有4种动画操作。</li><li>只是改变View的显示效果，但是不会真正改变View的属性。</li></ul><h4 id="6-3-属性动画"><a href="#6-3-属性动画" class="headerlink" title="6.3 属性动画"></a>6.3 属性动画</h4><p>相比于补间动画，属性动画重绘明显会少很多，应优先使用。</p><h4 id="6-4-硬件加速"><a href="#6-4-硬件加速" class="headerlink" title="6.4 硬件加速"></a>6.4 硬件加速</h4><h5 id="1、硬件加速原理"><a href="#1、硬件加速原理" class="headerlink" title="1、硬件加速原理"></a>1、硬件加速原理</h5><p>核心类：DisplayList，每一个View对应一个。</p><p>在打开硬件渲染后绘制View时，其中执行绘制的draw()方法会把所有绘制命令记录到一个新的显示列表（DisplayList），这个显示列表包含了输出的View层级的绘制代码，但并不是加入到显示列表就立刻执行，当这个ViewTree的DisplayList全都记录完毕后，由OpenGLRender负责将Root View中的DisplayList渲染到屏幕上。而invalidate()方法只是在显示列表中记录和更新显示层级，去标记不需要绘制的View。</p><h5 id="2、硬件加速控制级别"><a href="#2、硬件加速控制级别" class="headerlink" title="2、硬件加速控制级别"></a>2、硬件加速控制级别</h5><p>如果应用程序中只使用了标准View或者Drawable，就可以为整个系统打开硬件加速的全局设置。</p><h5 id="3、在动画上使用硬件加速"><a href="#3、在动画上使用硬件加速" class="headerlink" title="3、在动画上使用硬件加速"></a>3、在动画上使用硬件加速</h5><p>硬件纹理操作对一个View进行动画绘制，如果不调用invalidate()方法，就可以减少对View自身频繁的重绘。同时Android 3.0的属性动画也减小了重绘，当View通过硬件层返回时，最终所有的层叠画面显示到屏幕，View的属性同时被处理好，因此只要设置这些属性，就可以明显提高绘制的效率，它们不需要View重绘，设置属性后，View会自动刷新。因此，属性动画中绘制的递归次数比补间动画少很多。</p><p>在Android 3.0前，使用View的绘制缓冲或Canvas.saveLayer()函数对离屏缓冲进行渲染。Android 3.0后则使用View,.setLayerType(type, paint)方法代替，type可以为以下三种Layer类型之一：</p><ul><li>LAYER_TYPE_NONE：普通渲染方式，不会返回一个离屏的缓冲，默认值。</li><li>LAYER_TYPE_HARDWARE：如果这个应用使用了硬件加速，这个View将会在硬件中渲染为硬件纹理。</li><li>LAYER_TYPE_SOFTWARE：此View通过软件渲染为一个Bitmap。</li></ul><h5 id="设计一个动画的流程如下："><a href="#设计一个动画的流程如下：" class="headerlink" title="设计一个动画的流程如下："></a>设计一个动画的流程如下：</h5><p>1、将要执行动画的View的LayerType设置为LAYER_TYPE_HARDWARE。</p><p>2、计算动画View的属性等信息，更新View的属性。</p><p>3、若动画结束，将LayerType设置为NONE。</p><h5 id="硬件加速需要注意的问题："><a href="#硬件加速需要注意的问题：" class="headerlink" title="硬件加速需要注意的问题："></a>硬件加速需要注意的问题：</h5><ul><li>在软件渲染时，可以使用重用Bitmap的方法来节省内存，但是如果开起来硬件加速，这个方案就不起作用。</li><li>开启硬件加速的View在前台运行时，需要耗费额外的内存，加速的UI切换到后台时，产生的额外内存有可能不释放。</li><li>当UI中存在过渡绘制时，硬件加速会比较容易发问题。</li></ul><h3 id="七、卡顿监控方案与实现"><a href="#七、卡顿监控方案与实现" class="headerlink" title="七、卡顿监控方案与实现"></a>七、卡顿监控方案与实现</h3><p>目前比较流行的方案都是利用了Looper中的Printer来实现监控。</p><h4 id="7-1-监控原理"><a href="#7-1-监控原理" class="headerlink" title="7.1 监控原理"></a>7.1 监控原理</h4><p>利用主线程的消息队列处理机制，通过自定义Printer，然后在Printer中获取到两次被调用的时间差，这个时间差就是执行时间。如果该时间超过阈值（如1000ms）时，主线程卡顿发生，并抛出各种有用信息，供开发者分析。（此外，也可以在UI线程以外开启一个异步线程，定时向UI线程发送一个任务，并记下发送时间。任务的内容是将执行时间同步到发送线程，如果UI线程被阻塞，那么发送过去的任务不能被准时执行。但此方法会增加系统开销，不可取）</p><h5 id="可抓取的信息"><a href="#可抓取的信息" class="headerlink" title="可抓取的信息"></a>可抓取的信息</h5><ul><li>基础信息：系统版本、机型、进程名、应用版本号、磁盘空间、UID等。</li><li>耗时信息：卡顿开始和结束时间。</li><li>CPU信息：CPU的信息、整体CPU使用率和本进程CPU使用率（可粗略判断是当前应用消耗CPU资源太多导致的卡顿，还是其他原因）等。</li><li>堆栈信息。</li></ul><h5 id="注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。"><a href="#注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。" class="headerlink" title="注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。"></a>注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。</h5><h3 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h3><p>至此，这里我们分析一下绘制优化应经历的几个过程：</p><ul><li>1、发现问题：除使用时感知的卡顿外，还应通过卡段监控工具来发现整体的耗时情况，或打开开发者选项的一些辅助工具来发现问题。</li><li>2、分析问题：可以使用Systrace和TraceView来分析耗时，使用Hierarhy Viewer来分析页面层级。</li><li>3、寻求原因：深入探索导致问题的根本原因。</li><li>4、解决问题。</li></ul><p>应用之所以会出现卡顿，除了绘制方面的问题，还有一个影响因素就是内存，不合理地使用内存不仅会导致卡顿，还会对耗电和应用的稳定性造成很大影响，下一篇文章，笔者将对Android中的内存优化进行全面的讲解，若读者觉得哪里有写的不好的地方或有误的地方希望多多进行批评指正，愿我们共同进步和成长！</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android应用性能优化最佳实践</p><p>2、<a href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ?" target="_blank" rel="external">必知必会 | Android 性能优化的方面方面都在这儿</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
