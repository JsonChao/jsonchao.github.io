<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Wed, 21 Feb 2018 05:11:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Python学习笔记（二、函数和高级特性？）</title>
      <link>http://yoursite.com/2018/01/23/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9F%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/01/23/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9F%EF%BC%89/</guid>
      <pubDate>Tue, 23 Jan 2018 13:23:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;随着人工智能和AI行业的兴起，Python已经成为程序员不得不学的一门编程语言了，本篇，为Python学习第二篇。
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre><code>随着人工智能和AI行业的兴起，Python已经成为程序员不得不学的一门编程语言了，本篇，为Python学习第二篇。</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>Python中的函数类似于数学中的函数。</code></pre><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p><a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">Python中内置的函数</a></p><pre><code>例如：计算类函数：abs(x)，max(...)。数据类型转换函数：int()，str(), bool(), float()。函数名复制给变量，该变量指向了该函数的地址。因而，具有函数的功能。a = absa(-10)输出10。</code></pre><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><pre><code>def myAbs(x)：    if x &gt;= 0：        return x    else：         return -x以def为前缀 + 函数名 + (参数...), return返回函数返回值，没有return则返回None， return = return None。空函数：使用pass构造空函数def test:    pass也可以：if a &gt; 0:    pass</code></pre><h5 id="参数类型检查"><a href="#参数类型检查" class="headerlink" title="参数类型检查"></a>参数类型检查</h5><pre><code>使用isinstance检测参数类型：def myAbs(x):    if not isinstance (x, (int, float)):        raise TypeError(&quot;bad opread error&quot;)    if x &gt;= 0:        return x    else:        return -x</code></pre><h5 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h5><pre><code>当一个函数返回值有多个时，返回的是一个tuple，如(20, 30)。</code></pre><h5 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h5><pre><code>位置参数：test(x)、test(x, y)x、y的参数定义即为位置参数。默认参数：def test(x , age = 3, city = &apos;shenzhen&apos;)，其中age和city为默认参数。1.传入test(0)即为传入test(0, 3, &apos;shenzhen&apos;)。2.传入test(0, 25)即为传入test(0, 25, &apos;shenzhen&apos;)。3.传入test(0, city = &apos;guangzhou&apos;)即为传入&apos;guangzhou&apos;，注意，当参数位置不对应时，需要指明参数类型，即city。4.默认参数必须指向不变对象，使用test(city = none)替代test(city = [])，写入if(city = none):    city = []即可。额外的：为什么要设计str、none这样的不可变对象?可以避免在多线程中对象改变而造成的的错误，因此，尽量用不可变对象替代可变对象。可变参数：def test(*nums)1.可变参数在函数调用时自动组装成一个Tuple。2.nums可以是0个或多个数据。3.nums可以是一个List或者Tuple，此时*nums表示将List或者Tuple中的元素转化成可变参数传递进去。（内容拷贝）关键字参数：def test(**nums)1.关键字参数在函数调用时自动组装成一个dict。2.nums可以是0个或多个数据。3.nums可以是一个dict，此时**nums表示将dict中的元素转化为关键字参数传递进去。（内容拷贝）命名关键字参数：def test(a, *, b, c)，*，后面的为命名关键字参数。1.当函数中存在可变参数*x时，*x的作用等效于*，即此时，b、c也为命名关键字参数。2.调用含有关键字参数的函数时，应该使用key = value的形式，如本例：test(a, b = 1, c = &apos;haha&apos;)。3.当函数中指定了缺省值时，如def test(a, *x, b = 1, c)，此时，使用函数时可不填b参数。参数组合：5种参数的组合顺序为：位置参数、默认参数、可变参数、命名关键字参数、关键字参数。任意参数组合的函数都能给函数传入function(*x, **y)的组合传值形式。注意：参数组合过多会影响语义，尽量避免使用多参数组合。使用*args和**kw是习惯写法，建议遵循。</code></pre><h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><pre><code>1.优点：逻辑简单清晰，缺点：调用过深会导致栈溢出。2.可使用尾递归(返回自身本身)优化的方式避免栈溢出。3.大多数编程语言(包括Python)的编译器或解释器都没有针对尾递归进行优化。</code></pre><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><pre><code>代码越少，效率越高。</code></pre><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><pre><code>nums = list(range(100))切片：nums[0:2] == nums[:2]表示取下标为0到2(不包括2)的数据。倒数切片：nums[-2:0] == nums[-2:]表示取下标为-2到0(不包括0)的数据。nums[:10:2]前10个数，每2个取一个。nums[::5]所有数，每5个取一个。nums[::-1]取倒数。nums[:]输出该list。注意：nums指向的数据类型是什么，nums[...]取出来的数据类型就是什么。</code></pre><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><pre><code>for i in nums不管是否有下标，只有能迭代，就能适用迭代器。对于dict，迭代的是key，迭代value：for i in nums.values()迭代key、value for i in nums.items()1.通过collections的Iterable来判读是否能迭代：from collections import Iterableisinstance(&apos;abcd&apos;, Iterable)2.使用内置的enumerate将list变成索引-元素对：for i, j in enumerate([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]):    print(i, j)</code></pre><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><pre><code>[i * i for i in range(1, 10)][i * i for i in range(1, 10) if i % 2 == 0][i * j for i in range(1, 10) for j in range(1, 10)][i * j for i in range(1, 10) if i % 2 == 0 for j in range(1, 10) if j % 2 == 0]注意：&apos;a&apos; + 1，不同于java，python计算会出错。</code></pre><h6 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h6><pre><code>g = (x * x for x in range(10))for i in g一边循环，一边计算的机制称为生成器。获取返回值，必须捕获StopIterable异常。返回值就在包含在StopIterable的value中。except StopIterable as e：    print(e.value)    break普通函数和generate函数的区别普通函数调用直接返回结果，generate函数调用返回generate对象。</code></pre><h5 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h5><pre><code>直接作用于for循环的数据类型有以下几种：1.集合类型：list、tuple、dict、set、str等等。2.generate类型：generate对象和generate函数。这些可直接作用于for循环的对象称为Iterable对象。1.可直接作用于next()函数的数据类型称为Iterator对象。所有的生成器都是Iterator，而list、dict、str则不是。why：Iterator至少需满足2个条件：    1.长度不能够被提前知道。    2.可以表示无限大的数据。2.可通过iter()函数来获得一个Iterator对象。3.python的for循环的本质就是不断调用next()函数来实现的。</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/01/23/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%E3%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%9F%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python学习笔记（一、是时候上手Python了）</title>
      <link>http://yoursite.com/2018/01/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E3%80%81%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E6%89%8BPython%E4%BA%86%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/01/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E3%80%81%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E6%89%8BPython%E4%BA%86%EF%BC%89/</guid>
      <pubDate>Fri, 19 Jan 2018 09:22:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;随着人工智能和AI行业的兴起，Python已经成为程序员不得不学的一门编程语言了，本篇，为Python学习初篇。

        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><pre><code>随着人工智能和AI行业的兴起，Python已经成为程序员不得不学的一门编程语言了，本篇，为Python学习初篇。</code></pre><h4 id="初识Python"><a href="#初识Python" class="headerlink" title="初识Python"></a>初识Python</h4><pre><code>what：python是什么？    它是一门跨平台的高级编程语言，相对其它高级语言（如：C、Java）来说，它封装的功能更完善，能用更少的代码实现同样的功能。    python的作用？    Python的用处很多，它主要使用的领域有：    1.前后端开发    2.工具脚本开发    3.爬虫    4.人工智能、AI    优点：简洁、易懂、用更少的代码实现功能模块。    缺点：    1.程序运行速度很慢，因为python是解释性语言，计算机每执行一行python代码就会把它翻译成自身能识别的机器码，而其它语言，如C语言，则会在运行前就会被编译成计算机能识别的机制码。    2.python不能够加密，发布就是将源码发布出去，这正是解释性语言的缺陷，而编译型语言则不会，如C语言，它是将编译后得到的二进制码发布出去。why：为什么要使用python？    因为它的优点——简洁、易懂、能用更少的代码实现功能模块，特别适合做一些脚本工具。how：如何使用它？    请往下看。。。</code></pre><h4 id="安装Python开发工具（Windows系统）"><a href="#安装Python开发工具（Windows系统）" class="headerlink" title="安装Python开发工具（Windows系统）"></a>安装Python开发工具（Windows系统）</h4><pre><code>python有两个版本（2.x，3.x），只演示新版本的安装。打开python网站，选择安装Install-&gt;windows-&gt;最新relese 64bit即可，可选框全选即可。官网安装的python环境用的是CPython解释器（包含python代码的文档称为.py,解释器就是用来执行python代码的）。解释器有很多种，CPython是主流。</code></pre><h4 id="先用起来？"><a href="#先用起来？" class="headerlink" title="先用起来？"></a>先用起来？</h4><pre><code>启动方式？1.打开命令行模式，输入python进入python交互模式。输入exit()回到命令行模式。2.直接点击python终端，进入python交互模式。输入exit()退出命令行模式。注意：python交互模式的代码是输入一行，输出一行，它只适合初学者用来调试代码时使用，正常开发都是编写*.py文件，使用python *.py运行*.py文件，这样就会一次性执行python源代码。（文件名只能是英文字母、数字、下划线的组合）。</code></pre><h5 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h5><pre><code>输出：使用print()，可以“”，‘’的形式输出单个字符串，也可输出多个字符串如print(&quot;hello&quot;,&quot;I&quot;,&quot;am&quot;,&quot;jsonchao&quot;),输出时，号相当于一个空格。输入：使用input()，括号内可以写入输入的提示信息，如：name = print(&quot;please enter your name:&quot;)print(&quot;hello&quot;, name)其中name为字符串变量。</code></pre><h4 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h4><pre><code>python、C、JAVA都是高级语言，它们不同于自然语言，它们需要通过解释器或编译期将符合自身语法规则的语言转换为计算机能够执行的机器码。约定俗成的规则：1.#后面为注释；2.语句后面加：号结尾时，缩进的语句变为代码块；缩进一般为4个空格=tab键；3.不同于java，复制粘贴时，缩进的格式可能复制不过来，需要重起缩进格式；4.python程序是大小写敏感的。</code></pre><h5 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h5><pre><code>1.r&quot;&quot;表示字符串里面的内容默认不转义。2.&apos;&apos;&apos;hello    I am    jsonchao&apos;&apos;&apos;为避免加入多个\n的写法。3.布尔值：True、False首字母为大写，and、or、not为运算符。4.None为python中一个特殊的空值。5.变量a = 10    a = &quot;10&quot;，说明python是一门变量可以动态赋值为不同类型的语言，称为动态语言，而java的变量，则一开始则指定了类型，如：    int a = 10；所以java是一门静态语言。6.用大写字母规范地表示常量，虽然它的值还是可以动态改变。。。7.除法：/，//（地板除，值取整）得到的都是浮点数结果，%（取余，结果为整数）。8.python的整数没有大小限制，浮点数没有大小限制，但是超过一定值会表示为inf（无限大）。</code></pre><h5 id="字符编码和字符串"><a href="#字符编码和字符串" class="headerlink" title="字符编码和字符串"></a>字符编码和字符串</h5><pre><code>字符编码：最初的ASCLL编码为1个字节表示一个字符，由于不同国家有不同的编码，为了解决文本显示不同语言乱码的问题，国际统一了Unicode编码，一般为2个字节表示一个字符（生僻的中文为4个字节表示一个字符），为了节省Unicode在保存数据和传输数据时字符占用过多字节的问题，后面在储存和传输时会将Unicode转换为UTF-8编码，文本显示时又会转变回Unicode编码。最常用的编码为utf-8。Python的字符串：在最新的Python3中，字符是一Unicode编码的，因此，它能适配多语言。1.ord()获取字符的整数表示，chr()获取整数对应的字符。2.如果需要将字符串在进行网络传输或者存储到磁盘，就必须将其转换成bytes（字节）。3.b&apos;&apos;或b&quot;&quot;表示里面的为字节，使用encode()将字符串编码为字节，decode()将字节编码为字符串，括号内为指定的编译码格式，\x后面指定为不能被ASCLL识别的字符。b&apos;23\x3d3j&apos;.decode(&apos;utf-8&apos;, errors=&apos;ignore&apos;),以此格式指定忽略错误。4.len()表示计算出字符串的长度，内容为前缀加b则表示后面的String为字节。5.使用%d、%s、%f、%x来格式化字符串，形式为：&quot;emm..., is %s.&quot; % (jsonchao)&quot;emm...，$%d，is %s.&quot; % (10000000， jsonchao)还可以使用%0d表示0x，%.2f表示3.14这样的形式。用%%表示%字符串。还有另一种格式化字符串的方式，使用.format()，如：&apos;haha,i&apos;m {0} year\’s old, {1:.1f}%percent power&apos;.format(24, 30.555)注意，30.5会四舍五入为30.6。6.&apos;haha&apos;.replace(&apos;h&apos;, &apos;d&apos;)替换指定字符。</code></pre><h5 id="List和Tuple"><a href="#List和Tuple" class="headerlink" title="List和Tuple"></a>List和Tuple</h5><pre><code>List：MyList = [10,&apos;haha&apos;，[20, &apos;lala&apos;]]，可存储不同类型数据，元素还可以是List。MyList[-1], MyList[-2]表示取出倒数第一，二个值。MyList.append(20)，结尾添加值。MyList.insert(1, ‘haha’)，下标为1处添加值。MyList.pop()，弹出最后一个值。MyList.pop(0)，弹出第一个值。MyList[2][1],二维取值。MyList.sort()从小到大进行排序。Tuple:是不可变的，定义为：MyTuple = (20, &apos;haha&apos;)当Tuple中只表示一个元素时，必须使用MyTuple = (20,)来消除来Python以为是括号()+值的歧义。记住不变，是指Tuple的每一个元素的指向不变，并不是指向的元素内容不变。（相当于Java中指向元素的地址，C语言的指针）区别：即为可变与不可变。</code></pre><h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><pre><code>if:后面会执行接下来缩进的两行代码。1.elif为else if的缩写。2.if还有如下写法：if 20:    print(&apos;nice&apos;)只要if后的内容是非0，非空List，一切非空内容即为Ture。elif 20 &lt;= bmi &lt; 25不同于java，java为bmi &gt;= 20 &amp;&amp;bmi &lt; 25。**为java平方符合^。</code></pre><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><pre><code>names = [&apos;tianshen&apos;, &apos;jsonchao&apos;, &apos;zhanshen&apos;]for x in names    print(&quot;Hello, &quot; + x + &quot;!&quot;)whilebreakcontinuebreak和continue尽量少用，易造成程序逻辑混乱。</code></pre><h5 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h5><pre><code>dict称为字典，编写形式如下：d = {&apos;hello&apos; : 1, &apos;haha&apos; : 2, &apos;emem&apos; : 3}判断是否有对应的key：&apos;hello&apos; in d,有则True，无则False。d.get(&apos;hello&apos;)获取key对应的值。没有则返回none，python交互命令环境下不显示结果。d.pop(key)删除指定key和对应的值。dict和List的区别：dict的查找和插入速度极快，不会随着元素的增多而变慢。dict占用的内存较多。空间换时间。记住,dict中的key必须是不可变元素。key + Hash算法计算出值的内存地址。  set：创建一个set，需要传入一个List进入。add(key)remove(key)set相当于一个无序和无重复元素的集合。可以使用&amp;和|来进行交并集计算。区别：唯一区别是set没有存储对应的value</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/01/19/Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%E3%80%81%E6%98%AF%E6%97%B6%E5%80%99%E4%B8%8A%E6%89%8BPython%E4%BA%86%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>初探JNI与NDK</title>
      <link>http://yoursite.com/2018/01/16/%E5%88%9D%E6%8E%A2JNI%E4%B8%8ENDK/</link>
      <guid>http://yoursite.com/2018/01/16/%E5%88%9D%E6%8E%A2JNI%E4%B8%8ENDK/</guid>
      <pubDate>Tue, 16 Jan 2018 07:25:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;一直以来，对JNI和NDK这块并没有进行比较系统的学习，今天，打算循序渐进，把JNI和NDK这块的知识来全面的学习一下。&lt;/p&gt;

        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一直以来，对JNI和NDK这块并没有进行比较系统的学习，今天，打算循序渐进，把JNI和NDK这块的知识来全面的学习一下。</p><h4 id="JNI"><a href="#JNI" class="headerlink" title="JNI"></a>JNI</h4><pre><code>（what）定义：java native interface（即java本地接口）        作用：使java与本地类型语言（如C、C++)交互（why）在某些情况下，java需要与本地类型语言进行交互，但是由于java具备跨本台的特点，所以与本地类型语言的交互能力比较弱，所以使用JNI来增强与本地类型语言的交互能力（how）详情见Android Studio实现NDK部分</code></pre><h4 id="NDK"><a href="#NDK" class="headerlink" title="NDK"></a>NDK</h4><pre><code>（what）定义：native development kit（即本地开发工具包）        作用：快速开发C、C++的动态库，并自动把so和应用打包成apk，其就是一种在Android中使用jni与本地类型语言（如C、C++）交互的方式        特点：            1、性能方面：                1、运行效率高                在开发高性能的需求中，采用C、C++更有效率，本地代码（C、C++）执行算法的效率更高                2、代码安全性高                java是半解释性语言，容易被反汇编后得到源代码，而本地有些代码（C、C++）则不会，提高代码的安全性            2、功能方面：                1、功能扩展性强                能够使用其它语言的开源库            3、使用方面：                1、代码可复用及移植                使用本地语言（C、C++）开发的代码还可应用于其它支持该语言的平台            4、其它方面：                1、NDK提供的库有限，仅用于处理算法和敏感问题                2、提供了交叉编译器，用于生产特定平台的CPU动态库（why）方便在Android中使用JNI与本地语言进行交互。（how）详情见Android Studio实现NDK部分</code></pre><h4 id="JNI与NDK的关系"><a href="#JNI与NDK的关系" class="headerlink" title="JNI与NDK的关系"></a>JNI与NDK的关系</h4><pre><code>1、JNI是实现的目的，而NDK是在Android中实现JNI的手段，即在Android开发环境中，通过NDK实现JNI的功能。2、NDK提供了把.so文件和应用打包成apk的工具，而JNI没有，它只是把.so文件放在文件系统的特定位置。</code></pre><h4 id="Android-Studio实现NDK"><a href="#Android-Studio实现NDK" class="headerlink" title="Android Studio实现NDK"></a>Android Studio实现NDK</h4><p>一、Android Studio2.2之前实现NDK</p><pre><code>1、配置NDK开发环境    1、下载Android NDK工具包    2、解压NDK包    3、安装&amp;配置NDK包2、关联Android Studio项目与NDK    1、在Gradle的本地local.properties中添加配置    ndk.dir=/Users/JsonChao/Library/Android/sdk/ndk-bundle    2、在Gradle的gradle.properties中添加配置    // 对旧版本的NDK支持    android.useDeprecatedNdk=true     在app的build.gradle的defaultConfig中添加ndk节点    添加对应的moduleName（.so文件名）或者其它需要的功能3、创建本地代码文件    如果本地代码时C、C++，那么需要使用extern “C”{}把代码包进去    JNIEXPORT、jstring、JNICALL中的JNIEXPORT、JNICALL不能省略    关于方法名构成：    Java_包名_类名_方法名（Java首字母需要大写）    包名中的.变_，_变_1    新建src/main/jni，放入xxx.cpp文件    java与JNI数据类型对应的关系：    八大基本数据类型int-&gt;jint（前面直接加j）    void不变    Objec、class、String、Throwable-&gt;jobject（前面加j，第二个字母小写）    八大基本数据类型和Objec、class、String数组化    Object[]-&gt;jobjectArray(前面加j，第二个字母小写，[]数组符号变英文Array)4、创建Android.mk文件    作用：指定源码编译的配置信息    如工作目录、编译的模块的名称、编译的文件等等    放入src/main/jni中5、创建Application.mk文件    作用：配置编译平台相关内容    APP_ABI：armeabi（Android平台主要是使用armeabi）    放入src/main/jni中6、进入src/main/jni中，使用ndk-build命令编译生成.so文件，成功后，生成libs&amp;obj文件夹，.so文件在libs的armeabi文件夹中7、在新建的src/main/jniLibs文件夹中放入armeabi文件夹8、加入如下代码，在Android Studio中使用NDK实现jni功能//加载.so文件{    System.loadLibrary(&quot;hello_jni&quot;);}//映射的本地方法public native String getFromJni();</code></pre><p>二、Android Studio2.2之后实现NDK</p><p>Android Studio内部已经集成了NDK，所有只需在Android Studio内部配置即可。</p><pre><code>1、创建工程选择NDK选项，根据提示完成配置2、AS会直接生成C++代码，根据需求修改即可使用。</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/01/16/%E5%88%9D%E6%8E%A2JNI%E4%B8%8ENDK/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android 插件化</title>
      <link>http://yoursite.com/2018/01/12/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96/</link>
      <guid>http://yoursite.com/2018/01/12/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96/</guid>
      <pubDate>Fri, 12 Jan 2018 08:34:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;2012年，Android插件化技术诞生，从最初只支持动态加载Activity到完全模拟app运行时的沙箱系统，历经了快6年的时间
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>2012年，Android插件化技术诞生，从最初只支持动态加载Activity到完全模拟app运行时的沙箱系统，历经了快6年的时间，本文，旨在从全方面的角度解析Android插件化技术。</p><h4 id="实现Android插件化需要解决的问题"><a href="#实现Android插件化需要解决的问题" class="headerlink" title="实现Android插件化需要解决的问题"></a>实现Android插件化需要解决的问题</h4><pre><code>插件中代码的加载和主工程的相互调用插件中资源的加载和主工程的相互调用Android四大组件的生命周期管理</code></pre><h4 id="Android插件化的发展历程"><a href="#Android插件化的发展历程" class="headerlink" title="Android插件化的发展历程"></a>Android插件化的发展历程</h4><p>第一代：dynamic-load-apk和DroidPlugin</p><pre><code>dynamic-load-apk:早期使用ProxyActivity的代理技术，由ProxyActivity去控制插件Activity的生命周期。缺点：每一个Activity都必须继承插件Activity，处理Context时必须小心。DroidPlugin：通过hook系统服务的方式启动插件Activity，来达到和使用普通方式开发app的效果。缺点：过多的hook系统服务，这一过程十分复杂且不够稳定。</code></pre><p>第二代：VirtulApk、Small、RePlugin</p><pre><code>原理：实现原理上都选择尽量少的hook，通过在manifest上预埋一些组件实现四大组件的插件化。其中Small更形成了一个跨平台、组件化的框架。</code></pre><p>第三代：VirtulApp、Atlas</p><pre><code>VirtulApp：能够完全模拟app的运行环境，能够实现免安装应用和双开技术。Atlas：阿里出品，号称是一个容器化框架，结合了组件化和热更新技术。</code></pre><h4 id="Android插件化的实现原理"><a href="#Android插件化的实现原理" class="headerlink" title="Android插件化的实现原理"></a>Android插件化的实现原理</h4><p>一、类加载</p><p>1.外部apk中的类加载</p><pre><code>Android中有两种类加载器，DexClassLoader和PathClassLoader，它们都继承于BaseDexClassLoader。两者的区别：DexClassLoader多了一个optimizedDirectory的路径参数，这个目录必须是内部存储路径，用于缓存系统创建的Dex文件。所以我们可以使用DexClassLoader去加载外部Apk中的类。</code></pre><p>2.双亲委托机制</p><pre><code>ClassLoader调用loadClass方法加载类采用了双亲委托机制来避免重复加载类。首先，ClassLoader会查看自身已经加载的类中是否已经存在此类，如不存在，然后，则会使用父类来加载此类，如不能成功加载，则会使用自身重载于BaseDexClassLoader的findClass()方法来加载此类。DexClass的DexPathList在DexClass的构造器中生成，findClass()方法则是从DexPathList下面找出对应的DexFile，循环DexElements，通过dexElement.dexFile取出对应的DexFile，再通过DexFile.loadClassBinaryName()加载对应的类。</code></pre><p>二、单DexClassLoader和多DexClassLoader</p><p>作用：使用插件DexClassLoader加载出需要的类。</p><p>1.多DexClassLoader（Replugin）</p><pre><code>通过每一个插件的DexClassLoader加载出自身所需要的类，当每一个插件需要加载相同的类库时，可采用该类库的不同版本来使用。</code></pre><p>2.单DexClassLoader（Small）</p><pre><code>通过把每一个插件的pathList（DexFile）合并到主app的DexClassLoader上，来使各个插件和主app直接能够相互调用类和方法，并且各个插件中相同的功能可以抽取出来作为一个Common插件供其它插件使用。</code></pre><p>3.互相调用</p><p>插件调用主工程</p><pre><code>在ClassLoader构造时指定主工程的DexClassLoader为父加载器即可直接调用主工程中的类和方法。</code></pre><p>主工程调用插件</p><pre><code>如果是多DexClassLoader的情况，则需要通过插件的DexClassLoader加载对应的类并反射调用其方法。此种情况，主工程一般会在一个统一的地方对访问插件中的类和方法做一些访问权限的管理及配置。如果是单DexClassLoader的情况，则可以直接调用插件中的类和方法。但是当多个插件引用的库的版本不同时，会出现错误，因此，建议采用Gradle版本依赖管理统一处理主工程及各个插件的库依赖。</code></pre><p>三、资源加载</p><p>Android通过Resource来加载资源，只要有插件apk，就可以使用assertManager.addAssertPath（apkPath）的方式来生成assertManager，再使用其new出对应的Resource对象即可。</p><p>注意：由于AssertManager并不是Public，所以需要通过反射的方式去调用它。并且由于一些Rom对Resource的处理，所以，需要兼容处理。</p><p>1.资源路径的处理</p><p>有2种处理方式：</p><pre><code>合并式：利用assertManager.addAssetPath()将主工程和各个插件的apk路径一起加入。优势：资源共用。逆势：需要处理资源id冲突。独立式：主工程和插件都生成各自独立的Resource。优势：不需要处理资源id冲突。逆势：各个插件需要通过某些方式去获取其它插件的Resource。</code></pre><p>2.Context的处理</p><pre><code>1.创建主工程的Resource2.hook主工程的Resource3.将activity与Resource关联</code></pre><p>3.资源冲突</p><pre><code>产生的原因：由于主工程和各个插件引用的Resource id重复产生的冲突。解决思路：Android中的资源在系统中是以8位16进制0XPPTTRRRR的方式存在，其中PP即是资源区分的区域（Android系统只用它来区分系统资源和应用资源），只要让每一个插件的PP段取不同的值即可解决资源id冲突的问题。具体解决方式：1.修改aapt源码，编译期修改PP段。2.修改Resource的arsc文件，其中的每一条都包含了资源id和映射路径。</code></pre><h4 id="四大组件支持（Activity）"><a href="#四大组件支持（Activity）" class="headerlink" title="四大组件支持（Activity）"></a>四大组件支持（Activity）</h4><pre><code>Activity的处理最为复杂，有两种处理方式：1.ProxyActivity的方式。2.预埋StubActivity，hook系统启动Activity的过程。原理：VirtualAPK通过替换了系统的Instrumentation，hook了Activity的启动和创建，省去了手动管理插件Activity生命周期的繁琐，让插件Activity像正常的Activity一样被系统管理，并且插件Activity在开发时和常规一样，即能独立运行又能作为插件被主工程调用。</code></pre><h4 id="Android插件化的发展方向"><a href="#Android插件化的发展方向" class="headerlink" title="Android插件化的发展方向"></a>Android插件化的发展方向</h4><pre><code>Android插件化方向主要有2个方向：1.结合组件化技术，成为一个大中型app的基础框架。2.完全模拟app运行环境的沙盒系统。</code></pre>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/01/12/Android%20%E6%8F%92%E4%BB%B6%E5%8C%96/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android自动化测试实践</title>
      <link>http://yoursite.com/2018/01/09/Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/</link>
      <guid>http://yoursite.com/2018/01/09/Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/</guid>
      <pubDate>Tue, 09 Jan 2018 11:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;众所周知，一个好的项目需要不断地打造，而一些有效的测试则是加速这一过程的利器。本篇博文讲解较为全面的介绍Android测试方面的知
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>众所周知，一个好的项目需要不断地打造，而一些有效的测试则是加速这一过程的利器。本篇博文讲解较为全面的介绍Android测试方面的知识。</p><p>Android的测试主要分为三个方面：</p><pre><code>单元测试（Mokito、Junit4）UI测试（Espresso、UI Automator）额外的：Android testing support library包括AndroidJunitRunner、Espresso、UI Automator</code></pre><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>一、使用Junit4进行单元测试</p><p>Android Studio已经自动集成了Junit4测试框架，如下：</p><pre><code>dependencies {    ...    testImplementation &apos;junit:junit:4.12&apos;</code></pre><p>使用Junit4进行单元测试的步骤：</p><pre><code>1.编写测试类。2.鼠标右键点击测试类，选择选择Go To-&gt;Test（或者使用快捷键Ctrl+Shift+T）在Test/java/项目测试文件夹/下自动生成测试模板。3.使用断言（assertEqual、assertEqualArrayEquals等等)进行单元测试。4.右键点击测试类，Run编写好的测试类。</code></pre><p>额外的概念：测试驱动开发：编写测试，实现功能使测试通过，然后不断地使用这种方式实现功能的快速迭代开发。</p><p>二、使用Mcokito进行单元测试</p><p>在build.gradle里面添加Mcokito的依赖</p><pre><code>testImplementation &apos;org.mockito:mockito-core:2.7.1&apos;</code></pre><p>Mcokito是一个模拟对象工具，它的作用如下：</p><pre><code>1.验证方法调用Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)).thenReturn(true);//方法调用1次Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)， Mockito.times(3).thenReturn(true);//方法调用3次2.指定Mock对象的某些方法的行为Mockito.when(mockObject.targetMethod(args)).thenReturn(desiredReturnValue);（args可以使anyString()）</code></pre><h4 id="UI测试"><a href="#UI测试" class="headerlink" title="UI测试"></a>UI测试</h4><p>一、Espresso是属于Android Testing support Library的UI测试框架（适合用于编写白盒自动化测试），也是一种Instrumentation测试方法。</p><p>关于Instrumentation</p><pre><code>Instrumentation是Android系统里面的一套控制方法或者“钩子”,它可以控制单个组件的生命周期，同时可以控制Android如何加载应用程序。</code></pre><p>测试步骤：</p><pre><code>1.编写UI交互的测试。2.在androidTest/java/项目测试文件/新建Expresso测试类用于测试UI交互。3.右键点击测试类，Run编写好的测试类。</code></pre><p>涉及到的api：</p><p>视图匹配api</p><pre><code>1.Expresso.onView(Matcher&lt;View&gt; matcher)用于获取目标应用中UI组件的引用指定搜索条件有以下几种： 视图的类名称 视图的R.id 视图的显示文本 视图的内容描述</code></pre><p>适配器匹配api</p><pre><code>1.Expresso.onData(Matcher&lt;? extends Object&gt; matcher)获取AdapterView视图中的引用以便执行测试</code></pre><p>ViewActions（视图操作api）方法</p><pre><code>一段常用测试代码：onView(withId(R.id.editText)).perform(typeText(STRING_TO_BE_TYPED), closeSoftKeyboard()); onView(withText(&quot;Say hello!&quot;)).perform(click());String expectedText = &quot;Hello, &quot; + STRING_TO_BE_TYPED + &quot;!&quot;;onView(withId(R.id.textView)).check(matches(withText(expectedText)));</code></pre><p>更多使用请见：</p><p><a href="https://developer.android.com/training/testing/ui-testing/espresso-testing.html" target="_blank" rel="external">测试单个应用的UI</a></p><h4 id="Android-testing-support-library"><a href="#Android-testing-support-library" class="headerlink" title="Android testing support library"></a>Android testing support library</h4><p>Espresso已经讲到了，接下来还有AndroidJunitRunner和UI Automator。</p><h4 id="AndroidJunitRunner"><a href="#AndroidJunitRunner" class="headerlink" title="AndroidJunitRunner"></a>AndroidJunitRunner</h4><p>AndroidJunitRunner是Android用于兼容Junit4在Android中的使用而创建的单元测试类。</p><p>该单元测试类必须以 @RunWith(AndroidJUnit4.class) 注解作为前缀。除了Junit4提供的测试注解外，还有如下注解：</p><pre><code>1.@RequireDeive指定设备仅在物理设备上运行，不允许在模拟器上运行。2.@SdkSupress禁止给定级别api以下的设备运行（api级别本身不计算在内）。3.@SmallTest、@MediumTest、@LargeTest指定测试的运行时长和运行频率。</code></pre><h4 id="UI-Automator"><a href="#UI-Automator" class="headerlink" title="UI Automator"></a>UI Automator</h4><p>用于跨系统和跨应用的UI测试。此测试应用场景较少，具体使用见：</p><p><a href="https://developer.android.com/training/testing/ui-testing/uiautomator-testing.html" target="_blank" rel="external">测试多个应用的UI</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/01/09/Android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E5%AE%9E%E8%B7%B5/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
