<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Sun, 28 Oct 2018 15:10:27 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android核心技术点(五、View的绘制流程）</title>
      <link>http://yoursite.com/2018/10/28/Android%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9(%E4%BA%94%E3%80%81View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/10/28/Android%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9(%E4%BA%94%E3%80%81View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%EF%BC%89/</guid>
      <pubDate>Sun, 28 Oct 2018 12:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>上一篇中我们讲到了<a href="https://jsonchao.github.io/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Android的触摸事件传递机制</a>，除此之外，关于Android View的绘制流程这一块也是View相关的核心知识点。我们都知道，PhoneWindow是Android系统中最基本的窗口系统，每个Activity会创建一个。同时，PhoneWindow也是Activity和View系统交互的接口。DecorView本质上是一个FrameLayout，是Activity中所有View的祖先。</p><h3 id="一、开始：DecorView被加载到Window中"><a href="#一、开始：DecorView被加载到Window中" class="headerlink" title="一、开始：DecorView被加载到Window中"></a>一、开始：DecorView被加载到Window中</h3><p>从Activity的startActivity开始，最终调用到ActivityThread的handleLaunchActivity方法来创建Activity，相关核心代码如下：</p><pre><code>private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {    ....    // 创建Activity，会调用Activity的onCreate方法    // 从而完成DecorView的创建    Activity a = performLaunchActivity(r, customIntent);    if (a != null) {        r.createdConfig = new Configuration(mConfiguration);        Bundle oldState = r.state;        handleResumeActivity(r.tolen, false, r.isForward, !r.activity..mFinished &amp;&amp; !r.startsNotResumed);    }}final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) {    unscheduleGcIdler();    mSomeActivitiesChanged = true;    // 调用Activity的onResume方法    ActivityClientRecord r = performResumeActivity(token, clearHide);    if (r != null) {        final Activity a = r.activity;        ...        if (r.window == null &amp;&amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {            r.window = r.activity.getWindow();            // 得到DecorView            View decor = r.window.getDecorView();            decor.setVisibility(View.INVISIBLE);            // 得到了WindowManager，WindowManager是一个接口            // 并且继承了接口ViewManager            ViewManager wm = a.getWindowManager();            WindowManager.LayoutParams l = r.window.getAttributes();            a.mDecor = decor;            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;            l.softInputMode |= forwardBit;            if (a.mVisibleFromClient) {                a.mWindowAdded = true;                // WindowManager的实现类是WindowManagerImpl，                // 所以实际调用的是WindowManagerImpl的addView方法                wm.addView(decor, l);            }        }    }}public final class WindowManagerImpl implements WindowManager {    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();    ...    @Override    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {        applyDefaultToken(params);        mGlobal.addView(view, params, mDisplay, mParentWindow);    }    ...}</code></pre><p>在了解View绘制的整体流程之前，我们必须先了解下ViewRoot和DecorView的概念。ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，相关源码如下所示：</p><pre><code>// WindowManagerGlobal的addView方法public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {    ...    ViewRootImpl root;    View pannelParentView = null;    synchronized (mLock) {        ...        // 创建ViewRootImpl实例        root = new ViewRootImpl(view..getContext(), display);        view.setLayoutParams(wparams);        mViews.add(view);        mRoots.add(root);        mParams.add(wparams);    }    try {        // 把DecorView加载到Window中        root.setView(view, wparams, panelParentView);    } catch (RuntimeException e) {        synchronized (mLock) {            final int index = findViewLocked(view, false);            if (index &gt;= 0) {                removeViewLocked(index, true);            }        }        throw e;    }}</code></pre><h3 id="二、了解绘制的整体流程"><a href="#二、了解绘制的整体流程" class="headerlink" title="二、了解绘制的整体流程"></a>二、了解绘制的整体流程</h3><p>绘制会从根视图ViewRoot的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。performTraversals()的核心代码如下。</p><pre><code>private void performTraversals() {    ...    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);    ...    //执行测量流程    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    ...    //执行布局流程    performLayout(lp, desiredWindowWidth, desiredWindowHeight);    ...    //执行绘制流程    performDraw();}</code></pre><p>performTraversals的大致工作流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1967257-f245ffbefe056fb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>注意：</p><ul><li>preformLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的，不过这并没有本质区别。</li><li>获取content：</li></ul><pre><code>ViewGroup content = (ViewGroup)findViewById(android.R.id.content);</code></pre><ul><li>获取设置的View：</li></ul><pre><code>content.getChildAt(0);</code></pre><h3 id="三、理解MeasureSpec"><a href="#三、理解MeasureSpec" class="headerlink" title="三、理解MeasureSpec"></a>三、理解MeasureSpec</h3><h5 id="1-MeasureSpec源码解析"><a href="#1-MeasureSpec源码解析" class="headerlink" title="1.MeasureSpec源码解析"></a>1.MeasureSpec源码解析</h5><p>MeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。MeasureSpec是View类的一个静态内部类，用来说明应该如何测量这个View。MeasureSpec的核心代码如下。</p><pre><code>public static class MeasureSpec {    private static final int MODE_SHIFT = 30;    private static final int MODE_MASK = 0X3 &lt;&lt; MODE_SHIFT;    // 不指定测量模式, 父视图没有限制子视图的大小，子视图可以是想要    // 的任何尺寸，通常用于系统内部，应用开发中很少用到。    public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;    // 精确测量模式，视图宽高指定为match_parent或具体数值时生效，    // 表示父视图已经决定了子视图的精确大小，这种模式下View的测量    // 值就是SpecSize的值。    public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;    // 最大值测量模式，当视图的宽高指定为wrap_content时生效，此时    // 子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。    public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;    // 根据指定的大小和模式创建一个MeasureSpec    public static int makeMeasureSpec(int size, int mode) {        if (sUseBrokenMakeMeasureSpec) {            return size + mode;        } else {            return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);        }    }    // 微调某个MeasureSpec的大小    static int adjust(int measureSpec, int delta) {        final int mode = getMode(measureSpec);        if (mode == UNSPECIFIED) {            // No need to adjust size for UNSPECIFIED mode.            return make MeasureSpec(0, UNSPECIFIED);        }        int size = getSize(measureSpec) + delta;        if (size &lt; 0) {            size = 0;        }        return makeMeasureSpec(size, mode);    }}</code></pre><p>MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包的方法，打包方法为上述源码中的makeMeasureSpec，解包方法源码如下：</p><pre><code>public static int getMode(int measureSpec) {    return (measureSpec &amp; MODE_MASK);}public static int getSize(int measureSpec) {    return (measureSpec &amp; ~MODE_MASK);}</code></pre><h5 id="2-DecorView的MeasureSpec的创建过程："><a href="#2-DecorView的MeasureSpec的创建过程：" class="headerlink" title="2.DecorView的MeasureSpec的创建过程："></a>2.DecorView的MeasureSpec的创建过程：</h5><pre><code>//desiredWindowWidth和desiredWindowHeight是屏幕的尺寸childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);private static int getRootMeaureSpec(int windowSize, int rootDimension) {    int measureSpec;    switch (rootDimension) {        case ViewGroup.LayoutParams.MATRCH_PARENT:            // Window can&apos;t resize. Force root view to be windowSize.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);            break;        case ViewGroup.LayoutParams.WRAP_CONTENT：            // Window can resize. Set max size for root view.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);            break        default:            // Window wants to be an exact size. Force root view to be that size.            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);            break;    }    return measureSpec;}</code></pre><h5 id="3-子元素的MeasureSpec的创建过程"><a href="#3-子元素的MeasureSpec的创建过程" class="headerlink" title="3.子元素的MeasureSpec的创建过程"></a>3.子元素的MeasureSpec的创建过程</h5><pre><code>// ViewGroup的measureChildWithMargins方法protected void measureChildWithMargins(View child,int parentWidthMeasureSpec, int widthUsed,int parentHeightMeasureSpec, int heightUsed) {    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();    // 子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身    // 的LayoutParams有关，此外还和View的margin及padding有关    final int childWidthMeasureSpec = getChildMeasureSpec(    parentWidthMeasureSpec,    mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed,     lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(    parentHeightMeasureSpec,    mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed,     lp.height);    child..measure(childWidthMeasureSpec, childHeightMeasureSpec);}public static int getChildMeasureSpec(int spec, int padding, int childDimesion) {    int specMode = MeasureSpec.getMode(spec);    int specSize = MeasureSpec.getSize(spec);    // padding是指父容器中已占用的空间大小，因此子元素可用的    // 大小为父容器的尺寸减去padding    int size = Math.max(0, specSize - padding);    int resultSize = 0;    int resultMode = 0;    switch (sepcMode) {        // Parent has imposed an exact size on us        case MeasureSpec.EXACTLY:            if (childDimension &gt;= 0) {                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size. So be it.                resultSize = size;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimesion == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&apos;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // Parent has imposed a maximum size on us         case MeasureSpec.AT_MOST:            if (childDimension &gt;= 0) {                // Child wants a specific size... so be it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size, but our size is not fixed.                // Constrain child to not be bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&apos;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // Parent asked to see how big we want to be        case MeasureSpec.UNSPECIFIED:            if (childDimension &gt;= 0) {                // Child wants a specific size... let him have it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size... find out how big it should be                resultSize = 0;                resultMode = MeasureSpec.UNSPECIFIED;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size....                // find out how big it should be                resultSize = 0;                resultMode == MeasureSpec.UNSPECIFIED;            }            break;        }    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}</code></pre><p>普通View的MeasureSpec的创建规则如下：</p><p><img src="https://images2015.cnblogs.com/blog/918357/201706/918357-20170618234001337-203688773.png" alt="image"></p><p>注意：UNSPECIFIED模式主要用于系统内部多次Measure的情形，一般不需关注。</p><p>结论：对于DecorView而言，它的MeasureSpec由窗口尺寸和其自身的LayoutParams共同决定；对于普通的View，它的MeasureSpec由父视图的MeasureSpec和其自身的LayoutParams共同决定。</p><h3 id="四、View绘制流程之Measure"><a href="#四、View绘制流程之Measure" class="headerlink" title="四、View绘制流程之Measure"></a>四、View绘制流程之Measure</h3><h5 id="1-Measure的基本流程"><a href="#1-Measure的基本流程" class="headerlink" title="1.Measure的基本流程"></a>1.Measure的基本流程</h5><p>由前面的分析可知，页面的测量流程是从performMeasure方法开始的，相关的核心代码流程如下。</p><pre><code>private void perormMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {    ...    // 具体的测量操作分发给ViewGroup    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);    ...}// 在ViewGroup中的measureChildren()方法中遍历测量ViewGroup中所有的Viewprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {    final int size = mChildrenCount;    final View[] children = mChildren;    for (int i = 0; i &lt; size; ++i) {        final View child = children[i];        // 当View的可见性处于GONE状态时，不对其进行测量        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {            measureChild(child, widthMeasureSpec, heightMeasureSpec);        }    }}// 测量某个指定的Viewprotected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) {    final LayoutParams lp = child.getLayoutParams();    // 根据父容器的MeasureSpec和子View的LayoutParams等信息计算    // 子View的MeasureSpec    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height);    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);}// View的measure方法public final void measure(int widthMeasureSpec, int heightMeasureSpec) {    ...    // ViewGroup没有定义测量的具体过程，因为ViewGroup是一个    // 抽象类，其测量过程的onMeasure方法需要各个子类去实现    onMeasure(widthMeasureSpec, heightMeasureSpec);    ...}// 不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同，如果需要自定义测量过程，则子类可以重写这个方法protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    // setMeasureDimension方法用于设置View的测量宽高    setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),     getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));}// 如果View没有重写onMeasure方法，则会默认调用getDefaultSize来获得View的宽高public static int getDefaultSize(int size, int measureSpec) {    int result = size;    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {        case MeasureSpec.UNSPECIFIED:            result = size;            break;        case MeasureSpec.AT_MOST:        case MeasureSpec.EXACTLY:            result = sepcSize;            break;    }    return result;}</code></pre><h5 id="2-对getSuggestMinimumWidth的分析"><a href="#2-对getSuggestMinimumWidth的分析" class="headerlink" title="2.对getSuggestMinimumWidth的分析"></a>2.对getSuggestMinimumWidth的分析</h5><pre><code>protected int getSuggestedMinimumWidth() {    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinmumWidth());}protected int getSuggestedMinimumHeight() {    return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());}public int getMinimumWidth() {    final int intrinsicWidth = getIntrinsicWidth();    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;}</code></pre><p>如果View没有设置背景，那么返回android:minWidth这个属性所指定的值，这个值可以为0；如果View设置了背景，则返回android:minWidth和背景的最小宽度这两者中的最大值。</p><h5 id="3-自定义View时手动处理wrap-content时的情形"><a href="#3-自定义View时手动处理wrap-content时的情形" class="headerlink" title="3.自定义View时手动处理wrap_content时的情形"></a>3.自定义View时手动处理wrap_content时的情形</h5><p>直接继承View的控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。解决方式如下：</p><pre><code>protected void onMeasure(int widthMeasureSpec, int height MeasureSpec) {    super.onMeasure(widthMeasureSpec, heightMeasureSpec);    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);    int widtuhSpecSize = MeasureSpec.getSize(widthMeasureSpec);    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);    // 在wrap_content的情况下指定内部宽/高(mWidth和mHeight)    int heightSpecSize = MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) {        setMeasuredDimension(mWidth, mHeight);    } else if (widthSpecMode == MeasureSpec.AT_MOST) {        setMeasureDimension(mWidth, heightSpecSize);    } else if (heightSpecMode == MeasureSpec.AT_MOST) {        setMeasureDimension(widthSpecSize, mHeight);    }}</code></pre><h5 id="4-LinearLayout的onMeasure方法实现解析"><a href="#4-LinearLayout的onMeasure方法实现解析" class="headerlink" title="4.LinearLayout的onMeasure方法实现解析"></a>4.LinearLayout的onMeasure方法实现解析</h5><pre><code>protected void onMeasure(int widthMeasureSpec, int hegithMeasureSpec) {    if (mOrientation == VERTICAL) {        measureVertical(widthMeasureSpec, heightMeasureSpec);    } else {        measureHorizontal(widthMeasureSpec, heightMeasureSpec);    }}// measureVertical核心源码// See how tall everyone is. Also remember max width.for (int i = 0; i &lt; count; ++i) {    final View child = getVirtualChildAt(i);    ...    // Determine how big this child would like to be. If this or     // previous children have given a weight, then we allow it to     // use all available space (and we will shrink things later     // if need)    measureChildBeforeLayout(            child, i, widthMeasureSpec, 0, heightMeasureSpec,            totalWeight == 0 ? mTotalLength : 0);    if (oldHeight != Integer.MIN_VALUE) {        lp.height = oldHeight;    }    final int childHeight = child.getMeasuredHeight();    final int totalLength = mTotalLength;    mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +     lp.bottomMargin + getNextLocationOffset(child));}</code></pre><p>系统会遍历子元素并对每个子元素执行measureChildBeforeLayout方法，这个方法内部会调用子元素的measure方法，这样各个子元素就开始依次进入measure过程，并且系统会通过mTotalLength这个变量来存储LinearLayout在竖直方向的初步高度。每测量一个子元素，mTotalLength就会增加，增加的部分主要包括了子元素的高度以及子元素在竖直方向上的margin等。</p><pre><code>// LinearLayout测量自己大小的核心源码// Add in our paddingmTotalLength += mPaddingTop + mPaddingBottom;int heightSize = mTotalLength;// Check against our minimum heightheightSize = Math.max(heightSize, getSuggestedMinimumHeight());// Reconcile our calculated size with the heightMeasureSpecint heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK；...setMeasuredDimension(resolveSizeAndSize(maxWidth, widthMeasureSpec, childState),heightSizeAndState);public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {    int result = size;    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {        case MeasureSpec.UNSPECIFIED:            result = size;            break;        case MeasureSpec.AT_MOST:            // 高度不能超过父容器的剩余空间            if (specSize &lt; size) {                result = specSize | MEASURED_STATE_TOO_SMALL；            } else {                result = size;            }            break;        case MeasureSpec.EXACTLY:            result = specSize;            break;    }    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);}</code></pre><h5 id="5-在Activity中获取某个View的宽高"><a href="#5-在Activity中获取某个View的宽高" class="headerlink" title="5.在Activity中获取某个View的宽高"></a>5.在Activity中获取某个View的宽高</h5><p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。解决方式如下：</p><ul><li>Activity/View#onWindowFocusChanged</li></ul><pre><code>// 此时View已经初始化完毕// 当Activity的窗口得到焦点和失去焦点时均会被调用一次// 如果频繁地进行onResume和onPause，那么onWindowFocusChanged也会被频繁地调用public void onWindowFocusChanged(boolean hasFocus) {    super.onWindowFocusChanged(hasFocus);    if (hasFocus) {        int width = view.getMeasureWidth();        int height = view.getMeasuredHeight();    }}</code></pre><ul><li>view.post(runnable)</li></ul><pre><code>// 通过post可以将一个runnable投递到消息队列的尾部，// 然后等待Looper调用次runnable的时候，View也已经初// 始化好了protected void onStart() {    super.onStart();    view.post(new Runnable() {        @Override        public void run() {            int width = view.getMeasuredWidth();            int height = view.getMeasuredHeight();        }    });}</code></pre><ul><li>ViewTreeObserver</li></ul><pre><code>// 当View树的状态发生改变或者View树内部的View的可见// 性发生改变时，onGlobalLayout方法将被回调protected void onStart() {    super.onStart();    ViewTreeObserver observer = view.getViewTreeObserver();    observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {        @SuppressWarnings(&quot;deprecation&quot;)        @Override        public void onGlobalLayout() {            view.getViewTreeObserver().removeGlobalOnLayoutListener(this);            int width = view.getMeasuredWidth();            int height = view.getMeasuredHeight();        }    });}</code></pre><ul><li>View.measure(int widthMeasureSpec, int heightMeasureSpec)</li></ul><h3 id="五、View的绘制流程之Layout"><a href="#五、View的绘制流程之Layout" class="headerlink" title="五、View的绘制流程之Layout"></a>五、View的绘制流程之Layout</h3><h5 id="1-Layout的基本流程"><a href="#1-Layout的基本流程" class="headerlink" title="1.Layout的基本流程"></a>1.Layout的基本流程</h5><pre><code>// ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) {    ...    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());    ...}// View.javapublic void layout(int l, int t, int r, int b) {    ...    // 通过setFrame方法来设定View的四个顶点的位置，即View在父容器中的位置    boolean changed = isLayoutModeOptical(mParent) ?     set OpticalFrame(l, t, r, b) : setFrame(l, t, r, b);    ...    onLayout(changed, l, t, r, b);    ...}// 空方法，子类如果是ViewGroup类型，则重写这个方法，实现ViewGroup// 中所有View控件布局流程protected void onLayout(boolean changed, int left, int top, int right, int bottom) {}</code></pre><h5 id="2-LinearLayout的onLayout方法实现解析"><a href="#2-LinearLayout的onLayout方法实现解析" class="headerlink" title="2.LinearLayout的onLayout方法实现解析"></a>2.LinearLayout的onLayout方法实现解析</h5><pre><code>protected void onlayout(boolean changed, int l, int t, int r, int b) {    if (mOrientation == VERTICAL) {        layoutVertical(l, t, r, b);    } else {        layoutHorizontal(l,)    }}// layoutVertical核心源码void layoutVertical(int left, int top, int right, int bottom) {    ...    final int count = getVirtualChildCount();    for (int i = 0; i &lt; count; i++) {        final View child = getVirtualChildAt(i);        if (child == null) {            childTop += measureNullChild(i);        } else if (child.getVisibility() != GONE) {            final int childWidth = child.getMeasureWidth();            final int childHeight = child.getMeasuredHeight();            final LinearLayout.LayoutParams lp =                     (LinearLayout.LayoutParams) child.getLayoutParams();            ...            if (hasDividerBeforeChildAt(i)) {                childTop += mDividerHeight;            }            childTop += lp.topMargin;            // 为子元素确定对应的位置            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);            // childTop会逐渐增大，意味着后面的子元素会被            // 放置在靠下的位置            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);            i += getChildrenSkipCount(child,i)        }    }}private void setChildFrame(View child, int left, int top, int width, int height) {    child.layout(left, top, left + width, top + height);}</code></pre><p>注意：在View的默认实现中，View的测量宽/高和最终宽/高是相等的，只不过测量宽/高形成于View的measure过程，而最终宽/高形成于View的layout过程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。在一些特殊的情况下则两者不相等：</p><ul><li>重写View的layout方法,使最终宽度总是比测量宽/高大100px</li></ul><pre><code>public void layout(int l, int t, int r, int b) {    super.layout(l, t, r + 100, b + 100);}</code></pre><ul><li>View需要多长measure才能确定自己的测量宽/高,在前几次测量的过程中，其得出的测量宽/高有可能和最终宽/高不一致，但最终来说，测量宽/高还是和最终宽/高相同</li></ul><h3 id="六、View的绘制流程之Draw"><a href="#六、View的绘制流程之Draw" class="headerlink" title="六、View的绘制流程之Draw"></a>六、View的绘制流程之Draw</h3><h5 id="1-Draw的基本流程"><a href="#1-Draw的基本流程" class="headerlink" title="1.Draw的基本流程"></a>1.Draw的基本流程</h5><pre><code>private void performDraw() {    ...    draw(fullRefrawNeeded);    ...}private void draw(boolean fullRedrawNeeded) {    ...    if (!drawSoftware(surface, mAttachInfo, xOffest, yOffset,     scalingRequired, dirty)) {        return;    }    ...}private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scallingRequired, Rect dirty) {    ...    mView.draw(canvas);    ...}// 绘制基本上可以分为六个步骤public void draw(Canvas canvas) {    ...    // 步骤一：绘制View的背景    drawBackground(canvas);    ...    // 步骤二：如果需要的话，保持canvas的图层，为fading做准备    saveCount = canvas.getSaveCount();    ...    canvas.saveLayer(left, top, right, top + length, null, flags);    ...    // 步骤三：绘制View的内容    onDraw(canvas);    ...    // 步骤四：绘制View的子View    dispatchDraw(canvas);    ...    // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层    canvas.drawRect(left, top, right, top + length, p);    ...    canvas.restoreToCount(saveCount);    ...    // 步骤六：绘制View的装饰(例如滚动条等等)    onDrawForeground(canvas)}</code></pre><h5 id="2-setWillNotDraw的作用"><a href="#2-setWillNotDraw的作用" class="headerlink" title="2.setWillNotDraw的作用"></a>2.setWillNotDraw的作用</h5><pre><code>// 如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，// 系统会进行相应的优化。public void setWillNotDraw(boolean willNotDraw) {    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);}</code></pre><ul><li>默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。</li><li>当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。</li><li>当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显示地关闭WILL_NOT_DRAW这个标记位。</li></ul><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>View的绘制流程和事件分发机制都是Android开发中的核心知识点，也是自定View高手的内功心法。众所周知，Kotlin在Android中的地位越来越重要，下一篇将会给大家带来Kotlin的一系列教程，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android开发艺术探索</p><p>2、Android进阶之光</p><p>3、Android高级进阶</p><p>4、<a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external">Android应用层View绘制流程与源码分析</a></p><p>5、<a href="https://blog.csdn.net/sinat_35938012/article/details/81055380" target="_blank" rel="external">Android中View绘制流程浅析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/10/28/Android%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E7%82%B9(%E4%BA%94%E3%80%81View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android触摸事件传递机制</title>
      <link>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</link>
      <guid>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</guid>
      <pubDate>Wed, 17 Oct 2018 14:38:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><h3 id="一、了解Activity的构成"><a href="#一、了解Activity的构成" class="headerlink" title="一、了解Activity的构成"></a>一、了解Activity的构成</h3><p>一个Activity包含了一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根View，而这个DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平时所写的就是展示在ContentView中的，下图表示Activity的构成。</p><p><img src="https://upload-images.jianshu.io/upload_images/1417629-c87a3dd5ed19ee9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="二、触摸事件的类型"><a href="#二、触摸事件的类型" class="headerlink" title="二、触摸事件的类型"></a>二、触摸事件的类型</h3><p>触摸事件对应的是MotionEvent类，事件的类型主要有如下三种：</p><ul><li>ACTION_DOWN</li><li>ACTION_MOVE(移动的距离超过一定的阈值会被判定为ACTION_MOVE操作)</li><li>ACTION_UP</li></ul><h3 id="三、事件传递的三个阶段"><a href="#三、事件传递的三个阶段" class="headerlink" title="三、事件传递的三个阶段"></a>三、事件传递的三个阶段</h3><ul><li>分发（dispatchTouchEvent）：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件。</li><li>拦截（onInterceptTouchEvent）：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。<br>如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　</li></ul><pre><code>1.如果该View(ViewGroup)存在子View且点击到了该子View, 则不拦截, 继续分发给子View 处理, 此时相当于return false。2.如果该View(ViewGroup)没有子View或者有子View但是没有点击中子View(此时ViewGroup相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。</code></pre><ul><li>消费（onTouchEvent）：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：</li></ul><pre><code>1.如果该View是clickable或者longclickable的,则会返回true, 表示消费了该事件, 与返回true一样;2.如果该View不是clickable或者longclickable的,则会返回false, 表示不消费该事件,将会向上传递,与返回false一样.</code></pre><p>注意：在Android系统中，拥有事件传递处理能力的类有以下三种。</p><ul><li>Activity：拥有分发和消费两个方法。</li><li>ViewGroup：拥有分发、拦截和消费三个方法。</li><li>View：拥有分发、消费两个方法。</li></ul><h3 id="四、Activity对点击事件的分发过程"><a href="#四、Activity对点击事件的分发过程" class="headerlink" title="四、Activity对点击事件的分发过程"></a>四、Activity对点击事件的分发过程</h3><p>我们对触摸屏进行操作时，Linux就会收到相应的硬件中断，然后将中断加工成原始的输入事件并写入相应的设备节点中。而我们的Android 输入系统所做的事情概括起来说就是监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。<br>当点击事件产生后，事件会传递给当前的Activity，由Activity中的PhoneWindow完成，PhoneWindow再把事件处理工作交给DecorView，之后再有DecorView将事件处理工作交给ViewGroup。源码流程如下所示：</p><h5 id="1-Activity-dispatchTouchEvent"><a href="#1-Activity-dispatchTouchEvent" class="headerlink" title="1.Activity#dispatchTouchEvent"></a>1.Activity#dispatchTouchEvent</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {    if (ev.getAction() == MotionEvent.ACTION_DOWN) {        onUserInteraction();    }    // 由Activity所附属的Window分发，返回true，事件循环结束    if (getWindow().superDispatchTouchEvent(ev)) {        return true;    }    // 返回false意味着事件没人处理，所有View的onTouchEvent都    // 返回了false，那么Activity的onTouchEvent就会被调用    return onTouchEvent(ev);}</code></pre><h5 id="2-抽象类Window-superDispatchTouchEvent"><a href="#2-抽象类Window-superDispatchTouchEvent" class="headerlink" title="2.抽象类Window#superDispatchTouchEvent"></a>2.抽象类Window#superDispatchTouchEvent</h5><pre><code>public abstract boolean superDispatchTouchEvent(MotionEvent event);</code></pre><h5 id="3-唯一实现类PhoneWindow-superDispatchTouchEvent"><a href="#3-唯一实现类PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3.唯一实现类PhoneWindow#superDispatchTouchEvent"></a>3.唯一实现类PhoneWindow#superDispatchTouchEvent</h5><pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {    return mDecor.superDispatchTouchEvent(event);}</code></pre><h3 id="五、View的事件分发机制"><a href="#五、View的事件分发机制" class="headerlink" title="五、View的事件分发机制"></a>五、View的事件分发机制</h3><p>事件分发到ViewGroup的dispatchTouchEvent方法，如果它的onInterceptTouchEvent返回true，则由自己处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。如果它的onInterceptTouchEvent返回false，则交给点击事件链上的子View处理，如此循环，完成分发。ViewGroup#dispatchTouchEvent关键源码如下所示：</p><h5 id="1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作"><a href="#1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作" class="headerlink" title="1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作"></a>1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作</h5><pre><code>// Handle an initial down.if (actionMasked === MotionEvent.ACTION_DOWN) {    // Throw away all previous state when starting a new touch gesture.    // The framework may have dropped the up or cancel event for the    // previous gesture due to an app switch, ANR, or some other stae change.    cancelAndClearTouchTarget(ev);    // 在此方法中会重置FLAG_DISALLOW_INTERCEPT    resetTouchState();}</code></pre><h5 id="2-处理当前View是否拦截点击事件"><a href="#2-处理当前View是否拦截点击事件" class="headerlink" title="2.处理当前View是否拦截点击事件"></a>2.处理当前View是否拦截点击事件</h5><pre><code>final boolean interception；// 当事件由ViewGorup的子元素成功处理时，mFirstTouchTarget会被赋值// 并指向子元素，反之，被ViewGroup拦截时，mFirstTouchTarget则为null。if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {    // 在子View中通过requestDisallowInterceptTouchEvent方法来设置    // FLAG_DISALLOW_INTERCEPT,此时ViewGroup将无法拦截除ACTION_DOWN以外的其他事件     final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;    if (!disallowintercept) {        intercepted = onInterceptTouchEvent(ev);        //re store action in case it was changed        ev.setAction(action);    } else {        intercepted = false;    } else {        // There are no touch targets and this action is not an initial down so this         // view group continues to intercept touches（ACTION_MOVE、ACTION_UP.eg).        intercepted = true;    }}</code></pre><h5 id="3-dispatchTouchEvent-方法剩余的部分源码"><a href="#3-dispatchTouchEvent-方法剩余的部分源码" class="headerlink" title="3.dispatchTouchEvent()方法剩余的部分源码"></a>3.dispatchTouchEvent()方法剩余的部分源码</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {    ...    final View[] children = mChildren;    // 遍历ViewGroup的子元素，如果子元素能够接受到点击事件，则交给子元素处理。    for (int i = childrenCount - 1;i &gt;= 0;i--) {        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);        if (childWithAccessibilityFocus != null) {            if (childWithAccessibilityFocus != child) {                continue;            }            childWithAccessibilityFocus = null;            i = childrenCount - 1;            }            // 判断触摸点的位置是否在子View的范围内或者子View是否在播放动画，有一项            // 不符合则开始遍历下一个子View。            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {                ev.setTargetAccessibilityFocus(false);                continue;            }            newTouchTarget == getTouchTarget(child);            if (newTouchTarget != null) {                newTouchTarget.pointerIdBits |= idBitsToAssign;                break;            }            resetCancelNextUpFlag(child);            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {                mLastTouchDownTime = ev.getDownTime();                if (preorderedList != null) {                    for (int j = 0;j &lt; childrenCOunt;j++) {                        if (children[childIndex] == mChildren[j]) {                            mLastTouchDownIndex = j;                            break;                        }                    }                } else {                    mLastTouchDownIndex = childIndex;                }                mLastTouchDownX == ev.getX();                mLastTouchDownY = ev.getY();                newTouchTarget = addTouchTarget(child, idBitsToAssign);                alreadyDispatchedToNewTouchTarget == true;                break            }            ev.setTargetAccessibilityFocus(false);        }    ...}</code></pre><h5 id="4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"><a href="#4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑" class="headerlink" title="4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"></a>4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑</h5><pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event,boolean cancel,View child,int desiredPointerIdBits) {    final int oldAction = event.getAction();    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {        event.setAction(MotionEvent.ACTION_CANCEL);        // 有子View，则调用子View的dispatchTouchEvent(event)方法，如果没有子View，        // 则调用super.dispatchTouchEvent(event)方法。        if (child == null) {            handled == super..dispatchTouchEvent(event);        } else {            handled = child.dispatchTouchEvent(event);        }        event.setAction(oldAction);        return handled;    }    ...}</code></pre><h5 id="5-事件传递到View的dispatchTouchEvent"><a href="#5-事件传递到View的dispatchTouchEvent" class="headerlink" title="5.事件传递到View的dispatchTouchEvent()"></a>5.事件传递到View的dispatchTouchEvent()</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent event) {    ...    boolean result = false;    if (onFilterTouchEventForSecurity(event)) {        ListenerInfo li = mListenerInfo;        // onTouch方法优先级要高于onTouchEvent(event)方法        if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {            result = true;        }        if (!result &amp;&amp; onTouchEvent(event)) {            result == true;        }    }    ...    return result;}</code></pre><h5 id="6-事件传递到View的onTouchEvent"><a href="#6-事件传递到View的onTouchEvent" class="headerlink" title="6.事件传递到View的onTouchEvent()"></a>6.事件传递到View的onTouchEvent()</h5><pre><code>public boolean onTouchEvent(MotionEvent event) {    ...    final int action = event.getAction();    // 只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会    // 返回true消耗这个事件。    if ((viewFlags &amp; CLICKABLE) == CLICKABLE || （viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {        switch(action) {            case MotionEvent.ACTION_UP:                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;                if ((mPrivatFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {                    boolean focusTaken = false;                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {                        removeLongPressCallback();                        if (!focusTaken) {                            if (mPerformClick == null) {                                mPerformClick = new PerformClick();                            }                            if (!post(mPerformClick)) {                                performClick();                            }                        }                    }                }                ...            }            return true;    }    return true;}</code></pre><h5 id="7-在ACTION-UP事件中会调用performCLick-方法"><a href="#7-在ACTION-UP事件中会调用performCLick-方法" class="headerlink" title="7.在ACTION_UP事件中会调用performCLick()方法"></a>7.在ACTION_UP事件中会调用performCLick()方法</h5><pre><code>public boolean performClick() {    final boolean result;    final Listenerinfo li = mListenerInfo;    // 如果View设置了点击事件，onClick方法就会执行。    if (li != null &amp;&amp; li.mOnClickListener !== null) {        playSoundEffect(SoundEffectConstants.CLICK);        li.mOnClickListener.onClick(this);        result = true;    } else {        result = false;    }    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);    return result;}</code></pre><p>由以上源码分析可得出View完整的点击事件传递流程如下图所示。</p><p><img src="https://camo.githubusercontent.com/e1e469bffad8a95732db704cc161384f8e3c7f0e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323931313033382d35333439643665626233323337326461" alt="image"></p><h3 id="六、总结：点击事件分发的传递规则"><a href="#六、总结：点击事件分发的传递规则" class="headerlink" title="六、总结：点击事件分发的传递规则"></a>六、总结：点击事件分发的传递规则</h3><p>由事件分发的源码分析可知点击事件分发的3个重要方法的关系，用伪代码表示为：</p><pre><code>public boolean diapatchTouchEvent(MotionEvent ev) {    boolean consume = false;    if (onInterceptTouchEvent(ev)) {        consume = onTouchEvent(ev);    } else {        consume = child.dispatchTouchEvent(ev);    }    return consume;}</code></pre><p>一些重要的结论：</p><p>1.事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。</p><p>2.正常情况下，一个时间序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。特例：通过将重写View的onTouchEvent返回false可强行将事件转交给其他View处理。</p><p>3.如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</p><p>4.ViewGroup默认不拦截任何事件（返回false）。</p><p>5.View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。</p><p>6.View的enable属性不影响onTouchEvent的默认返回值。</p><p>7.通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p><p>最终完整的事件分发流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png" alt="image"></p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android开发艺术探索</p><p>2、Android进阶之光</p><p>3、Android高级进阶</p><p>4、<a href="http://gityuan.com/2015/09/19/android-touch/" target="_blank" rel="external">Gityuan Android事件分发机制</a></p><p>5、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492294&amp;idx=1&amp;sn=1645fa7730dbb1c627bd374e917cd557&amp;chksm=8eec80b9b99b09af1938836b2f19afc60b46c284050b9f17ceb5018867cd86df1c6a40fe56eb&amp;scene=38#wechat_redirect" target="_blank" rel="external">通俗理解Android的事件分发机制</a></p><p>6、<a href="http://www.jianshu.com/p/38015afcdb58" target="_blank" rel="external">Android事件分发机制详解：史上最全面、最易懂</a></p><p>7、<a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247486486&amp;idx=1&amp;sn=7acc1c9dd8c600ad0ec2db7d32f82f1f&amp;chksm=97f6b2a2a0813bb425cf8bf329bf0e856d3769ac8e21ed5a9a6cb7c57b1097c41f94afe4202d&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android开发之漫漫长途 Ⅵ——图解Android事件分发机制（深入底层源码）</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Python入门篇</title>
      <link>http://yoursite.com/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/</link>
      <guid>http://yoursite.com/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/</guid>
      <pubDate>Thu, 26 Jul 2018 14:46:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>随着人工智能和AI行业的兴起，Python已经成为程序员不得不学的一门编程语言了，本系列文章主要是涉及使用Python入门方面的知识。</p><h3 id="初识Python"><a href="#初识Python" class="headerlink" title="初识Python"></a>初识Python</h3><pre><code>what：python是什么？    它是一门跨平台的高级编程语言，相对其它高级语言（如：C、Java）    来说，它封装的功能更完善，能用更少的代码实现同样的功能。    python的作用？    Python的用处很多，它主要使用的领域有：    1.前后端开发    2.工具脚本开发    3.爬虫    4.人工智能    优点：简洁、易懂、用更少的代码实现功能模块。    缺点：    1.程序运行速度很慢，因为python是解释性语言，计算机每执行一行    python代码就会把它翻译成自身能识别的机器码，而其它语言，如    C语言，则会在运行前就会被编译成计算机能识别的机器码。    2.python不能够加密，发布就是将源码发布出去，这正是解释性语言    的缺陷，而编译型语言则不会，如C语言，它是将编译后得到的二进制    码发布出去。why：为什么要使用python？    因为它的优点——简洁、易懂、能用更少的代码实现功能模块，特别适合做一些脚本工具。how：如何使用它？    请往下看。。。</code></pre><h4 id="安装Python开发工具（Windows系统）"><a href="#安装Python开发工具（Windows系统）" class="headerlink" title="安装Python开发工具（Windows系统）"></a>安装Python开发工具（Windows系统）</h4><pre><code>python有两个版本（2.x，3.x），只演示新版本的安装。打开python网站，选择安装Install-&gt;windows-&gt;最新relese 64bit即可，可选框全选即可。官网安装的python环境用的是CPython解释器（包含python代码的文档称为.py,解释器就是用来执行python代码的）。解释器有很多种，CPython是主流。</code></pre><h4 id="先用起来？"><a href="#先用起来？" class="headerlink" title="先用起来？"></a>先用起来？</h4><pre><code>启动方式？1.打开命令行模式，输入python进入python交互模式。输入exit()回到命令行模式。2.直接点击python终端，进入python交互模式。输入exit()退出命令行模式。注意：python交互模式的代码是输入一行，输出一行，它只适合初学者用来调试代码时使用，正常开发都是编写*.py文件，使用python *.py运行*.py文件，这样就会一次性执行python源代码。（文件名只能是英文字母、数字、下划线的组合）。</code></pre><h5 id="输入和输出"><a href="#输入和输出" class="headerlink" title="输入和输出"></a>输入和输出</h5><pre><code>输出：使用print()，可以“”，‘’的形式输出单个字符串，也可输出多个字符串如print(&quot;hello&quot;,&quot;I&quot;,&quot;am&quot;,&quot;jsonchao&quot;),输出时，号相当于一个空格。输入：使用input()，括号内可以写入输入的提示信息，如：name = print(&quot;please enter your name:&quot;)print(&quot;hello&quot;, name)其中name为字符串变量。</code></pre><h4 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h4><pre><code>python、C、JAVA都是高级语言，它们不同于自然语言，它们需要通过解释器或编译期将符合自身语法规则的语言转换为计算机能够执行的机器码。约定俗成的规则：1.#后面为注释；2.语句后面加：号结尾时，缩进的语句变为代码块；缩进一般为4个空格=tab键；3.不同于java，复制粘贴时，缩进的格式可能复制不过来，需要重起缩进格式；4.python程序是大小写敏感的。</code></pre><h5 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h5><pre><code>1.r&quot;&quot;表示字符串里面的内容默认不转义。2.&apos;&apos;&apos;hello    I am    jsonchao&apos;&apos;&apos;为避免加入多个\n的写法。3.布尔值：True、False首字母为大写，and、or、not为运算符。4.None为python中一个特殊的空值。5.变量a = 10    a = &quot;10&quot;，说明python是一门变量可以动态赋值为不同类型的语言，    称为动态语言，而java的变量，则一开始则指定了类型，如：    int a = 10；所以java是一门静态语言。6.用大写字母规范地表示常量，虽然它的值还是可以动态改变。。。7.除法：/，//（地板除，值取整）得到的都是浮点数结果，%（取余，结果为整数）。8.python的整数没有大小限制，浮点数没有大小限制，但是超过一定值会表示为inf（无限大）。</code></pre><h5 id="字符编码和字符串"><a href="#字符编码和字符串" class="headerlink" title="字符编码和字符串"></a>字符编码和字符串</h5><pre><code>字符编码：最初的ASCLL编码为1个字节表示一个字符，由于不同国家有不同的编码，为了解决文本显示不同语言乱码的问题，国际统一了Unicode编码，一般为2个字节表示一个字符（生僻的中文为4个字节表示一个字符），为了节省Unicode在保存数据和传输数据时字符占用过多字节的问题，后面在储存和传输时会将Unicode转换为UTF-8编码，文本显示时又会转变回Unicode编码。最常用的编码为utf-8。Python的字符串：在最新的Python3中，字符是Unicode编码的，因此，它能适配多语言。1.ord()获取字符的整数表示，chr()获取整数对应的字符。2.如果需要将字符串在进行网络传输或者存储到磁盘，就必须将其转换成bytes（字节）。3.b&apos;&apos;或b&quot;&quot;表示里面的为字节，使用encode()将字符串编码为字节，decode()将字节编码为字符串，括号内为指定的编译码格式，\x后面指定为不能被ASCLL识别的字符。b&apos;23\x3d3j&apos;.decode(&apos;utf-8&apos;,errors=&apos;ignore&apos;),以此格式指定忽略错误。4.len()表示计算出字符串的长度。5.使用%d、%s、%f、%x来格式化字符串，形式为：&quot;emm..., is %s.&quot; % (jsonchao)&quot;emm...，$%d，is %s.&quot; % (10000000， jsonchao)还可以使用%0d表示0x，%.2f表示3.14这样的形式。用%%表示%字符串。还有另一种格式化字符串的方式，使用.format()，如：&apos;haha,i&apos;m {0} year\’s old, {1:.1f}%percent power&apos;.format(24, 30.555)注意，30.5会四舍五入为30.6。6.&apos;haha&apos;.replace(&apos;h&apos;, &apos;d&apos;)替换指定字符。</code></pre><h5 id="List和Tuple"><a href="#List和Tuple" class="headerlink" title="List和Tuple"></a>List和Tuple</h5><pre><code>List：MyList = [10,&apos;haha&apos;，[20, &apos;lala&apos;]]，可存储不同类型数据，元素还可以是List。MyList[-1], MyList[-2]表示取出倒数第一，二个值。MyList.append(20)，结尾添加值。MyList.insert(1, ‘haha’)，下标为1处添加值。MyList.pop()，弹出最后一个值。MyList.pop(0)，弹出第一个值。MyList[2][1],二维取值。MyList.sort()从小到大进行排序。Tuple:是不可变的，定义为：MyTuple = (20, &apos;haha&apos;)当Tuple中只表示一个元素时，必须使用MyTuple = (20,)来消除来Python以为是括号()+值的歧义。记住不变，是指Tuple的每一个元素的指向不变，并不是指向的元素内容不变。（相当于Java中指向元素的地址，C语言的指针）为什么需要元组？1.旧式字符串格式化中参数要用元组；2.在字典中当作键值；3.数据库的返回值……区别：即为可变与不可变。</code></pre><h5 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h5><pre><code>if:后面会执行接下来缩进的两行代码。1.elif为else if的缩写。2.if还有如下写法：if 20:    print(&apos;nice&apos;)只要if后的内容是非0，非空List，一切非空内容即为Ture。elif 20 &lt;= bmi &lt; 25不同于java，java为bmi &gt;= 20 &amp;&amp;bmi &lt; 25。**为java平方符合^。</code></pre><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><pre><code>names = [&apos;tianshen&apos;, &apos;jsonchao&apos;, &apos;zhanshen&apos;]for x in names：    print(&quot;Hello, &quot; + x + &quot;!&quot;)whilebreakcontinuebreak和continue尽量少用，易造成程序逻辑混乱。</code></pre><h5 id="dict和set"><a href="#dict和set" class="headerlink" title="dict和set"></a>dict和set</h5><pre><code>dict称为字典，编写形式如下：d = {&apos;hello&apos; : 1, &apos;haha&apos; : 2, &apos;emem&apos; : 3}判断是否有对应的key：&apos;hello&apos; in d,有则True，无则False。d.get(&apos;hello&apos;)获取key对应的值。没有则返回none，python交互命令环境下不显示结果。d.pop(key)删除指定key和对应的值。dict和List的区别：dict的查找和插入速度极快，不会随着元素的增多而变慢。dict占用的内存较多。空间换时间。记住,dict中的key必须是不可变元素。key + Hash算法计算出值的内存地址。  s = set([1,2,3,3,4])s{1,2,3,4}set：创建一个set，需要传入一个List进入。add(key)remove(key)set相当于一个无序和不重复元素的集合。可以使用&amp;和|来进行交并集计算。注意：创建空集合的时候只能用set来创建，因为在Python中{}创建的是一个空的字典：s = {}type(s)dict区别：唯一区别是set没有存储对应的value整数的内存地址是不可变的    对一些简单的数值，为了提高效率，python会重用对象内存：x = 2y = 2x is yTruepython的一些数据值被视为False的有：False0None空字符串、空列表、空集合、空字典</code></pre><h4 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h4><pre><code>对应于元组（tuple）与列表（list）的关系，对于集合（set），Python提供了一种叫做不可变集合（frozen set）的数据结构。使用 frozenset 来进行创建：s = frozenset([1, 2, 3, &apos;a&apos;, 1])sfrozenset({1, 2, 3, &apos;a&apos;})与集合不同的是，不可变集合一旦创建就不可以改变。不可变集合的一个主要应用是用来作为字典的键。</code></pre><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><pre><code>Python中的函数类似于数学中的函数。</code></pre><h5 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h5><p><a href="http://docs.python.org/3/library/functions.html#abs" target="_blank" rel="external">Python中内置的函数</a></p><pre><code>例如：计算类函数：abs(x)，max(...)。数据类型转换函数：int()，str(), bool(), float()。函数名复制给变量，该变量指向了该函数的地址。因而，具有函数的功能。a = absa(-10)输出10。</code></pre><h5 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h5><pre><code>def myAbs(x)：    if x &gt;= 0：        return x    else：         return -x以def为前缀 + 函数名 + (参数...), return返回函数返回值，没有return则返回None， return = return None。空函数：使用pass构造空函数def test:    pass也可以：if a &gt; 0:    pass</code></pre><h5 id="参数类型检查"><a href="#参数类型检查" class="headerlink" title="参数类型检查"></a>参数类型检查</h5><pre><code>使用isinstance检测参数类型：def myAbs(x):    if not isinstance (x, (int, float)):        raise TypeError(&quot;bad opread error&quot;)    if x &gt;= 0:        return x    else:        return -x</code></pre><h5 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h5><pre><code>当一个函数返回值有多个时，返回的是一个tuple，如(20, 30)。</code></pre><h5 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h5><pre><code>位置参数：test(x)、test(x, y)x、y的参数定义即为位置参数。默认参数：def test(x , age = 3, city = &apos;shenzhen&apos;)，其中age和city为默认参数。1.传入test(0)即为传入test(0, 3, &apos;shenzhen&apos;)。2.传入test(0, 25)即为传入test(0, 25, &apos;shenzhen&apos;)。3.传入test(0, city = &apos;guangzhou&apos;)即为传入&apos;guangzhou&apos;，注意，当参数位置不对应时，需要指明参数类型，即city。4.默认参数必须指向不变对象，使用test(city = none)替代test(city = [])，写入if(city = none):    city = []即可。额外的：为什么要设计str、none这样的不可变对象?可以避免在多线程中对象改变而造成的的错误，因此，尽量用不可变对象替代可变对象。可变参数：def test(*nums)1.可变参数在函数调用时自动组装成一个Tuple。2.nums可以是0个或多个数据。3.nums可以是一个List或者Tuple，此时*nums表示将List或者Tuple中的元素转化成可变参数传递进去。（内容拷贝）关键字参数：def test(**nums)1.关键字参数在函数调用时自动组装成一个dict。2.nums可以是0个或多个数据。3.nums可以是一个dict，此时**nums表示将dict中的元素转化为关键字参数传递进去。（内容拷贝）命名关键字参数：def test(a, *, b, c)，*，后面的为命名关键字参数。1.当函数中存在可变参数*x时，*x的作用等效于*，即此时，b、c也为命名关键字参数。2.调用含有关键字参数的函数时，应该使用key = value的形式，如本例：test(a, b = 1, c = &apos;haha&apos;)。3.当函数中指定了缺省值时，如def test(a, *x, b = 1, c)，此时，使用函数时可不填b参数。参数组合：5种参数的组合顺序为：位置参数、默认参数、可变参数、命名关键字参数、关键字参数。任意参数组合的函数都能给函数传入function(*x, **y)的组合传值形式。注意：参数组合过多会影响语义，尽量避免使用多参数组合。使用*args和**kw是习惯写法，建议遵循。</code></pre><h5 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h5><pre><code>1.优点：逻辑简单清晰，缺点：调用过深会导致栈溢出。2.可使用尾递归(返回自身本身)优化的方式避免栈溢出。3.大多数编程语言(包括Python)的编译器或解释器都没有针对尾递归进行优化。</code></pre><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><pre><code>代码越少，效率越高。</code></pre><h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><pre><code>nums = list(range(100))切片：nums[0:2] == nums[:2]表示取下标为0到2(不包括2)的数据。倒数切片：nums[-2:0] == nums[-2:]表示取下标为-2到0(不包括0)的数据。nums[:10:2]前10个数，每2个取一个。nums[::5]所有数，每5个取一个。nums[::-1]取倒数。nums[:]输出该list。注意：nums指向的数据类型是什么，nums[...]取出来的数据类型就是什么。</code></pre><h5 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h5><pre><code>for i in nums不管是否有下标，只要能迭代，就能使用迭代器。对于dict，迭代的是key，迭代value：for i in nums.values()迭代key、value for i in nums.items()1.通过collections的Iterable来判读是否能迭代：from collections import Iterableisinstance(&apos;abcd&apos;, Iterable)2.使用内置的enumerate将list变成索引-元素对：for i, j in enumerate([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]):    print(i, j)</code></pre><h5 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h5><pre><code>[i * i for i in range(1, 10)][i * i for i in range(1, 10) if i % 2 == 0][i * j for i in range(1, 10) for j in range(1, 10)][i * j for i in range(1, 10) if i % 2 == 0 for j in range(1, 10) if j % 2 == 0]注意：&apos;a&apos; + 1，不同于java，python计算会出错。此外，列表生成式还可以生成集合和字典：{i ** 2 for i in range(1, 10)}{i : i ** 2 for i in range(1, 10)}可以使用sum()得到生成式的和：total = sum([i ** 2 for i in range(1, 10)])但是这样python为它生成了一个列表，并且由于没有变量指向它，它会被放在垃圾回收器中，因此，此时使用产生式列表替代它：total = sum(i ** 2 for i in range(1, 10))</code></pre><h6 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h6><pre><code>g = (x * x for x in range(10))for i in g一边循环，一边计算的机制称为生成器。获取返回值，必须捕获StopIterable异常。返回值就在包含在StopIterable的value中。except StopIterable as e：    print(e.value)    break普通函数和generate函数的区别普通函数调用直接返回结果，generate函数调用返回generate对象。def fib(max):n, a, b = 0, 0, 1while n &lt; max:    yield b    a, b = b, a + b    n = n + 1return &apos;done&apos;函数中使用yield关键字，每次调用next()时，遇到yield语句就返回，再次执行next()时，又继续从上次的位置往下执行。</code></pre><h5 id="迭代器对象"><a href="#迭代器对象" class="headerlink" title="迭代器对象"></a>迭代器对象</h5><pre><code>直接作用于for循环的数据类型有以下几种：1.集合类型：list、tuple、dict、set、str等等。2.generate类型：generate对象和generate函数。这些可直接作用于for循环的对象称为Iterable对象。1.可直接作用于next()函数的数据类型称为Iterator对象。所有的生成器都是Iterator，而list、dict、str则不是。why：Iterator至少需满足2个条件：    1.长度不能够被提前知道。    2.可以表示无限大的数据。2.可通过iter()函数来获得一个Iterator对象。3.python的for循环的本质就是不断调用next()函数来实现的。</code></pre><h3 id="函数式编程语言"><a href="#函数式编程语言" class="headerlink" title="函数式编程语言"></a>函数式编程语言</h3><pre><code>抽象程度很高的编程范式。只要输入确定，输出就确定，就是纯函数式编程语言。否则，则不是(当有变量存在函数中)。特点：允许将函数作为参数传入另一个函数，也可以返回一个函数。</code></pre><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><h5 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h5><pre><code>x = absx(-10)10说明变量指向函数</code></pre><h5 id="函数名指向变量"><a href="#函数名指向变量" class="headerlink" title="函数名指向变量"></a>函数名指向变量</h5><pre><code>abs是函数名，同时它也是一个变量，它指向一个计算绝对值的函数。</code></pre><h5 id="传入函数"><a href="#传入函数" class="headerlink" title="传入函数"></a>传入函数</h5><pre><code>既然变量可以作为参数传入到函数中，那么因为函数名指向变量得缘故，所以函数中可以传入函数，传入函数作为变量的函数称为高阶函数。</code></pre><h5 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h5><pre><code>def f(x):    return x * xy = map(f, [1, 3, 5])list(y)[1, 9, 25]map函数传入2个参数，第一个参数是函数，第二个是Iterable对象，map将传入的结果依次作用到Iterable对象的每一个元素，最后返回一个Iterator(map)对象。此外，map函数还可以作用于多个参数：def f(x, y):    return x * yy = map(f, [2, 3], (2, 4))from functools import reducedef f(x, y):    return x + yreduce(f, [1, 2, 3, 4]) == f(f(f(1, 2), 3), 4)reduce函数传入2个参数，第一个参数是函数，第二个是Iterable对象，reduce将每次取2个元素使用函数计算，得出的结果继续和下个元素传入函数做计算，依次类推。</code></pre><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><pre><code>def is_odd(x):    return x % 2 == 1list(filter(is_odd, [1, 2, 3, 4]))[1, 3]过滤序列，同map/reduce一样，传入2个参数，第一个参数是函数，第二个是Iterable对象，对Iterable对象的每一个元素作用函数，返回True则保留，否则不保留。</code></pre><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><pre><code>sorted([&apos;Hello&apos;, &apos;JsonChao&apos;, &apos;quchao&apos;], key = str.lower, reverse = True)对字符串排序是按首字母的ASCLL码对应的值大小来进行。key给要排序的元素作用同一个函数，reverse = True为反转排序结果。用sorted排序的关键在于实现一个映射函数。</code></pre><h4 id="返回函数"><a href="#返回函数" class="headerlink" title="返回函数"></a>返回函数</h4><h5 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h5><pre><code>def sum(*nums):    def add():        ax = 0        for n in nums:            ax = ax + i        return ax    return add其中，add是返回函数，输出add为函数本身，add()为函数返回值。注意：x1 = sum(1, 3, 5)    x2 = sum(1, 3, 5)    x1 == x2    输出False。</code></pre><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><pre><code>注意：返回闭包时应牢记不要引用循环变量和后面会发生改变的变量。如要使用，在内部再创建一个函数，用该函数的参数绑定循环变量的值。</code></pre><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><pre><code>使用lambda实现匿名内部类，形如：: 前面的为参数，lambda x, y : x * y无参则为lambda: x * x</code></pre><h4 id="模块和包"><a href="#模块和包" class="headerlink" title="模块和包"></a>模块和包</h4><h5 id="name属性"><a href="#name属性" class="headerlink" title="name属性"></a><strong>name</strong>属性</h5><pre><code>当我们想让当前.py文件既可以当成一个模块，又可以当成作为一个脚本使用时，可以写成如下：test()是该脚本中的方法。只有.py被当做脚本执行时，__name__的值才会是__main__。if __name__ == ‘__main__’:    test()</code></pre><h5 id="导入模块或模块中的变量"><a href="#导入模块或模块中的变量" class="headerlink" title="导入模块或模块中的变量"></a>导入模块或模块中的变量</h5><pre><code>import os 导入模块from ex2 import PI导入ex2模块中的变量PIfrom ex2 import *导入所有变量</code></pre><h5 id="包"><a href="#包" class="headerlink" title="包"></a>包</h5><pre><code>__init__文件存在文件夹中则表明这是一个包。</code></pre><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><pre><code>try:    ...catch ValueError as exc：    exc.message捕捉单个异常try:    ...catch (ValueError, ZeroDivisionError):    ...try:    ...catch ValueError:    ...catch ZeroDivisionError：    ...捕捉多个异常try:    ...catch Expection：    ...捕捉所有异常raise ValueError(&quot;Value error&quot;)使用raise来抛出异常try:    ... ##有异常的代码块finally:    ...finally会在try后执行，抛出异常前执行。try:    ...catch Expection:    ...finally:    ...如果异常被捕获了，finally则会最后执行。</code></pre><h4 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h4><pre><code>使用 warnings.warn(msg, RuntimeWarning)抛出警告，在调用抛出警告的方法前加上warnings.filterwarnings(action = &apos;ignore&apos;, category = RuntimeWarning)可过滤指定的警告。</code></pre><h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><pre><code>%%writefile test.txt...写入文件f = open(&quot;test.txt&quot;)f = file(&quot;test.txt&quot;)打开文件f.read()读入文件夹中的所有内容。f.readLines()行读入文件，返回一个列表，格式为:[..../n..../n...]f.close()文件读写完毕，关闭文件。f = open(&apos;test.txt&apos;, &apos;w&apos;)f.write(&apos;hello, python, I come in~&apos;)f.close()print open(&apos;test.txt&apos;).read()使用open函数的写入模式来写文件,如果文件不存在，则创建该文件写入，如果之前已经存在该文件，则会把之前写入的内容覆盖。将&apos;w&apos;改为&apos;a&apos;，即使用追加模式加入新的内容到文件中。将&apos;w&apos;改为&apos;w+&apos;即可使用读写模式，使用f.read()即可读出文件内容。注意：二进制文件的写入，读取格式为&apos;wb&apos;,&apos;rb&apos;。</code></pre><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/07/26/%20Python%E5%85%A5%E9%97%A8%E7%AF%87/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一文全面了解Android单元测试</title>
      <link>http://yoursite.com/2018/07/09/%E4%B8%80%E6%96%87%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link>
      <guid>http://yoursite.com/2018/07/09/%E4%B8%80%E6%96%87%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid>
      <pubDate>Mon, 09 Jul 2018 15:06:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p><a href="https://github.com/JsonChao/Awesome-WanAndroid/tree/master/app/src/test/java/json/chao/com/wanandroid" target="_blank" rel="external">==》完整项目单元测试学习案例</a></p><p>众所周知，一个好的项目需要不断地打造，而一些有效的测试则是加速这一过程的利器。本篇博文将带你了解并逐步深入Android单元测试。</p><h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><hr><p>单元测试就是针对类中的某一个方法进行验证是否正确的过程，单元就是指<strong>独立的粒子</strong>，在Android和Java中大都是指方法。</p><h3 id="为什么要进行单元测试？"><a href="#为什么要进行单元测试？" class="headerlink" title="为什么要进行单元测试？"></a>为什么要进行单元测试？</h3><hr><p>使用单元测试可以提高开发效率，当项目随着迭代越来越大时，每一次编译、运行、打包、调试需要耗费的时间会随之上升，因此，使用单元测试可以不需这一步骤就可以对单个方法进行功能或逻辑测试。<br>同时，为了能测试每一个细分功能模块，需要将其相关代码抽成相应的方法封装起来，这也在一定程度上改善了代码的设计。因为是单个方法的测试，所以能更快地定位到bug。</p><p>单元测试case需要对这段业务逻辑进行验证。在验证的过程中，开发人员可以<strong>深度了解业务流程</strong>，同时新人来了看一下项目单元测试就知道<strong>哪个逻辑跑了多少函数，需要注意哪些边界</strong>——是的，单元测试做的好和文档一样<strong>具备业务指导能力。</strong></p><h3 id="Android测试的分类"><a href="#Android测试的分类" class="headerlink" title="Android测试的分类"></a>Android测试的分类</h3><hr><p>Android测试主要分为三个方面：</p><pre><code>单元测试（Junit4、Mockito、PowerMockito、Robolectric）UI测试（Espresso、UI Automator）压力测试（Monkey）</code></pre><h3 id="一、单元测试之基础Junit4"><a href="#一、单元测试之基础Junit4" class="headerlink" title="一、单元测试之基础Junit4"></a>一、单元测试之基础Junit4</h3><hr><h4 id="什么是Junit4？"><a href="#什么是Junit4？" class="headerlink" title="什么是Junit4？"></a>什么是Junit4？</h4><hr><p>Junit4是事实上的Java标准测试库，并且它是JUnit框架有史以来的最大改进，其主要目标便是利用Java5的Annotation特性简化测试用例的编写。</p><h4 id="开始使用Junit4进行单元测试"><a href="#开始使用Junit4进行单元测试" class="headerlink" title="开始使用Junit4进行单元测试"></a>开始使用Junit4进行单元测试</h4><hr><h5 id="1-Android-Studio已经自动集成了Junit4测试框架，如下"><a href="#1-Android-Studio已经自动集成了Junit4测试框架，如下" class="headerlink" title="1.Android Studio已经自动集成了Junit4测试框架，如下"></a>1.Android Studio已经自动集成了Junit4测试框架，如下</h5><pre><code>dependencies {    ...    testImplementation &apos;junit:junit:4.12&apos;}</code></pre><h5 id="2-Junit4框架使用时涉及到的重要注解如下"><a href="#2-Junit4框架使用时涉及到的重要注解如下" class="headerlink" title="2.Junit4框架使用时涉及到的重要注解如下"></a>2.Junit4框架使用时涉及到的重要注解如下</h5><pre><code>@Test 指明这是一个测试方法 (@Test注解可以接受2个参数，一个是预期错误expected，一个是超时时间timeout，格式如 @Test(expected = IndexOutOfBoundsException.class), @Test（timeout = 1000)@Before 在所有测试方法之前执行@After 在所有测试方法之后执行@BeforeClass 在该类的所有测试方法和@Before方法之前执行 （修饰的方法必须是静态的）@AfterClass 在该类的所有测试方法和@After方法之后执行（修饰的方法必须是静态的）@Ignore 忽略此单元测试</code></pre><p>此外，很多时候，因为某些原因（比如正式代码还没有实现等），我们可能想让JUnit忽略某些方法，让它在跑所有测试方法的时候不要跑这个测试方法。要达到这个目的也很简单，只需要在要被忽略的<strong>测试方法前面加上@Ignore</strong>就可以了</p><h5 id="3-主要的测试方法——断言"><a href="#3-主要的测试方法——断言" class="headerlink" title="3.主要的测试方法——断言"></a>3.主要的测试方法——断言</h5><pre><code>assertEquals(expected, actual) 判断2个值是否相等，相等则测试通过。assertEquals(expected, actual, tolerance) tolerance 偏差值</code></pre><p>注意：上面的每一个方法，都有一个重载的方法，可以加一个String类型的参数，表示如果验证失败的话，将<strong>用这个字符串作为失败的结果报告</strong>。</p><h5 id="4-自定义Junit-Rule——实现TestRule接口并重写apply方法"><a href="#4-自定义Junit-Rule——实现TestRule接口并重写apply方法" class="headerlink" title="4.自定义Junit Rule——实现TestRule接口并重写apply方法"></a>4.自定义Junit Rule——实现TestRule接口并重写apply方法</h5><pre><code>public class JsonChaoRule implements TestRule {    @Override    public Statement apply(final Statement base, final Description description) {        Statement repeatStatement =  new Statement() {            @Override            public void evaluate() throws Throwable {                    //测试前的初始化工作                    //执行测试方法                    base.evaluate();                    //测试后的释放资源等工作            }        };        return repeatStatement;    }}</code></pre><p>然后在想要的测试类中使用@Rule注解声明使用JsonChaoRule即可（注意<strong>被@Rule注解的变量必须是final的</strong>）：</p><pre><code>@Rulepublic final JsonChaoRule repeatRule = new JsonChaoRule();</code></pre><h5 id="5-开始上手，使用Junit4进行单元测试"><a href="#5-开始上手，使用Junit4进行单元测试" class="headerlink" title="5.开始上手，使用Junit4进行单元测试"></a>5.开始上手，使用Junit4进行单元测试</h5><pre><code>1.编写测试类。2.鼠标右键点击测试类，选择选择Go To-&gt;Test（或者使用快捷键Ctrl+Shift+T，此快捷键可以在方法和测试方法之间来回切换）在Test/java/项目测试文件夹/下自动生成测试模板。3.使用断言（assertEqual、assertEqualArrayEquals等等)进行单元测试。4.右键点击测试类，Run编写好的测试类。</code></pre><h5 id="6-使用Android-Studio自带的Gradle脚本自动化单元测试"><a href="#6-使用Android-Studio自带的Gradle脚本自动化单元测试" class="headerlink" title="6.使用Android Studio自带的Gradle脚本自动化单元测试"></a>6.使用Android Studio自带的Gradle脚本自动化单元测试</h5><p>点击Android Studio中的<strong>Gradle projects</strong>下的<strong>app/Tasks/verification/test</strong>即可同时测试module下所有的测试类（案例），并在<strong>module下的build/reports/tests/下</strong>生成对应的<strong>index.html测试报告</strong>。</p><h5 id="7-对Junit4的总结："><a href="#7-对Junit4的总结：" class="headerlink" title="7.对Junit4的总结："></a>7.对Junit4的总结：</h5><pre><code>优点：速度快，支持代码覆盖率等代码质量的检测工具，缺点：无法单独对Android UI，一些类进行操作，与原生JAVA有一些差异。</code></pre><p>可能涉及到的额外的概念：</p><p>打桩方法：使方法简单快速地返回一个有效的结果。</p><p>测试驱动开发：编写测试，实现功能使测试通过，然后不断地使用这种方式实现功能的快速迭代开发。</p><h3 id="二、单元测试之基础Mockito"><a href="#二、单元测试之基础Mockito" class="headerlink" title="二、单元测试之基础Mockito"></a>二、单元测试之基础Mockito</h3><hr><h4 id="什么是Mockito？"><a href="#什么是Mockito？" class="headerlink" title="什么是Mockito？"></a>什么是Mockito？</h4><p>Mockito 是美味的 Java 单元测试 Mock 框架，mock可以模拟各种各样的对象，从而代替真正的对象做出希望的响应。</p><h4 id="开始使用Mockito进行单元测试"><a href="#开始使用Mockito进行单元测试" class="headerlink" title="开始使用Mockito进行单元测试"></a>开始使用Mockito进行单元测试</h4><h5 id="1-在build-gradle里面添加Mcokito的依赖"><a href="#1-在build-gradle里面添加Mcokito的依赖" class="headerlink" title="1.在build.gradle里面添加Mcokito的依赖"></a>1.在build.gradle里面添加Mcokito的依赖</h5><pre><code>testImplementation &apos;org.mockito:mockito-core:2.7.1&apos;</code></pre><h5 id="2-使用mock-方法模拟对象"><a href="#2-使用mock-方法模拟对象" class="headerlink" title="2.使用mock()方法模拟对象"></a>2.使用mock()方法模拟对象</h5><pre><code>Person mPerson = mock(Person.class); </code></pre><h5 id="能量补充站（-vov-）"><a href="#能量补充站（-vov-）" class="headerlink" title="能量补充站（-vov-）"></a>能量补充站（-vov-）</h5><p>在JUnit框架下，case（带@Test注解的那个函数）也是个函数，直接调用这个函数就不是case，和case是无关的，两者并不会相互影响，可以直接调用以减少重复代码。<strong>单元测试不应该对某一个条件过度耦合</strong>，因此，需要用mock解除耦合，<strong>直接mock出网络请求得到的数据，单独验证页面对数据的响应。</strong></p><h5 id="3-验证方法的调用，指定方法的返回值，或者执行特定的动作"><a href="#3-验证方法的调用，指定方法的返回值，或者执行特定的动作" class="headerlink" title="3.验证方法的调用，指定方法的返回值，或者执行特定的动作"></a>3.验证方法的调用，指定方法的返回值，或者执行特定的动作</h5><pre><code>when(iMathUtils.sum(1, 1)).thenReturn(2); doReturn(3).when(iMathUtils).sum(1,1);   //给方法设置桩可以设置多次，只会返回最后一次设置的值doReturn(2).when(iMathUtils).sum(1,1);//验证方法调用次数//方法调用1次Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)).thenReturn(true);//方法调用3次Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)， Mockito.times(3).thenReturn(true);//verify方法用于验证“模仿对象”的互动或验证发生的某些行为verify(mPerson, atLeast(2)).getAge();//参数匹配器,用于匹配特定的参数any()contains()argThat()when(mPerson.eat(any(String.class))).thenReturn(&quot;米饭&quot;);//除了mock()外，spy()也可以模拟对象，spy与mock的//唯一区别就是默认行为不一样：spy对象的方法默认调用//真实的逻辑，mock对象的方法默认什么都不做，或直接//返回默认值//如果要保留原来对象的功能，而仅仅修改一个或几个//方法的返回值，可以采用spy方法,无参构造的类初始//化也使用spy方法Person mPerson = spy(Person.class); //检查入参的mocks是否有任何未经验证的交互verifyNoMoreInteractions(iMathUtils);</code></pre><h5 id="4-使用Mockito后的思考"><a href="#4-使用Mockito后的思考" class="headerlink" title="4.使用Mockito后的思考"></a>4.使用Mockito后的思考</h5><p>简单的测试会使整体的代码更简单，更可读、更可维护。如果你<strong>不能把测试写的很简单，那么请在测试时重构你的代码</strong>。    </p><pre><code>优点：丰富强大的方式验证“模仿对象”的互动或验证发生的某些行为缺点：Mockito框架不支持mock匿名类、final类、static方法、private方法。</code></pre><p>虽然，static方法可以使用wrapper静态类的方式实现mockito的单元测试，但是，毕竟过于繁琐，因此，PowerMockito由此而来。</p><h3 id="三、拯救Mockito于水深火热的PowerMockito"><a href="#三、拯救Mockito于水深火热的PowerMockito" class="headerlink" title="三、拯救Mockito于水深火热的PowerMockito"></a>三、拯救Mockito于水深火热的PowerMockito</h3><hr><h4 id="什么是PowerMockito？"><a href="#什么是PowerMockito？" class="headerlink" title="什么是PowerMockito？"></a>什么是PowerMockito？</h4><hr><p>PowerMockito是一个扩展了Mockito的具有更强大功能的单元测试框架，它支持mock匿名类、final类、static方法、private方法</p><h4 id="开始PowerMockito之旅"><a href="#开始PowerMockito之旅" class="headerlink" title="开始PowerMockito之旅"></a>开始PowerMockito之旅</h4><hr><h5 id="1-在build-gradle里面添加Mcokito的依赖-1"><a href="#1-在build-gradle里面添加Mcokito的依赖-1" class="headerlink" title="1.在build.gradle里面添加Mcokito的依赖"></a>1.在build.gradle里面添加Mcokito的依赖</h5><pre><code>testImplementation &apos;org.powermock:powermock-module-junit4:1.6.5&apos;testImplementation &apos;org.powermock:powermock-api-mockito:1.6.5&apos;</code></pre><h5 id="2-用PowerMockito来模拟对象"><a href="#2-用PowerMockito来模拟对象" class="headerlink" title="2.用PowerMockito来模拟对象"></a>2.用PowerMockito来模拟对象</h5><pre><code>//使用PowerMock须加注解@PrepareForTest和@RunWith(PowerMockRunner.class)（@PrepareForTest()里写的是对应方法所在的类    ，mockito支持的方法使用PowerMock的形式实现时，可以不加这两个注解）@PrepareForTest(T.class)@RunWith(PowerMockRunner.class)//mock含静态方法或字段的类    PowerMockito.mockStatic(Banana.class);//Powermock提供了一个Whitebox的class，可以方便的绕开权限限制，可以get/set private属性，实现注入。也可以调用private方法。也可以处理static的//属性/方法，根据不同需求选择不同参数的方法即可。//修改类里面静态字段的值Whitebox.setInternalState(Banana.class, &quot;COLOR&quot;, &quot;蓝色&quot;);//调用类中的真实方法PowerMockito.when(banana.getBananaInfo()).thenCallRealMethod();//验证私有方法是否被调用PowerMockito.verifyPrivate(banana, times(1)).invoke(&quot;flavor&quot;);//忽略调用私有方法PowerMockito.suppress(PowerMockito.method(Banana.class, &quot;flavor&quot;));//修改私有变量MemberModifier.field(Banana.class, &quot;fruit&quot;).set(banana, &quot;西瓜&quot;);//使用PowerMockito mock出来的对象可以直接调用final方法Banana banana = PowerMockito.mock(Banana.class);//whenNew 方法的意思是之后 new 这个对象时，返回某个被 Mock //的对象而不是让真的 new //新的对象。如果构造方法有参数，可以在withNoArguments方法中传入。PowerMockito.whenNew(Banana.class).withNoArguments().thenReturn(banana);</code></pre><h5 id="3-使用PowerMockRule来代替-RunWith-PowerMockRunner-class-的方式，需要多添加以下依赖："><a href="#3-使用PowerMockRule来代替-RunWith-PowerMockRunner-class-的方式，需要多添加以下依赖：" class="headerlink" title="3.使用PowerMockRule来代替@RunWith(PowerMockRunner.class)的方式，需要多添加以下依赖："></a>3.使用PowerMockRule来代替@RunWith(PowerMockRunner.class)的方式，需要多添加以下依赖：</h5><pre><code>testImplementation &quot;org.powermock:powermock-module-junit4-rule:1.7.4&quot;testImplementation &quot;org.powermock:powermock-classloading-xstream:1.7.4&quot;</code></pre><p>使用示例如下：</p><pre><code>@Rulepublic PowerMockRule mPowerMockRule = new PowerMockRule();</code></pre><h5 id="4-使用Parameterized来进行参数化测试："><a href="#4-使用Parameterized来进行参数化测试：" class="headerlink" title="4.使用Parameterized来进行参数化测试："></a>4.使用Parameterized来进行参数化测试：</h5><p><strong>通过注解@Parameterized.parameters提供一系列数据给构造器中的构造参数</strong>或给<strong>被注解@Parameterized.parameter注解的public全局变量</strong></p><pre><code>RunWith(Parameterized.class)public class ParameterizedTest {    private int num;    private boolean truth;    public ParameterizedTest(int num, boolean truth) {        this.num = num;        this.truth = truth;    }    //被此注解注解的方法将把返回的列表数据中的元素对应注入到测试类    //的构造函数ParameterizedTest(int num, boolean truth)中    @Parameterized.Parameters    public static Collection providerTruth() {        return Arrays.asList(new Object[][]{                {0, true},                {1, false},                {2, true},                {3, false},                {4, true},                {5, false}        });    }//    //也可不使用构造函数注入的方式，使用注解注入public变量的方式//    @Parameterized.Parameter//    public int num;//    //value = 1指定括号里的第二个Boolean值//    @Parameterized.Parameter(value = 1)//    public boolean truth;    @Test    public void printTest() {        Assert.assertEquals(truth, print(num));        System.out.println(num);    }    private boolean print(int num) {        return num % 2 == 0;    }}</code></pre><h3 id="四、能在Java单元测试里面执行Android代码的Robolectric"><a href="#四、能在Java单元测试里面执行Android代码的Robolectric" class="headerlink" title="四、能在Java单元测试里面执行Android代码的Robolectric"></a>四、能在Java单元测试里面执行Android代码的Robolectric</h3><hr><h4 id="什么是Robolectric？"><a href="#什么是Robolectric？" class="headerlink" title="什么是Robolectric？"></a>什么是Robolectric？</h4><hr><p>Robolectric通过<strong>一套能运行在JVM上的Android代码</strong>，解决了在Java单元测试中很难进行Android单元测试的痛点。</p><h4 id="进入Roboletric的领地"><a href="#进入Roboletric的领地" class="headerlink" title="进入Roboletric的领地"></a>进入Roboletric的领地</h4><hr><h5 id="1-在build-gradle里面添加Robolectric的依赖"><a href="#1-在build-gradle里面添加Robolectric的依赖" class="headerlink" title="1.在build.gradle里面添加Robolectric的依赖"></a>1.在build.gradle里面添加Robolectric的依赖</h5><pre><code>//Robolectric核心testImplementation &quot;org.robolectric:robolectric:3.8&quot;//支持support-v4testImplementation &apos;org.robolectric:shadows-support-v4:3.4-rc2&apos;//支持Multidex功能testImplementation &quot;org.robolectric:shadows-multidex:3.+&quot; </code></pre><h5 id="2-Robolectric常用用法"><a href="#2-Robolectric常用用法" class="headerlink" title="2.Robolectric常用用法"></a>2.Robolectric常用用法</h5><p>首先给指定的测试类上面进行配置</p><pre><code>@RunWith(RobolectricTestRunner.class)//目前Robolectric最高支持sdk版本为23。@Config(constants = BuildConfig.class, sdk = 23)</code></pre><p>下面是一些常用用法</p><pre><code>//当Robolectric.setupActivity()方法返回的时候，//默认会调用Activity的onCreate()、onStart()、onResume()mTestActivity = Robolectric.setupActivity(TestActivity.class);//获取TestActivity对应的影子类，从而能获取其相应的动作或行为ShadowActivity shadowActivity = Shadows.shadowOf(mTestActivity);Intent intent = shadowActivity.getNextStartedActivity();//使用ShadowToast类获取展示toast时相应的动作或行为Toast latestToast = ShadowToast.getLatestToast();Assert.assertNull(latestToast);//直接通过ShadowToast简单工厂类获取Toast中的文本Assert.assertEquals(&quot;hahaha&quot;, ShadowToast.getTextOfLatestToast());//使用ShadowAlertDialog类获取展示AlertDialog时相应的//动作或行为（暂时只支持app包下的，不支持v7。。。）latestAlertDialog = ShadowAlertDialog.getLatestAlertDialog();AlertDialog latestAlertDialog = ShadowAlertDialog.getLatestAlertDialog();Assert.assertNull(latestAlertDialog);//使用RuntimeEnvironment.application可以获取到//Application，方便我们使用。比如访问资源文件。Application application = RuntimeEnvironment.application;String appName = application.getString(R.string.app_name);Assert.assertEquals(&quot;WanAndroid&quot;, appName);//也可以直接通过ShadowApplication获取applicationShadowApplication application = ShadowApplication.getInstance();Assert.assertNotNull(application.hasReceiverForIntent(intent));</code></pre><p>自定义Shadow类</p><pre><code>@Implements(Person.class)public class ShadowPerson {    @Implementation    public String getName() {        return &quot;AndroidUT&quot;;    }}@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class,        sdk = 23,        shadows = {ShadowPerson.class})    Person person = new Person();    //实际上调用的是ShadowPerson的方法，输出JsonChao    Log.d(&quot;test&quot;, person.getName());    ShadowPerson shadowPerson = Shadow.extract(person);    //测试通过    Assert.assertEquals(&quot;JsonChao&quot;, shadowPerson.getName());}</code></pre><p>注意：<br>异步测试出现一些问题（比如改变一些编码习惯，比如回调函数不能写成匿名内部类对象，需要定义一个全局变量，并破坏其封装性，即提供一个get方法，供UT调用），解决方案<strong>使用Mockito来结合进行测试，将异步转为同步</strong>。</p><h5 id="3-Robolectric的优缺点"><a href="#3-Robolectric的优缺点" class="headerlink" title="3.Robolectric的优缺点"></a>3.Robolectric的优缺点</h5><pre><code>优点：支持大部分Android平台依赖类底层的引用与模拟。缺点：异步测试有些问题，需要结合一些框架来配合完成更多功能。</code></pre><h3 id="五、单元测试覆盖率报告生成之jacoco"><a href="#五、单元测试覆盖率报告生成之jacoco" class="headerlink" title="五、单元测试覆盖率报告生成之jacoco"></a>五、单元测试覆盖率报告生成之jacoco</h3><hr><h4 id="什么是Jacoco"><a href="#什么是Jacoco" class="headerlink" title="什么是Jacoco"></a>什么是Jacoco</h4><hr><p>Jacoco的全称为Java Code Coverage（Java代码覆盖率），可以<strong>生成java的单元测试代码覆盖率报告</strong>。</p><h4 id="加入Jacoco到你的单元测试大家族"><a href="#加入Jacoco到你的单元测试大家族" class="headerlink" title="加入Jacoco到你的单元测试大家族"></a>加入Jacoco到你的单元测试大家族</h4><hr><p>在应用Module下加入jacoco.gradle自定义脚本，app.gradle apply from它，同步，即可看到在app的Task下生成了Report目录，Report目录<br>下生成了JacocoTestReport任务。</p><pre><code>apply plugin: &apos;jacoco&apos;jacoco {    toolVersion = &quot;0.7.7.201606060606&quot; //指定jacoco的版本    reportsDir = file(&quot;$buildDir/JacocoReport&quot;) //指定jacoco生成报告的文件夹}//依赖于testDebugUnitTest任务task jacocoTestReport(type: JacocoReport, dependsOn: &apos;testDebugUnitTest&apos;) {    group = &quot;reporting&quot; //指定task的分组    reports {        xml.enabled = true //开启xml报告        html.enabled = true //开启html报告    }    def debugTree = fileTree(dir: &quot;${buildDir}/intermediates/classes/debug&quot;,            includes: [&quot;**/*Presenter.*&quot;],            excludes: [&quot;*.*&quot;])//指定类文件夹、包含类的规则及排除类的规则，            //这里我们生成所有Presenter类的测试报告    def mainSrc = &quot;${project.projectDir}/src/main/java&quot; //指定源码目录    sourceDirectories = files([mainSrc])    classDirectories = files([debugTree])    executionData = files(&quot;${buildDir}/jacoco/testDebugUnitTest.exec&quot;)//指定报告数据的路径}</code></pre><p>在Gradle构建板块<strong>Gradle.projects</strong>下的<strong>app/Task/verification</strong>下，其中<strong>testDebugUnitTest</strong>构建任务会生成单元测试结果报告，包<strong>含xml及html</strong>格式，分别对应<strong>test-results和reports</strong>文件夹；jacocoTestReport任务会生成单元测试覆盖率报告，结果存放在jacoco和JacocoReport文件夹。</p><p><img src="https://s1.ax1x.com/2018/07/09/PnEv7j.png" alt="image"></p><p>生成的JacocoReport文件夹下的index.html即对应的单元测试覆盖率报告，用浏览器打开后，可以看到覆盖情况被不同的颜色标识出来，其中<strong>绿色表示代码被单元测试覆盖到，黄色表示部分覆盖，红色则表示完全没有覆盖到</strong>。</p><h3 id="六、单元测试的流程"><a href="#六、单元测试的流程" class="headerlink" title="六、单元测试的流程"></a>六、单元测试的流程</h3><hr><p>要验证程序正确性，必然要给出所有可能的条件（极限编程），并验证其行为或结果，才算是100%覆盖条件。实际项目中，验证<strong>一般条件</strong>和<strong>边界条件</strong>就OK了。</p><p>在实际项目中，<strong>单元测试对象与页面是一对一的</strong>，并不建议跨页面，这样的单元测试耦合太大，维护困难。<br>需要写完后，看覆盖率，找出单元测试中没有覆盖到的函数分支条件等，然后继续补充单元测试case列表，并在单元测试工程代码中补上case。<br>直到规划的<strong>页面中所有逻辑的重要分支、边界条件都被覆盖</strong>，该项目的单元测试结束。</p><h5 id="建议（-ovo-）"><a href="#建议（-ovo-）" class="headerlink" title="建议（-ovo-）~"></a>建议（-ovo-）~</h5><hr><p>可以从公司项目<strong>小规模使用</strong>，形成<strong>自己的单元测试风格</strong>后，就可以跟大范围地推广了。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="http://www.wanandroid.com/blog/show/2085" target="_blank" rel="external">必知必会 | Android 测试相关的方方面面都在这儿</a></p><p>2、<a href="https://www.jianshu.com/p/03118c11c199" target="_blank" rel="external">在Android Studio中进行单元测试和UI测试</a></p><p>3、<a href="https://www.jianshu.com/p/0a8bbfe6cba2" target="_blank" rel="external">Android单元测试（一）</a></p><p>4、<a href="https://www.jianshu.com/subscriptions" target="_blank" rel="external">Android单元测试（二）</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/07/09/%E4%B8%80%E6%96%87%E5%85%A8%E9%9D%A2%E4%BA%86%E8%A7%A3Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>可能会改变你的话</title>
      <link>http://yoursite.com/2018/04/22/Some%20awesome%20tips/</link>
      <guid>http://yoursite.com/2018/04/22/Some%20awesome%20tips/</guid>
      <pubDate>Sun, 22 Apr 2018 13:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><pre><code>这是一篇记录平时读书遇到的一些让人觉得会改变自己的话。</code></pre><h4 id="Some-awesome-tips"><a href="#Some-awesome-tips" class="headerlink" title="Some awesome tips"></a>Some awesome tips</h4><pre><code>1.一个浪头打过来，最好的办法是迎上去了解个究竟，而不是漠视，或者干脆当事情没有发生。2.记住这个教训：别猜，去问！去查！3.隔一段时间重顾知识是记忆的关键方法。不要一次性学完一项知识就不管了，这样你无法真正的掌握。隔一段时间回顾一下，每次重复，你都会加深自己的理解，次数多了，你就会理解每个细节，成为真正的专家。4.对于一个技术通常我们需要抱有这样的疑问它是什么 一句话概括解决了什么问题 存在的意义怎样去使用它怎样解决了问题 内部的实现它的缺点是什么 多角度分析5.高效率的学习方法。理清楚概念很重要做好控制变量法多动手实践，与理论结合抓住重点，剔除干扰因素6.关于如何选择第三方库确定这个库是否是必需的这个库能否带来开发效率的提升，降低代码的维护成本这个库的学习成本如何 比如rxjava其实学习成本会相对高一些。这个库的质量如何，不要仅仅看star，更要看issue的处理情况。7.怎样练习算法题？每道算法题都先自己去实现，先写思路，然后自己去实现一遍，然后再看看答案，记住答案的思路，第二天再重新按照答案的思路实现一遍。8.&quot;另类&quot;的学习方法抄书的奥妙——那就是延缓阅读速度，不至遗漏每一个重要的细节：眼到，手到，心到，其实不仅书抄得，代码(优秀源码)也抄得。9.建议：建立逐字稿计算机网络相关的逐字稿计算机操作系统相关的逐字稿数据库相关的逐字稿设计模式相关的逐字稿数据结构与算法相关的逐字稿Java知识相关的逐字稿Kotlin知识相关的逐字稿Python知识相关的逐字稿React Native知识相关的逐字稿Flutter知识相关的逐字稿小程序知识相关的逐字稿JS知识相关的逐字稿Android知识相关的逐字稿与技术无关的逐字稿10.如何提升你的阅读能力？只字不差的反复阅读真正的获取知识，是通过阅读，深入思考与践行11.如何高效阅读一篇文章？由主题扩展为知识树尝试描述尝试记忆12.如何阅读源码？准备：Java设计模式(模板方法，单例，观察者，工厂方法，代理，策略，装饰者)，Java高级相关熟练掌握这个库先Google了解软件的整体架构设计搭建系统，把源码跑起来开始阅读：根据你对系统的理解，设计几个主要的测试案例，定义好输入，输出。(Debug一遍肯定是不行的，需要Debug很多遍)第一篇抛弃细节，抓住主要流程，第二篇，第三篇，再去看各个部分的细节。阅读的时候同时使用UML画出系统的类图。主要的测试案例明白了，丰富测试案例，考虑一些分支。这一步会非常非常地花费时间，但是你做完了，对系统的理解绝对有质的飞跃。13.想象一个来自未来的自己，他非常自信，非常成功，拥有你现在所希望的一切，他会对现在的你说些什么？他怎么说，你就怎么去做，10年之后，你就变成了他。14.重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。15.我们需要从别人身上学习。从老师、领导、同事、下属甚至对手身上学习，是快速成长的重要手段。16.多多总结，多多分享，善莫大焉。17.解答别人的问题也是个人成长的重要手段。有时候，某个问题自己本来不太懂，但是在给别人讲解的时候却豁然开朗。所以，“诲人不倦”利人惠己。18.学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。19.良好的用人方式应该如下：首选选择相信，在面临失败后，收缩信任度。查找失败的原因，提供改进意见，提升下属的能力。总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。20.学习就是不断地刻意联系，刻意练习，就是有目的的练习，先规划好，再去练习。首先给自己定一个目标，目标可以有效的引导你学习，然后使用3F练习法：1： 专注（Focus），专注在眼前的任务上，在学习过程中保持专注，可以尝试使用番茄工作法。2：反馈（Feedback），意识到自己的不足，学习完之后进行反思，思考下自己哪些方面不足，为什么不足，3： 修正（Fix），改进自己的不足。不停的练习和思考可以改变大脑结构，大脑像肌肉一样，挑战越大，影响越大，学习更高效，并且也会产生突破性。21.写一篇博客的过程，其实就是对一件事情，学习、理解、思考、转化，最终输出成一篇博客的过程。22.深入浅出SQL给出的学习法则：如何快速记忆知识？将文字转换为图片（将文字嵌入图片效果比较好)，如果能转换为令人惊奇，有趣的情景模拟，那么可以让你的大脑意识到这是重要的东西，记忆效果会更好。1.慢慢来，理解越多，需要强记得就越少。2.勤做笔记，写下你的心得笔记。3.你的大脑会需要一段时间来消化新知识，如果之后再学别的知识，会使之前的记忆效果减弱，因此，在睡前看最重要的知识。4.喝水，多喝水。5.大声说出你想要记忆的知识，如果能与别人进行一问一答则效果更佳。6.当学习知识时，达到了漫不经心或过目即忘的状态，则应该让大脑好好休息。7.用心感受，让你的大脑知道这很重要，将学习的内容尽量以情景化+惊奇+幽默的形式展示出来。8.用学到的知识解决实际的难题（真实的情景演练）。23.想要学习新技术，想要提升自己，不是看见新技术就去学，沉下心来认真钻研才行，吃透它，不再为缓解焦虑而学习。24.业务代码一样很牛逼1.使用封装和抽象可以使业务代码更具扩展性。2.多和产品交流以便更好地理解和实现业务。3.日志记录好了问题定位效率可以提升10倍。25.在工作中学习、实战提升是效果最好的，其余时间可有目的去碎片化学习一整块知识，也可以快速构建牢固的知识体系。26.做更多：工作中熟悉多个业务代码，端到端（前后端）的业务代码，自学。做更好：1.提升项目稳定性，引进单元测试和UI测试。2.重构解耦项目。3.性能优化。4.设计模式去除重复代码。做练习：1.学习2.尝试3.教学27.一项新技术的出现，应该先去了解它，看它是否对自身的技术成长有比较大的帮助，有的话按优先级加入计划表28.重复记忆时间间隔：1小时、早上/晚上、1天、3天、7天、1个月、3个月形成长期记忆~29.学习一个新的知识点的流程：what、why、how、原理/源码、优缺点~注意”先主后从“原则，多实践加深理解。</code></pre><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/22/Some%20awesome%20tips/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
