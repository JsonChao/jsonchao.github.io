<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Sun, 16 Dec 2018 12:27:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android主流三方库源码分析（三、深入理解Glide源码）</title>
      <link>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 16 Dec 2018 12:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>。本篇，我们将会来深入地分析下目前Android使用最广泛的图片加载框架框架Glide的源码加载流程。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><p>Glide最基本的使用流程就是下面这行代码，其它所有扩展的额外功能都是以其建造者链式调用的基础上增加的。</p><pre><code>GlideApp.with(context).load(url).into(iv);</code></pre><p>其中的GlideApp是注解处理器自动生成的，要使用GlideApp，必须先配置应用的AppGlideModule模块，里面可以为空配置，也可以根据实际情况添加指定配置。</p><pre><code>@GlideModulepublic class MyAppGlideModule extends AppGlideModule {    @Override    public void applyOptions(Context context, GlideBuilder builder) {        // 实际使用中根据情况可以添加如下配置        &lt;!--builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));--&gt;        &lt;!--int memoryCacheSizeBytes = 1024 * 1024 * 20;--&gt;        &lt;!--builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));--&gt;        &lt;!--int bitmapPoolSizeBytes = 1024 * 1024 * 30;--&gt;        &lt;!--builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));--&gt;        &lt;!--int diskCacheSizeBytes = 1024 * 1024 * 100;--&gt;        &lt;!--builder.setDiskCache(new InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));--&gt;    }}</code></pre><p>接下来，本文将针对Glide的最新源码版本V4.8.0对Glide加载网络图片的流程进行详细地分析与讲解，力争做到让读者朋友们知其然也知其所以然。</p><h3 id="二、GlideApp-with-context-源码详解"><a href="#二、GlideApp-with-context-源码详解" class="headerlink" title="二、GlideApp.with(context)源码详解"></a>二、GlideApp.with(context)源码详解</h3><p>首先，用<strong>艽野尘梦</strong>绘制的这份Glide框架图让我们对Glide的总体框架有一个初步的了解。</p><p><img src="https://pic4.zhimg.com/v2-57ecd38997babcdc92667017bd553323_r.jpg" alt="image"></p><p>从GlideApp.with这行代码开始，内部主线执行流程如下。</p><h4 id="1、GlideApp-with"><a href="#1、GlideApp-with" class="headerlink" title="1、GlideApp#with"></a>1、GlideApp#with</h4><pre><code>return (GlideRequests) Glide.with(context);</code></pre><h4 id="2、Glide-with"><a href="#2、Glide-with" class="headerlink" title="2、Glide#with"></a>2、Glide#with</h4><pre><code>return getRetriever(context).get(context);return Glide.get(context).getRequestManagerRetriever();// 外部使用了双重检锁的同步方式确保同一时刻只执一次Glide的初始化checkAndInitializeGlide(context);initializeGlide(context);// 最终执行到Glide的另一个重载方法initializeGlide(context, new GlideBuilder());@SuppressWarnings(&quot;deprecation&quot;)  private static void initializeGlide(@NonNull Context   context, @NonNull GlideBuilder builder) {    Context applicationContext =     context.getApplicationContext();    // 1、获取前面应用中带注解的GlideModule    GeneratedAppGlideModule annotationGeneratedModule =     getAnnotationGeneratedGlideModules();    // 2、如果GlideModule为空或者可配置manifest里面的标志为true，则获取manifest里面    // 配置的GlideModule模块（manifestModules）。    List&lt;com.bumptech.glide.module.GlideModule&gt;     manifestModules = Collections.emptyList();    if (annotationGeneratedModule == null ||     annotationGeneratedModule.isManifestParsingEnabled(    )) {      manifestModules = new   ManifestParser(applicationContext).parse();    }    ...    RequestManagerRetriever.RequestManagerFactory     factory =        annotationGeneratedModule != null            ? annotationGeneratedModule.getRequestManag    erFactory() : null;    builder.setRequestManagerFactory(factory);    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {      module.applyOptions(applicationContext, builder);    }    if (annotationGeneratedModule != null) {      annotationGeneratedModule.applyOptions(applicatio  nContext, builder);    }    // 3、初始化各种配置信息    Glide glide = builder.build(applicationContext);    // 4、把manifestModules以及annotationGeneratedModule里面的配置信息放到builder    // 里面（applyOptions）替换glide默认组件（registerComponents）    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {      module.registerComponents(applicationContext,   glide, glide.registry);    }    if (annotationGeneratedModule != null) {      annotationGeneratedModule.registerComponents(appl  icationContext, glide, glide.registry);    }    applicationContext.registerComponentCallbacks(glide    );    Glide.glide = glide;}</code></pre><h4 id="3、GlideBuilder-build"><a href="#3、GlideBuilder-build" class="headerlink" title="3、GlideBuilder#build"></a>3、GlideBuilder#build</h4><pre><code>@NonNull  Glide build(@NonNull Context context) {    // 创建请求图片线程池sourceExecutor    if (sourceExecutor == null) {      sourceExecutor =   GlideExecutor.newSourceExecutor();    }    // 创建硬盘缓存线程池diskCacheExecutor    if (diskCacheExecutor == null) {      diskCacheExecutor =   GlideExecutor.newDiskCacheExecutor();    }    // 创建动画线程池animationExecutor    if (animationExecutor == null) {      animationExecutor =   GlideExecutor.newAnimationExecutor();    }    if (memorySizeCalculator == null) {      memorySizeCalculator = new   MemorySizeCalculator.Builder(context).build();    }    if (connectivityMonitorFactory == null) {      connectivityMonitorFactory = new   DefaultConnectivityMonitorFactory();    }    if (bitmapPool == null) {      // 依据设备的屏幕密度和尺寸设置各种pool的size      int size =   memorySizeCalculator.getBitmapPoolSize();      if (size &gt; 0) {        // 创建图片线程池LruBitmapPool，缓存所有被释放的bitmap        // 缓存策略在API大于19时，为SizeConfigStrategy，小于为AttributeStrategy。        // 其中SizeConfigStrategy是以bitmap的size和config为key，value为bitmap的HashMap        bitmapPool = new LruBitmapPool(size);      } else {        bitmapPool = new BitmapPoolAdapter();      }    }    // 创建对象数组缓存池LruArrayPool，默认4M    if (arrayPool == null) {      arrayPool = new   LruArrayPool(memorySizeCalculator.getArrayPoolSiz  eInBytes());    }    // 创建LruResourceCache，内存缓存    if (memoryCache == null) {      memoryCache = new   LruResourceCache(memorySizeCalculator.getMemoryCa  cheSize());    }    if (diskCacheFactory == null) {      diskCacheFactory = new   InternalCacheDiskCacheFactory(context);    }    // 创建任务和资源管理引擎（线程池，内存缓存和硬盘缓存对象）    if (engine == null) {      engine =          new Engine(              memoryCache,              diskCacheFactory,              diskCacheExecutor,              sourceExecutor,              GlideExecutor.newUnlimitedSourceExecutor(  ),              GlideExecutor.newAnimationExecutor(),              isActiveResourceRetentionAllowed);    }    RequestManagerRetriever requestManagerRetriever =    new RequestManagerRetriever(requestManagerFactory);    return new Glide(        context,        engine,        memoryCache,        bitmapPool,        arrayPool,        requestManagerRetriever,        connectivityMonitorFactory,        logLevel,        defaultRequestOptions.lock(),        defaultTransitionOptions);}</code></pre><h4 id="4、Glide-Glide构造方法"><a href="#4、Glide-Glide构造方法" class="headerlink" title="4、Glide#Glide构造方法"></a>4、Glide#Glide构造方法</h4><pre><code>Glide(...) {    ...    // 注册管理任务执行对象的类(Registry)    // Registry是一个工厂，而其中所有注册的对象都是一个工厂员工，当任务分发时，    // 根据当前任务的性质，分发给相应员工进行处理    registry = new Registry();    ...    // 这里大概有60余次的append或register员工组件（解析器、编解码器、工厂类、转码类等等组件）    registry    .append(ByteBuffer.class, new ByteBufferEncoder())    .append(InputStream.class, new StreamEncoder(arrayPool))    // 根据给定子类产出对应类型的target（BitmapImageViewTarget / DrawableImageViewTarget)    ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();    glideContext =        new GlideContext(            context,            arrayPool,            registry,            imageViewTargetFactory,            defaultRequestOptions,            defaultTransitionOptions,            engine,            logLevel);}</code></pre><h4 id="5、RequestManagerRetriever-get"><a href="#5、RequestManagerRetriever-get" class="headerlink" title="5、RequestManagerRetriever#get"></a>5、RequestManagerRetriever#get</h4><pre><code>@NonNullpublic RequestManager get(@NonNull Context context) {  if (context == null) {    throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);  } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {    // 如果当前线程是主线程且context不是Application走相应的get重载方法    if (context instanceof FragmentActivity) {      return get((FragmentActivity) context);    } else if (context instanceof Activity) {      return get((Activity) context);    } else if (context instanceof ContextWrapper) {      return get(((ContextWrapper) context).getBaseContext());    }  }  // 否则直接将请求与ApplicationLifecycle关联  return getApplicationManager(context);}</code></pre><p>这里总结一下，对于当前传入的context是application或当前线程是子线程时，请求的生命周期和ApplicationLifecycle关联，否则，context是FragmentActivity或Fragment时，在当前组件添加一个SupportFragment（SupportRequestManagerFragment），context是Activity时，在当前组件添加一个Fragment(RequestManagerFragment)。</p><h5 id="6、GlideApp-with小结"><a href="#6、GlideApp-with小结" class="headerlink" title="6、GlideApp#with小结"></a>6、GlideApp#with小结</h5><h5 id="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"><a href="#1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，" class="headerlink" title="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"></a>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，</h5><h5 id="2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。"><a href="#2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。" class="headerlink" title="2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。"></a>2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。</h5><h3 id="三、load-url-源码详解"><a href="#三、load-url-源码详解" class="headerlink" title="三、load(url)源码详解"></a>三、load(url)源码详解</h3><h4 id="1、GlideRequest-RequestManager-load"><a href="#1、GlideRequest-RequestManager-load" class="headerlink" title="1、GlideRequest(RequestManager)#load"></a>1、GlideRequest(RequestManager)#load</h4><pre><code>return (GlideRequest&lt;Drawable&gt;) super.load(string);return asDrawable().load(string);// 1、asDrawable部分return (GlideRequest&lt;Drawable&gt;) super.asDrawable();return as(Drawable.class);// 最终返回了一个GlideRequest（RequestManager的子类）return new GlideRequest&lt;&gt;(glide, this, resourceClass, context);// 2、load部分return (GlideRequest&lt;TranscodeType&gt;) super.load(string);return loadGeneric(string);@NonNullprivate RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) {    // model则为设置的url    this.model = model;    // 记录url已设置    isModelSet = true;    return this;}</code></pre><p>可以看到，load这部分的源码很简单，就是给GlideRequest（RequestManager）设置了要请求的mode（url），并记录了url已设置的状态。</p><h3 id="四、into-iv-源码详解"><a href="#四、into-iv-源码详解" class="headerlink" title="四、into(iv)源码详解"></a>四、into(iv)源码详解</h3><p>前方预警，真正复杂的地方开始了。</p><h4 id="1、RequestBuilder-into"><a href="#1、RequestBuilder-into" class="headerlink" title="1、RequestBuilder.into"></a>1、RequestBuilder.into</h4><pre><code> @NonNullpublic ViewTarget&lt;ImageView, TranscodeType&gt;   into(@NonNull ImageView view) {  Util.assertMainThread();  Preconditions.checkNotNull(view);  RequestOptions requestOptions =     this.requestOptions;  if (!requestOptions.isTransformationSet()      &amp;&amp; requestOptions.isTransformationAllowed()      &amp;&amp; view.getScaleType() != null) {    // Clone in this method so that if we use this   RequestBuilder to load into a View and then    // into a different target, we don&apos;t retain the   transformation applied based on the previous    // View&apos;s scale type.    switch (view.getScaleType()) {      // 这个RequestOptions里保存了要设置的scaleType，Glide自身封装了CenterCrop、CenterInside、      // FitCenter、CenterInside四种规格。      case CENTER_CROP:        requestOptions =   requestOptions.clone().optionalCenterCrop();        break;      case CENTER_INSIDE:        requestOptions =   requestOptions.clone().optionalCenterInside()  ;        break;      case FIT_CENTER:      case FIT_START:      case FIT_END:        requestOptions =   requestOptions.clone().optionalFitCenter();        break;      case FIT_XY:        requestOptions =   requestOptions.clone().optionalCenterInside()  ;        break;      case CENTER:      case MATRIX:      default:        // Do nothing.    }  }  // 注意，这个transcodeClass是指的drawable或bitmap  return into(      glideContext.buildImageViewTarget(view,     transcodeClass),      /*targetListener=*/ null,      requestOptions);}</code></pre><h4 id="2、GlideContext-buildImageViewTarget"><a href="#2、GlideContext-buildImageViewTarget" class="headerlink" title="2、GlideContext#buildImageViewTarget"></a>2、GlideContext#buildImageViewTarget</h4><pre><code>return imageViewTargetFactory.buildTarget(imageView, transcodeClass);</code></pre><h4 id="3、ImageViewTargetFactory-buildTarget"><a href="#3、ImageViewTargetFactory-buildTarget" class="headerlink" title="3、ImageViewTargetFactory#buildTarget"></a>3、ImageViewTargetFactory#buildTarget</h4><pre><code>@NonNull@SuppressWarnings(&quot;unchecked&quot;)public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt;   buildTarget(@NonNull ImageView view,    @NonNull Class&lt;Z&gt; clazz) {  // 返回展示Bimtap/Drawable资源的目标对象  if (Bitmap.class.equals(clazz)) {    return (ViewTarget&lt;ImageView, Z&gt;) new   BitmapImageViewTarget(view);  } else if (Drawable.class.isAssignableFrom(clazz))     {    return (ViewTarget&lt;ImageView, Z&gt;) new   DrawableImageViewTarget(view);  } else {    throw new IllegalArgumentException(        &quot;Unhandled class: &quot; + clazz + &quot;, try   .as*(Class).transcode(ResourceTranscoder)&quot;);  }}</code></pre><p>可以看到，Glide内部只维护了两种target，一种是BitmapImageViewTarget，另一种则是DrawableImageViewTarget，接下来继续深入。</p><h4 id="4、RequestBuilder-into"><a href="#4、RequestBuilder-into" class="headerlink" title="4、RequestBuilder#into"></a>4、RequestBuilder#into</h4><pre><code>private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(      @NonNull Y target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      @NonNull RequestOptions options) {    Util.assertMainThread();    Preconditions.checkNotNull(target);    if (!isModelSet) {      throw new IllegalArgumentException(&quot;You must call   #load() before calling #into()&quot;);    }    options = options.autoClone();    // 分析1.建立请求    Request request = buildRequest(target,     targetListener, options);    Request previous = target.getRequest();    if (request.isEquivalentTo(previous)        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousReques    t(options, previous)) {      request.recycle();      // If the request is completed, beginning again   will ensure the result is re-delivered,      // triggering RequestListeners and Targets. If   the request is failed, beginning again will      // restart the request, giving it another chance   to complete. If the request is already      // running, we can let it continue running   without interruption.      if (!Preconditions.checkNotNull(previous).isRunni  ng()) {        // Use the previous request rather than the new     one to allow for optimizations like skipping        // setting placeholders, tracking and     un-tracking Targets, and obtaining View     dimensions        // that are done in the individual Request.        previous.begin();      }      return target;    }    requestManager.clear(target);    target.setRequest(request);    // 分析2.真正追踪请求的地方    requestManager.track(target, request);    return target;}// 分析1private Request buildRequest(      Target&lt;TranscodeType&gt; target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      RequestOptions requestOptions) {    return buildRequestRecursive(        target,        targetListener,        /*parentCoordinator=*/ null,        transitionOptions,        requestOptions.getPriority(),        requestOptions.getOverrideWidth(),        requestOptions.getOverrideHeight(),        requestOptions);}// 分析1private Request buildRequestRecursive(      Target&lt;TranscodeType&gt; target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      @Nullable RequestCoordinator parentCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight,      RequestOptions requestOptions) {    // Build the ErrorRequestCoordinator first if     necessary so we can update parentCoordinator.    ErrorRequestCoordinator errorRequestCoordinator =     null;    if (errorBuilder != null) {      // 创建errorRequestCoordinator（异常处理对象）      errorRequestCoordinator = new   ErrorRequestCoordinator(parentCoordinator);      parentCoordinator = errorRequestCoordinator;    }    // 递归建立缩略图请求    Request mainRequest =        buildThumbnailRequestRecursive(            target,            targetListener,            parentCoordinator,            transitionOptions,            priority,            overrideWidth,            overrideHeight,            requestOptions);    if (errorRequestCoordinator == null) {      return mainRequest;    }    ...    Request errorRequest =     errorBuilder.buildRequestRecursive(        target,        targetListener,        errorRequestCoordinator,        errorBuilder.transitionOptions,        errorBuilder.requestOptions.getPriority(),        errorOverrideWidth,        errorOverrideHeight,        errorBuilder.requestOptions);    errorRequestCoordinator.setRequests(mainRequest,     errorRequest);    return errorRequestCoordinator;}// 分析1private Request buildThumbnailRequestRecursive(      Target&lt;TranscodeType&gt; target,      RequestListener&lt;TranscodeType&gt; targetListener,      @Nullable RequestCoordinator parentCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight,      RequestOptions requestOptions) {    if (thumbnailBuilder != null) {      // Recursive case: contains a potentially recursive thumbnail request builder.      ...      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);      // 获取一个正常请求对象      Request fullRequest =          obtainRequest(              target,              targetListener,              requestOptions,              coordinator,              transitionOptions,              priority,              overrideWidth,              overrideHeight);      isThumbnailBuilt = true;      // Recursively generate thumbnail requests.      // 使用递归的方式建立一个缩略图请求对象      Request thumbRequest =          thumbnailBuilder.buildRequestRecursive(              target,              targetListener,              coordinator,              thumbTransitionOptions,              thumbPriority,              thumbOverrideWidth,              thumbOverrideHeight,              thumbnailBuilder.requestOptions);      isThumbnailBuilt = false;      // coordinator（ThumbnailRequestCoordinator）是作为两者的协调者，      // 能够同时加载缩略图和正常的图的请求      coordinator.setRequests(fullRequest, thumbRequest);      return coordinator;    } else if (thumbSizeMultiplier != null) {      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.      // 当设置了缩略的比例thumbSizeMultiplier(0 ~  1)时，      // 不需要递归建立缩略图请求      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);      Request fullRequest =          obtainRequest(              target,              targetListener,              requestOptions,              coordinator,              transitionOptions,              priority,              overrideWidth,              overrideHeight);      RequestOptions thumbnailOptions = requestOptions.clone()          .sizeMultiplier(thumbSizeMultiplier);      Request thumbnailRequest =          obtainRequest(              target,              targetListener,              thumbnailOptions,              coordinator,              transitionOptions,              getThumbnailPriority(priority),              overrideWidth,              overrideHeight);      coordinator.setRequests(fullRequest, thumbnailRequest);      return coordinator;    } else {      // Base case: no thumbnail.      // 没有缩略图请求时，直接获取一个正常图请求      return obtainRequest(          target,          targetListener,          requestOptions,          parentCoordinator,          transitionOptions,          priority,          overrideWidth,          overrideHeight);    }}private Request obtainRequest(      Target&lt;TranscodeType&gt; target,      RequestListener&lt;TranscodeType&gt; targetListener,      RequestOptions requestOptions,      RequestCoordinator requestCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight) {    // 最终实际返回的是一个SingleRequest对象（将制定的资源加载进对应的Target    return SingleRequest.obtain(        context,        glideContext,        model,        transcodeClass,        requestOptions,        overrideWidth,        overrideHeight,        priority,        target,        targetListener,        requestListeners,        requestCoordinator,        glideContext.getEngine(),        transitionOptions.getTransitionFactory());}</code></pre><p>从上源码分析可知，我们在分析1处的buildRequest()方法里建立了请求，且最多可同时进行缩略图和正常图的请求，最后，调用了requestManager.track(target, request)方法，接着看看track里面做了什么。</p><h4 id="4、RequestManager-track"><a href="#4、RequestManager-track" class="headerlink" title="4、RequestManager#track"></a>4、RequestManager#track</h4><pre><code>// 分析2void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) {    // 加入一个target目标集合(Set)    targetTracker.track(target);    requestTracker.runRequest(request);}</code></pre><h4 id="5、RequestTracker-runRequest"><a href="#5、RequestTracker-runRequest" class="headerlink" title="5、RequestTracker#runRequest"></a>5、RequestTracker#runRequest</h4><pre><code>/*** Starts tracking the given request.*/// 分析2public void runRequest(@NonNull Request request) {    requests.add(request);    if (!isPaused) {      // 如果不是暂停状态则开始请求      request.begin();    } else {      request.clear();      if (Log.isLoggable(TAG, Log.VERBOSE)) {        Log.v(TAG, &quot;Paused, delaying request&quot;);      }      // 否则清空请求，加入延迟请求队列（为了对这些请求维持一个强引用，使用了ArrayList实现）      pendingRequests.add(request);    }}</code></pre><h4 id="6、SingleRequest-begin"><a href="#6、SingleRequest-begin" class="headerlink" title="6、SingleRequest#begin"></a>6、SingleRequest#begin</h4><pre><code>// 分析2@Overridepublic void begin() {  ...  if (model == null) {    ...    // model（url）为空，回调加载失败    onLoadFailed(new GlideException(&quot;Received null   model&quot;), logLevel);    return;  }  if (status == Status.RUNNING) {    throw new IllegalArgumentException(&quot;Cannot   restart a running request&quot;);  }  // If we&apos;re restarted after we&apos;re complete (usually     via something like a notifyDataSetChanged  // that starts an identical request into the same     Target or View), we can simply use the  // resource and size we retrieved the last time     around and skip obtaining a new size, starting a  // new load etc. This does mean that users who want     to restart a load because they expect that  // the view size has changed will need to     explicitly clear the View or Target before starting  // the new load.  if (status == Status.COMPLETE) {    onResourceReady(resource,   DataSource.MEMORY_CACHE);    return;  }  // Restarts for requests that are neither complete     nor running can be treated as new requests  // and can run again from the beginning.  status = Status.WAITING_FOR_SIZE;  if (Util.isValidDimensions(overrideWidth,     overrideHeight)) {    // 最终的核心处理位于onSizeReady    onSizeReady(overrideWidth, overrideHeight);  } else {    // 最终也会走到onSizeReady    target.getSize(this);  }  if ((status == Status.RUNNING || status ==     Status.WAITING_FOR_SIZE)      &amp;&amp; canNotifyStatusChanged()) {    // 预先加载设置的缩略图    target.onLoadStarted(getPlaceholderDrawable());  }  if (IS_VERBOSE_LOGGABLE) {    logV(&quot;finished run method in &quot; +   LogTime.getElapsedMillis(startTime));  }}</code></pre><p>从requestManager.track(target, request)开始，最终会执行到SingleRequest#begin()方法的onSizeReady，可以猜到（因为后面只做了预加载缩略图的处理），真正的请求就是从这里开始的，咱们进去一探究竟~</p><h4 id="7、SingleRequest-onSizeReady"><a href="#7、SingleRequest-onSizeReady" class="headerlink" title="7、SingleRequest#onSizeReady"></a>7、SingleRequest#onSizeReady</h4><pre><code>// 分析2@Overridepublic void onSizeReady(int width, int height) {  stateVerifier.throwIfRecycled();  ...  status = Status.RUNNING;  float sizeMultiplier =     requestOptions.getSizeMultiplier();  this.width = maybeApplySizeMultiplier(width,     sizeMultiplier);  this.height = maybeApplySizeMultiplier(height,     sizeMultiplier);  ...  // 根据给定的配置进行加载，engine是一个负责加载、管理活跃和缓存资源的引擎类  loadStatus = engine.load(      glideContext,      model,      requestOptions.getSignature(),      this.width,      this.height,      requestOptions.getResourceClass(),      transcodeClass,      priority,      requestOptions.getDiskCacheStrategy(),      requestOptions.getTransformations(),      requestOptions.isTransformationRequired(),      requestOptions.isScaleOnlyOrNoTransform(),      requestOptions.getOptions(),      requestOptions.isMemoryCacheable(),      requestOptions.getUseUnlimitedSourceGeneratorsP    ool(),      requestOptions.getUseAnimationPool(),      requestOptions.getOnlyRetrieveFromCache(),      this);  ...}</code></pre><p>终于看到Engine类了，感觉距离成功不远了，继续~</p><h4 id="8、Engine-load"><a href="#8、Engine-load" class="headerlink" title="8、Engine#load"></a>8、Engine#load</h4><pre><code>/*** Starts a load for the given arguments.** &lt;p&gt;Must be called on the main thread.** &lt;p&gt;The flow for any request is as follows:* &lt;ul&gt;*   &lt;li&gt;Check the current set of actively used  resources, return the active resource if*   present, and move any newly inactive resources  into the memory cache.&lt;/li&gt;*   &lt;li&gt;Check the memory cache and provide the  cached resource if present.&lt;/li&gt;*   &lt;li&gt;Check the current set of in progress loads  and add the cb to the in progress load if*   one is present.&lt;/li&gt;*   &lt;li&gt;Start a new load.&lt;/li&gt;* &lt;/ul&gt;** &lt;p&gt;Active resources are those that have been  provided to at least one request and have not yet* been released. Once all consumers of a resource  have released that resource, the resource then* goes to cache. If the resource is ever returned to  a new consumer from cache, it is re-added to* the active resources. If the resource is evicted  from the cache, its resources are recycled and* re-used if possible and the resource is discarded.  There is no strict requirement that* consumers release their resources so active  resources are held weakly.** @param width  The target width in pixels of the  desired resource.* @param height The target height in pixels of the  desired resource.* @param cb     The callback that will be called  when the load completes.*/public &lt;R&gt; LoadStatus load(    GlideContext glideContext,    Object model,    Key signature,    int width,    int height,    Class&lt;?&gt; resourceClass,    Class&lt;R&gt; transcodeClass,    Priority priority,    DiskCacheStrategy diskCacheStrategy,    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,    boolean isTransformationRequired,    boolean isScaleOnlyOrNoTransform,    Options options,    boolean isMemoryCacheable,    boolean useUnlimitedSourceExecutorPool,    boolean useAnimationPool,    boolean onlyRetrieveFromCache,    ResourceCallback cb) {  ...  // 先从弱引用中查找，如果有的话回调onResourceReady并直接返回  EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);  if (active != null) {    cb.onResourceReady(active,   DataSource.MEMORY_CACHE);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Loaded resource from active     resources&quot;, startTime, key);    }    return null;  }  // 没有再从内存中查找,有的话会取出并放到ActiveResources（内部维护的弱引用缓存map）里面  EngineResource&lt;?&gt; cached = loadFromCache(key,     isMemoryCacheable);  if (cached != null) {    cb.onResourceReady(cached,   DataSource.MEMORY_CACHE);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Loaded resource from cache&quot;,     startTime, key);    }    return null;  }  EngineJob&lt;?&gt; current = jobs.get(key,     onlyRetrieveFromCache);  if (current != null) {    current.addCallback(cb);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Added to existing load&quot;,     startTime, key);    }    return new LoadStatus(cb, current);  }  // 如果内存中没有，则创建engineJob（decodejob的回调类，管理下载过程以及状态）  EngineJob&lt;R&gt; engineJob =      engineJobFactory.build(          key,          isMemoryCacheable,          useUnlimitedSourceExecutorPool,          useAnimationPool,          onlyRetrieveFromCache);  // 创建解析工作对象  DecodeJob&lt;R&gt; decodeJob =      decodeJobFactory.build(          glideContext,          model,          key,          signature,          width,          height,          resourceClass,          transcodeClass,          priority,          diskCacheStrategy,          transformations,          isTransformationRequired,          isScaleOnlyOrNoTransform,          onlyRetrieveFromCache,          options,          engineJob);  // 放在Jobs内部维护的HashMap中  jobs.put(key, engineJob);  engineJob.addCallback(cb);  // 内部开启线程去请求  engineJob.start(decodeJob);  if (VERBOSE_IS_LOGGABLE) {    logWithTimeAndKey(&quot;Started new load&quot;, startTime,   key);  }  return new LoadStatus(cb, engineJob);}public void start(DecodeJob&lt;R&gt; decodeJob) {    this.decodeJob = decodeJob;    // willDecodeFromCache方法内部根据不同的阶段stage，如果是RESOURCE_CACHE/DATA_CACHE则返回true，使用diskCacheExecutor，否则调用getActiveSourceExecutor，内部会根据相应的条件返回sourceUnlimitedExecutor/animationExecutor/sourceExecutor    GlideExecutor executor =       decodeJob.willDecodeFromCache()        ? diskCacheExecutor        : getActiveSourceExecutor();    executor.execute(decodeJob);}</code></pre><p>可以看到，最终Engine(引擎)类内部会执行到自身的start方法，它会根据不同的配置采用不同的线程池使用diskCacheExecutor/sourceUnlimitedExecutor/animationExecutor/sourceExecutor来执行最终的解码任务decodeJob。</p><h4 id="9、DecodeJob-run"><a href="#9、DecodeJob-run" class="headerlink" title="9、DecodeJob#run"></a>9、DecodeJob#run</h4><pre><code>runWrapped();private void runWrapped() {    switch (runReason) {      case INITIALIZE:        stage = getNextStage(Stage.INITIALIZE);        // 关注点1        currentGenerator = getNextGenerator();        // 关注点2 内部会调用相应Generator的startNext()        runGenerators();        break;      case SWITCH_TO_SOURCE_SERVICE:        runGenerators();        break;      case DECODE_DATA:        decodeFromRetrievedData();        break;      default:        throw new IllegalStateException(&quot;Unrecognized     run reason: &quot; + runReason);    }}// 关注点1，完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext()private DataFetcherGenerator getNextGenerator() {    switch (stage) {      case RESOURCE_CACHE:        return new ResourceCacheGenerator(decodeHelper,     this);      case DATA_CACHE:        return new DataCacheGenerator(decodeHelper,     this);      case SOURCE:        return new SourceGenerator(decodeHelper, this);      case FINISHED:        return null;      default:        throw new IllegalStateException(&quot;Unrecognized     stage: &quot; + stage);    }}</code></pre><h4 id="10、SourceGenerator-startNext"><a href="#10、SourceGenerator-startNext" class="headerlink" title="10、SourceGenerator#startNext"></a>10、SourceGenerator#startNext</h4><pre><code>// 关注点2@Overridepublic boolean startNext() {  // dataToCache数据不为空的话缓存到硬盘（第一执行该方法是不会调用的）  if (dataToCache != null) {    Object data = dataToCache;    dataToCache = null;    cacheData(data);  }  if (sourceCacheGenerator != null &amp;&amp;     sourceCacheGenerator.startNext()) {    return true;  }  sourceCacheGenerator = null;  loadData = null;  boolean started = false;  while (!started &amp;&amp; hasNextModelLoader()) {    // 关注点3 getLoadData()方法内部会在modelLoaders里面找到ModelLoder对象    // （每个Generator对应一个ModelLoader），    // 并使用modelLoader.buildLoadData方法返回一个loadData列表    loadData =   helper.getLoadData().get(loadDataListIndex++);    if (loadData != null        &amp;&amp; (helper.getDiskCacheStrategy().isDataCache  able(loadData.fetcher.getDataSource())        || helper.hasLoadPath(loadData.fetcher.getDat  aClass()))) {      started = true;      // 关注点5 通过loadData对象的fetcher对象（有关注点3的分析可知其实现类为HttpUrlFetcher）的      // loadData方法来获取图片数据      loadData.fetcher.loadData(helper.getPriority(),     this);    }  }  return started;}</code></pre><h4 id="11、DecodeHelper-getLoadData"><a href="#11、DecodeHelper-getLoadData" class="headerlink" title="11、DecodeHelper#getLoadData"></a>11、DecodeHelper#getLoadData</h4><pre><code>List&lt;LoadData&lt;?&gt;&gt; getLoadData() {    if (!isLoadDataSet) {      isLoadDataSet = true;      loadData.clear();      List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders =   glideContext.getRegistry().getModelLoaders(model)  ;      //noinspection ForLoopReplaceableByForEach to   improve perf      for (int i = 0, size = modelLoaders.size(); i &lt;   size; i++) {        ModelLoader&lt;Object, ?&gt; modelLoader =     modelLoaders.get(i);        // 注意：这里最终是通过HttpGlideUrlLoader的buildLoadData获取到实际的loadData对象        LoadData&lt;?&gt; current =            modelLoader.buildLoadData(model, width,     height, options);        if (current != null) {          loadData.add(current);        }      }    }    return loadData;}</code></pre><h4 id="12、HttpGlideUrlLoader-buildLoadData"><a href="#12、HttpGlideUrlLoader-buildLoadData" class="headerlink" title="12、HttpGlideUrlLoader#buildLoadData"></a>12、HttpGlideUrlLoader#buildLoadData</h4><pre><code>@Overridepublic LoadData&lt;InputStream&gt; buildLoadData(@NonNull   GlideUrl model, int width, int height,    @NonNull Options options) {  // GlideUrls memoize parsed URLs so caching them     saves a few object instantiations and time  // spent parsing urls.  GlideUrl url = model;  if (modelCache != null) {    url = modelCache.get(model, 0, 0);    if (url == null) {      // 关注点4      modelCache.put(model, 0, 0, model);      url = model;    }  }  int timeout = options.get(TIMEOUT);  // 注意，这里创建了一个DataFetcher的实现类HttpUrlFetcher  return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url,     timeout));}// 关注点4public void put(A model, int width, int height, B value) {    ModelKey&lt;A&gt; key = ModelKey.get(model, width,     height);    // 最终是通过LruCache来缓存对应的值，key是一个ModelKey对象（由model、width、height三个属性组成）    cache.put(key, value);}</code></pre><p>从这里的分析，我们明白了HttpUrlFetcher实际上就是最终的请求执行者，而且，我们知道了Glide会使用LruCache来对解析后的url来进行缓存，以便后续可以省去解析url的时间。</p><h4 id="13、HtttpUrlFetcher-loadData"><a href="#13、HtttpUrlFetcher-loadData" class="headerlink" title="13、HtttpUrlFetcher#loadData"></a>13、HtttpUrlFetcher#loadData</h4><pre><code>@Overridepublic void loadData(@NonNull Priority priority,    @NonNull DataCallback&lt;? super InputStream&gt;   callback) {  long startTime = LogTime.getLogTime();  try {    // 关注点5     // loadDataWithRedirects内部是通过HttpURLConnection网络请求数据    InputStream result =   loadDataWithRedirects(glideUrl.toURL(), 0, null,   glideUrl.getHeaders());    // 请求成功回调onDataReady()    callback.onDataReady(result);  } catch (IOException e) {    if (Log.isLoggable(TAG, Log.DEBUG)) {      Log.d(TAG, &quot;Failed to load data for url&quot;, e);    }    callback.onLoadFailed(e);  } finally {    if (Log.isLoggable(TAG, Log.VERBOSE)) {      Log.v(TAG, &quot;Finished http url fetcher fetch in     &quot; + LogTime.getElapsedMillis(startTime));    }  }}</code></pre><p>在HttpUrlFetcher#loadData方法的loadDataWithRedirects里面，Glide通过原生的HttpURLConnection进行请求后，并调用getStreamForSuccessfulRequest()方法获取到了最终的图片资源。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>到此，Glide整个的加载流程分析就结束了，可以看到，Glide最核心的逻辑都聚集在into()方法中，它里面的设计精巧而复杂，这部分的源码分析非常耗时，但是，如果你真真正正地去一步步去深入其中，你也许在Android进阶之路上将会有顿悟的感觉。目前，Android主流三方库源码分析系列已经对网络库（OkHttp、Retrofit）和图片加载库（Glide）进行了详细的源码分析，接下来，将会对响应式编程框架RxJava的核心源码进行深入的分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Glide V4.8.0源码</p><p>2、<a href="https://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="external">从源码的角度理解Glide的执行流程</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/37297719" target="_blank" rel="external">glide源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（二、深入理解Retrofit源码）</title>
      <link>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 09 Dec 2018 14:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前篇我们详细地分析了OKHttp的核心源码，如果对OKHttp内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>。这篇，将会来深入地分析下目前Android最优秀的网络封装框架Retrofit的源码流程。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><h4 id="1、定义HTTP-API，用于描述请求"><a href="#1、定义HTTP-API，用于描述请求" class="headerlink" title="1、定义HTTP API，用于描述请求"></a>1、定义HTTP API，用于描述请求</h4><pre><code>public interface GitHubService {     @GET(&quot;users/{user}/repos&quot;)     Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><h4 id="2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）"><a href="#2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）" class="headerlink" title="2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）"></a>2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）</h4><pre><code>// 1.Retrofit构建过程Retrofit retrofit = new Retrofit.Builder().baseUrl(&quot;https://api.github.com/&quot;).build();// 2.创建网络请求接口类实例过程GitHubService service = retrofit.create(GitHubService.class);</code></pre><h4 id="3、调用API方法，生成Call，执行请求"><a href="#3、调用API方法，生成Call，执行请求" class="headerlink" title="3、调用API方法，生成Call，执行请求"></a>3、调用API方法，生成Call，执行请求</h4><pre><code>// 3.生成并执行请求过程Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);repos.execute() or repos.enqueue()</code></pre><p>Retrofit的基本使用流程很简洁，但是简洁并不代表简单，Retrofit为了实现这种简洁的使用流程，内部使用了优秀的架构设计和大量的设计模式，在我分析过Retrofit最新版的源码和大量优秀的Retrofit源码分析文章后，我发现，要想真正理解Retrofit内部的核心源码流程和设计思想，首先，需要对这九大设计模式有一定的了解，如下：</p><pre><code>1.Retrofit构建过程 建造者模式、工厂方法模式2.创建网络请求接口实例过程外观模式、代理模式、单例模式、策略模式、装饰模式（建造者模式）3.生成并执行请求过程适配器模式（代理模式、装饰模式）</code></pre><p>其次，需要对OKHttp源码有一定的了解，如果不了解的可以看看这篇<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>。最后，让我们按以上流程去深入Retrofit源码内部，领悟它带给我们的<strong>设计之美</strong>。</p><h3 id="二、Retrofit构建过程"><a href="#二、Retrofit构建过程" class="headerlink" title="二、Retrofit构建过程"></a>二、Retrofit构建过程</h3><h4 id="1、Retrofit核心对象解析"><a href="#1、Retrofit核心对象解析" class="headerlink" title="1、Retrofit核心对象解析"></a>1、Retrofit核心对象解析</h4><p>首先Retrofit中有一个全局变量非常关键，在V2.5之前的版本，使用的是LinkedHashMap()，它是一个网络请求配置对象，是由网络请求接口中方法注解进行解析后得到的。</p><pre><code>public final class Retrofit {    // 网络请求配置对象，存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等    private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();</code></pre><p>Retrofit使用了建造者模式通过内部类Builder类建立一个Retrofit实例，如下：</p><pre><code>public static final class Builder {    // 平台类型对象（Platform -&gt; Android)    private final Platform platform;    // 网络请求工厂，默认使用OkHttpCall（工厂方法模式）    private @Nullable okhttp3.Call.Factory callFactory;    // 网络请求的url地址    private @Nullable HttpUrl baseUrl;    // 数据转换器工厂的集合    private final List&lt;Converter.Factory&gt; converterFactories = new     ArrayList&lt;&gt;();    // 网络请求适配器工厂的集合，默认是ExecutorCallAdapterFactory    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new     ArrayList&lt;&gt;();    // 回调方法执行器，在 Android 上默认是封装了 handler 的 MainThreadExecutor, 默认作用是：切换线程（子线程 -&gt; 主线程）    private @Nullable Executor callbackExecutor;    // 一个开关，为true则会缓存创建的ServiceMethod    private boolean validateEagerly;</code></pre><h4 id="2、Builder内部构造"><a href="#2、Builder内部构造" class="headerlink" title="2、Builder内部构造"></a>2、Builder内部构造</h4><p>下面看看Builder内部构造做了什么。</p><pre><code>public static final class Builder {    ...    Builder(Platform platform) {        this.platform = platform;    }    public Builder() {        this(Platform.get());    }    ...}class Platform {    private static final Platform PLATFORM = findPlatform();    static Platform get() {      return PLATFORM;    }    private static Platform findPlatform() {      try {        // 使用JVM加载类的方式判断是否是Android平台        Class.forName(&quot;android.os.Build&quot;);        if (Build.VERSION.SDK_INT != 0) {          return new Android();        }      } catch (ClassNotFoundException ignored) {      }      try {        // 同时支持Java平台        Class.forName(&quot;java.util.Optional&quot;);        return new Java8();      } catch (ClassNotFoundException ignored) {      }      return new Platform();    }static class Android extends Platform {    ...    @Override public Executor defaultCallbackExecutor() {        //切换线程（子线程 -&gt; 主线程）        return new MainThreadExecutor();    }    // 创建默认的网络请求适配器工厂，如果是Android7.0或Java8上，则使    // 用了并发包中的CompletableFuture保证了回调的同步    // 在Retrofit中提供了四种CallAdapterFactory(策略模式)：    // ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、    // va8CallAdapterFactory、RxJavaCallAdapterFactory    @Override List&lt;? extends CallAdapter.Factory&gt;     defaultCallAdapterFactories(        @Nullable Executor callbackExecutor) {      if (callbackExecutor == null) throw new AssertionError();      ExecutorCallAdapterFactory executorFactory = new   ExecutorCallAdapterFactory(callbackExecutor);      return Build.VERSION.SDK_INT &gt;= 24        ? asList(CompletableFutureCallAdapterFactory.INSTANCE,     executorFactory)        : singletonList(executorFactory);    }    ...    @Override List&lt;? extends Converter.Factory&gt;     defaultConverterFactories() {      return Build.VERSION.SDK_INT &gt;= 24          ? singletonList(OptionalConverterFactory.INSTANCE)          : Collections.&lt;Converter.Factory&gt;emptyList();    }    ...    static class MainThreadExecutor implements Executor {        // 获取Android 主线程的Handler         private final Handler handler = new   Handler(Looper.getMainLooper());        @Override public void execute(Runnable r) {            // 在UI线程对网络请求返回数据处理            handler.post(r);        }    }}</code></pre><p>可以看到，在Builder内部构造时设置了默认Platform、callAdapterFactories和callbackExecutor。</p><h4 id="3、添加baseUrl"><a href="#3、添加baseUrl" class="headerlink" title="3、添加baseUrl"></a>3、添加baseUrl</h4><p>很简单，就是将String类型的url转换为OkHttp的HttpUrl过程如下：</p><pre><code>/** * Set the API base URL. * * @see #baseUrl(HttpUrl) */public Builder baseUrl(String baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    return baseUrl(HttpUrl.get(baseUrl));}public Builder baseUrl(HttpUrl baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    List&lt;String&gt; pathSegments = baseUrl.pathSegments();    if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) {      throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; +     baseUrl);    }    this.baseUrl = baseUrl;    return this;}</code></pre><h4 id="4、添加GsonConverterFactory"><a href="#4、添加GsonConverterFactory" class="headerlink" title="4、添加GsonConverterFactory"></a>4、添加GsonConverterFactory</h4><p>首先，看到GsonConverterFactory.creat()的源码。</p><pre><code>public final class GsonConverterFactory extends Converter.Factory {    public static GsonConverterFactory create() {        return create(new Gson());    }    public static GsonConverterFactory create(Gson gson) {        if (gson == null) throw new NullPointerException(&quot;gson ==   null&quot;);        return new GsonConverterFactory(gson);    }    private final Gson gson;    // 创建了一个含有Gson对象实例的GsonConverterFactory    private GsonConverterFactory(Gson gson) {        this.gson = gson;    }</code></pre><p>然后，看看addConverterFactory()方法内部。</p><pre><code>public Builder addConverterFactory(Converter.Factory factory) {    converterFactories.add(checkNotNull(factory, &quot;factory null&quot;));    return this;}</code></pre><p>可知，这一步是将一个含有Gson对象实例的GsonConverterFactory放入到了数据转换器工厂converterFactories里。</p><h4 id="5、build过程"><a href="#5、build过程" class="headerlink" title="5、build过程"></a>5、build过程</h4><pre><code>public Retrofit build() {    if (baseUrl == null) {      throw new IllegalStateException(&quot;Base URL required.&quot;);    }    okhttp3.Call.Factory callFactory = this.callFactory;    if (callFactory == null) {        // 默认使用okhttp         callFactory = new OkHttpClient();    }    Executor callbackExecutor = this.callbackExecutor;    if (callbackExecutor == null) {        // Android默认的callbackExecutor        callbackExecutor = platform.defaultCallbackExecutor();    }    // Make a defensive copy of the adapters and add the defaultCall  adapter.    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);    // 添加默认适配器工厂在集合尾部    callAdapterFactories.addAll(platform.defaultCallAdapterFactorisca  llbackExecutor));    // Make a defensive copy of the converters.    List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(        1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());    // Add the built-in converter factory first. This prevents overriding its behavior but also    // ensures correct behavior when using converters thatconsumeall   types.    converterFactories.add(new BuiltInConverters());    converterFactories.addAll(this.converterFactories);    converterFactories.addAll(platform.defaultConverterFactories();    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);}</code></pre><p>可以看到，最终我们在Builder类中看到的6大核心对象都已经配置到Retrofit对象中了。</p><h3 id="三、创建网络请求接口实例过程"><a href="#三、创建网络请求接口实例过程" class="headerlink" title="三、创建网络请求接口实例过程"></a>三、创建网络请求接口实例过程</h3><p>retrofit.create()使用了外观模式和代理模式创建了网络请求的接口实例，我们分析下create方法。</p><pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {        // 判断是否需要提前缓存ServiceMethod对象        eagerlyValidateMethods(service);    }    // 使用动态代理拿到请求接口所有注解配置后，创建网络请求接口实例    return (T) Proxy.newProxyInstance(service.getClassLoader(), new     Class&lt;?&gt;[] { service },        new InvocationHandler() {          private final Platform platform = Platform.get();          private final Object[] emptyArgs = new Object[0];          @Override public Object invoke(Object proxy, Method method,   @Nullable Object[] args)              throws Throwable {            // If the method is a method from Object then defer to normal     invocation.            if (method.getDeclaringClass() == Object.class) {              return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {              return platform.invokeDefaultMethod(method, service, proxy,   args);            }            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);          }    }); }private void eagerlyValidateMethods(Class&lt;?&gt; service) {  Platform platform = Platform.get();  for (Method method : service.getDeclaredMethods()) {    if (!platform.isDefaultMethod(method)) {      loadServiceMethod(method);    }  }}</code></pre><p>继续看看loadServiceMethod的内部流程</p><pre><code>ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) {      result = serviceMethodCache.get(method);      if (result == null) {            // 解析注解配置得到了ServiceMethod            result = ServiceMethod.parseAnnotations(this, method);            // 可以看到，最终加入到ConcurrentHashMap缓存中            serviceMethodCache.put(method, result);      }    }    return result;}abstract class ServiceMethod&lt;T&gt; {  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method   method) {        // 通过RequestFactory解析注解配置（工厂模式、内部使用了建造者模式）        RequestFactory requestFactory =         RequestFactory.parseAnnotations(retrofit, method);        Type returnType = method.getGenericReturnType();        if (Utils.hasUnresolvableType(returnType)) {          throw methodError(method,              &quot;Method return type must not include a type variable or      wildcard: %s&quot;, returnType);        }        if (returnType == void.class) {          throw methodError(method, &quot;Service methods cannot return    void.&quot;);        }        // 最终是通过HttpServiceMethod构建的请求方法        return HttpServiceMethod.parseAnnotations(retrofit, method,         requestFactory);    }    abstract T invoke(Object[] args);}</code></pre><h4 id="以下为请求构造核心流程"><a href="#以下为请求构造核心流程" class="headerlink" title="以下为请求构造核心流程"></a>以下为请求构造核心流程</h4><p>根据RequestFactory#Builder构造方法和parseAnnotations方法的源码，可知的它的作用就是用来解析注解配置的。</p><pre><code>Builder(Retrofit retrofit, Method method) {    this.retrofit = retrofit;    this.method = method;    // 获取网络请求接口方法里的注释    this.methodAnnotations = method.getAnnotations();    // 获取网络请求接口方法里的参数类型           this.parameterTypes = method.getGenericParameterTypes();    // 获取网络请求接口方法里的注解内容        this.parameterAnnotationsArray = method.getParameterAnnotations();}</code></pre><p>接着看HttpServiceMethod.parseAnnotations()的内部流程。</p><pre><code>static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt;     parseAnnotations(      Retrofit retrofit, Method method, RequestFactory requestFactory) {        // 1.根据网络请求接口方法的返回值和注解类型，        // 从Retrofit对象中获取对应的网络请求适配器         CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =         createCallAdapter(retrofit, method);        // 得到响应类型        Type responseType = callAdapter.responseType();        ...        // 2.根据网络请求接口方法的返回值和注解类型，从Retrofit对象中获取对应的数据转换器         Converter&lt;ResponseBody, ResponseT&gt; responseConverter =            createResponseConverter(retrofit, method, responseType);        okhttp3.Call.Factory callFactory = retrofit.callFactory;        return new HttpServiceMethod&lt;&gt;(requestFactory, callFactory,         callAdapter, responseConverter);}</code></pre><h5 id="1-createCallAdapter-retrofit-method"><a href="#1-createCallAdapter-retrofit-method" class="headerlink" title="1.createCallAdapter(retrofit, method)"></a>1.createCallAdapter(retrofit, method)</h5><pre><code>private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt;     createCallAdapter(      Retrofit retrofit, Method method) {    // 获取网络请求接口里方法的返回值类型    Type returnType = method.getGenericReturnType();    // 获取网络请求接口接口里的注解    Annotation[] annotations = method.getAnnotations();    try {      //noinspection unchecked      return (CallAdapter&lt;ResponseT, ReturnT&gt;)  retrofit.callAdapter(returnType, annotations);    } catch (RuntimeException e) { // Wide exception range because         factories are user code.      throw methodError(method, e, &quot;Unable to create call adapter  for     %s&quot;, returnType);    }}public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) {    return nextCallAdapter(null, returnType, annotations);}public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,  Annotation[] annotations) {    ...    int start = callAdapterFactories.indexOf(skipPast) + 1;    // 遍历 CallAdapter.Factory 集合寻找合适的工厂    for (int i = start, count = callAdapterFactories.size(); i &lt;count; i++) {        CallAdapter&lt;?, ?&gt; adapter =    callAdapterFactories.get(i).get(returnType, annotations, this);        if (adapter != null) {          return adapter;        }    }}</code></pre><h5 id="2-createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType"><a href="#2-createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType" class="headerlink" title="2.createResponseConverter(Retrofit retrofit, Method method, Type responseType)"></a>2.createResponseConverter(Retrofit retrofit, Method method, Type responseType)</h5><pre><code> private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt;  createResponseConverter(     Retrofit retrofit, Method method, Type responseType) {   Annotation[] annotations = method.getAnnotations();   try {     return retrofit.responseBodyConverter(responseType,annotations);   } catch (RuntimeException e) { // Wide exception range because    factories are user code.     throw methodError(method, e, &quot;Unable to create converter for%s&quot;,   responseType);   }}public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) {    return nextResponseBodyConverter(null, type, annotations);}public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(  @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {...int start = converterFactories.indexOf(skipPast) + 1;// 遍历 Converter.Factory 集合并寻找合适的工厂, 这里是GsonResponseBodyConverterfor (int i = start, count = converterFactories.size(); i &lt; count; i++) {  Converter&lt;ResponseBody, ?&gt; converter =      converterFactories.get(i).responseBodyConverter(type, annotations, this);  if (converter != null) {    //noinspection unchecked    return (Converter&lt;ResponseBody, T&gt;) converter;  }}</code></pre><h4 id="最终，执行HttpServiceMethod的invoke方法"><a href="#最终，执行HttpServiceMethod的invoke方法" class="headerlink" title="最终，执行HttpServiceMethod的invoke方法"></a>最终，执行HttpServiceMethod的invoke方法</h4><pre><code>@Override ReturnT invoke(Object[] args) {    return callAdapter.adapt(        new OkHttpCall&lt;&gt;(requestFactory, args, callFactory,     responseConverter));}</code></pre><p>最终在adapt中创建了一个ExecutorCallbackCall对象，它是一个装饰者，而在它内部真正去执行网络请求的还是OkHttpCall。</p><h3 id="四、创建网络请求接口类实例并执行请求过程"><a href="#四、创建网络请求接口类实例并执行请求过程" class="headerlink" title="四、创建网络请求接口类实例并执行请求过程"></a>四、创建网络请求接口类实例并执行请求过程</h3><h4 id="1、service-listRepos"><a href="#1、service-listRepos" class="headerlink" title="1、service.listRepos()"></a>1、service.listRepos()</h4><pre><code>1、Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</code></pre><p>service对象是动态代理对象Proxy.newProxyInstance()，当调用getCall()时会被<br>它拦截，然后调用自身的InvocationHandler#invoke()，得到最终的Call对象。</p><h4 id="2、同步执行流程-repos-execute"><a href="#2、同步执行流程-repos-execute" class="headerlink" title="2、同步执行流程 repos.execute()"></a>2、同步执行流程 repos.execute()</h4><pre><code>@Override public Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already     executed.&quot;);      executed = true;      if (creationFailure != null) {        if (creationFailure instanceof IOException) {          throw (IOException) creationFailure;        } else if (creationFailure instanceof RuntimeException) {          throw (RuntimeException) creationFailure;        } else {          throw (Error) creationFailure;        }      }      call = rawCall;      if (call == null) {        try {          // 创建一个OkHttp的Request对象请求          call = rawCall = createRawCall();        } catch (IOException | RuntimeException | Error e) {          throwIfFatal(e); //  Do not assign a fatal error to     creationFailure.          creationFailure = e;          throw e;        }      }    }    if (canceled) {      call.cancel();    }    // 调用OkHttpCall的execute()发送网络请求（同步），    // 并解析网络请求返回的数据    return parseResponse(call.execute());}private okhttp3.Call createRawCall() throws IOException {    // 创建 一个okhttp3.Request    okhttp3.Call call =    callFactory.newCall(requestFactory.create(args));    if (call == null) {      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    }    return call;}Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {    ResponseBody rawBody = rawResponse.body();     // Remove the body&apos;s source (the only stateful object) so we can   pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(),     rawBody.contentLength()))        .build();        // 根据响应返回的状态码进行处理        int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) {      try {        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);      } finally {        rawBody.close();      }    }        if (code == 204 || code == 205) {      rawBody.close();      return Response.success(null, rawResponse);    }        ExceptionCatchingResponseBody catchingBody = new    ExceptionCatchingResponseBody(rawBody);    try {      // 将响应体转为Java对象      T body = responseConverter.convert(catchingBody);      return Response.success(body, rawResponse);    } catch (RuntimeException e) {      // If the underlying source threw an exception, propagate that     rather than indicating it was      // a runtime exception.      catchingBody.throwIfCaught();      throw e;    }}</code></pre><h4 id="3、异步请求流程-repos-enqueque"><a href="#3、异步请求流程-repos-enqueque" class="headerlink" title="3、异步请求流程 repos.enqueque"></a>3、异步请求流程 repos.enqueque</h4><pre><code>@Override public void enqueue(final Callback&lt;T&gt; callback) {    // 使用静态代理 delegate进行异步请求     delegate.enqueue(new Callback&lt;T&gt;() {      @Override       public void onResponse(Call&lt;T&gt; call, finalResponse&lt;T&gt;response)     {        // 线程切换，在主线程显示结果        callbackExecutor.execute(new Runnable() {            @Override              public void run() {            if (delegate.isCanceled()) {              callback.onFailure(ExecutorCallbackCall.this, newIOException(&quot;Canceled&quot;));            } else {              callback.onResponse(ExecutorCallbackCall.this,respons);            }          }        });      }      @Override       public void onFailure(Call&lt;T&gt; call, final Throwable t) {        callbackExecutor.execute(new Runnable() {          @Override public void run() {            callback.onFailure(ExecutorCallbackCall.this, t);          }        });      }    });}</code></pre><p>看看 delegate.enqueue 内部流程。</p><pre><code>@Override public void enqueue(final Callback&lt;T&gt; callback) {    okhttp3.Call call;    Throwable failure;    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);      executed = true;      call = rawCall;      failure = creationFailure;      if (call == null &amp;&amp; failure == null) {        try {          // 创建OkHttp的Request对象，再封装成OkHttp.call          // 方法同发送同步请求，此处上面已分析          call = rawCall = createRawCall();         } catch (Throwable t) {          failure = creationFailure = t;        }      }@Override public void enqueue(final Callback&lt;T&gt; callback) {  checkNotNull(callback, &quot;callback == null&quot;);  okhttp3.Call call;  Throwable failure;  ...  call.enqueue(new okhttp3.Callback() {    @Override public void onResponse(okhttp3.Call call,   okhttp3.Response rawResponse) {      Response&lt;T&gt; response;      try {        // 此处上面已分析        response = parseResponse(rawResponse);      } catch (Throwable e) {        throwIfFatal(e);        callFailure(e);        return;      }      try {        callback.onResponse(OkHttpCall.this, response);      } catch (Throwable t) {        t.printStackTrace();      }    }    @Override public void onFailure(okhttp3.Call call, IOException e) {      callFailure(e);    }    private void callFailure(Throwable e) {      try {        callback.onFailure(OkHttpCall.this, e);      } catch (Throwable t) {        t.printStackTrace();      }    }  });}</code></pre><p>如果你看到这里的话，恭喜你，你已经对Retrofit已经有一个比较深入的了解了，但是，笔者还是要建议大家自己主动配合着Retrofit最新版的源码一步步去彻底地认识它，只要这样，你才能看到它真实的内心，最后附上一张Stay的Retrofit源码流程图，要注意的是，这是V2.5之前版本的流程，但是，在看完上面的源码分析后，我们知道，主体流程是没有变化的。</p><p><img src="https://upload-images.jianshu.io/upload_images/625299-29a632638d9f518f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/891/format/webp" alt="image"></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>从本质上来说，Retrofit虽然只是一个RESTful 的HTTP 网络请求框架的封装库。但是，它内部通过 大量的设计模式 封装了 OkHttp，让使用者感到它非常简洁、易懂。它内部主要是用动态代理 的方式，动态将网络请求接口的注解 解析 成HTTP请求，最后执行请求的过程。好了，至此，我们的Android主流三方库源码分析的网络库分析部分已经完毕。接下来，将为大家带来最流行的图片加载框架Glide的源码分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Retrofit V2.5.0源码</p><p>2、Android进阶之光</p><p>3、<a href="https://www.jianshu.com/p/0c055ad46b6c" target="_blank" rel="external">Android：手把手带你 深入读懂 Retrofit 2.0 源码</a></p><p>4、<a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（一、深入理解OKHttp源码）</title>
      <link>http://yoursite.com/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sat, 01 Dec 2018 11:49:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细分析了View的核心源码—<a href="https://jsonchao.github.io/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Android的触摸事件传递机制</a>和<a href="https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Android View的绘制流程</a>，从这篇开始，笔者接下来将会陪大家深入分析目前Android中大部分的主流开源框架源码，从而能够让我们真正地去理解这些优秀开源框架背后的思想，真真切切地提升自己的内功。目前，这一系列的分析顺序如下：</p><pre><code>主流三方库：网络：1、OKHttp2、Retrofit图片：3、Glide数据库：4、GreenDao响应式编程：5、RxJava内存泄露：6、LeakCanary依赖注入：7、ButterKnife8、Dagger2事件总线：9、EventBus</code></pre><p>这一篇将会对Android的三方网络库OKHttp源码进行深入的分析，在阅读过OKHttp源码和大量其它优秀的OKHttp源码分析文章后，我发现只要搞懂以下这三块，就能<strong>证明你对OKHttp有了一个深入的理解</strong>。</p><ul><li>OKHttp请求流程</li><li>网络请求缓存处理</li><li>连接池</li></ul><p>首先，补充一点网络知识：</p><p>一些常用的状态码</p><ul><li>100~199：指示信息，表示请求已接收，继续处理</li><li>200~299：请求成功，表示请求已被成功接收、理解、接受</li><li>300~399：重定向，要完成请求必须进行更进一步的操作</li><li>400~499：客户端错误，请求有语法错误或请求无法实现</li><li>500~599：服务器端错误，服务器未能实现合法的请求</li></ul><h3 id="一、OKHttp请求流程"><a href="#一、OKHttp请求流程" class="headerlink" title="一、OKHttp请求流程"></a>一、OKHttp请求流程</h3><p>OKHttp内部的大致请求流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1916953-fc6439af2bfefddc.jpg?imageMogr2/auto-orient/" alt="image"></p><p>如下为使用OKHttp进行Get请求的步骤：</p><pre><code>//1.新建OKHttpClient客户端OkHttpClient client = new OkHttpClient();//新建一个Request对象Request request = new Request.Builder()        .url(url)        .build();//2.Response为OKHttp中的响应Response response = client.newCall(request).execute();</code></pre><h4 id="1-新建OKHttpClient客户端"><a href="#1-新建OKHttpClient客户端" class="headerlink" title="1.新建OKHttpClient客户端"></a>1.新建OKHttpClient客户端</h4><pre><code>OkHttpClient client = new OkHttpClient();public OkHttpClient() {    this(new Builder());}OkHttpClient(Builder builder) {    ....}</code></pre><p>可以看到，OkHttpClient使用了建造者模式，Builder里面的可配置参数如下：</p><pre><code>public static final class Builder {    Dispatcher dispatcher;//分发器    @Nullable Proxy proxy;    List&lt;Protocol&gt; protocols;    List&lt;ConnectionSpec&gt; connectionSpecs;//传输层版本和连接协议    final List&lt;Interceptor&gt; interceptors = new     ArrayList&lt;&gt;();//拦截器    final List&lt;Interceptor&gt; networkInterceptors = new     ArrayList&lt;&gt;();    EventListener.Factory eventListenerFactory;    ProxySelector proxySelector;    CookieJar cookieJar;    @Nullable Cache cache;    @Nullable InternalCache internalCache;//内部缓存    SocketFactory socketFactory;    @Nullable SSLSocketFactory sslSocketFactory;//安全套接层socket 工厂，用于HTTPS    @Nullable CertificateChainCleaner     certificateChainCleaner;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。    HostnameVerifier hostnameVerifier;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。    CertificatePinner certificatePinner;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。    Authenticator proxyAuthenticator;//代理身份验证    Authenticator authenticator;//代理身份验证    ConnectionPool connectionPool;//代理身份验证    Dns dns;    boolean followSslRedirects; //安全套接层重定向    boolean followRedirects;//本地重定向    boolean retryOnConnectionFailure;//重试连接失败    int callTimeout;    int connectTimeout;    int readTimeout;    int writeTimeout;    int pingInterval;    // 这里是默认配置的构建参数    public Builder() {        dispatcher = new Dispatcher();        protocols = DEFAULT_PROTOCOLS;        connectionSpecs = DEFAULT_CONNECTION_SPECS;        ...    }    // 这里传入自己配置的构建参数    Builder(OkHttpClient okHttpClient) {        this.dispatcher = okHttpClient.dispatcher;        this.proxy = okHttpClient.proxy;        this.protocols = okHttpClient.protocols;        this.connectionSpecs = okHttpClient.connectionSpecs;        this.interceptors.addAll(okHttpClient.interceptors);        this.networkInterceptors.addAll(okHttpClient.networkInterceptors);        ...    }</code></pre><h4 id="2-执行-同步-请求流程"><a href="#2-执行-同步-请求流程" class="headerlink" title="2.执行(同步)请求流程"></a>2.执行(同步)请求流程</h4><pre><code>Response response = client.newCall(request).execute();/*** Prepares the {@code request} to be executed at   some point in the future.*/@Override public Call newCall(Request request) {    return RealCall.newRealCall(this, request, false /*     for web socket */);}// RealCall为真正的请求执行者static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {    // Safely publish the Call instance to the EventListener.    RealCall call = new RealCall(client, originalRequest, forWebSocket);    call.eventListener = client.eventListenerFactory().create(call);    return call;}@Override public Response execute() throws IOException {    synchronized (this) {        // 每个Call只能执行一次        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);        executed = true;    }    captureCallStackTrace();    timeout.enter();    eventListener.callStart(this);    try {        // 通知dispatcher已经进入执行状态        client.dispatcher().executed(this);        // 通过一系列的拦截器请求处理和响应处理得到最终的返回结果        Response result =     getResponseWithInterceptorChain();        if (result == null) throw new     IOException(&quot;Canceled&quot;);        return result;    } catch (IOException e) {        e = timeoutExit(e);        eventListener.callFailed(this, e);        throw e;    } finally {        // 通知 dispatcher 自己已经执行完毕        client.dispatcher().finished(this);    }}Response getResponseWithInterceptorChain() throws IOException {    // Build a full stack of interceptors.    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();    // 在配置 OkHttpClient 时设置的 interceptors；    interceptors.addAll(client.interceptors());    // 负责失败重试以及重定向    interceptors.add(retryAndFollowUpInterceptor);    // 请求时，对必要的Header进行一些添加，接受响应时，移除必要的Header    interceptors.add(new     BridgeInterceptor(client.cookieJar()));    // 负责读取缓存直接返回、更新缓存    interceptors.add(new     CacheInterceptor(client.internalCache()));    // 负责和服务器建立连接    interceptors.add(new ConnectInterceptor(client));    if (!forWebSocket) {        // 配置 OkHttpClient 时设置的 networkInterceptors        interceptors.addAll(client.networkInterceptors())  ;    }    // 负责向服务器发送请求数据、从服务器读取响应数据    interceptors.add(new CallServerInterceptor(forWebSocket));    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,        originalRequest, this, eventListener, client.connectTimeoutMillis(),        client.readTimeoutMillis(), client.writeTimeoutMillis());    // 使用责任链模式开启链式调用    return chain.proceed(originalRequest);}// StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流// 和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,  RealConnection connection) throws IOException {    ...    // Call the next interceptor in the chain.    // 实例化下一个拦截器对应的RealIterceptorChain对象    RealInterceptorChain next = new     RealInterceptorChain(interceptors,     streamAllocation, httpCodec,        connection, index + 1, request, call,     eventListener, connectTimeout, readTimeout,        writeTimeout);    // 得到当前的拦截器    Interceptor interceptor = interceptors.get(index);    // 调用当前拦截器的intercept()方法，并将下一个拦截器的RealIterceptorChain对象传递下去,最后得到响应    Response response = interceptor.intercept(next);    ...    return response;}</code></pre><h4 id="3-异步请求的流程"><a href="#3-异步请求的流程" class="headerlink" title="3.异步请求的流程"></a>3.异步请求的流程</h4><pre><code>Request request = new Request.Builder()    .url(&quot;http://publicobject.com/helloworld.txt&quot;)    .build();client.newCall(request).enqueue(new Callback() {    @Override     public void onFailure(Call call, IOException e) {      e.printStackTrace();    }    @Override     public void onResponse(Call call, Response   response) throws IOException {        ...    }void enqueue(AsyncCall call) {synchronized (this) {    readyAsyncCalls.add(call);}    promoteAndExecute();}// 正在准备中的异步请求队列private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();// 运行中的异步请求private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();// 同步请求private final Deque&lt;RealCall&gt; runningSyncCalls = new   ArrayDeque&lt;&gt;();//  Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs// them on the executor service. Must not be called with synchronization because executing calls// can call into user code.private boolean promoteAndExecute() {    assert (!Thread.holdsLock(this));    List&lt;AsyncCall&gt; executableCalls = new     ArrayList&lt;&gt;();    boolean isRunning;    synchronized (this) {      for (Iterator&lt;AsyncCall&gt; i =   readyAsyncCalls.iterator(); i.hasNext(); ) {        AsyncCall asyncCall = i.next();        // 如果中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行，        // 同时利用线程池执行call；否者将call加入到readyAsyncCalls中。        if (runningAsyncCalls.size() &gt;= maxRequests)     break; // Max capacity.        if (runningCallsForHost(asyncCall) &gt;=     maxRequestsPerHost) continue; // Host max     capacity.        i.remove();        executableCalls.add(asyncCall);        runningAsyncCalls.add(asyncCall);      }      isRunning = runningCallsCount() &gt; 0;    }    for (int i = 0, size = executableCalls.size(); i &lt;     size; i++) {      AsyncCall asyncCall = executableCalls.get(i);      asyncCall.executeOn(executorService());    }    return isRunning;}</code></pre><p>最后，我们在看看AsynCall的代码。</p><pre><code>final class AsyncCall extends NamedRunnable {    private final Callback responseCallback;    AsyncCall(Callback responseCallback) {      super(&quot;OkHttp %s&quot;, redactedUrl());      this.responseCallback = responseCallback;    }    String host() {      return originalRequest.url().host();    }    Request request() {      return originalRequest;    }    RealCall get() {      return RealCall.this;    }    /**     * Attempt to enqueue this async call on {@code    executorService}. This will attempt to clean up     * if the executor has been shut down by reporting    the call as failed.     */    void executeOn(ExecutorService executorService) {      assert (!Thread.holdsLock(client.dispatcher()));      boolean success = false;      try {        executorService.execute(this);        success = true;      } catch (RejectedExecutionException e) {        InterruptedIOException ioException = new     InterruptedIOException(&quot;executor rejected&quot;);        ioException.initCause(e);        eventListener.callFailed(RealCall.this,     ioException);        responseCallback.onFailure(RealCall.this,     ioException);      } finally {        if (!success) {          client.dispatcher().finished(this); // This   call is no longer running!        }      }    }    @Override protected void execute() {      boolean signalledCallback = false;      timeout.enter();      try {        // 跟同步执行一样，最后都会调用到这里        Response response =     getResponseWithInterceptorChain();        if (retryAndFollowUpInterceptor.isCanceled()) {          signalledCallback = true;          responseCallback.onFailure(RealCall.this, new   IOException(&quot;Canceled&quot;));        } else {          signalledCallback = true;          responseCallback.onResponse(RealCall.this,   response);        }      } catch (IOException e) {        e = timeoutExit(e);        if (signalledCallback) {          // Do not signal the callback twice!          Platform.get().log(INFO, &quot;Callback failure   for &quot; + toLoggableString(), e);        } else {          eventListener.callFailed(RealCall.this, e);          responseCallback.onFailure(RealCall.this, e);        }      } finally {        client.dispatcher().finished(this);      }    }}</code></pre><p>从上面的源码可以知道，拦截链的处理OKHttp帮我们默认做了五步拦截处理，其中RetryAndFollowUpInterceptor、BridgeInterceptor、CallServerInterceptor内部的源码很简洁易懂，此处不再多说，下面将对OKHttp最为核心的两部分缓存处理和连接处理（连接池）进行讲解。   </p><h3 id="二、网络请求缓存处理之CacheInterceptor"><a href="#二、网络请求缓存处理之CacheInterceptor" class="headerlink" title="二、网络请求缓存处理之CacheInterceptor"></a>二、网络请求缓存处理之CacheInterceptor</h3><pre><code>@Override public Response intercept(Chain chain) throws IOException {    // 根据request得到cache中缓存的response    Response cacheCandidate = cache != null        ? cache.get(chain.request())        : null;    long now = System.currentTimeMillis();    // request判断缓存的策略，是否要使用了网络，缓存或两者都使用    CacheStrategy strategy = new     CacheStrategy.Factory(now, chain.request(),     cacheCandidate).get();    Request networkRequest = strategy.networkRequest;    Response cacheResponse = strategy.cacheResponse;    if (cache != null) {      cache.trackResponse(strategy);    }    if (cacheCandidate != null &amp;&amp; cacheResponse ==     null) {      closeQuietly(cacheCandidate.body()); // The cache   candidate wasn&apos;t applicable. Close it.    }    // If we&apos;re forbidden from using the network and     the cache is insufficient, fail.    if (networkRequest == null &amp;&amp; cacheResponse ==     null) {      return new Response.Builder()          .request(chain.request())          .protocol(Protocol.HTTP_1_1)          .code(504)          .message(&quot;Unsatisfiable Request   (only-if-cached)&quot;)          .body(Util.EMPTY_RESPONSE)          .sentRequestAtMillis(-1L)          .receivedResponseAtMillis(System.currentTimeM  illis())          .build();    }    // If we don&apos;t need the network, we&apos;re done.    if (networkRequest == null) {      return cacheResponse.newBuilder()          .cacheResponse(stripBody(cacheResponse))          .build();    }    Response networkResponse = null;    try {        // 调用下一个拦截器，决定从网络上来得到response        networkResponse = chain.proceed(networkRequest);    } finally {        // If we&apos;re crashing on I/O or otherwise,   don&apos;t   leak the cache body.        if (networkResponse == null &amp;&amp; cacheCandidate   !=   null) {          closeQuietly(cacheCandidate.body());        }    }    // If we have a cache response too, then we&apos;re     doing a conditional get.    // 如果本地已经存在cacheResponse，那么让它和网络得到的networkResponse做比较，决定是否来更新缓存的cacheResponse    if (cacheResponse != null) {        if (networkResponse.code() ==   HTTP_NOT_MODIFIED)   {          Response response =     cacheResponse.newBuilder()                  .headers(combine(cacheResponse.headers(    ),     networkResponse.headers()))                  .sentRequestAtMillis(networkResponse.se    ntRe    questAtMillis())                  .receivedResponseAtMillis(networkRespon    se.r    eceivedResponseAtMillis())                  .cacheResponse(stripBody(cacheResponse)    )                  .networkResponse(stripBody(networkRespo    nse)    )              .build();          networkResponse.body().close();          // Update the cache after combining headers     but     before stripping the          // Content-Encoding header (as performed by         initContentStream()).          cache.trackConditionalCacheHit();          cache.update(cacheResponse, response);          return response;        } else {          closeQuietly(cacheResponse.body());        }    }    Response response = networkResponse.newBuilder()        .cacheResponse(stripBody(cacheResponse))        .networkResponse(stripBody(networkResponse))        .build();    if (cache != null) {      if (HttpHeaders.hasBody(response) &amp;&amp;   CacheStrategy.isCacheable(response,   networkRequest)) {        // Offer this request to the cache.        // 缓存未经缓存过的response        CacheRequest cacheRequest =     cache.put(response);        return cacheWritingResponse(cacheRequest,     response);      }      if (HttpMethod.invalidatesCache(networkRequest.me  thod())) {        try {          cache.remove(networkRequest);        } catch (IOException ignored) {          // The cache cannot be written.        }      }    }    return response;}</code></pre><p>缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存给用户，否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。</p><h3 id="三、ConnectInterceptor之连接池"><a href="#三、ConnectInterceptor之连接池" class="headerlink" title="三、ConnectInterceptor之连接池"></a>三、ConnectInterceptor之连接池</h3><pre><code>@Override public Response intercept(Chain chain) throws IOException {    RealInterceptorChain realChain =     (RealInterceptorChain) chain;    Request request = realChain.request();    StreamAllocation streamAllocation =     realChain.streamAllocation();    // We need the network to satisfy this request.     Possibly for validating a conditional GET.    boolean doExtensiveHealthChecks =     !request.method().equals(&quot;GET&quot;);    // HttpCodec是对 HTTP 协议操作的抽象，有两个实现：Http1Codec和Http2Codec，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。在这个方法的内部实现连接池的复用处理    HttpCodec httpCodec =     streamAllocation.newStream(client, chain,     doExtensiveHealthChecks);    RealConnection connection =     streamAllocation.connection();    return realChain.proceed(request, streamAllocation,     httpCodec, connection);}// Returns a connection to host a new stream. This // prefers the existing connection if it exists,// then the pool, finally building a new connection.// 调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列// 的判断到达 StreamAllocation 中的 findConnection() 方法private RealConnection findConnection(int   connectTimeout, int readTimeout, int writeTimeout,    int pingIntervalMillis, boolean   connectionRetryEnabled) throws IOException {      ...      // Attempt to use an already-allocated       connection. We need to be careful here because       our      // already-allocated connection may have been       restricted from creating new streams.      // 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流      releasedConnection = this.connection;      // 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接      toClose = releaseIfNoNewStreams();      if (this.connection != null) {        // We had an already-allocated connection and       it&apos;s good.        result = this.connection;        releasedConnection = null;      }      if (!reportedAcquired) {        // If the connection was never reported       acquired, don&apos;t report it as released!        // 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire()   方法修改        releasedConnection = null;      }      if (result == null) {        // Attempt to get a connection from the pool.        // 尝试供连接池中获取一个连接        Internal.instance.get(connectionPool,   address,     this, null);        if (connection != null) {          foundPooledConnection = true;          result = connection;        } else {          selectedRoute = route;        }      }    }    // 关闭连接    closeQuietly(toClose);    if (releasedConnection != null) {      eventListener.connectionReleased(call,       releasedConnection);    }    if (foundPooledConnection) {      eventListener.connectionAcquired(call, result);    }    if (result != null) {      // If we found an already-allocated or pooled       connection, we&apos;re done.      // 如果已经从连接池中获取到了一个连接，就将其返回      return result;    }    // If we need a route selection, make one. This   is     a blocking operation.    boolean newRouteSelection = false;    if (selectedRoute == null &amp;&amp; (routeSelection ==       null || !routeSelection.hasNext())) {      newRouteSelection = true;      routeSelection = routeSelector.next();    }    synchronized (connectionPool) {      if (canceled) throw new     IOException(&quot;Canceled&quot;);      if (newRouteSelection) {        // Now that we have a set of IP addresses,   make     another attempt at getting a   connection from        // the pool. This could match due to   connection     coalescing.         // 根据一系列的 IP地址从连接池中获取一个链接        List&lt;Route&gt; routes = routeSelection.getAll();        for (int i = 0, size = routes.size(); i &lt;   size;     i++) {          Route route = routes.get(i);          // 从连接池中获取一个连接          Internal.instance.get(connectionPool,       address, this, route);          if (connection != null) {            foundPooledConnection = true;            result = connection;            this.route = route;            break;          }        }      }      if (!foundPooledConnection) {        if (selectedRoute == null) {          selectedRoute = routeSelection.next();        }        // Create a connection and assign it to this       allocation immediately. This makes it   possible        // for an asynchronous cancel() to interrupt       the handshake we&apos;re about to do.        // 在连接池中如果没有该连接，则创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端        route = selectedRoute;        refusedStreamCount = 0;        result = new RealConnection(connectionPool,       selectedRoute);        acquire(result, false);      }    }    // If we found a pooled connection on the 2nd time around, we&apos;re done.    if (foundPooledConnection) {    // 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回      eventListener.connectionAcquired(call, result);      return result;    }    // Do TCP + TLS handshakes. This is a blocking     operation.     // 进行 TCP 和 TLS 握手    result.connect(connectTimeout, readTimeout,     writeTimeout, pingIntervalMillis,        connectionRetryEnabled, call, eventListener);    routeDatabase().connected(result.route());    Socket socket = null;    synchronized (connectionPool) {      reportedAcquired = true;      // Pool the connection.      // 将该连接放进连接池中      Internal.instance.put(connectionPool, result);      // If another multiplexed connection to the same   address was created concurrently, then      // release this connection and acquire that one.      // 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接      if (result.isMultiplexed()) {        socket =     Internal.instance.deduplicate(connectionPool,     address, this);        result = connection;      }    }    closeQuietly(socket);    eventListener.connectionAcquired(call, result);    return result;}</code></pre><p>从以上的源码分析可知：</p><ul><li>判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流；</li><li>如果当前的连接无法使用，就从连接池中获取一个连接；</li><li>连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。</li></ul><p>在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。并且，从中我们明白了连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。</p><p>接下来，我们来详细分析下ConnectionPool是如何实现连接管理的。</p><p>OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。</p><pre><code>private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();void put(RealConnection connection) {assert (Thread.holdsLock(this));    if (!cleanupRunning) {      cleanupRunning = true;      // 使用线程池执行清理任务      executor.execute(cleanupRunnable);    }    // 将新建的连接插入到双端队列中    connections.add(connection);} private final Runnable cleanupRunnable = new Runnable() {@Override public void run() {    while (true) {        // 内部调用 cleanup() 方法来清理无效的连接        long waitNanos = cleanup(System.nanoTime());        if (waitNanos == -1) return;        if (waitNanos &gt; 0) {          long waitMillis = waitNanos / 1000000L;          waitNanos -= (waitMillis * 1000000L);          synchronized (ConnectionPool.this) {            try {              ConnectionPool.this.wait(waitMillis,     (int) waitNanos);            } catch (InterruptedException ignored) {            }          }        }    }};long cleanup(long now) {    int inUseConnectionCount = 0;    int idleConnectionCount = 0;    RealConnection longestIdleConnection = null;    long longestIdleDurationNs = Long.MIN_VALUE;    // Find either a connection to evict, or the time     that the next eviction is due.    synchronized (this) {        // 遍历所有的连接        for (Iterator&lt;RealConnection&gt; i =     connections.iterator(); i.hasNext(); ) {          RealConnection connection = i.next();          // If the connection is in use, keep     searching.          // 遍历所有的连接          if (pruneAndGetAllocationCount(connection,     now)     &gt; 0) {            inUseConnectionCount++;            continue;          }          idleConnectionCount++;          // If the connection is ready to be     evicted,     we&apos;re done.          // 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放          long idleDurationNs = now -         connection.idleAtNanos;          if (idleDurationNs &gt; longestIdleDurationNs)     {            longestIdleDurationNs = idleDurationNs;            longestIdleConnection = connection;          }        }        // maxIdleConnections 表示最大允许的闲置的连接的数量,keepAliveDurationNs表示连接允许存活的最长的时间。默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。        if (longestIdleDurationNs &gt;=     this.keepAliveDurationNs            || idleConnectionCount &gt;     this.maxIdleConnections) {          // We&apos;ve found a connection to evict.     Remove it     from the list, then close it     below (outside          // of the synchronized block).          // 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除          connections.remove(longestIdleConnection);        } else if (idleConnectionCount &gt; 0) {          // A connection will be ready to evict     soon.          // 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候）          return keepAliveDurationNs -         longestIdleDurationNs;        } else if (inUseConnectionCount &gt; 0) {          // All connections are in use. It&apos;ll be at         least the keep alive duration &apos;til we     run     again.          // 所有的连接都在使用中，5分钟后再清理          return keepAliveDurationNs;        } else {          // No connections, idle or in use.           // 没有连接          cleanupRunning = false;          return -1;      }}</code></pre><p>从以上的源码分析可知，首先会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>经过上面对OKHttp内部工作机制的一系列分析，我相信你已经对OKHttp已经有了一个很深入的理解了。首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。其中，除了OKHttp的内部请求流程这点之外，缓存和连接这两部分内容也是两个很重要的点，相信经过本文的讲解，读者对着三部分重点内容已经有了自己的理解。后面，将会为大家带来OKHttp的封装框架Retrofit源码的深入分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、OKHttp V3.12.0源码</p><p>1、Android进阶之光</p><p>2、<a href="https://www.jianshu.com/p/27c1554b7fee" target="_blank" rel="external">OKHttp源码解析</a></p><p>3、<a href="https://juejin.im/post/5bc89fbc5188255c713cb8a5#heading-10" target="_blank" rel="external">Andriod 网络框架 OkHttp 源码解析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android View的绘制流程</title>
      <link>http://yoursite.com/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</link>
      <guid>http://yoursite.com/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Sun, 28 Oct 2018 12:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>上一篇中我们讲到了<a href="https://jsonchao.github.io/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Android的触摸事件传递机制</a>，除此之外，关于Android View的绘制流程这一块也是View相关的核心知识点。我们都知道，PhoneWindow是Android系统中最基本的窗口系统，每个Activity会创建一个。同时，PhoneWindow也是Activity和View系统交互的接口。DecorView本质上是一个FrameLayout，是Activity中所有View的祖先。</p><h3 id="一、开始：DecorView被加载到Window中"><a href="#一、开始：DecorView被加载到Window中" class="headerlink" title="一、开始：DecorView被加载到Window中"></a>一、开始：DecorView被加载到Window中</h3><p>从Activity的startActivity开始，最终调用到ActivityThread的handleLaunchActivity方法来创建Activity，相关核心代码如下：</p><pre><code>private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {    ....    // 创建Activity，会调用Activity的onCreate方法    // 从而完成DecorView的创建    Activity a = performLaunchActivity(r, customIntent);    if (a != null) {        r.createdConfig = new Configuration(mConfiguration);        Bundle oldState = r.state;        handleResumeActivity(r.tolen, false, r.isForward, !r.activity..mFinished &amp;&amp; !r.startsNotResumed);    }}final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) {    unscheduleGcIdler();    mSomeActivitiesChanged = true;    // 调用Activity的onResume方法    ActivityClientRecord r = performResumeActivity(token, clearHide);    if (r != null) {        final Activity a = r.activity;        ...        if (r.window == null &amp;&amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {            r.window = r.activity.getWindow();            // 得到DecorView            View decor = r.window.getDecorView();            decor.setVisibility(View.INVISIBLE);            // 得到了WindowManager，WindowManager是一个接口            // 并且继承了接口ViewManager            ViewManager wm = a.getWindowManager();            WindowManager.LayoutParams l = r.window.getAttributes();            a.mDecor = decor;            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;            l.softInputMode |= forwardBit;            if (a.mVisibleFromClient) {                a.mWindowAdded = true;                // WindowManager的实现类是WindowManagerImpl，                // 所以实际调用的是WindowManagerImpl的addView方法                wm.addView(decor, l);            }        }    }}public final class WindowManagerImpl implements WindowManager {    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();    ...    @Override    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {        applyDefaultToken(params);        mGlobal.addView(view, params, mDisplay, mParentWindow);    }    ...}</code></pre><p>在了解View绘制的整体流程之前，我们必须先了解下ViewRoot和DecorView的概念。ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，相关源码如下所示：</p><pre><code>// WindowManagerGlobal的addView方法public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {    ...    ViewRootImpl root;    View pannelParentView = null;    synchronized (mLock) {        ...        // 创建ViewRootImpl实例        root = new ViewRootImpl(view..getContext(), display);        view.setLayoutParams(wparams);        mViews.add(view);        mRoots.add(root);        mParams.add(wparams);    }    try {        // 把DecorView加载到Window中        root.setView(view, wparams, panelParentView);    } catch (RuntimeException e) {        synchronized (mLock) {            final int index = findViewLocked(view, false);            if (index &gt;= 0) {                removeViewLocked(index, true);            }        }        throw e;    }}</code></pre><h3 id="二、了解绘制的整体流程"><a href="#二、了解绘制的整体流程" class="headerlink" title="二、了解绘制的整体流程"></a>二、了解绘制的整体流程</h3><p>绘制会从根视图ViewRoot的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。performTraversals()的核心代码如下。</p><pre><code>private void performTraversals() {    ...    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);    ...    //执行测量流程    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    ...    //执行布局流程    performLayout(lp, desiredWindowWidth, desiredWindowHeight);    ...    //执行绘制流程    performDraw();}</code></pre><p>performTraversals的大致工作流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1967257-f245ffbefe056fb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>注意：</p><ul><li>preformLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的，不过这并没有本质区别。</li><li>获取content：</li></ul><pre><code>ViewGroup content = (ViewGroup)findViewById(android.R.id.content);</code></pre><ul><li>获取设置的View：</li></ul><pre><code>content.getChildAt(0);</code></pre><h3 id="三、理解MeasureSpec"><a href="#三、理解MeasureSpec" class="headerlink" title="三、理解MeasureSpec"></a>三、理解MeasureSpec</h3><h5 id="1-MeasureSpec源码解析"><a href="#1-MeasureSpec源码解析" class="headerlink" title="1.MeasureSpec源码解析"></a>1.MeasureSpec源码解析</h5><p>MeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。MeasureSpec是View类的一个静态内部类，用来说明应该如何测量这个View。MeasureSpec的核心代码如下。</p><pre><code>public static class MeasureSpec {    private static final int MODE_SHIFT = 30;    private static final int MODE_MASK = 0X3 &lt;&lt; MODE_SHIFT;    // 不指定测量模式, 父视图没有限制子视图的大小，子视图可以是想要    // 的任何尺寸，通常用于系统内部，应用开发中很少用到。    public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;    // 精确测量模式，视图宽高指定为match_parent或具体数值时生效，    // 表示父视图已经决定了子视图的精确大小，这种模式下View的测量    // 值就是SpecSize的值。    public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;    // 最大值测量模式，当视图的宽高指定为wrap_content时生效，此时    // 子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。    public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;    // 根据指定的大小和模式创建一个MeasureSpec    public static int makeMeasureSpec(int size, int mode) {        if (sUseBrokenMakeMeasureSpec) {            return size + mode;        } else {            return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);        }    }    // 微调某个MeasureSpec的大小    static int adjust(int measureSpec, int delta) {        final int mode = getMode(measureSpec);        if (mode == UNSPECIFIED) {            // No need to adjust size for UNSPECIFIED mode.            return make MeasureSpec(0, UNSPECIFIED);        }        int size = getSize(measureSpec) + delta;        if (size &lt; 0) {            size = 0;        }        return makeMeasureSpec(size, mode);    }}</code></pre><p>MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包的方法，打包方法为上述源码中的makeMeasureSpec，解包方法源码如下：</p><pre><code>public static int getMode(int measureSpec) {    return (measureSpec &amp; MODE_MASK);}public static int getSize(int measureSpec) {    return (measureSpec &amp; ~MODE_MASK);}</code></pre><h5 id="2-DecorView的MeasureSpec的创建过程："><a href="#2-DecorView的MeasureSpec的创建过程：" class="headerlink" title="2.DecorView的MeasureSpec的创建过程："></a>2.DecorView的MeasureSpec的创建过程：</h5><pre><code>//desiredWindowWidth和desiredWindowHeight是屏幕的尺寸childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);private static int getRootMeaureSpec(int windowSize, int rootDimension) {    int measureSpec;    switch (rootDimension) {        case ViewGroup.LayoutParams.MATRCH_PARENT:            // Window can&apos;t resize. Force root view to be windowSize.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);            break;        case ViewGroup.LayoutParams.WRAP_CONTENT：            // Window can resize. Set max size for root view.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);            break        default:            // Window wants to be an exact size. Force root view to be that size.            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);            break;    }    return measureSpec;}</code></pre><h5 id="3-子元素的MeasureSpec的创建过程"><a href="#3-子元素的MeasureSpec的创建过程" class="headerlink" title="3.子元素的MeasureSpec的创建过程"></a>3.子元素的MeasureSpec的创建过程</h5><pre><code>// ViewGroup的measureChildWithMargins方法protected void measureChildWithMargins(View child,int parentWidthMeasureSpec, int widthUsed,int parentHeightMeasureSpec, int heightUsed) {    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();    // 子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身    // 的LayoutParams有关，此外还和View的margin及padding有关    final int childWidthMeasureSpec = getChildMeasureSpec(    parentWidthMeasureSpec,    mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed,     lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(    parentHeightMeasureSpec,    mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed,     lp.height);    child..measure(childWidthMeasureSpec, childHeightMeasureSpec);}public static int getChildMeasureSpec(int spec, int padding, int childDimesion) {    int specMode = MeasureSpec.getMode(spec);    int specSize = MeasureSpec.getSize(spec);    // padding是指父容器中已占用的空间大小，因此子元素可用的    // 大小为父容器的尺寸减去padding    int size = Math.max(0, specSize - padding);    int resultSize = 0;    int resultMode = 0;    switch (sepcMode) {        // Parent has imposed an exact size on us        case MeasureSpec.EXACTLY:            if (childDimension &gt;= 0) {                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size. So be it.                resultSize = size;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimesion == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&apos;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // Parent has imposed a maximum size on us         case MeasureSpec.AT_MOST:            if (childDimension &gt;= 0) {                // Child wants a specific size... so be it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size, but our size is not fixed.                // Constrain child to not be bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&apos;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // Parent asked to see how big we want to be        case MeasureSpec.UNSPECIFIED:            if (childDimension &gt;= 0) {                // Child wants a specific size... let him have it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size... find out how big it should be                resultSize = 0;                resultMode = MeasureSpec.UNSPECIFIED;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size....                // find out how big it should be                resultSize = 0;                resultMode == MeasureSpec.UNSPECIFIED;            }            break;        }    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}</code></pre><p>普通View的MeasureSpec的创建规则如下：</p><p><img src="https://images2015.cnblogs.com/blog/918357/201706/918357-20170618234001337-203688773.png" alt="image"></p><p>注意：UNSPECIFIED模式主要用于系统内部多次Measure的情形，一般不需关注。</p><p>结论：对于DecorView而言，它的MeasureSpec由窗口尺寸和其自身的LayoutParams共同决定；对于普通的View，它的MeasureSpec由父视图的MeasureSpec和其自身的LayoutParams共同决定。</p><h3 id="四、View绘制流程之Measure"><a href="#四、View绘制流程之Measure" class="headerlink" title="四、View绘制流程之Measure"></a>四、View绘制流程之Measure</h3><h5 id="1-Measure的基本流程"><a href="#1-Measure的基本流程" class="headerlink" title="1.Measure的基本流程"></a>1.Measure的基本流程</h5><p>由前面的分析可知，页面的测量流程是从performMeasure方法开始的，相关的核心代码流程如下。</p><pre><code>private void perormMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {    ...    // 具体的测量操作分发给ViewGroup    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);    ...}// 在ViewGroup中的measureChildren()方法中遍历测量ViewGroup中所有的Viewprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {    final int size = mChildrenCount;    final View[] children = mChildren;    for (int i = 0; i &lt; size; ++i) {        final View child = children[i];        // 当View的可见性处于GONE状态时，不对其进行测量        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {            measureChild(child, widthMeasureSpec, heightMeasureSpec);        }    }}// 测量某个指定的Viewprotected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) {    final LayoutParams lp = child.getLayoutParams();    // 根据父容器的MeasureSpec和子View的LayoutParams等信息计算    // 子View的MeasureSpec    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height);    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);}// View的measure方法public final void measure(int widthMeasureSpec, int heightMeasureSpec) {    ...    // ViewGroup没有定义测量的具体过程，因为ViewGroup是一个    // 抽象类，其测量过程的onMeasure方法需要各个子类去实现    onMeasure(widthMeasureSpec, heightMeasureSpec);    ...}// 不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同，如果需要自定义测量过程，则子类可以重写这个方法protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    // setMeasureDimension方法用于设置View的测量宽高    setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),     getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));}// 如果View没有重写onMeasure方法，则会默认调用getDefaultSize来获得View的宽高public static int getDefaultSize(int size, int measureSpec) {    int result = size;    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {        case MeasureSpec.UNSPECIFIED:            result = size;            break;        case MeasureSpec.AT_MOST:        case MeasureSpec.EXACTLY:            result = sepcSize;            break;    }    return result;}</code></pre><h5 id="2-对getSuggestMinimumWidth的分析"><a href="#2-对getSuggestMinimumWidth的分析" class="headerlink" title="2.对getSuggestMinimumWidth的分析"></a>2.对getSuggestMinimumWidth的分析</h5><pre><code>protected int getSuggestedMinimumWidth() {    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinmumWidth());}protected int getSuggestedMinimumHeight() {    return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());}public int getMinimumWidth() {    final int intrinsicWidth = getIntrinsicWidth();    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;}</code></pre><p>如果View没有设置背景，那么返回android:minWidth这个属性所指定的值，这个值可以为0；如果View设置了背景，则返回android:minWidth和背景的最小宽度这两者中的最大值。</p><h5 id="3-自定义View时手动处理wrap-content时的情形"><a href="#3-自定义View时手动处理wrap-content时的情形" class="headerlink" title="3.自定义View时手动处理wrap_content时的情形"></a>3.自定义View时手动处理wrap_content时的情形</h5><p>直接继承View的控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。解决方式如下：</p><pre><code>protected void onMeasure(int widthMeasureSpec, int height MeasureSpec) {    super.onMeasure(widthMeasureSpec, heightMeasureSpec);    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);    int widtuhSpecSize = MeasureSpec.getSize(widthMeasureSpec);    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);    // 在wrap_content的情况下指定内部宽/高(mWidth和mHeight)    int heightSpecSize = MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) {        setMeasuredDimension(mWidth, mHeight);    } else if (widthSpecMode == MeasureSpec.AT_MOST) {        setMeasureDimension(mWidth, heightSpecSize);    } else if (heightSpecMode == MeasureSpec.AT_MOST) {        setMeasureDimension(widthSpecSize, mHeight);    }}</code></pre><h5 id="4-LinearLayout的onMeasure方法实现解析"><a href="#4-LinearLayout的onMeasure方法实现解析" class="headerlink" title="4.LinearLayout的onMeasure方法实现解析"></a>4.LinearLayout的onMeasure方法实现解析</h5><pre><code>protected void onMeasure(int widthMeasureSpec, int hegithMeasureSpec) {    if (mOrientation == VERTICAL) {        measureVertical(widthMeasureSpec, heightMeasureSpec);    } else {        measureHorizontal(widthMeasureSpec, heightMeasureSpec);    }}// measureVertical核心源码// See how tall everyone is. Also remember max width.for (int i = 0; i &lt; count; ++i) {    final View child = getVirtualChildAt(i);    ...    // Determine how big this child would like to be. If this or     // previous children have given a weight, then we allow it to     // use all available space (and we will shrink things later     // if need)    measureChildBeforeLayout(            child, i, widthMeasureSpec, 0, heightMeasureSpec,            totalWeight == 0 ? mTotalLength : 0);    if (oldHeight != Integer.MIN_VALUE) {        lp.height = oldHeight;    }    final int childHeight = child.getMeasuredHeight();    final int totalLength = mTotalLength;    mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +     lp.bottomMargin + getNextLocationOffset(child));}</code></pre><p>系统会遍历子元素并对每个子元素执行measureChildBeforeLayout方法，这个方法内部会调用子元素的measure方法，这样各个子元素就开始依次进入measure过程，并且系统会通过mTotalLength这个变量来存储LinearLayout在竖直方向的初步高度。每测量一个子元素，mTotalLength就会增加，增加的部分主要包括了子元素的高度以及子元素在竖直方向上的margin等。</p><pre><code>// LinearLayout测量自己大小的核心源码// Add in our paddingmTotalLength += mPaddingTop + mPaddingBottom;int heightSize = mTotalLength;// Check against our minimum heightheightSize = Math.max(heightSize, getSuggestedMinimumHeight());// Reconcile our calculated size with the heightMeasureSpecint heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK；...setMeasuredDimension(resolveSizeAndSize(maxWidth, widthMeasureSpec, childState),heightSizeAndState);public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {    int result = size;    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {        case MeasureSpec.UNSPECIFIED:            result = size;            break;        case MeasureSpec.AT_MOST:            // 高度不能超过父容器的剩余空间            if (specSize &lt; size) {                result = specSize | MEASURED_STATE_TOO_SMALL；            } else {                result = size;            }            break;        case MeasureSpec.EXACTLY:            result = specSize;            break;    }    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);}</code></pre><h5 id="5-在Activity中获取某个View的宽高"><a href="#5-在Activity中获取某个View的宽高" class="headerlink" title="5.在Activity中获取某个View的宽高"></a>5.在Activity中获取某个View的宽高</h5><p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。解决方式如下：</p><ul><li>Activity/View#onWindowFocusChanged</li></ul><pre><code>// 此时View已经初始化完毕// 当Activity的窗口得到焦点和失去焦点时均会被调用一次// 如果频繁地进行onResume和onPause，那么onWindowFocusChanged也会被频繁地调用public void onWindowFocusChanged(boolean hasFocus) {    super.onWindowFocusChanged(hasFocus);    if (hasFocus) {        int width = view.getMeasureWidth();        int height = view.getMeasuredHeight();    }}</code></pre><ul><li>view.post(runnable)</li></ul><pre><code>// 通过post可以将一个runnable投递到消息队列的尾部，// 然后等待Looper调用次runnable的时候，View也已经初// 始化好了protected void onStart() {    super.onStart();    view.post(new Runnable() {        @Override        public void run() {            int width = view.getMeasuredWidth();            int height = view.getMeasuredHeight();        }    });}</code></pre><ul><li>ViewTreeObserver</li></ul><pre><code>// 当View树的状态发生改变或者View树内部的View的可见// 性发生改变时，onGlobalLayout方法将被回调protected void onStart() {    super.onStart();    ViewTreeObserver observer = view.getViewTreeObserver();    observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {        @SuppressWarnings(&quot;deprecation&quot;)        @Override        public void onGlobalLayout() {            view.getViewTreeObserver().removeGlobalOnLayoutListener(this);            int width = view.getMeasuredWidth();            int height = view.getMeasuredHeight();        }    });}</code></pre><ul><li>View.measure(int widthMeasureSpec, int heightMeasureSpec)</li></ul><h3 id="五、View的绘制流程之Layout"><a href="#五、View的绘制流程之Layout" class="headerlink" title="五、View的绘制流程之Layout"></a>五、View的绘制流程之Layout</h3><h5 id="1-Layout的基本流程"><a href="#1-Layout的基本流程" class="headerlink" title="1.Layout的基本流程"></a>1.Layout的基本流程</h5><pre><code>// ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) {    ...    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());    ...}// View.javapublic void layout(int l, int t, int r, int b) {    ...    // 通过setFrame方法来设定View的四个顶点的位置，即View在父容器中的位置    boolean changed = isLayoutModeOptical(mParent) ?     set OpticalFrame(l, t, r, b) : setFrame(l, t, r, b);    ...    onLayout(changed, l, t, r, b);    ...}// 空方法，子类如果是ViewGroup类型，则重写这个方法，实现ViewGroup// 中所有View控件布局流程protected void onLayout(boolean changed, int left, int top, int right, int bottom) {}</code></pre><h5 id="2-LinearLayout的onLayout方法实现解析"><a href="#2-LinearLayout的onLayout方法实现解析" class="headerlink" title="2.LinearLayout的onLayout方法实现解析"></a>2.LinearLayout的onLayout方法实现解析</h5><pre><code>protected void onlayout(boolean changed, int l, int t, int r, int b) {    if (mOrientation == VERTICAL) {        layoutVertical(l, t, r, b);    } else {        layoutHorizontal(l,)    }}// layoutVertical核心源码void layoutVertical(int left, int top, int right, int bottom) {    ...    final int count = getVirtualChildCount();    for (int i = 0; i &lt; count; i++) {        final View child = getVirtualChildAt(i);        if (child == null) {            childTop += measureNullChild(i);        } else if (child.getVisibility() != GONE) {            final int childWidth = child.getMeasureWidth();            final int childHeight = child.getMeasuredHeight();            final LinearLayout.LayoutParams lp =                     (LinearLayout.LayoutParams) child.getLayoutParams();            ...            if (hasDividerBeforeChildAt(i)) {                childTop += mDividerHeight;            }            childTop += lp.topMargin;            // 为子元素确定对应的位置            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);            // childTop会逐渐增大，意味着后面的子元素会被            // 放置在靠下的位置            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);            i += getChildrenSkipCount(child,i)        }    }}private void setChildFrame(View child, int left, int top, int width, int height) {    child.layout(left, top, left + width, top + height);}</code></pre><p>注意：在View的默认实现中，View的测量宽/高和最终宽/高是相等的，只不过测量宽/高形成于View的measure过程，而最终宽/高形成于View的layout过程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。在一些特殊的情况下则两者不相等：</p><ul><li>重写View的layout方法,使最终宽度总是比测量宽/高大100px</li></ul><pre><code>public void layout(int l, int t, int r, int b) {    super.layout(l, t, r + 100, b + 100);}</code></pre><ul><li>View需要多长measure才能确定自己的测量宽/高,在前几次测量的过程中，其得出的测量宽/高有可能和最终宽/高不一致，但最终来说，测量宽/高还是和最终宽/高相同</li></ul><h3 id="六、View的绘制流程之Draw"><a href="#六、View的绘制流程之Draw" class="headerlink" title="六、View的绘制流程之Draw"></a>六、View的绘制流程之Draw</h3><h5 id="1-Draw的基本流程"><a href="#1-Draw的基本流程" class="headerlink" title="1.Draw的基本流程"></a>1.Draw的基本流程</h5><pre><code>private void performDraw() {    ...    draw(fullRefrawNeeded);    ...}private void draw(boolean fullRedrawNeeded) {    ...    if (!drawSoftware(surface, mAttachInfo, xOffest, yOffset,     scalingRequired, dirty)) {        return;    }    ...}private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scallingRequired, Rect dirty) {    ...    mView.draw(canvas);    ...}// 绘制基本上可以分为六个步骤public void draw(Canvas canvas) {    ...    // 步骤一：绘制View的背景    drawBackground(canvas);    ...    // 步骤二：如果需要的话，保持canvas的图层，为fading做准备    saveCount = canvas.getSaveCount();    ...    canvas.saveLayer(left, top, right, top + length, null, flags);    ...    // 步骤三：绘制View的内容    onDraw(canvas);    ...    // 步骤四：绘制View的子View    dispatchDraw(canvas);    ...    // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层    canvas.drawRect(left, top, right, top + length, p);    ...    canvas.restoreToCount(saveCount);    ...    // 步骤六：绘制View的装饰(例如滚动条等等)    onDrawForeground(canvas)}</code></pre><h5 id="2-setWillNotDraw的作用"><a href="#2-setWillNotDraw的作用" class="headerlink" title="2.setWillNotDraw的作用"></a>2.setWillNotDraw的作用</h5><pre><code>// 如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，// 系统会进行相应的优化。public void setWillNotDraw(boolean willNotDraw) {    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);}</code></pre><ul><li>默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。</li><li>当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。</li><li>当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显示地关闭WILL_NOT_DRAW这个标记位。</li></ul><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>View的绘制流程和事件分发机制都是Android开发中的核心知识点，也是自定义View高手的内功心法。对于一名优秀的Android开发来说，主流三方源码分析和Android核心源码分析可以说是必修课，下一篇，将会带领大家更进一步深入Android。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android开发艺术探索</p><p>2、Android进阶之光</p><p>3、Android高级进阶</p><p>4、<a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external">Android应用层View绘制流程与源码分析</a></p><p>5、<a href="https://blog.csdn.net/sinat_35938012/article/details/81055380" target="_blank" rel="external">Android中View绘制流程浅析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android触摸事件传递机制</title>
      <link>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</link>
      <guid>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/</guid>
      <pubDate>Wed, 17 Oct 2018 14:38:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><h3 id="一、了解Activity的构成"><a href="#一、了解Activity的构成" class="headerlink" title="一、了解Activity的构成"></a>一、了解Activity的构成</h3><p>一个Activity包含了一个Window对象，这个对象是由PhoneWindow来实现的。PhoneWindow将DecorView作为整个应用窗口的根View，而这个DecorView又将屏幕划分为两个区域：一个是TitleView，另一个是ContentView，而我们平时所写的就是展示在ContentView中的，下图表示Activity的构成。</p><p><img src="https://upload-images.jianshu.io/upload_images/1417629-c87a3dd5ed19ee9d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="二、触摸事件的类型"><a href="#二、触摸事件的类型" class="headerlink" title="二、触摸事件的类型"></a>二、触摸事件的类型</h3><p>触摸事件对应的是MotionEvent类，事件的类型主要有如下三种：</p><ul><li>ACTION_DOWN</li><li>ACTION_MOVE(移动的距离超过一定的阈值会被判定为ACTION_MOVE操作)</li><li>ACTION_UP</li></ul><h3 id="三、事件传递的三个阶段"><a href="#三、事件传递的三个阶段" class="headerlink" title="三、事件传递的三个阶段"></a>三、事件传递的三个阶段</h3><ul><li>分发（dispatchTouchEvent）：方法返回值为true表示事件被当前视图消费掉；返回为super.dispatchTouchEvent表示继续分发该事件。</li><li>拦截（onInterceptTouchEvent）：方法返回值为true表示拦截这个事件并交由自身的onTouchEvent方法进行消费；返回false表示不拦截，需要继续传递给子视图。<br>如果return super.onInterceptTouchEvent(ev)， 事件拦截分两种情况: 　</li></ul><pre><code>1.如果该View(ViewGroup)存在子View且点击到了该子View, 则不拦截, 继续分发给子View 处理, 此时相当于return false。2.如果该View(ViewGroup)没有子View或者有子View但是没有点击中子View(此时ViewGroup相当于普通View), 则交由该View的onTouchEvent响应，此时相当于return true。 注意：一般的LinearLayout、 RelativeLayout、FrameLayout等ViewGroup默认不拦截， 而ScrollView、ListView等ViewGroup则可能拦截，得看具体情况。</code></pre><ul><li>消费（onTouchEvent）：方法返回值为true表示当前视图可以处理对应的事件；返回值为false表示当前视图不处理这个事件，它会被传递给父视图的onTouchEvent方法进行处理。如果return super.onTouchEvent(ev)，事件处理分为两种情况：</li></ul><pre><code>1.如果该View是clickable或者longclickable的,则会返回true, 表示消费了该事件, 与返回true一样;2.如果该View不是clickable或者longclickable的,则会返回false, 表示不消费该事件,将会向上传递,与返回false一样.</code></pre><p>注意：在Android系统中，拥有事件传递处理能力的类有以下三种。</p><ul><li>Activity：拥有分发和消费两个方法。</li><li>ViewGroup：拥有分发、拦截和消费三个方法。</li><li>View：拥有分发、消费两个方法。</li></ul><h3 id="四、Activity对点击事件的分发过程"><a href="#四、Activity对点击事件的分发过程" class="headerlink" title="四、Activity对点击事件的分发过程"></a>四、Activity对点击事件的分发过程</h3><p>我们对触摸屏进行操作时，Linux就会收到相应的硬件中断，然后将中断加工成原始的输入事件并写入相应的设备节点中。而我们的Android 输入系统所做的事情概括起来说就是监控这些设备节点，当某个设备节点有数据可读时，将数据读出并进行一系列的翻译加工，然后在所有的窗口中找到合适的事件接收者，并派发给它。<br>当点击事件产生后，事件会传递给当前的Activity，由Activity中的PhoneWindow完成，PhoneWindow再把事件处理工作交给DecorView，之后再有DecorView将事件处理工作交给ViewGroup。源码流程如下所示：</p><h5 id="1-Activity-dispatchTouchEvent"><a href="#1-Activity-dispatchTouchEvent" class="headerlink" title="1.Activity#dispatchTouchEvent"></a>1.Activity#dispatchTouchEvent</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {    if (ev.getAction() == MotionEvent.ACTION_DOWN) {        onUserInteraction();    }    // 由Activity所附属的Window分发，返回true，事件循环结束    if (getWindow().superDispatchTouchEvent(ev)) {        return true;    }    // 返回false意味着事件没人处理，所有View的onTouchEvent都    // 返回了false，那么Activity的onTouchEvent就会被调用    return onTouchEvent(ev);}</code></pre><h5 id="2-抽象类Window-superDispatchTouchEvent"><a href="#2-抽象类Window-superDispatchTouchEvent" class="headerlink" title="2.抽象类Window#superDispatchTouchEvent"></a>2.抽象类Window#superDispatchTouchEvent</h5><pre><code>public abstract boolean superDispatchTouchEvent(MotionEvent event);</code></pre><h5 id="3-唯一实现类PhoneWindow-superDispatchTouchEvent"><a href="#3-唯一实现类PhoneWindow-superDispatchTouchEvent" class="headerlink" title="3.唯一实现类PhoneWindow#superDispatchTouchEvent"></a>3.唯一实现类PhoneWindow#superDispatchTouchEvent</h5><pre><code>public boolean superDispatchTouchEvent(MotionEvent event) {    return mDecor.superDispatchTouchEvent(event);}</code></pre><h3 id="五、View的事件分发机制"><a href="#五、View的事件分发机制" class="headerlink" title="五、View的事件分发机制"></a>五、View的事件分发机制</h3><p>事件分发到ViewGroup的dispatchTouchEvent方法，如果它的onInterceptTouchEvent返回true，则由自己处理，这时如果它的mOnTouchListener被设置，则onTouch会被调用，否则onTouchEvent会被调用。在onTouchEvent中，如果设置了mOnCLickListener，则onClick会被调用。如果它的onInterceptTouchEvent返回false，则交给点击事件链上的子View处理，如此循环，完成分发。ViewGroup#dispatchTouchEvent关键源码如下所示：</p><h5 id="1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作"><a href="#1-ViewGroup会在ACTION-DOWN事件到来时做重置状态操作" class="headerlink" title="1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作"></a>1.ViewGroup会在ACTION_DOWN事件到来时做重置状态操作</h5><pre><code>// Handle an initial down.if (actionMasked === MotionEvent.ACTION_DOWN) {    // Throw away all previous state when starting a new touch gesture.    // The framework may have dropped the up or cancel event for the    // previous gesture due to an app switch, ANR, or some other stae change.    cancelAndClearTouchTarget(ev);    // 在此方法中会重置FLAG_DISALLOW_INTERCEPT    resetTouchState();}</code></pre><h5 id="2-处理当前View是否拦截点击事件"><a href="#2-处理当前View是否拦截点击事件" class="headerlink" title="2.处理当前View是否拦截点击事件"></a>2.处理当前View是否拦截点击事件</h5><pre><code>final boolean interception；// 当事件由ViewGorup的子元素成功处理时，mFirstTouchTarget会被赋值// 并指向子元素，反之，被ViewGroup拦截时，mFirstTouchTarget则为null。if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {    // 在子View中通过requestDisallowInterceptTouchEvent方法来设置    // FLAG_DISALLOW_INTERCEPT,此时ViewGroup将无法拦截除ACTION_DOWN以外的其他事件     final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;    if (!disallowintercept) {        intercepted = onInterceptTouchEvent(ev);        //re store action in case it was changed        ev.setAction(action);    } else {        intercepted = false;    } else {        // There are no touch targets and this action is not an initial down so this         // view group continues to intercept touches（ACTION_MOVE、ACTION_UP.eg).        intercepted = true;    }}</code></pre><h5 id="3-dispatchTouchEvent-方法剩余的部分源码"><a href="#3-dispatchTouchEvent-方法剩余的部分源码" class="headerlink" title="3.dispatchTouchEvent()方法剩余的部分源码"></a>3.dispatchTouchEvent()方法剩余的部分源码</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent ev) {    ...    final View[] children = mChildren;    // 遍历ViewGroup的子元素，如果子元素能够接受到点击事件，则交给子元素处理。    for (int i = childrenCount - 1;i &gt;= 0;i--) {        final int childIndex = customOrder ? getChildDrawingOrder(childrenCount, i) : i;        final View child = (preorderedList == null) ? children[childIndex] : preorderedList.get(childIndex);        if (childWithAccessibilityFocus != null) {            if (childWithAccessibilityFocus != child) {                continue;            }            childWithAccessibilityFocus = null;            i = childrenCount - 1;            }            // 判断触摸点的位置是否在子View的范围内或者子View是否在播放动画，有一项            // 不符合则开始遍历下一个子View。            if (!canViewReceivePointerEvents(child) || !isTransformedTouchPointInView(x, y, child, null)) {                ev.setTargetAccessibilityFocus(false);                continue;            }            newTouchTarget == getTouchTarget(child);            if (newTouchTarget != null) {                newTouchTarget.pointerIdBits |= idBitsToAssign;                break;            }            resetCancelNextUpFlag(child);            if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {                mLastTouchDownTime = ev.getDownTime();                if (preorderedList != null) {                    for (int j = 0;j &lt; childrenCOunt;j++) {                        if (children[childIndex] == mChildren[j]) {                            mLastTouchDownIndex = j;                            break;                        }                    }                } else {                    mLastTouchDownIndex = childIndex;                }                mLastTouchDownX == ev.getX();                mLastTouchDownY = ev.getY();                newTouchTarget = addTouchTarget(child, idBitsToAssign);                alreadyDispatchedToNewTouchTarget == true;                break            }            ev.setTargetAccessibilityFocus(false);        }    ...}</code></pre><h5 id="4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"><a href="#4-在dispathcTransformedTouchEvent方法中执行真正的分发逻辑" class="headerlink" title="4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑"></a>4.在dispathcTransformedTouchEvent方法中执行真正的分发逻辑</h5><pre><code>private boolean dispatchTransformedTouchEvent(MotionEvent event,boolean cancel,View child,int desiredPointerIdBits) {    final int oldAction = event.getAction();    if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {        event.setAction(MotionEvent.ACTION_CANCEL);        // 有子View，则调用子View的dispatchTouchEvent(event)方法，如果没有子View，        // 则调用super.dispatchTouchEvent(event)方法。        if (child == null) {            handled == super..dispatchTouchEvent(event);        } else {            handled = child.dispatchTouchEvent(event);        }        event.setAction(oldAction);        return handled;    }    ...}</code></pre><h5 id="5-事件传递到View的dispatchTouchEvent"><a href="#5-事件传递到View的dispatchTouchEvent" class="headerlink" title="5.事件传递到View的dispatchTouchEvent()"></a>5.事件传递到View的dispatchTouchEvent()</h5><pre><code>public boolean dispatchTouchEvent(MotionEvent event) {    ...    boolean result = false;    if (onFilterTouchEventForSecurity(event)) {        ListenerInfo li = mListenerInfo;        // onTouch方法优先级要高于onTouchEvent(event)方法        if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {            result = true;        }        if (!result &amp;&amp; onTouchEvent(event)) {            result == true;        }    }    ...    return result;}</code></pre><h5 id="6-事件传递到View的onTouchEvent"><a href="#6-事件传递到View的onTouchEvent" class="headerlink" title="6.事件传递到View的onTouchEvent()"></a>6.事件传递到View的onTouchEvent()</h5><pre><code>public boolean onTouchEvent(MotionEvent event) {    ...    final int action = event.getAction();    // 只要View的CLICKABLE和LONG_CLICKABLE有一个为true，onTouchEvent()就会    // 返回true消耗这个事件。    if ((viewFlags &amp; CLICKABLE) == CLICKABLE || （viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {        switch(action) {            case MotionEvent.ACTION_UP:                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;                if ((mPrivatFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {                    boolean focusTaken = false;                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {                        removeLongPressCallback();                        if (!focusTaken) {                            if (mPerformClick == null) {                                mPerformClick = new PerformClick();                            }                            if (!post(mPerformClick)) {                                performClick();                            }                        }                    }                }                ...            }            return true;    }    return true;}</code></pre><h5 id="7-在ACTION-UP事件中会调用performCLick-方法"><a href="#7-在ACTION-UP事件中会调用performCLick-方法" class="headerlink" title="7.在ACTION_UP事件中会调用performCLick()方法"></a>7.在ACTION_UP事件中会调用performCLick()方法</h5><pre><code>public boolean performClick() {    final boolean result;    final Listenerinfo li = mListenerInfo;    // 如果View设置了点击事件，onClick方法就会执行。    if (li != null &amp;&amp; li.mOnClickListener !== null) {        playSoundEffect(SoundEffectConstants.CLICK);        li.mOnClickListener.onClick(this);        result = true;    } else {        result = false;    }    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);    return result;}</code></pre><p>由以上源码分析可得出View完整的点击事件传递流程如下图所示。</p><p><img src="https://camo.githubusercontent.com/e1e469bffad8a95732db704cc161384f8e3c7f0e/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f323931313033382d35333439643665626233323337326461" alt="image"></p><h3 id="六、总结：点击事件分发的传递规则"><a href="#六、总结：点击事件分发的传递规则" class="headerlink" title="六、总结：点击事件分发的传递规则"></a>六、总结：点击事件分发的传递规则</h3><p>由事件分发的源码分析可知点击事件分发的3个重要方法的关系，用伪代码表示为：</p><pre><code>public boolean diapatchTouchEvent(MotionEvent ev) {    boolean consume = false;    if (onInterceptTouchEvent(ev)) {        consume = onTouchEvent(ev);    } else {        consume = child.dispatchTouchEvent(ev);    }    return consume;}</code></pre><p>一些重要的结论：</p><p>1.事件传递优先级：onTouchListener.onTouch &gt; onTouchEvent &gt; onClickListener.onClick。</p><p>2.正常情况下，一个时间序列只能被一个View拦截且消耗。因为一旦一个元素拦截了此事件，那么同一个事件序列内的所有事件都会直接交给它处理（即不会再调用这个View的拦截方法去询问它是否要拦截了，而是把剩余的ACTION_MOVE、ACTION_DOWN等事件直接交给它来处理）。特例：通过将重写View的onTouchEvent返回false可强行将事件转交给其他View处理。</p><p>3.如果View不消耗除ACTION_DOWN以外的其他事件，那么这个点击事件会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终这些消失的点击事件会传递给Activity处理。</p><p>4.ViewGroup默认不拦截任何事件（返回false）。</p><p>5.View的onTouchEvent默认都会消耗事件（返回true），除非它是不可点击的（clickable和longClickable同时为false）。View的longClickable属性默认都为false，clickable属性要分情况，比如Button的clickable属性默认为true，而TextView的clickable默认为false。</p><p>6.View的enable属性不影响onTouchEvent的默认返回值。</p><p>7.通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p><p>最终完整的事件分发流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/944365-aea821bbb613c195.png" alt="image"></p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android开发艺术探索</p><p>2、Android进阶之光</p><p>3、Android高级进阶</p><p>4、<a href="http://gityuan.com/2015/09/19/android-touch/" target="_blank" rel="external">Gityuan Android事件分发机制</a></p><p>5、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492294&amp;idx=1&amp;sn=1645fa7730dbb1c627bd374e917cd557&amp;chksm=8eec80b9b99b09af1938836b2f19afc60b46c284050b9f17ceb5018867cd86df1c6a40fe56eb&amp;scene=38#wechat_redirect" target="_blank" rel="external">通俗理解Android的事件分发机制</a></p><p>6、<a href="http://www.jianshu.com/p/38015afcdb58" target="_blank" rel="external">Android事件分发机制详解：史上最全面、最易懂</a></p><p>7、<a href="http://mp.weixin.qq.com/s?__biz=MzIxNzU1Nzk3OQ==&amp;mid=2247486486&amp;idx=1&amp;sn=7acc1c9dd8c600ad0ec2db7d32f82f1f&amp;chksm=97f6b2a2a0813bb425cf8bf329bf0e856d3769ac8e21ed5a9a6cb7c57b1097c41f94afe4202d&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android开发之漫漫长途 Ⅵ——图解Android事件分发机制（深入底层源码）</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
