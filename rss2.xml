<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Sat, 22 Dec 2018 14:56:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android主流三方库源码分析（四、深入理解GreenDao源码）</title>
      <link>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sat, 22 Dec 2018 14:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>，除了热门的网络库之外，我们还分析了使用最广泛的图片加载框架Glide的加载流程，大家读完这篇源码分析会有不少提升，有兴趣可以看看<a href="https://jsonchao.github.io/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>。本篇，我们将会来对目前Android数据库框架中性能最好的GreenDao来进行较为深入地讲解。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><h4 id="1、导入GreenDao的代码生成插件和库"><a href="#1、导入GreenDao的代码生成插件和库" class="headerlink" title="1、导入GreenDao的代码生成插件和库"></a>1、导入GreenDao的代码生成插件和库</h4><pre><code>// 项目下的build.gradlebuildscript {    ...    dependencies {        classpath &apos;com.android.tools.build:gradle:2.3.0&apos;        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos;     }}// app模块下的build.gradleapply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos;...dependencies {    ...    compile &apos;org.greenrobot:greendao:3.2.0&apos; }</code></pre><h4 id="2、创建一个实体类，这里为HistoryData"><a href="#2、创建一个实体类，这里为HistoryData" class="headerlink" title="2、创建一个实体类，这里为HistoryData"></a>2、创建一个实体类，这里为HistoryData</h4><pre><code>@Entitypublic class HistoryData {    @Id(autoincrement = true)    private Long id;    private long date;    private String data;}</code></pre><h4 id="3、选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"><a href="#3、选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。" class="headerlink" title="3、选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"></a>3、选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。</h4><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/greendao_auto_generate_class.png" alt="image"></p><pre><code>@Entitypublic class HistoryData {    @Id(autoincrement = true)    private Long id;    private long date;    private String data;    @Generated(hash = 1371145256)    public HistoryData(Long id, long date, String data) {        this.id = id;        this.date = date;        this.data = data;    }    @Generated(hash = 422767273)    public HistoryData() {    }    public Long getId() {        return this.id;    }    public void setId(Long id) {        this.id = id;    }    public long getDate() {        return this.date;    }    public void setDate(long date) {        this.date = date;    }    public String getData() {        return this.data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>这里点明一下这几个类的作用：</p><ul><li>DaoMaster：所有Dao类的主人，负责整个库的运行，内部的静态抽象子类DevOpenHelper继承并重写了Android的SqliteOpenHelper。</li><li>DaoSession：作为一个会话层的角色，用于生成相应的Dao对象、Dao对象的注册，操作Dao的具体对象。</li><li>xxDao（HistoryDataDao）：生成的Dao对象，用于进行具体的数据库操作。</li></ul><h4 id="4、获取并使用相应的Dao对象进行增删改查操作"><a href="#4、获取并使用相应的Dao对象进行增删改查操作" class="headerlink" title="4、获取并使用相应的Dao对象进行增删改查操作"></a>4、获取并使用相应的Dao对象进行增删改查操作</h4><pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME);SQLiteDatabase database = devOpenHelper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(database);mDaoSession = daoMaster.newSession();HistoryDataDao historyDataDao = daoSession.getHistoryDataDao();// 省略创建historyData的代码...// 增historyDataDao.insert(historyData);// 删historyDataDao.delete(historyData);// 改historyDataDao.update(historyData);// 查List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll();</code></pre><p>本篇文章将会以上述使用流程来对GreenDao的源码进行逐步分析，最后会分析下GreenDao中一些优秀的特性，让读者朋友们对GreenDao的理解有更一步的加深。</p><h3 id="二、GreenDao使用流程分析"><a href="#二、GreenDao使用流程分析" class="headerlink" title="二、GreenDao使用流程分析"></a>二、GreenDao使用流程分析</h3><h4 id="1、创建数据库帮助类对象DaoMaster-DevOpenHelper"><a href="#1、创建数据库帮助类对象DaoMaster-DevOpenHelper" class="headerlink" title="1、创建数据库帮助类对象DaoMaster.DevOpenHelper"></a>1、创建数据库帮助类对象DaoMaster.DevOpenHelper</h4><pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME);</code></pre><p>创建GreenDao内部实现的数据库帮助类对象devOpenHelper，核心源码如下：</p><pre><code>public class DaoMaster extends AbstractDaoMaster {    ...    public static abstract class OpenHelper extends DatabaseOpenHelper {    ...         @Override        public void onCreate(Database db) {            Log.i(&quot;greenDAO&quot;, &quot;Creating tables for schema version &quot; +     SCHEMA_VERSION);            createAllTables(db, false);        }    }    public static class DevOpenHelper extends OpenHelper {        ...        @Override        public void onUpgrade(Database db, int oldVersion, int     newVersion) {            Log.i(&quot;greenDAO&quot;, &quot;Upgrading schema from version &quot; +     oldVersion + &quot; to &quot; + newVersion + &quot; by dropping all     tables&quot;);            dropAllTables(db, true);            onCreate(db);        }    }}</code></pre><p>DevOpenHelper自身实现了更新的逻辑，这里是弃置了所有的表，并且调用了OpenHelper实现的onCreate方法用于创建所有的表，其中DevOpenHelper继承于OpenHelper，于OpenHelper自身又继承于DatabaseOpenHelper，那么，这个DatabaseOpenHelper这个类的作用是什么呢？</p><pre><code>public abstract class DatabaseOpenHelper extends SQLiteOpenHelper {    ...    // 关注点1    public Database getWritableDb() {        return wrap(getWritableDatabase());    }    public Database getReadableDb() {        return wrap(getReadableDatabase());    }       protected Database wrap(SQLiteDatabase sqLiteDatabase) {        return new StandardDatabase(sqLiteDatabase);    }    ...    // 关注点2    public Database getEncryptedWritableDb(String password) {        EncryptedHelper encryptedHelper = checkEncryptedHelper();        return encryptedHelper.wrap(encryptedHelper.getWritableDatabase(password));    }    public Database getEncryptedReadableDb(String password) {        EncryptedHelper encryptedHelper = checkEncryptedHelper();        return encryptedHelper.wrap(encryptedHelper.getReadableDatabase(password));    }    ...    private class EncryptedHelper extends net.sqlcipher.database.SQLiteOpenHelper {        ...        protected Database wrap(net.sqlcipher.database.SQLiteDatabase     sqLiteDatabase) {            return new EncryptedDatabase(sqLiteDatabase);        }    }</code></pre><p>其实，DatabaseOpenHelper也是实现了SQLiteOpenHelper的一个帮助类，它内部可以获取到两种不同的数据库类型，一种是==StandardDatabase==，另一种是==EncryptedDatabase==，从以上源码可知，它们内部都通过wrap这样一个包装的方法，返回了对应的数据库类型，我们大致看一下StandardDatabase和EncryptedDatabase的内部实现。</p><pre><code>public class StandardDatabase implements Database {    // 这里的SQLiteDatabase是android.database.sqlite.SQLiteDatabase包下的    private final SQLiteDatabase delegate;    public StandardDatabase(SQLiteDatabase delegate) {        this.delegate = delegate;    }    @Override    public Cursor rawQuery(String sql, String[] selectionArgs) {        return delegate.rawQuery(sql, selectionArgs);    }    @Override    public void execSQL(String sql) throws SQLException {        delegate.execSQL(sql);    }    ...}public class EncryptedDatabaseStatement implements DatabaseStatement     {    // 这里的SQLiteStatement是net.sqlcipher.database.SQLiteStatement包下的    private final SQLiteStatement delegate;    public EncryptedDatabaseStatement(SQLiteStatement delegate) {        this.delegate = delegate;    }    @Override    public void execute() {        delegate.execute();    }    ...}</code></pre><p>StandardDatabase和EncryptedDatabase这两个类内部都使用了<strong>代理模式</strong>给相同的接口添加了不同的具体实现，StandardDatabase自然是使用的Android包下的SQLiteDatabase，而EncryptedDatabaseStatement为了实现加密数据库的功能，则使用了一个叫做==sqlcipher==的数据库加密三方库，这样，如果你项目下的数据库需要保存比较重要的数据，则可以使用getEncryptedWritableDb方法来代替getdWritableDb方法对数据库进行加密，这样，我们之后的数据库操作则会以代理模式的形式间接地使用sqlcipher提供的API去操作数据库。</p><h4 id="2、创建DaoMaster对象"><a href="#2、创建DaoMaster对象" class="headerlink" title="2、创建DaoMaster对象"></a>2、创建DaoMaster对象</h4><pre><code>SQLiteDatabase database = devOpenHelper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(database);</code></pre><p>首先，DaoMaster作为所有Dao对象的主人，它内部肯定是需要一个SQLiteDatabase对象的，因此，先由DaoMaster的帮助类对象devOpenHelper的getWritableDatabase方法得到一个标准的数据库类对象database，再由此创建一个DaoMaster对象。</p><pre><code>public class DaoMaster extends AbstractDaoMaster {    ...    public DaoMaster(SQLiteDatabase db) {        this(new StandardDatabase(db));    }    public DaoMaster(Database db) {        super(db, SCHEMA_VERSION);        registerDaoClass(HistoryDataDao.class);    }    ...}</code></pre><p>在DaoMaster的构造方法中，它首先执行了super(db, SCHEMA_VERSION)方法，即它的父类AbstractDaoMaster的构造方法。</p><pre><code>public abstract class AbstractDaoMaster {    ...    public AbstractDaoMaster(Database db, int schemaVersion) {        this.db = db;        this.schemaVersion = schemaVersion;        daoConfigMap = new HashMap&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt;();    }    protected void registerDaoClass(Class&lt;? extends AbstractDao&lt;?,     ?&gt;&gt; daoClass) {        DaoConfig daoConfig = new DaoConfig(db, daoClass);        daoConfigMap.put(daoClass, daoConfig);    }    ...}</code></pre><p>在AbstractDaoMaster对象的构造方法中，除了记录当前的数据库对象db和版本schemaVersion之外，还创建了一个类型为HashMap<class<? extends="" abstractdao<?,="" ?="">&gt;, DaoConfig&gt;()的daoConfigMap对象<strong>用于保存每一个DAO对应的数据配置对象DaoConfig</strong>，Daoconfig对象存储了对应的Dao对象所必需的数据。最后，在DaoMaster的构造方法中使用了registerDaoClass(HistoryDataDao.class)方法将HistoryDataDao类对象进行了注册，其实，就是为HistoryDataDao这个Dao对象创建了相应的DaoConfig对象并将它放入daoConfigMap对象中保存起来。</class<?></p><h4 id="3、创建DaoSession对象"><a href="#3、创建DaoSession对象" class="headerlink" title="3、创建DaoSession对象"></a>3、创建DaoSession对象</h4><pre><code>mDaoSession = daoMaster.newSession();</code></pre><p>在DaoMaster对象中使用了newSession方法新建了一个DaoSession对象。</p><pre><code>public DaoSession newSession() {    return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);}</code></pre><p>在DaoSeesion的构造方法中，又做了哪些事情呢？</p><pre><code>public class DaoSession extends AbstractDaoSession {    ...    public DaoSession(Database db, IdentityScopeType type, Map&lt;Class&lt;?     extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt;            daoConfigMap) {        super(db);        historyDataDaoConfig =     daoConfigMap.get(HistoryDataDao.class).clone();        historyDataDaoConfig.initIdentityScope(type);        historyDataDao = new HistoryDataDao(historyDataDaoConfig, this);        registerDao(HistoryData.class, historyDataDao);    }    ...}</code></pre><p>首先，调用了父类AbstractDaoSession的构造方法。</p><pre><code>public class AbstractDaoSession {    ...    public AbstractDaoSession(Database db) {        this.db = db;        this.entityToDao = new HashMap&lt;Class&lt;?&gt;, AbstractDao&lt;?, ?&gt;&gt;();    }    protected &lt;T&gt; void registerDao(Class&lt;T&gt; entityClass, AbstractDao&lt;T,     ?&gt; dao) {        entityToDao.put(entityClass, dao);    }    ...}</code></pre><p>在AbstractDaoSession构造方法里面<strong>创建了一个实体和Dao对象的映射集合</strong>。接下来，在DaoSession的构造方法中还做了2件事：</p><ul><li>1、创建每一个Dao对应的DaoConfig对象，这里是historyDataDaoConfig，并且根据IdentityScopeType的类型初始化创建一个相应的IdentityScope，根据type的不同，它由两种类型，分别是==IdentityScopeObject==和==IdentityScopeLong==，它的作用是根据主键缓存对应的实体数据，当主键是数字类型的时候，如long/Long、int/Integer、short/Short、byte/Byte，则使用IdentityScopeObject缓存实体数据，当主键不是数字类型的时候，则使用IdentityScopeObject缓存实体数据。</li><li>2、根据DaoSession对象和每一个Dao对应的DaoConfig对象，创建与之对应的historyDataDao对象，由于这个项目只创建了一个实体类HistoryData，因此这里只有一个Dao对象historyDataDao，然后就是注册Dao对象，其实就是将实体和对应的Dao对象放入entityToDao这个映射集合中保存起来了。</li></ul><h4 id="4、插入源码分析"><a href="#4、插入源码分析" class="headerlink" title="4、插入源码分析"></a>4、插入源码分析</h4><pre><code>HistoryDataDao historyDataDao = daoSession.getHistoryDataDao();// 增historyDataDao.insert(historyData);</code></pre><p>这里首先在会话层DaoSession中获取了我们要操作的Dao对象HistoryDataDao，然后插入了一个我们预先创建好的historyData实体对象。其中HistoryDataDao继承了AbstractDao<historydata, long=""> 。</historydata,></p><pre><code>public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; {    ...}</code></pre><p>那么，这个AbstractDao是干什么的呢？</p><pre><code>public abstract class AbstractDao&lt;T, K&gt; {    ...    public List&lt;T&gt; loadAll() {        Cursor cursor = db.rawQuery(statements.getSelectAll(), null);        return loadAllAndCloseCursor(cursor);    }    ...    public long insert(T entity) {        return executeInsert(entity, statements.getInsertStatement(),     true);    }    ...    public void delete(T entity) {        assertSinglePk();        K key = getKeyVerified(entity);        deleteByKey(key);    }    ...}</code></pre><p>看到这里，大家应该能猜到，AbstractDao是所有Dao对象的基类，它实现了实体数据的操作如增删改查。我们接着分析insert是如何实现的，在AbstractDao的insert方法中又调用了executeInsert这个方法。在这个方法中，第二个参数这里的statements是一个==TableStatements==对象，它是在AbstractDao初始化构造器时从DaoConfig对象中取出来的，它是一个<strong>根据指定的表格创建SQL语句的一个帮助类</strong>。使用statements.getInsertStatement()则是获取了一个插入的语句。而第三个参数则是判断是否是主键的标志。</p><pre><code>public class TableStatements {    ...    public DatabaseStatement getInsertStatement() {        if (insertStatement == null) {            String sql = SqlUtils.createSqlInsert(&quot;INSERT INTO &quot;,     tablename, allColumns);            DatabaseStatement newInsertStatement =     db.compileStatement(sql);            ...        }        return insertStatement;    }    ...}</code></pre><p>在TableStatements的getInsertStatement方法中，主要做了两件事：</p><ul><li>使用SqlUtils创建了插入的sql语句。</li><li>根据不同的数据库类型（标准数据库或加密数据库）将sql语句编译成当前数据库对应的语句。</li></ul><p>我们继续往下分析executeInsert的执行流程。</p><pre><code>private long executeInsert(T entity, DatabaseStatement stmt, boolean setKeyAndAttach) {    long rowId;    if (db.isDbLockedByCurrentThread()) {        rowId = insertInsideTx(entity, stmt);    } else {        db.beginTransaction();        try {            rowId = insertInsideTx(entity, stmt);            db.setTransactionSuccessful();        } finally {            db.endTransaction();        }    }    if (setKeyAndAttach) {        updateKeyAfterInsertAndAttach(entity, rowId, true);    }    return rowId;}</code></pre><p>这里首先是判断数据库是否被当前线程锁定，如果是直接插入数据，否则为了避免死锁，则开启一个数据库事物，再进行插入数据的操作，最后如果设置了主键，则在插入数据之后更新主键的值并将对应的实体缓存到相应identityScope中，这一块的代码流程如下所示：</p><pre><code>protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {    if (rowId != -1) {        K key = updateKeyAfterInsert(entity, rowId);        attachEntity(key, entity, lock);    } else {       ...    }}protected final void attachEntity(K key, T entity, boolean lock) {    attachEntity(entity);    if (identityScope != null &amp;&amp; key != null) {        if (lock) {            identityScope.put(key, entity);        } else {            identityScope.putNoLock(key, entity);        }    }}</code></pre><p>接着，我们还是继续追踪主线流程，在executeInsert这个方法中调用了insertInsideTx进行数据的插入。</p><pre><code>private long insertInsideTx(T entity, DatabaseStatement stmt) {    synchronized (stmt) {        if (isStandardSQLite) {            SQLiteStatement rawStmt = (SQLiteStatement) stmt.getRawStatement();            bindValues(rawStmt, entity);            return rawStmt.executeInsert();        } else {            bindValues(stmt, entity);            return stmt.executeInsert();        }    }}</code></pre><p>为了防止并发，这里使用了悲观锁保证了数据的一致性，在AbstractDao这个类中，大量使用了这种锁保证了它的线程安全性。接着，如果当前是标准数据库，则直接获取stmt这个DatabaseStatement类对应的原始语句进行实体字段属性的绑定和最后的执行插入操作。如果是加密数据库，则直接使用当前的加密数据库所属的插入语句进行实体字段属性的绑定和执行最后的插入操作。其中bindValues这个方法对应的实现类就是我们的HistoryDataDao类。</p><pre><code>public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; {    ...    @Override    protected final void bindValues(DatabaseStatement stmt, HistoryData     entity) {        stmt.clearBindings();        Long id = entity.getId();        if (id != null) {            stmt.bindLong(1, id);        }        stmt.bindLong(2, entity.getDate());        String data = entity.getData();        if (data != null) {            stmt.bindString(3, data);        }    }    @Override    protected final void bindValues(SQLiteStatement stmt, HistoryData     entity) {        stmt.clearBindings();        Long id = entity.getId();        if (id != null) {            stmt.bindLong(1, id);        }        stmt.bindLong(2, entity.getDate());        String data = entity.getData();        if (data != null) {            stmt.bindString(3, data);        }    }    ...}</code></pre><p>可以看到，这里对HistoryData的所有字段使用对应的数据库语句进行了绑定操作，这里最后再提及一下，当前数据库是加密型时，则会使用最开始提及的DatabaseStatement的加密实现类EncryptedDatabaseStatement应用代理模式去使用sqlcipher这个数据加密库的executeInsert方法。</p><h4 id="5、查询源码分析"><a href="#5、查询源码分析" class="headerlink" title="5、查询源码分析"></a>5、查询源码分析</h4><p>经过对插入源码的分析，我相信大家对GreenDao内部的机制已经有了一些自己的理解，由于删除和更新内部的流程比较简单，且与插入源码有异曲同工之妙，这里就不在赘述了。最后我们再分析下查询的源码，查询的流程调用链较长，所以将它的核心流程源码直接给出。</p><pre><code>List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll();public List&lt;T&gt; loadAll() {    Cursor cursor = db.rawQuery(statements.getSelectAll(), null);    return loadAllAndCloseCursor(cursor);}protected List&lt;T&gt; loadAllAndCloseCursor(Cursor cursor) {    try {        return loadAllFromCursor(cursor);    } finally {        cursor.close();    }}protected List&lt;T&gt; loadAllFromCursor(Cursor cursor) {    int count = cursor.getCount();    ...    boolean useFastCursor = false;    if (cursor instanceof CrossProcessCursor) {        window = ((CrossProcessCursor) cursor).getWindow();        if (window != null) {              if (window.getNumRows() == count) {                cursor = new FastCursor(window);                useFastCursor = true;            } else {              ...            }        }    }    if (cursor.moveToFirst()) {        ...        try {            if (!useFastCursor &amp;&amp; window != null &amp;&amp; identityScope != null) {                loadAllUnlockOnWindowBounds(cursor, window, list);            } else {                do {                    list.add(loadCurrent(cursor, 0, false));                } while (cursor.moveToNext());            }        } finally {            ...        }    }    return list;}</code></pre><p>最终，loadAll方法调用到loadAllFromCursor这个方法，首先，如果<strong>当前的游标cursor是跨进程的Cursor</strong>，并且cursor的行数没有偏差的话，则使用一个加快版的==FastCursor==对象进行游标遍历。接着，不管是执行loadAllUnlockOnWindowBounds这个方法还是直接加载当前的数据列表list.add(loadCurrent(cursor, 0, false))，最后都会调用到这行list.add(loadCurrent(cursor, 0, false))代码，很明显，loadCurrent方法就是加载数据的方法。</p><pre><code>final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {    if (identityScopeLong != null) {        ...        T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);        if (entity != null) {            return entity;        } else {            entity = readEntity(cursor, offset);            attachEntity(entity);            if (lock) {                identityScopeLong.put2(key, entity);            } else {                identityScopeLong.put2NoLock(key, entity);            }            return entity;        }    } else if (identityScope != null) {        ...        T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key);        if (entity != null) {            return entity;        } else {            entity = readEntity(cursor, offset);            attachEntity(key, entity, lock);            return entity;        }    } else {        ...        T entity = readEntity(cursor, offset);        attachEntity(entity);        return entity;    }}</code></pre><p>我们来理解下loadCurrent这个方法内部的执行策略。<strong>首先，如果有实体数据缓存identityScopeLong/identityScope，则先从缓存中取，如果缓存中没有，会使用该实体对应的Dao对象，这里的是HistoryDataDao，它在内部根据游标取出的数据新建了一个新的HistoryData实体对象返回。</strong></p><pre><code>@Overridepublic HistoryData readEntity(Cursor cursor, int offset) {    HistoryData entity = new HistoryData( //        cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id        cursor.getLong(offset + 1), // date        cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2) // data    );    return entity;}</code></pre><p><strong>最后，如果是非identityScopeLong缓存类型，即是属于identityScope的情况下，则还会在identityScope中将上面获得的数据进行缓存。如果没有实体数据缓存的话，则直接调用readEntity组件数据返回即可。</strong></p><p>注意：对于GreenDao缓存的特性，可能会出现没有拿到最新数据的bug，因此，如果遇到这种情况，可以使用DaoSession的clear方法删除缓存。</p><h3 id="三、GreenDao是如何与ReactiveX结合？"><a href="#三、GreenDao是如何与ReactiveX结合？" class="headerlink" title="三、GreenDao是如何与ReactiveX结合？"></a>三、GreenDao是如何与ReactiveX结合？</h3><p>首先，看下与rx结合的使用流程：</p><pre><code>RxDao&lt;HistoryData, Long&gt; xxDao = daoSession.getHistoryDataDao().rx();xxDao.insert(historyData)        .observerOn(AndroidSchedulers.mainThread())        .subscribe(new Action1&lt;HistoryData&gt;() {            @Override            public void call(HistoryData entity) {                // insert success            }        });</code></pre><p>在AbstractDao对象的.rx()方法中，创建了一个默认执行在io线程的rxDao对象。</p><pre><code>@Experimentalpublic RxDao&lt;T, K&gt; rx() {    if (rxDao == null) {        rxDao = new RxDao&lt;&gt;(this, Schedulers.io());    }    return rxDao;}</code></pre><p>接着分析rxDao的insert方法。</p><pre><code>@Experimentalpublic Observable&lt;T&gt; insert(final T entity) {    return wrap(new Callable&lt;T&gt;() {        @Override        public T call() throws Exception {            dao.insert(entity);            return entity;        }    });}</code></pre><p>起实质作用的就是这个wrap方法了，在这个方法里面主要是调用了RxUtils.fromCallable(callable)这个方法。</p><pre><code>@Internalclass RxBase {    ...    protected &lt;R&gt; Observable&lt;R&gt; wrap(Callable&lt;R&gt; callable) {        return wrap(RxUtils.fromCallable(callable));    }    protected &lt;R&gt; Observable&lt;R&gt; wrap(Observable&lt;R&gt; observable) {        if (scheduler != null) {            return observable.subscribeOn(scheduler);        } else {            return observable;        }    }    ...}</code></pre><p>在RxUtils的fromCallable这个方法内部，其实就是<strong>使用defer这个延迟操作符来进行被观察者事件的发送，主要目的就是为了确保Observable被订阅后才执行。</strong></p><pre><code>@Internalclass RxUtils {    @Internal    static &lt;T&gt; Observable&lt;T&gt; fromCallable(final Callable&lt;T&gt; callable) {        return Observable.defer(new Func0&lt;Observable&lt;T&gt;&gt;() {            @Override            public Observable&lt;T&gt; call() {                T result;                try {                    result = callable.call();                } catch (Exception e) {                    return Observable.error(e);                }                return Observable.just(result);            }        });    }}</code></pre><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>在分析完GreenDao的大致源码之后，我发现，GreenDao作为最好的数据库框架之一，是有一定道理的。首先，它通过使用自身的插件配套相应freemarker模板生成所需的静态代码，避免了反射等消耗性能的操作。其次，它内部提供了实体数据的映射缓存机制，能够进一步加快查询速度。对于不同数据库对应的SQL语句，也使用了不同的DataBaseStatement实现类结合代理模式进行了封装，屏蔽了数据库操作等繁琐的细节。最后，它使用了sqlcipher提供了加密数据库的功能，一定程度确保了安全性，同时，结合RxJava，我们便能更简洁地实现异步的数据库操作。GreenDao源码分析到这里就真的完结了，下一篇，笔者将会对RxJava的核心源码进行细致地讲解，以此能让大家对RxJava有一个更为深入的理解。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、GreenDao V3.2.2源码</p><p>2、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492577&amp;idx=1&amp;sn=b35b0ef0f3769efa8c5d49fc5d60dd80&amp;chksm=8eec879eb99b0e8881dd83cac912192df742ad547ccd274b7fccd2995edd08b095e1fd556cfe&amp;scene=38#wechat_redirect" target="_blank" rel="external">GreenDao源码分析</a></p><p>3、<a href="http://www.voidcn.com/article/p-ksrtulcy-brp.html" target="_blank" rel="external">GreenDao源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（三、深入理解Glide源码）</title>
      <link>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 16 Dec 2018 12:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>。本篇，我们将会来深入地分析下目前Android使用最广泛的图片加载框架框架Glide的源码加载流程。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><p>Glide最基本的使用流程就是下面这行代码，其它所有扩展的额外功能都是以其建造者链式调用的基础上增加的。</p><pre><code>GlideApp.with(context).load(url).into(iv);</code></pre><p>其中的GlideApp是注解处理器自动生成的，要使用GlideApp，必须先配置应用的AppGlideModule模块，里面可以为空配置，也可以根据实际情况添加指定配置。</p><pre><code>@GlideModulepublic class MyAppGlideModule extends AppGlideModule {    @Override    public void applyOptions(Context context, GlideBuilder builder) {        // 实际使用中根据情况可以添加如下配置        &lt;!--builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));--&gt;        &lt;!--int memoryCacheSizeBytes = 1024 * 1024 * 20;--&gt;        &lt;!--builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));--&gt;        &lt;!--int bitmapPoolSizeBytes = 1024 * 1024 * 30;--&gt;        &lt;!--builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));--&gt;        &lt;!--int diskCacheSizeBytes = 1024 * 1024 * 100;--&gt;        &lt;!--builder.setDiskCache(new InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));--&gt;    }}</code></pre><p>接下来，本文将针对Glide的最新源码版本V4.8.0对Glide加载网络图片的流程进行详细地分析与讲解，力争做到让读者朋友们知其然也知其所以然。</p><h3 id="二、GlideApp-with-context-源码详解"><a href="#二、GlideApp-with-context-源码详解" class="headerlink" title="二、GlideApp.with(context)源码详解"></a>二、GlideApp.with(context)源码详解</h3><p>首先，用<strong>艽野尘梦</strong>绘制的这份Glide框架图让我们对Glide的总体框架有一个初步的了解。</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Glide%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg" alt="image"></p><p>从GlideApp.with这行代码开始，内部主线执行流程如下。</p><h4 id="1、GlideApp-with"><a href="#1、GlideApp-with" class="headerlink" title="1、GlideApp#with"></a>1、GlideApp#with</h4><pre><code>return (GlideRequests) Glide.with(context);</code></pre><h4 id="2、Glide-with"><a href="#2、Glide-with" class="headerlink" title="2、Glide#with"></a>2、Glide#with</h4><pre><code>return getRetriever(context).get(context);return Glide.get(context).getRequestManagerRetriever();// 外部使用了双重检锁的同步方式确保同一时刻只执一次Glide的初始化checkAndInitializeGlide(context);initializeGlide(context);// 最终执行到Glide的另一个重载方法initializeGlide(context, new GlideBuilder());@SuppressWarnings(&quot;deprecation&quot;)  private static void initializeGlide(@NonNull Context   context, @NonNull GlideBuilder builder) {    Context applicationContext =     context.getApplicationContext();    // 1、获取前面应用中带注解的GlideModule    GeneratedAppGlideModule annotationGeneratedModule =     getAnnotationGeneratedGlideModules();    // 2、如果GlideModule为空或者可配置manifest里面的标志为true，则获取manifest里面    // 配置的GlideModule模块（manifestModules）。    List&lt;com.bumptech.glide.module.GlideModule&gt;     manifestModules = Collections.emptyList();    if (annotationGeneratedModule == null ||     annotationGeneratedModule.isManifestParsingEnabled(    )) {      manifestModules = new   ManifestParser(applicationContext).parse();    }    ...    RequestManagerRetriever.RequestManagerFactory     factory =        annotationGeneratedModule != null            ? annotationGeneratedModule.getRequestManag    erFactory() : null;    builder.setRequestManagerFactory(factory);    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {      module.applyOptions(applicationContext, builder);    }    if (annotationGeneratedModule != null) {      annotationGeneratedModule.applyOptions(applicatio  nContext, builder);    }    // 3、初始化各种配置信息    Glide glide = builder.build(applicationContext);    // 4、把manifestModules以及annotationGeneratedModule里面的配置信息放到builder    // 里面（applyOptions）替换glide默认组件（registerComponents）    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {      module.registerComponents(applicationContext,   glide, glide.registry);    }    if (annotationGeneratedModule != null) {      annotationGeneratedModule.registerComponents(appl  icationContext, glide, glide.registry);    }    applicationContext.registerComponentCallbacks(glide    );    Glide.glide = glide;}</code></pre><h4 id="3、GlideBuilder-build"><a href="#3、GlideBuilder-build" class="headerlink" title="3、GlideBuilder#build"></a>3、GlideBuilder#build</h4><pre><code>@NonNull  Glide build(@NonNull Context context) {    // 创建请求图片线程池sourceExecutor    if (sourceExecutor == null) {      sourceExecutor =   GlideExecutor.newSourceExecutor();    }    // 创建硬盘缓存线程池diskCacheExecutor    if (diskCacheExecutor == null) {      diskCacheExecutor =   GlideExecutor.newDiskCacheExecutor();    }    // 创建动画线程池animationExecutor    if (animationExecutor == null) {      animationExecutor =   GlideExecutor.newAnimationExecutor();    }    if (memorySizeCalculator == null) {      memorySizeCalculator = new   MemorySizeCalculator.Builder(context).build();    }    if (connectivityMonitorFactory == null) {      connectivityMonitorFactory = new   DefaultConnectivityMonitorFactory();    }    if (bitmapPool == null) {      // 依据设备的屏幕密度和尺寸设置各种pool的size      int size =   memorySizeCalculator.getBitmapPoolSize();      if (size &gt; 0) {        // 创建图片线程池LruBitmapPool，缓存所有被释放的bitmap        // 缓存策略在API大于19时，为SizeConfigStrategy，小于为AttributeStrategy。        // 其中SizeConfigStrategy是以bitmap的size和config为key，value为bitmap的HashMap        bitmapPool = new LruBitmapPool(size);      } else {        bitmapPool = new BitmapPoolAdapter();      }    }    // 创建对象数组缓存池LruArrayPool，默认4M    if (arrayPool == null) {      arrayPool = new   LruArrayPool(memorySizeCalculator.getArrayPoolSiz  eInBytes());    }    // 创建LruResourceCache，内存缓存    if (memoryCache == null) {      memoryCache = new   LruResourceCache(memorySizeCalculator.getMemoryCa  cheSize());    }    if (diskCacheFactory == null) {      diskCacheFactory = new   InternalCacheDiskCacheFactory(context);    }    // 创建任务和资源管理引擎（线程池，内存缓存和硬盘缓存对象）    if (engine == null) {      engine =          new Engine(              memoryCache,              diskCacheFactory,              diskCacheExecutor,              sourceExecutor,              GlideExecutor.newUnlimitedSourceExecutor(  ),              GlideExecutor.newAnimationExecutor(),              isActiveResourceRetentionAllowed);    }    RequestManagerRetriever requestManagerRetriever =    new RequestManagerRetriever(requestManagerFactory);    return new Glide(        context,        engine,        memoryCache,        bitmapPool,        arrayPool,        requestManagerRetriever,        connectivityMonitorFactory,        logLevel,        defaultRequestOptions.lock(),        defaultTransitionOptions);}</code></pre><h4 id="4、Glide-Glide构造方法"><a href="#4、Glide-Glide构造方法" class="headerlink" title="4、Glide#Glide构造方法"></a>4、Glide#Glide构造方法</h4><pre><code>Glide(...) {    ...    // 注册管理任务执行对象的类(Registry)    // Registry是一个工厂，而其中所有注册的对象都是一个工厂员工，当任务分发时，    // 根据当前任务的性质，分发给相应员工进行处理    registry = new Registry();    ...    // 这里大概有60余次的append或register员工组件（解析器、编解码器、工厂类、转码类等等组件）    registry    .append(ByteBuffer.class, new ByteBufferEncoder())    .append(InputStream.class, new StreamEncoder(arrayPool))    // 根据给定子类产出对应类型的target（BitmapImageViewTarget / DrawableImageViewTarget)    ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();    glideContext =        new GlideContext(            context,            arrayPool,            registry,            imageViewTargetFactory,            defaultRequestOptions,            defaultTransitionOptions,            engine,            logLevel);}</code></pre><h4 id="5、RequestManagerRetriever-get"><a href="#5、RequestManagerRetriever-get" class="headerlink" title="5、RequestManagerRetriever#get"></a>5、RequestManagerRetriever#get</h4><pre><code>@NonNullpublic RequestManager get(@NonNull Context context) {  if (context == null) {    throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);  } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {    // 如果当前线程是主线程且context不是Application走相应的get重载方法    if (context instanceof FragmentActivity) {      return get((FragmentActivity) context);    } else if (context instanceof Activity) {      return get((Activity) context);    } else if (context instanceof ContextWrapper) {      return get(((ContextWrapper) context).getBaseContext());    }  }  // 否则直接将请求与ApplicationLifecycle关联  return getApplicationManager(context);}</code></pre><p>这里总结一下，对于当前传入的context是application或当前线程是子线程时，请求的生命周期和ApplicationLifecycle关联，否则，context是FragmentActivity或Fragment时，在当前组件添加一个SupportFragment（SupportRequestManagerFragment），context是Activity时，在当前组件添加一个Fragment(RequestManagerFragment)。</p><h5 id="6、GlideApp-with小结"><a href="#6、GlideApp-with小结" class="headerlink" title="6、GlideApp#with小结"></a>6、GlideApp#with小结</h5><h5 id="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"><a href="#1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，" class="headerlink" title="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"></a>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，</h5><h5 id="2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。"><a href="#2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。" class="headerlink" title="2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。"></a>2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。</h5><h5 id="这里我们再回顾一下with方法的执行流程。"><a href="#这里我们再回顾一下with方法的执行流程。" class="headerlink" title="这里我们再回顾一下with方法的执行流程。"></a>这里我们再回顾一下with方法的执行流程。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_with%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p><h3 id="三、load-url-源码详解"><a href="#三、load-url-源码详解" class="headerlink" title="三、load(url)源码详解"></a>三、load(url)源码详解</h3><h4 id="1、GlideRequest-RequestManager-load"><a href="#1、GlideRequest-RequestManager-load" class="headerlink" title="1、GlideRequest(RequestManager)#load"></a>1、GlideRequest(RequestManager)#load</h4><pre><code>return (GlideRequest&lt;Drawable&gt;) super.load(string);return asDrawable().load(string);// 1、asDrawable部分return (GlideRequest&lt;Drawable&gt;) super.asDrawable();return as(Drawable.class);// 最终返回了一个GlideRequest（RequestManager的子类）return new GlideRequest&lt;&gt;(glide, this, resourceClass, context);// 2、load部分return (GlideRequest&lt;TranscodeType&gt;) super.load(string);return loadGeneric(string);@NonNullprivate RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) {    // model则为设置的url    this.model = model;    // 记录url已设置    isModelSet = true;    return this;}</code></pre><p>可以看到，load这部分的源码很简单，就是给GlideRequest（RequestManager）设置了要请求的mode（url），并记录了url已设置的状态。</p><h5 id="这里，我们再看看load方法的执行流程。"><a href="#这里，我们再看看load方法的执行流程。" class="headerlink" title="这里，我们再看看load方法的执行流程。"></a>这里，我们再看看load方法的执行流程。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_load%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p><h3 id="四、into-iv-源码详解"><a href="#四、into-iv-源码详解" class="headerlink" title="四、into(iv)源码详解"></a>四、into(iv)源码详解</h3><p>前方预警，真正复杂的地方开始了。</p><h4 id="1、RequestBuilder-into"><a href="#1、RequestBuilder-into" class="headerlink" title="1、RequestBuilder.into"></a>1、RequestBuilder.into</h4><pre><code> @NonNullpublic ViewTarget&lt;ImageView, TranscodeType&gt;   into(@NonNull ImageView view) {  Util.assertMainThread();  Preconditions.checkNotNull(view);  RequestOptions requestOptions =     this.requestOptions;  if (!requestOptions.isTransformationSet()      &amp;&amp; requestOptions.isTransformationAllowed()      &amp;&amp; view.getScaleType() != null) {    // Clone in this method so that if we use this   RequestBuilder to load into a View and then    // into a different target, we don&apos;t retain the   transformation applied based on the previous    // View&apos;s scale type.    switch (view.getScaleType()) {      // 这个RequestOptions里保存了要设置的scaleType，Glide自身封装了CenterCrop、CenterInside、      // FitCenter、CenterInside四种规格。      case CENTER_CROP:        requestOptions =   requestOptions.clone().optionalCenterCrop();        break;      case CENTER_INSIDE:        requestOptions =   requestOptions.clone().optionalCenterInside()  ;        break;      case FIT_CENTER:      case FIT_START:      case FIT_END:        requestOptions =   requestOptions.clone().optionalFitCenter();        break;      case FIT_XY:        requestOptions =   requestOptions.clone().optionalCenterInside()  ;        break;      case CENTER:      case MATRIX:      default:        // Do nothing.    }  }  // 注意，这个transcodeClass是指的drawable或bitmap  return into(      glideContext.buildImageViewTarget(view,     transcodeClass),      /*targetListener=*/ null,      requestOptions);}</code></pre><h4 id="2、GlideContext-buildImageViewTarget"><a href="#2、GlideContext-buildImageViewTarget" class="headerlink" title="2、GlideContext#buildImageViewTarget"></a>2、GlideContext#buildImageViewTarget</h4><pre><code>return imageViewTargetFactory.buildTarget(imageView, transcodeClass);</code></pre><h4 id="3、ImageViewTargetFactory-buildTarget"><a href="#3、ImageViewTargetFactory-buildTarget" class="headerlink" title="3、ImageViewTargetFactory#buildTarget"></a>3、ImageViewTargetFactory#buildTarget</h4><pre><code>@NonNull@SuppressWarnings(&quot;unchecked&quot;)public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt;   buildTarget(@NonNull ImageView view,    @NonNull Class&lt;Z&gt; clazz) {  // 返回展示Bimtap/Drawable资源的目标对象  if (Bitmap.class.equals(clazz)) {    return (ViewTarget&lt;ImageView, Z&gt;) new   BitmapImageViewTarget(view);  } else if (Drawable.class.isAssignableFrom(clazz))     {    return (ViewTarget&lt;ImageView, Z&gt;) new   DrawableImageViewTarget(view);  } else {    throw new IllegalArgumentException(        &quot;Unhandled class: &quot; + clazz + &quot;, try   .as*(Class).transcode(ResourceTranscoder)&quot;);  }}</code></pre><p>可以看到，Glide内部只维护了两种target，一种是BitmapImageViewTarget，另一种则是DrawableImageViewTarget，接下来继续深入。</p><h4 id="4、RequestBuilder-into"><a href="#4、RequestBuilder-into" class="headerlink" title="4、RequestBuilder#into"></a>4、RequestBuilder#into</h4><pre><code>private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(      @NonNull Y target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      @NonNull RequestOptions options) {    Util.assertMainThread();    Preconditions.checkNotNull(target);    if (!isModelSet) {      throw new IllegalArgumentException(&quot;You must call   #load() before calling #into()&quot;);    }    options = options.autoClone();    // 分析1.建立请求    Request request = buildRequest(target,     targetListener, options);    Request previous = target.getRequest();    if (request.isEquivalentTo(previous)        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousReques    t(options, previous)) {      request.recycle();      // If the request is completed, beginning again   will ensure the result is re-delivered,      // triggering RequestListeners and Targets. If   the request is failed, beginning again will      // restart the request, giving it another chance   to complete. If the request is already      // running, we can let it continue running   without interruption.      if (!Preconditions.checkNotNull(previous).isRunni  ng()) {        // Use the previous request rather than the new     one to allow for optimizations like skipping        // setting placeholders, tracking and     un-tracking Targets, and obtaining View     dimensions        // that are done in the individual Request.        previous.begin();      }      return target;    }    requestManager.clear(target);    target.setRequest(request);    // 分析2.真正追踪请求的地方    requestManager.track(target, request);    return target;}// 分析1private Request buildRequest(      Target&lt;TranscodeType&gt; target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      RequestOptions requestOptions) {    return buildRequestRecursive(        target,        targetListener,        /*parentCoordinator=*/ null,        transitionOptions,        requestOptions.getPriority(),        requestOptions.getOverrideWidth(),        requestOptions.getOverrideHeight(),        requestOptions);}// 分析1private Request buildRequestRecursive(      Target&lt;TranscodeType&gt; target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      @Nullable RequestCoordinator parentCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight,      RequestOptions requestOptions) {    // Build the ErrorRequestCoordinator first if     necessary so we can update parentCoordinator.    ErrorRequestCoordinator errorRequestCoordinator =     null;    if (errorBuilder != null) {      // 创建errorRequestCoordinator（异常处理对象）      errorRequestCoordinator = new   ErrorRequestCoordinator(parentCoordinator);      parentCoordinator = errorRequestCoordinator;    }    // 递归建立缩略图请求    Request mainRequest =        buildThumbnailRequestRecursive(            target,            targetListener,            parentCoordinator,            transitionOptions,            priority,            overrideWidth,            overrideHeight,            requestOptions);    if (errorRequestCoordinator == null) {      return mainRequest;    }    ...    Request errorRequest =     errorBuilder.buildRequestRecursive(        target,        targetListener,        errorRequestCoordinator,        errorBuilder.transitionOptions,        errorBuilder.requestOptions.getPriority(),        errorOverrideWidth,        errorOverrideHeight,        errorBuilder.requestOptions);    errorRequestCoordinator.setRequests(mainRequest,     errorRequest);    return errorRequestCoordinator;}// 分析1private Request buildThumbnailRequestRecursive(      Target&lt;TranscodeType&gt; target,      RequestListener&lt;TranscodeType&gt; targetListener,      @Nullable RequestCoordinator parentCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight,      RequestOptions requestOptions) {    if (thumbnailBuilder != null) {      // Recursive case: contains a potentially recursive thumbnail request builder.      ...      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);      // 获取一个正常请求对象      Request fullRequest =          obtainRequest(              target,              targetListener,              requestOptions,              coordinator,              transitionOptions,              priority,              overrideWidth,              overrideHeight);      isThumbnailBuilt = true;      // Recursively generate thumbnail requests.      // 使用递归的方式建立一个缩略图请求对象      Request thumbRequest =          thumbnailBuilder.buildRequestRecursive(              target,              targetListener,              coordinator,              thumbTransitionOptions,              thumbPriority,              thumbOverrideWidth,              thumbOverrideHeight,              thumbnailBuilder.requestOptions);      isThumbnailBuilt = false;      // coordinator（ThumbnailRequestCoordinator）是作为两者的协调者，      // 能够同时加载缩略图和正常的图的请求      coordinator.setRequests(fullRequest, thumbRequest);      return coordinator;    } else if (thumbSizeMultiplier != null) {      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.      // 当设置了缩略的比例thumbSizeMultiplier(0 ~  1)时，      // 不需要递归建立缩略图请求      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);      Request fullRequest =          obtainRequest(              target,              targetListener,              requestOptions,              coordinator,              transitionOptions,              priority,              overrideWidth,              overrideHeight);      RequestOptions thumbnailOptions = requestOptions.clone()          .sizeMultiplier(thumbSizeMultiplier);      Request thumbnailRequest =          obtainRequest(              target,              targetListener,              thumbnailOptions,              coordinator,              transitionOptions,              getThumbnailPriority(priority),              overrideWidth,              overrideHeight);      coordinator.setRequests(fullRequest, thumbnailRequest);      return coordinator;    } else {      // Base case: no thumbnail.      // 没有缩略图请求时，直接获取一个正常图请求      return obtainRequest(          target,          targetListener,          requestOptions,          parentCoordinator,          transitionOptions,          priority,          overrideWidth,          overrideHeight);    }}private Request obtainRequest(      Target&lt;TranscodeType&gt; target,      RequestListener&lt;TranscodeType&gt; targetListener,      RequestOptions requestOptions,      RequestCoordinator requestCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight) {    // 最终实际返回的是一个SingleRequest对象（将制定的资源加载进对应的Target    return SingleRequest.obtain(        context,        glideContext,        model,        transcodeClass,        requestOptions,        overrideWidth,        overrideHeight,        priority,        target,        targetListener,        requestListeners,        requestCoordinator,        glideContext.getEngine(),        transitionOptions.getTransitionFactory());}</code></pre><p>从上源码分析可知，我们在分析1处的buildRequest()方法里建立了请求，且最多可同时进行缩略图和正常图的请求，最后，调用了requestManager.track(target, request)方法，接着看看track里面做了什么。</p><h4 id="5、RequestManager-track"><a href="#5、RequestManager-track" class="headerlink" title="5、RequestManager#track"></a>5、RequestManager#track</h4><pre><code>// 分析2void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) {    // 加入一个target目标集合(Set)    targetTracker.track(target);    requestTracker.runRequest(request);}</code></pre><h4 id="6、RequestTracker-runRequest"><a href="#6、RequestTracker-runRequest" class="headerlink" title="6、RequestTracker#runRequest"></a>6、RequestTracker#runRequest</h4><pre><code>/*** Starts tracking the given request.*/// 分析2public void runRequest(@NonNull Request request) {    requests.add(request);    if (!isPaused) {      // 如果不是暂停状态则开始请求      request.begin();    } else {      request.clear();      if (Log.isLoggable(TAG, Log.VERBOSE)) {        Log.v(TAG, &quot;Paused, delaying request&quot;);      }      // 否则清空请求，加入延迟请求队列（为了对这些请求维持一个强引用，使用了ArrayList实现）      pendingRequests.add(request);    }}</code></pre><h4 id="7、SingleRequest-begin"><a href="#7、SingleRequest-begin" class="headerlink" title="7、SingleRequest#begin"></a>7、SingleRequest#begin</h4><pre><code>// 分析2@Overridepublic void begin() {  ...  if (model == null) {    ...    // model（url）为空，回调加载失败    onLoadFailed(new GlideException(&quot;Received null   model&quot;), logLevel);    return;  }  if (status == Status.RUNNING) {    throw new IllegalArgumentException(&quot;Cannot   restart a running request&quot;);  }  if (status == Status.COMPLETE) {    onResourceReady(resource,   DataSource.MEMORY_CACHE);    return;  }  status = Status.WAITING_FOR_SIZE;  if (Util.isValidDimensions(overrideWidth, overrideHeight)) {    // 当使用override() API为图片指定了一个固定的宽高时直接执行onSizeReady，    // 最终的核心处理位于onSizeReady    onSizeReady(overrideWidth, overrideHeight);  } else {    // 根据imageView的宽高算出图片的宽高，最终也会走到onSizeReady    target.getSize(this);  }  if ((status == Status.RUNNING || status ==     Status.WAITING_FOR_SIZE)      &amp;&amp; canNotifyStatusChanged()) {    // 预先加载设置的缩略图    target.onLoadStarted(getPlaceholderDrawable());  }  if (IS_VERBOSE_LOGGABLE) {    logV(&quot;finished run method in &quot; +   LogTime.getElapsedMillis(startTime));  }}</code></pre><p>从requestManager.track(target, request)开始，最终会执行到SingleRequest#begin()方法的onSizeReady，可以猜到（因为后面只做了预加载缩略图的处理），真正的请求就是从这里开始的，咱们进去一探究竟~</p><h4 id="8、SingleRequest-onSizeReady"><a href="#8、SingleRequest-onSizeReady" class="headerlink" title="8、SingleRequest#onSizeReady"></a>8、SingleRequest#onSizeReady</h4><pre><code>// 分析2@Overridepublic void onSizeReady(int width, int height) {  stateVerifier.throwIfRecycled();  ...  status = Status.RUNNING;  float sizeMultiplier =     requestOptions.getSizeMultiplier();  this.width = maybeApplySizeMultiplier(width,     sizeMultiplier);  this.height = maybeApplySizeMultiplier(height,     sizeMultiplier);  ...  // 根据给定的配置进行加载，engine是一个负责加载、管理活跃和缓存资源的引擎类  loadStatus = engine.load(      glideContext,      model,      requestOptions.getSignature(),      this.width,      this.height,      requestOptions.getResourceClass(),      transcodeClass,      priority,      requestOptions.getDiskCacheStrategy(),      requestOptions.getTransformations(),      requestOptions.isTransformationRequired(),      requestOptions.isScaleOnlyOrNoTransform(),      requestOptions.getOptions(),      requestOptions.isMemoryCacheable(),      requestOptions.getUseUnlimitedSourceGeneratorsP    ool(),      requestOptions.getUseAnimationPool(),      requestOptions.getOnlyRetrieveFromCache(),      this);  ...}</code></pre><p>终于看到Engine类了，感觉距离成功不远了，继续~</p><h4 id="9、Engine-load"><a href="#9、Engine-load" class="headerlink" title="9、Engine#load"></a>9、Engine#load</h4><pre><code>public &lt;R&gt; LoadStatus load(    GlideContext glideContext,    Object model,    Key signature,    int width,    int height,    Class&lt;?&gt; resourceClass,    Class&lt;R&gt; transcodeClass,    Priority priority,    DiskCacheStrategy diskCacheStrategy,    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,    boolean isTransformationRequired,    boolean isScaleOnlyOrNoTransform,    Options options,    boolean isMemoryCacheable,    boolean useUnlimitedSourceExecutorPool,    boolean useAnimationPool,    boolean onlyRetrieveFromCache,    ResourceCallback cb) {  ...  // 先从弱引用中查找，如果有的话回调onResourceReady并直接返回  EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);  if (active != null) {    cb.onResourceReady(active,   DataSource.MEMORY_CACHE);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Loaded resource from active     resources&quot;, startTime, key);    }    return null;  }  // 没有再从内存中查找,有的话会取出并放到ActiveResources（内部维护的弱引用缓存map）里面  EngineResource&lt;?&gt; cached = loadFromCache(key,     isMemoryCacheable);  if (cached != null) {    cb.onResourceReady(cached,   DataSource.MEMORY_CACHE);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Loaded resource from cache&quot;,     startTime, key);    }    return null;  }  EngineJob&lt;?&gt; current = jobs.get(key,     onlyRetrieveFromCache);  if (current != null) {    current.addCallback(cb);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Added to existing load&quot;,     startTime, key);    }    return new LoadStatus(cb, current);  }  // 如果内存中没有，则创建engineJob（decodejob的回调类，管理下载过程以及状态）  EngineJob&lt;R&gt; engineJob =      engineJobFactory.build(          key,          isMemoryCacheable,          useUnlimitedSourceExecutorPool,          useAnimationPool,          onlyRetrieveFromCache);  // 创建解析工作对象  DecodeJob&lt;R&gt; decodeJob =      decodeJobFactory.build(          glideContext,          model,          key,          signature,          width,          height,          resourceClass,          transcodeClass,          priority,          diskCacheStrategy,          transformations,          isTransformationRequired,          isScaleOnlyOrNoTransform,          onlyRetrieveFromCache,          options,          engineJob);  // 放在Jobs内部维护的HashMap中  jobs.put(key, engineJob);  // 关注点8 后面分析会用到  // 注册ResourceCallback接口  engineJob.addCallback(cb);  // 内部开启线程去请求  engineJob.start(decodeJob);  if (VERBOSE_IS_LOGGABLE) {    logWithTimeAndKey(&quot;Started new load&quot;, startTime,   key);  }  return new LoadStatus(cb, engineJob);}public void start(DecodeJob&lt;R&gt; decodeJob) {    this.decodeJob = decodeJob;    // willDecodeFromCache方法内部根据不同的阶段stage，如果是RESOURCE_CACHE/DATA_CACHE则返回true，使用diskCacheExecutor，否则调用getActiveSourceExecutor，内部会根据相应的条件返回sourceUnlimitedExecutor/animationExecutor/sourceExecutor    GlideExecutor executor =       decodeJob.willDecodeFromCache()        ? diskCacheExecutor        : getActiveSourceExecutor();    executor.execute(decodeJob);}</code></pre><p>可以看到，最终Engine(引擎)类内部会执行到自身的start方法，它会根据不同的配置采用不同的线程池使用diskCacheExecutor/sourceUnlimitedExecutor/animationExecutor/sourceExecutor来执行最终的解码任务decodeJob。</p><h4 id="10、DecodeJob-run"><a href="#10、DecodeJob-run" class="headerlink" title="10、DecodeJob#run"></a>10、DecodeJob#run</h4><pre><code>runWrapped();private void runWrapped() {    switch (runReason) {      case INITIALIZE:        stage = getNextStage(Stage.INITIALIZE);        // 关注点1        currentGenerator = getNextGenerator();        // 关注点2 内部会调用相应Generator的startNext()        runGenerators();        break;      case SWITCH_TO_SOURCE_SERVICE:        runGenerators();        break;      case DECODE_DATA:        // 关注点3 将获取的数据解码成对应的资源        decodeFromRetrievedData();        break;      default:        throw new IllegalStateException(&quot;Unrecognized     run reason: &quot; + runReason);    }}// 关注点1，完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext()private DataFetcherGenerator getNextGenerator() {    switch (stage) {      case RESOURCE_CACHE:        return new ResourceCacheGenerator(decodeHelper, this);      case DATA_CACHE:        return new DataCacheGenerator(decodeHelper, this);      case SOURCE:        return new SourceGenerator(decodeHelper, this);      case FINISHED:        return null;      default:        throw new IllegalStateException(&quot;Unrecognized     stage: &quot; + stage);    }}</code></pre><h4 id="11、SourceGenerator-startNext"><a href="#11、SourceGenerator-startNext" class="headerlink" title="11、SourceGenerator#startNext"></a>11、SourceGenerator#startNext</h4><pre><code>// 关注点2@Overridepublic boolean startNext() {  // dataToCache数据不为空的话缓存到硬盘（第一执行该方法是不会调用的）  if (dataToCache != null) {    Object data = dataToCache;    dataToCache = null;    cacheData(data);  }  if (sourceCacheGenerator != null &amp;&amp;     sourceCacheGenerator.startNext()) {    return true;  }  sourceCacheGenerator = null;  loadData = null;  boolean started = false;  while (!started &amp;&amp; hasNextModelLoader()) {    // 关注点4 getLoadData()方法内部会在modelLoaders里面找到ModelLoder对象    // （每个Generator对应一个ModelLoader），    // 并使用modelLoader.buildLoadData方法返回一个loadData列表    loadData =   helper.getLoadData().get(loadDataListIndex++);    if (loadData != null        &amp;&amp; (helper.getDiskCacheStrategy().isDataCache  able(loadData.fetcher.getDataSource())        || helper.hasLoadPath(loadData.fetcher.getDat  aClass()))) {      started = true;      // 关注点6 通过loadData对象的fetcher对象（有关注点3的分析可知其实现类为HttpUrlFetcher）的      // loadData方法来获取图片数据      loadData.fetcher.loadData(helper.getPriority(),     this);    }  }  return started;}</code></pre><h4 id="12、DecodeHelper-getLoadData"><a href="#12、DecodeHelper-getLoadData" class="headerlink" title="12、DecodeHelper#getLoadData"></a>12、DecodeHelper#getLoadData</h4><pre><code>List&lt;LoadData&lt;?&gt;&gt; getLoadData() {    if (!isLoadDataSet) {      isLoadDataSet = true;      loadData.clear();      List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders =   glideContext.getRegistry().getModelLoaders(model)  ;      //noinspection ForLoopReplaceableByForEach to   improve perf      for (int i = 0, size = modelLoaders.size(); i &lt;   size; i++) {        ModelLoader&lt;Object, ?&gt; modelLoader =     modelLoaders.get(i);        // 注意：这里最终是通过HttpGlideUrlLoader的buildLoadData获取到实际的loadData对象        LoadData&lt;?&gt; current =            modelLoader.buildLoadData(model, width,     height, options);        if (current != null) {          loadData.add(current);        }      }    }    return loadData;}</code></pre><h4 id="13、HttpGlideUrlLoader-buildLoadData"><a href="#13、HttpGlideUrlLoader-buildLoadData" class="headerlink" title="13、HttpGlideUrlLoader#buildLoadData"></a>13、HttpGlideUrlLoader#buildLoadData</h4><pre><code>@Overridepublic LoadData&lt;InputStream&gt; buildLoadData(@NonNull   GlideUrl model, int width, int height,    @NonNull Options options) {  // GlideUrls memoize parsed URLs so caching them     saves a few object instantiations and time  // spent parsing urls.  GlideUrl url = model;  if (modelCache != null) {    url = modelCache.get(model, 0, 0);    if (url == null) {      // 关注点5      modelCache.put(model, 0, 0, model);      url = model;    }  }  int timeout = options.get(TIMEOUT);  // 注意，这里创建了一个DataFetcher的实现类HttpUrlFetcher  return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url,     timeout));}// 关注点5public void put(A model, int width, int height, B value) {    ModelKey&lt;A&gt; key = ModelKey.get(model, width,     height);    // 最终是通过LruCache来缓存对应的值，key是一个ModelKey对象（由model、width、height三个属性组成）    cache.put(key, value);}</code></pre><p>从这里的分析，我们明白了HttpUrlFetcher实际上就是最终的请求执行者，而且，我们知道了Glide会使用LruCache来对解析后的url来进行缓存，以便后续可以省去解析url的时间。</p><h4 id="14、HttpUrlFetcher-loadData"><a href="#14、HttpUrlFetcher-loadData" class="headerlink" title="14、HttpUrlFetcher#loadData"></a>14、HttpUrlFetcher#loadData</h4><pre><code>@Overridepublic void loadData(@NonNull Priority priority,    @NonNull DataCallback&lt;? super InputStream&gt;   callback) {  long startTime = LogTime.getLogTime();  try {    // 关注点6    // loadDataWithRedirects内部是通过HttpURLConnection网络请求数据    InputStream result =   loadDataWithRedirects(glideUrl.toURL(), 0, null,   glideUrl.getHeaders());    // 请求成功回调onDataReady()    callback.onDataReady(result);  } catch (IOException e) {    if (Log.isLoggable(TAG, Log.DEBUG)) {      Log.d(TAG, &quot;Failed to load data for url&quot;, e);    }    callback.onLoadFailed(e);  } finally {    if (Log.isLoggable(TAG, Log.VERBOSE)) {      Log.v(TAG, &quot;Finished http url fetcher fetch in     &quot; + LogTime.getElapsedMillis(startTime));    }  }}private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,  Map&lt;String, String&gt; headers) throws IOException {    ...    urlConnection.connect();    // Set the stream so that it&apos;s closed in cleanup to avoid resource leaks. See #2352.    stream = urlConnection.getInputStream();    if (isCancelled) {      return null;    }    final int statusCode = urlConnection.getResponseCode();    // 只要是2xx形式的状态码则判断为成功    if (isHttpOk(statusCode)) {      // 从urlConnection中获取资源流      return getStreamForSuccessfulRequest(urlConnection);    } else if (isHttpRedirect(statusCode)) {      ...      // 重定向请求      return loadDataWithRedirects(redirectUrl, redirects + 1, url,   headers);    } else if (statusCode == INVALID_STATUS_CODE) {      throw new HttpException(statusCode);    } else {      throw new HttpException(urlConnection.getResponseMessage(),   statusCode);    }}private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)  throws IOException {    if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {      int contentLength = urlConnection.getContentLength();      stream = ContentLengthInputStream.obtain(urlConnection.getInputStr  eam(), contentLength);    } else {      if (Log.isLoggable(TAG, Log.DEBUG)) {        Log.d(TAG, &quot;Got non empty content encoding: &quot; +     urlConnection.getContentEncoding());      }      stream = urlConnection.getInputStream();    }    return stream;}</code></pre><p>在HttpUrlFetcher#loadData方法的loadDataWithRedirects里面，Glide通过原生的HttpURLConnection进行请求后，并调用getStreamForSuccessfulRequest()方法获取到了最终的图片流。</p><h4 id="15、DecodeJob-run"><a href="#15、DecodeJob-run" class="headerlink" title="15、DecodeJob#run"></a>15、DecodeJob#run</h4><p>在我们通过HtttpUrlFetcher的loadData()方法请求得到对应的流之后，我们还必须对流进行处理得到最终我们想要的资源。这里我们回到第10步DecodeJob#run方法的关注点3处，这行代码将会对流进行解码。</p><pre><code>decodeFromRetrievedData();</code></pre><p>接下来，继续看看他内部的处理。</p><pre><code>private void decodeFromRetrievedData() {    if (Log.isLoggable(TAG, Log.VERBOSE)) {      logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,          &quot;data: &quot; + currentData              + &quot;, cache key: &quot; + currentSourceKey              + &quot;, fetcher: &quot; + currentFetcher);    }    Resource&lt;R&gt; resource = null;    try {      //  核心代码       // 从数据中解码得到资源      resource = decodeFromData(currentFetcher, currentData,   currentDataSource);    } catch (GlideException e) {      e.setLoggingDetails(currentAttemptingKey, currentDataSource);      throwables.add(e);    }    if (resource != null) {      // 关注点8       // 编码和发布最终得到的Resource&lt;Bitmap&gt;对象      notifyEncodeAndRelease(resource, currentDataSource);    } else {      runGenerators();    }} private &lt;Data&gt; Resource&lt;R&gt; decodeFromData(DataFetcher&lt;?&gt; fetcher, Data data,  DataSource dataSource) throws GlideException {    try {      if (data == null) {        return null;      }      long startTime = LogTime.getLogTime();      // 核心代码      // 进一步包装了解码方法      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);      if (Log.isLoggable(TAG, Log.VERBOSE)) {        logWithTimeAndKey(&quot;Decoded result &quot; + result, startTime);      }      return result;    } finally {      fetcher.cleanup();    }}@SuppressWarnings(&quot;unchecked&quot;)private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource)  throws GlideException {    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());    // 核心代码    // 将解码任务分发给LoadPath    return runLoadPath(data, dataSource, path);}private &lt;Data, ResourceType&gt; Resource&lt;R&gt; runLoadPath(Data data, DataSource dataSource,  LoadPath&lt;Data, ResourceType, R&gt; path) throws GlideException {    Options options = getOptionsWithHardwareConfig(dataSource);    // 将数据进一步包装    DataRewinder&lt;Data&gt; rewinder =     glideContext.getRegistry().getRewinder(data);    try {      // ResourceType in DecodeCallback below is required for   compilation to work with gradle.      // 核心代码      // 将解码任务分发给LoadPath      return path.load(          rewinder, options, width, height, new   DecodeCallback&lt;ResourceType&gt;(dataSource));    } finally {      rewinder.cleanup();    }}</code></pre><h4 id="16、LoadPath-load"><a href="#16、LoadPath-load" class="headerlink" title="16、LoadPath#load"></a>16、LoadPath#load</h4><pre><code>public Resource&lt;Transcode&gt; load(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, int width,  int height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback) throws GlideException {List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());try {  // 核心代码  return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);} finally {  listPool.release(throwables);}</code></pre><p>  }</p><pre><code>private Resource&lt;Transcode&gt; loadWithExceptionList(DataRewinder&lt;Data&gt; rewinder,      @NonNull Options options,      int width, int height, DecodePath.DecodeCallback&lt;ResourceType&gt;   decodeCallback,      List&lt;Throwable&gt; exceptions) throws GlideException {    Resource&lt;Transcode&gt; result = null;    //noinspection ForLoopReplaceableByForEach to improve perf    for (int i = 0, size = decodePaths.size(); i &lt; size; i++) {      DecodePath&lt;Data, ResourceType, Transcode&gt; path =   decodePaths.get(i);      try {        // 核心代码        // 将解码任务又进一步分发给DecodePath的decode方法去解码        result = path.decode(rewinder, width, height, options,     decodeCallback);      } catch (GlideException e) {        exceptions.add(e);      }      if (result != null) {        break;      }    }    if (result == null) {      throw new GlideException(failureMessage, new   ArrayList&lt;&gt;(exceptions));    }    return result;}</code></pre><h4 id="17、DecodePath-decode"><a href="#17、DecodePath-decode" class="headerlink" title="17、DecodePath#decode"></a>17、DecodePath#decode</h4><pre><code>public Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder,     int width, int height,      @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)   throws GlideException {    // 核心代码    // 继续调用DecodePath的decodeResource方法去解析出数据    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width,     height, options);    Resource&lt;ResourceType&gt; transformed =     callback.onResourceDecoded(decoded);    return transcoder.transcode(transformed, options);}@NonNullprivate Resource&lt;ResourceType&gt; decodeResource(DataRewinder&lt;DataType&gt;   rewinder, int width,    int height, @NonNull Options options) throws GlideException {  List&lt;Throwable&gt; exceptions =     Preconditions.checkNotNull(listPool.acquire());  try {    // 核心代码    return decodeResourceWithList(rewinder, width, height, options,   exceptions);  } finally {    listPool.release(exceptions);  }}@NonNullprivate Resource&lt;ResourceType&gt;   decodeResourceWithList(DataRewinder&lt;DataType&gt; rewinder, int width,    int height, @NonNull Options options, List&lt;Throwable&gt; exceptions)   throws GlideException {  Resource&lt;ResourceType&gt; result = null;  //noinspection ForLoopReplaceableByForEach to improve perf  for (int i = 0, size = decoders.size(); i &lt; size; i++) {    ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);    try {      DataType data = rewinder.rewindAndGet();      if (decoder.handles(data, options)) {        // 获取包装的数据        data = rewinder.rewindAndGet();        // 核心代码         // 根据DataType和ResourceType的类型分发给不同的解码器Decoder        result = decoder.decode(data, width, height, options);      }    } catch (IOException | RuntimeException | OutOfMemoryError e) {      if (Log.isLoggable(TAG, Log.VERBOSE)) {        Log.v(TAG, &quot;Failed to decode data for &quot; + decoder, e);      }      exceptions.add(e);    }    if (result != null) {      break;    }  }  if (result == null) {    throw new GlideException(failureMessage, new   ArrayList&lt;&gt;(exceptions));  }  return result;}</code></pre><p>可以看到，经过一连串的嵌套调用，最终执行到了decoder.decode()这行代码，decode是一个ResourceDecoder<datatype, resourcetype="">接口（资源解码器），根据不同的DataType和ResourceType它会有不同的实现类，这里的实现类是ByteBufferBitmapDecoder，接下来让我们来看看这个解码器内部的解码流程。</datatype,></p><h4 id="18、ByteBufferBitmapDecoder-decode"><a href="#18、ByteBufferBitmapDecoder-decode" class="headerlink" title="18、ByteBufferBitmapDecoder#decode"></a>18、ByteBufferBitmapDecoder#decode</h4><pre><code>/** * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link    java.nio.ByteBuffer ByteBuffers}. */public class ByteBufferBitmapDecoder implements     ResourceDecoder&lt;ByteBuffer, Bitmap&gt; {  ...  @Override  public Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, int width,   int height,      @NonNull Options options)      throws IOException {    InputStream is = ByteBufferUtil.toStream(source);    // 核心代码    return downsampler.decode(is, width, height, options);  }}</code></pre><p>可以看到，最终是使用了一个downsampler，它是一个压缩器，主要是对流进行解码，压缩，圆角等处理。</p><h4 id="19、DownSampler-decode"><a href="#19、DownSampler-decode" class="headerlink" title="19、DownSampler#decode"></a>19、DownSampler#decode</h4><pre><code>public Resource&lt;Bitmap&gt; decode(InputStream is, int outWidth, int outHeight,  Options options) throws IOException {    return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);} @SuppressWarnings({&quot;resource&quot;, &quot;deprecation&quot;})public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight,      Options options, DecodeCallbacks callbacks) throws IOException {    Preconditions.checkArgument(is.markSupported(), &quot;You must provide an     InputStream that supports&quot;        + &quot; mark()&quot;);    ...    try {      // 核心代码      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,          downsampleStrategy, decodeFormat, isHardwareConfigAllowed,   requestedWidth,          requestedHeight, fixBitmapToRequestedDimensions, callbacks);      // 关注点7         // 解码得到Bitmap对象后，包装成BitmapResource对象返回，      // 通过内部的get方法得到Resource&lt;Bitmap&gt;对象      return BitmapResource.obtain(result, bitmapPool);    } finally {      releaseOptions(bitmapFactoryOptions);      byteArrayPool.put(bytesForOptions);    }}private Bitmap decodeFromWrappedStreams(InputStream is,      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,      int requestedHeight, boolean fixBitmapToRequestedDimensions,      DecodeCallbacks callbacks) throws IOException {    // 省去计算压缩比例等一系列非核心逻辑    ...    // 核心代码    Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);    callbacks.onDecodeComplete(bitmapPool, downsampled);    ...    // Bimtap旋转处理    ...    return rotated;}private static Bitmap decodeStream(InputStream is,     BitmapFactory.Options options,      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws   IOException {    ...    TransformationUtils.getBitmapDrawableLock().lock();    try {      // 核心代码      result = BitmapFactory.decodeStream(is, null, options);    } catch (IllegalArgumentException e) {      ...    } finally {      TransformationUtils.getBitmapDrawableLock().unlock();    }    if (options.inJustDecodeBounds) {      is.reset();    }    return result;}</code></pre><p>从以上源码流程我们知道，最后是在DownSampler的decodeStream()方法中使用了BitmapFactory.decodeStream()来得到Bitmap对象。然后，我们来分析下图片时如何显示的，我们回到步骤19的DownSampler#decode方法，看到关注点7，这里是将Bitmap包装成BitmapResource对象返回，通过内部的get方法可以得到Resource<bitmap>对象，再回到步骤15的DecodeJob#run方法，这是使用了notifyEncodeAndRelease()方法对Resource<bitmap>对象进行了发布。</bitmap></bitmap></p><h4 id="20、DecodeJob-notifyEncodeAndRelease"><a href="#20、DecodeJob-notifyEncodeAndRelease" class="headerlink" title="20、DecodeJob#notifyEncodeAndRelease"></a>20、DecodeJob#notifyEncodeAndRelease</h4><pre><code>private void notifyEncodeAndRelease(Resource&lt;R&gt; resource, DataSource     dataSource) {    ...    notifyComplete(result, dataSource);    ...}private void notifyComplete(Resource&lt;R&gt; resource, DataSource     dataSource) {    setNotifiedOrThrow();    callback.onResourceReady(resource, dataSource);}</code></pre><p>从以上EngineJob的源码可知，它实现了DecodeJob.CallBack<r>这个接口。</r></p><pre><code>class EngineJob&lt;R&gt; implements DecodeJob.Callback&lt;R&gt;,    Poolable {    ...}</code></pre><h4 id="21、EngineJob-onResourceReady"><a href="#21、EngineJob-onResourceReady" class="headerlink" title="21、EngineJob#onResourceReady"></a>21、EngineJob#onResourceReady</h4><pre><code>@Overridepublic void onResourceReady(Resource&lt;R&gt; resource, DataSource   dataSource) {  this.resource = resource;  this.dataSource = dataSource;  MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();}private static class MainThreadCallback implements Handler.Callback{    ...    @Override    public boolean handleMessage(Message message) {      EngineJob&lt;?&gt; job = (EngineJob&lt;?&gt;) message.obj;      switch (message.what) {        case MSG_COMPLETE:          // 核心代码          job.handleResultOnMainThread();          break;        ...      }      return true;    }}</code></pre><p>从以上源码可知，通过主线程Handler对象进行切换线程，然后在主线程调用了handleResultOnMainThread这个方法。</p><pre><code>@Syntheticvoid handleResultOnMainThread() {  ...  //noinspection ForLoopReplaceableByForEach to improve perf  for (int i = 0, size = cbs.size(); i &lt; size; i++) {    ResourceCallback cb = cbs.get(i);    if (!isInIgnoredCallbacks(cb)) {      engineResource.acquire();      cb.onResourceReady(engineResource, dataSource);    }  }  ...}</code></pre><p>这里又通过一个循环调用了所有ResourceCallback的方法，让我们回到步骤9处Engine#load方法的关注点8这行代码，这里对ResourceCallback进行了注册，在步骤8出SingleRequest#onSizeReady方法里的engine.load中，我们看到最后一个参数，传入的是this，可以明白，engineJob.addCallback(cb)这里的cb的实现类就是SingleRequest。接下来，让我们看看SingleRequest的onResourceReady方法。</p><h4 id="22、SingleRequest-onResourceReady"><a href="#22、SingleRequest-onResourceReady" class="headerlink" title="22、SingleRequest#onResourceReady"></a>22、SingleRequest#onResourceReady</h4><pre><code>/** * A callback method that should never be invoked directly. */@SuppressWarnings(&quot;unchecked&quot;)@Overridepublic void onResourceReady(Resource&lt;?&gt; resource, DataSource   dataSource) {  ...  // 从Resource&lt;Bitmap&gt;中得到Bitmap对象  Object received = resource.get();  ...  onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);}private void onResourceReady(Resource&lt;R&gt; resource, R resultDataSource dataSource) {    ...    try {      ...      if (!anyListenerHandledUpdatingTarget) {        Transition&lt;? super R&gt; animation =            animationFactory.build(dataSource, isFirstResource);        // 核心代码        target.onResourceReady(result, animation);      }    } finally {      isCallingCallbacks = false;    }    notifyLoadSuccess();}</code></pre><p>在SingleRequest#onResourceReady方法中又调用了target.onResourceReady(result, animation)方法，这里的target其实就是我们在into方法中建立的那个BitmapImageViewTarget，看到ImageViewTarget类，我们并没有发现onResourceReady方法，但是我们从它的子类ImageViewTarget中发现了onResourceReady方法，从这里我们继续往下看。</p><h4 id="23、ImageViewTarget-onResourceReady"><a href="#23、ImageViewTarget-onResourceReady" class="headerlink" title="23、ImageViewTarget#onResourceReady"></a>23、ImageViewTarget#onResourceReady</h4><pre><code>public abstract class ImageViewTarget&lt;Z&gt; extends ViewTarget&lt;ImageView, Z&gt;implements Transition.ViewAdapter {    ...    @Override    public void onResourceReady(@NonNull Z resource, @Nullable       Transition&lt;? super Z&gt; transition) {      if (transition == null || !transition.transition(resource, this))   {        // 核心代码        setResourceInternal(resource);      } else {        maybeUpdateAnimatable(resource);      }    }    ...    private void setResourceInternal(@Nullable Z resource) {        // Order matters here. Set the resource first to make sure that the         Drawable has a valid and        // non-null Callback before starting it.        // 核心代码        setResource(resource);        maybeUpdateAnimatable(resource);    }    // 核心代码    protected abstract void setResource(@Nullable Z resource);}</code></pre><p>这里我们在回到BitmapImageViewTarget的setResource方法中，我们终于看到Bitmap被设置到了当前的imageView上了。</p><pre><code>public class BitmapImageViewTarget extends ImageViewTarget&lt;Bitmap&gt; {    ...    @Override    protected void setResource(Bitmap resource) {      view.setImageBitmap(resource);    }}</code></pre><p>到这里，我们的分析就结束了，从以上的分析可知，Glide将大部分的逻辑处理都放在了最后一个into方法中，里面经过了20多个分析步骤才将请求图片流、解码出图片，到最终设置到对应的imageView上。</p><h5 id="最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。"><a href="#最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。" class="headerlink" title="最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。"></a>最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>到此，Glide整个的加载流程分析就结束了，可以看到，Glide最核心的逻辑都聚集在into()方法中，它里面的设计精巧而复杂，这部分的源码分析非常耗时，但是，如果你真真正正地去一步步去深入其中，你也许在Android进阶之路上将会有顿悟的感觉。目前，Android主流三方库源码分析系列已经对网络库（OkHttp、Retrofit）和图片加载库（Glide）进行了详细的源码分析，接下来，将会对数据库框架GreenDao的核心源码进行深入的分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Glide V4.8.0源码</p><p>2、<a href="https://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="external">从源码的角度理解Glide的执行流程</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/37297719" target="_blank" rel="external">glide源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（二、深入理解Retrofit源码）</title>
      <link>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 09 Dec 2018 14:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前篇我们详细地分析了OKHttp的核心源码，如果对OKHttp内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>。这篇，将会来深入地分析下目前Android最优秀的网络封装框架Retrofit的源码流程。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><h4 id="1、定义HTTP-API，用于描述请求"><a href="#1、定义HTTP-API，用于描述请求" class="headerlink" title="1、定义HTTP API，用于描述请求"></a>1、定义HTTP API，用于描述请求</h4><pre><code>public interface GitHubService {     @GET(&quot;users/{user}/repos&quot;)     Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><h4 id="2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）"><a href="#2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）" class="headerlink" title="2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）"></a>2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）</h4><pre><code>// 1.Retrofit构建过程Retrofit retrofit = new Retrofit.Builder().baseUrl(&quot;https://api.github.com/&quot;).build();// 2.创建网络请求接口类实例过程GitHubService service = retrofit.create(GitHubService.class);</code></pre><h4 id="3、调用API方法，生成Call，执行请求"><a href="#3、调用API方法，生成Call，执行请求" class="headerlink" title="3、调用API方法，生成Call，执行请求"></a>3、调用API方法，生成Call，执行请求</h4><pre><code>// 3.生成并执行请求过程Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);repos.execute() or repos.enqueue()</code></pre><p>Retrofit的基本使用流程很简洁，但是简洁并不代表简单，Retrofit为了实现这种简洁的使用流程，内部使用了优秀的架构设计和大量的设计模式，在我分析过Retrofit最新版的源码和大量优秀的Retrofit源码分析文章后，我发现，要想真正理解Retrofit内部的核心源码流程和设计思想，首先，需要对这九大设计模式有一定的了解，如下：</p><pre><code>1.Retrofit构建过程 建造者模式、工厂方法模式2.创建网络请求接口实例过程外观模式、代理模式、单例模式、策略模式、装饰模式（建造者模式）3.生成并执行请求过程适配器模式（代理模式、装饰模式）</code></pre><p>其次，需要对OKHttp源码有一定的了解，如果不了解的可以看看这篇<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>。最后，让我们按以上流程去深入Retrofit源码内部，领悟它带给我们的<strong>设计之美</strong>。</p><h3 id="二、Retrofit构建过程"><a href="#二、Retrofit构建过程" class="headerlink" title="二、Retrofit构建过程"></a>二、Retrofit构建过程</h3><h4 id="1、Retrofit核心对象解析"><a href="#1、Retrofit核心对象解析" class="headerlink" title="1、Retrofit核心对象解析"></a>1、Retrofit核心对象解析</h4><p>首先Retrofit中有一个全局变量非常关键，在V2.5之前的版本，使用的是LinkedHashMap()，它是一个网络请求配置对象，是由网络请求接口中方法注解进行解析后得到的。</p><pre><code>public final class Retrofit {    // 网络请求配置对象，存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等    private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();</code></pre><p>Retrofit使用了建造者模式通过内部类Builder类建立一个Retrofit实例，如下：</p><pre><code>public static final class Builder {    // 平台类型对象（Platform -&gt; Android)    private final Platform platform;    // 网络请求工厂，默认使用OkHttpCall（工厂方法模式）    private @Nullable okhttp3.Call.Factory callFactory;    // 网络请求的url地址    private @Nullable HttpUrl baseUrl;    // 数据转换器工厂的集合    private final List&lt;Converter.Factory&gt; converterFactories = new     ArrayList&lt;&gt;();    // 网络请求适配器工厂的集合，默认是ExecutorCallAdapterFactory    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new     ArrayList&lt;&gt;();    // 回调方法执行器，在 Android 上默认是封装了 handler 的 MainThreadExecutor, 默认作用是：切换线程（子线程 -&gt; 主线程）    private @Nullable Executor callbackExecutor;    // 一个开关，为true则会缓存创建的ServiceMethod    private boolean validateEagerly;</code></pre><h4 id="2、Builder内部构造"><a href="#2、Builder内部构造" class="headerlink" title="2、Builder内部构造"></a>2、Builder内部构造</h4><p>下面看看Builder内部构造做了什么。</p><pre><code>public static final class Builder {    ...    Builder(Platform platform) {        this.platform = platform;    }    public Builder() {        this(Platform.get());    }    ...}class Platform {    private static final Platform PLATFORM = findPlatform();    static Platform get() {      return PLATFORM;    }    private static Platform findPlatform() {      try {        // 使用JVM加载类的方式判断是否是Android平台        Class.forName(&quot;android.os.Build&quot;);        if (Build.VERSION.SDK_INT != 0) {          return new Android();        }      } catch (ClassNotFoundException ignored) {      }      try {        // 同时支持Java平台        Class.forName(&quot;java.util.Optional&quot;);        return new Java8();      } catch (ClassNotFoundException ignored) {      }      return new Platform();    }static class Android extends Platform {    ...    @Override public Executor defaultCallbackExecutor() {        //切换线程（子线程 -&gt; 主线程）        return new MainThreadExecutor();    }    // 创建默认的网络请求适配器工厂，如果是Android7.0或Java8上，则使    // 用了并发包中的CompletableFuture保证了回调的同步    // 在Retrofit中提供了四种CallAdapterFactory(策略模式)：    // ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、    // va8CallAdapterFactory、RxJavaCallAdapterFactory    @Override List&lt;? extends CallAdapter.Factory&gt;     defaultCallAdapterFactories(        @Nullable Executor callbackExecutor) {      if (callbackExecutor == null) throw new AssertionError();      ExecutorCallAdapterFactory executorFactory = new   ExecutorCallAdapterFactory(callbackExecutor);      return Build.VERSION.SDK_INT &gt;= 24        ? asList(CompletableFutureCallAdapterFactory.INSTANCE,     executorFactory)        : singletonList(executorFactory);    }    ...    @Override List&lt;? extends Converter.Factory&gt;     defaultConverterFactories() {      return Build.VERSION.SDK_INT &gt;= 24          ? singletonList(OptionalConverterFactory.INSTANCE)          : Collections.&lt;Converter.Factory&gt;emptyList();    }    ...    static class MainThreadExecutor implements Executor {        // 获取Android 主线程的Handler         private final Handler handler = new   Handler(Looper.getMainLooper());        @Override public void execute(Runnable r) {            // 在UI线程对网络请求返回数据处理            handler.post(r);        }    }}</code></pre><p>可以看到，在Builder内部构造时设置了默认Platform、callAdapterFactories和callbackExecutor。</p><h4 id="3、添加baseUrl"><a href="#3、添加baseUrl" class="headerlink" title="3、添加baseUrl"></a>3、添加baseUrl</h4><p>很简单，就是将String类型的url转换为OkHttp的HttpUrl过程如下：</p><pre><code>/** * Set the API base URL. * * @see #baseUrl(HttpUrl) */public Builder baseUrl(String baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    return baseUrl(HttpUrl.get(baseUrl));}public Builder baseUrl(HttpUrl baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    List&lt;String&gt; pathSegments = baseUrl.pathSegments();    if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) {      throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; +     baseUrl);    }    this.baseUrl = baseUrl;    return this;}</code></pre><h4 id="4、添加GsonConverterFactory"><a href="#4、添加GsonConverterFactory" class="headerlink" title="4、添加GsonConverterFactory"></a>4、添加GsonConverterFactory</h4><p>首先，看到GsonConverterFactory.creat()的源码。</p><pre><code>public final class GsonConverterFactory extends Converter.Factory {    public static GsonConverterFactory create() {        return create(new Gson());    }    public static GsonConverterFactory create(Gson gson) {        if (gson == null) throw new NullPointerException(&quot;gson ==   null&quot;);        return new GsonConverterFactory(gson);    }    private final Gson gson;    // 创建了一个含有Gson对象实例的GsonConverterFactory    private GsonConverterFactory(Gson gson) {        this.gson = gson;    }</code></pre><p>然后，看看addConverterFactory()方法内部。</p><pre><code>public Builder addConverterFactory(Converter.Factory factory) {    converterFactories.add(checkNotNull(factory, &quot;factory null&quot;));    return this;}</code></pre><p>可知，这一步是将一个含有Gson对象实例的GsonConverterFactory放入到了数据转换器工厂converterFactories里。</p><h4 id="5、build过程"><a href="#5、build过程" class="headerlink" title="5、build过程"></a>5、build过程</h4><pre><code>public Retrofit build() {    if (baseUrl == null) {      throw new IllegalStateException(&quot;Base URL required.&quot;);    }    okhttp3.Call.Factory callFactory = this.callFactory;    if (callFactory == null) {        // 默认使用okhttp         callFactory = new OkHttpClient();    }    Executor callbackExecutor = this.callbackExecutor;    if (callbackExecutor == null) {        // Android默认的callbackExecutor        callbackExecutor = platform.defaultCallbackExecutor();    }    // Make a defensive copy of the adapters and add the defaultCall  adapter.    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);    // 添加默认适配器工厂在集合尾部    callAdapterFactories.addAll(platform.defaultCallAdapterFactorisca  llbackExecutor));    // Make a defensive copy of the converters.    List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(        1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());    // Add the built-in converter factory first. This prevents overriding its behavior but also    // ensures correct behavior when using converters thatconsumeall   types.    converterFactories.add(new BuiltInConverters());    converterFactories.addAll(this.converterFactories);    converterFactories.addAll(platform.defaultConverterFactories();    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);}</code></pre><p>可以看到，最终我们在Builder类中看到的6大核心对象都已经配置到Retrofit对象中了。</p><h3 id="三、创建网络请求接口实例过程"><a href="#三、创建网络请求接口实例过程" class="headerlink" title="三、创建网络请求接口实例过程"></a>三、创建网络请求接口实例过程</h3><p>retrofit.create()使用了外观模式和代理模式创建了网络请求的接口实例，我们分析下create方法。</p><pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {        // 判断是否需要提前缓存ServiceMethod对象        eagerlyValidateMethods(service);    }    // 使用动态代理拿到请求接口所有注解配置后，创建网络请求接口实例    return (T) Proxy.newProxyInstance(service.getClassLoader(), new     Class&lt;?&gt;[] { service },        new InvocationHandler() {          private final Platform platform = Platform.get();          private final Object[] emptyArgs = new Object[0];          @Override public Object invoke(Object proxy, Method method,   @Nullable Object[] args)              throws Throwable {            // If the method is a method from Object then defer to normal     invocation.            if (method.getDeclaringClass() == Object.class) {              return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {              return platform.invokeDefaultMethod(method, service, proxy,   args);            }            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);          }    }); }private void eagerlyValidateMethods(Class&lt;?&gt; service) {  Platform platform = Platform.get();  for (Method method : service.getDeclaredMethods()) {    if (!platform.isDefaultMethod(method)) {      loadServiceMethod(method);    }  }}</code></pre><p>继续看看loadServiceMethod的内部流程</p><pre><code>ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) {      result = serviceMethodCache.get(method);      if (result == null) {            // 解析注解配置得到了ServiceMethod            result = ServiceMethod.parseAnnotations(this, method);            // 可以看到，最终加入到ConcurrentHashMap缓存中            serviceMethodCache.put(method, result);      }    }    return result;}abstract class ServiceMethod&lt;T&gt; {  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method   method) {        // 通过RequestFactory解析注解配置（工厂模式、内部使用了建造者模式）        RequestFactory requestFactory =         RequestFactory.parseAnnotations(retrofit, method);        Type returnType = method.getGenericReturnType();        if (Utils.hasUnresolvableType(returnType)) {          throw methodError(method,              &quot;Method return type must not include a type variable or      wildcard: %s&quot;, returnType);        }        if (returnType == void.class) {          throw methodError(method, &quot;Service methods cannot return    void.&quot;);        }        // 最终是通过HttpServiceMethod构建的请求方法        return HttpServiceMethod.parseAnnotations(retrofit, method,         requestFactory);    }    abstract T invoke(Object[] args);}</code></pre><h4 id="以下为请求构造核心流程"><a href="#以下为请求构造核心流程" class="headerlink" title="以下为请求构造核心流程"></a>以下为请求构造核心流程</h4><p>根据RequestFactory#Builder构造方法和parseAnnotations方法的源码，可知的它的作用就是用来解析注解配置的。</p><pre><code>Builder(Retrofit retrofit, Method method) {    this.retrofit = retrofit;    this.method = method;    // 获取网络请求接口方法里的注释    this.methodAnnotations = method.getAnnotations();    // 获取网络请求接口方法里的参数类型           this.parameterTypes = method.getGenericParameterTypes();    // 获取网络请求接口方法里的注解内容        this.parameterAnnotationsArray = method.getParameterAnnotations();}</code></pre><p>接着看HttpServiceMethod.parseAnnotations()的内部流程。</p><pre><code>static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt;     parseAnnotations(      Retrofit retrofit, Method method, RequestFactory requestFactory) {        // 1.根据网络请求接口方法的返回值和注解类型，        // 从Retrofit对象中获取对应的网络请求适配器         CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =         createCallAdapter(retrofit, method);        // 得到响应类型        Type responseType = callAdapter.responseType();        ...        // 2.根据网络请求接口方法的返回值和注解类型，从Retrofit对象中获取对应的数据转换器         Converter&lt;ResponseBody, ResponseT&gt; responseConverter =            createResponseConverter(retrofit, method, responseType);        okhttp3.Call.Factory callFactory = retrofit.callFactory;        return new HttpServiceMethod&lt;&gt;(requestFactory, callFactory,         callAdapter, responseConverter);}</code></pre><h5 id="1-createCallAdapter-retrofit-method"><a href="#1-createCallAdapter-retrofit-method" class="headerlink" title="1.createCallAdapter(retrofit, method)"></a>1.createCallAdapter(retrofit, method)</h5><pre><code>private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt;     createCallAdapter(      Retrofit retrofit, Method method) {    // 获取网络请求接口里方法的返回值类型    Type returnType = method.getGenericReturnType();    // 获取网络请求接口接口里的注解    Annotation[] annotations = method.getAnnotations();    try {      //noinspection unchecked      return (CallAdapter&lt;ResponseT, ReturnT&gt;)  retrofit.callAdapter(returnType, annotations);    } catch (RuntimeException e) { // Wide exception range because         factories are user code.      throw methodError(method, e, &quot;Unable to create call adapter  for     %s&quot;, returnType);    }}public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) {    return nextCallAdapter(null, returnType, annotations);}public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,  Annotation[] annotations) {    ...    int start = callAdapterFactories.indexOf(skipPast) + 1;    // 遍历 CallAdapter.Factory 集合寻找合适的工厂    for (int i = start, count = callAdapterFactories.size(); i &lt;count; i++) {        CallAdapter&lt;?, ?&gt; adapter =    callAdapterFactories.get(i).get(returnType, annotations, this);        if (adapter != null) {          return adapter;        }    }}</code></pre><h5 id="2-createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType"><a href="#2-createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType" class="headerlink" title="2.createResponseConverter(Retrofit retrofit, Method method, Type responseType)"></a>2.createResponseConverter(Retrofit retrofit, Method method, Type responseType)</h5><pre><code> private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt;  createResponseConverter(     Retrofit retrofit, Method method, Type responseType) {   Annotation[] annotations = method.getAnnotations();   try {     return retrofit.responseBodyConverter(responseType,annotations);   } catch (RuntimeException e) { // Wide exception range because    factories are user code.     throw methodError(method, e, &quot;Unable to create converter for%s&quot;,   responseType);   }}public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) {    return nextResponseBodyConverter(null, type, annotations);}public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(  @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {...int start = converterFactories.indexOf(skipPast) + 1;// 遍历 Converter.Factory 集合并寻找合适的工厂, 这里是GsonResponseBodyConverterfor (int i = start, count = converterFactories.size(); i &lt; count; i++) {  Converter&lt;ResponseBody, ?&gt; converter =      converterFactories.get(i).responseBodyConverter(type, annotations, this);  if (converter != null) {    //noinspection unchecked    return (Converter&lt;ResponseBody, T&gt;) converter;  }}</code></pre><h4 id="最终，执行HttpServiceMethod的invoke方法"><a href="#最终，执行HttpServiceMethod的invoke方法" class="headerlink" title="最终，执行HttpServiceMethod的invoke方法"></a>最终，执行HttpServiceMethod的invoke方法</h4><pre><code>@Override ReturnT invoke(Object[] args) {    return callAdapter.adapt(        new OkHttpCall&lt;&gt;(requestFactory, args, callFactory,     responseConverter));}</code></pre><p>最终在adapt中创建了一个ExecutorCallbackCall对象，它是一个装饰者，而在它内部真正去执行网络请求的还是OkHttpCall。</p><h3 id="四、创建网络请求接口类实例并执行请求过程"><a href="#四、创建网络请求接口类实例并执行请求过程" class="headerlink" title="四、创建网络请求接口类实例并执行请求过程"></a>四、创建网络请求接口类实例并执行请求过程</h3><h4 id="1、service-listRepos"><a href="#1、service-listRepos" class="headerlink" title="1、service.listRepos()"></a>1、service.listRepos()</h4><pre><code>1、Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</code></pre><p>service对象是动态代理对象Proxy.newProxyInstance()，当调用getCall()时会被<br>它拦截，然后调用自身的InvocationHandler#invoke()，得到最终的Call对象。</p><h4 id="2、同步执行流程-repos-execute"><a href="#2、同步执行流程-repos-execute" class="headerlink" title="2、同步执行流程 repos.execute()"></a>2、同步执行流程 repos.execute()</h4><pre><code>@Override public Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already     executed.&quot;);      executed = true;      if (creationFailure != null) {        if (creationFailure instanceof IOException) {          throw (IOException) creationFailure;        } else if (creationFailure instanceof RuntimeException) {          throw (RuntimeException) creationFailure;        } else {          throw (Error) creationFailure;        }      }      call = rawCall;      if (call == null) {        try {          // 创建一个OkHttp的Request对象请求          call = rawCall = createRawCall();        } catch (IOException | RuntimeException | Error e) {          throwIfFatal(e); //  Do not assign a fatal error to     creationFailure.          creationFailure = e;          throw e;        }      }    }    if (canceled) {      call.cancel();    }    // 调用OkHttpCall的execute()发送网络请求（同步），    // 并解析网络请求返回的数据    return parseResponse(call.execute());}private okhttp3.Call createRawCall() throws IOException {    // 创建 一个okhttp3.Request    okhttp3.Call call =    callFactory.newCall(requestFactory.create(args));    if (call == null) {      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    }    return call;}Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {    ResponseBody rawBody = rawResponse.body();     // Remove the body&apos;s source (the only stateful object) so we can   pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(),     rawBody.contentLength()))        .build();        // 根据响应返回的状态码进行处理        int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) {      try {        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);      } finally {        rawBody.close();      }    }        if (code == 204 || code == 205) {      rawBody.close();      return Response.success(null, rawResponse);    }        ExceptionCatchingResponseBody catchingBody = new    ExceptionCatchingResponseBody(rawBody);    try {      // 将响应体转为Java对象      T body = responseConverter.convert(catchingBody);      return Response.success(body, rawResponse);    } catch (RuntimeException e) {      // If the underlying source threw an exception, propagate that     rather than indicating it was      // a runtime exception.      catchingBody.throwIfCaught();      throw e;    }}</code></pre><h4 id="3、异步请求流程-repos-enqueque"><a href="#3、异步请求流程-repos-enqueque" class="headerlink" title="3、异步请求流程 repos.enqueque"></a>3、异步请求流程 repos.enqueque</h4><pre><code>@Override public void enqueue(final Callback&lt;T&gt; callback) {    // 使用静态代理 delegate进行异步请求     delegate.enqueue(new Callback&lt;T&gt;() {      @Override       public void onResponse(Call&lt;T&gt; call, finalResponse&lt;T&gt;response)     {        // 线程切换，在主线程显示结果        callbackExecutor.execute(new Runnable() {            @Override              public void run() {            if (delegate.isCanceled()) {              callback.onFailure(ExecutorCallbackCall.this, newIOException(&quot;Canceled&quot;));            } else {              callback.onResponse(ExecutorCallbackCall.this,respons);            }          }        });      }      @Override       public void onFailure(Call&lt;T&gt; call, final Throwable t) {        callbackExecutor.execute(new Runnable() {          @Override public void run() {            callback.onFailure(ExecutorCallbackCall.this, t);          }        });      }    });}</code></pre><p>看看 delegate.enqueue 内部流程。</p><pre><code>@Override public void enqueue(final Callback&lt;T&gt; callback) {    okhttp3.Call call;    Throwable failure;    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);      executed = true;      call = rawCall;      failure = creationFailure;      if (call == null &amp;&amp; failure == null) {        try {          // 创建OkHttp的Request对象，再封装成OkHttp.call          // 方法同发送同步请求，此处上面已分析          call = rawCall = createRawCall();         } catch (Throwable t) {          failure = creationFailure = t;        }      }@Override public void enqueue(final Callback&lt;T&gt; callback) {  checkNotNull(callback, &quot;callback == null&quot;);  okhttp3.Call call;  Throwable failure;  ...  call.enqueue(new okhttp3.Callback() {    @Override public void onResponse(okhttp3.Call call,   okhttp3.Response rawResponse) {      Response&lt;T&gt; response;      try {        // 此处上面已分析        response = parseResponse(rawResponse);      } catch (Throwable e) {        throwIfFatal(e);        callFailure(e);        return;      }      try {        callback.onResponse(OkHttpCall.this, response);      } catch (Throwable t) {        t.printStackTrace();      }    }    @Override public void onFailure(okhttp3.Call call, IOException e) {      callFailure(e);    }    private void callFailure(Throwable e) {      try {        callback.onFailure(OkHttpCall.this, e);      } catch (Throwable t) {        t.printStackTrace();      }    }  });}</code></pre><p>如果你看到这里的话，恭喜你，你已经对Retrofit已经有一个比较深入的了解了，但是，笔者还是要建议大家自己主动配合着Retrofit最新版的源码一步步去彻底地认识它，只要这样，你才能看到它真实的内心，最后附上一张Stay的Retrofit源码流程图，要注意的是，这是V2.5之前版本的流程，但是，在看完上面的源码分析后，我们知道，主体流程是没有变化的。</p><p><img src="https://upload-images.jianshu.io/upload_images/625299-29a632638d9f518f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/891/format/webp" alt="image"></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>从本质上来说，Retrofit虽然只是一个RESTful 的HTTP 网络请求框架的封装库。但是，它内部通过 大量的设计模式 封装了 OkHttp，让使用者感到它非常简洁、易懂。它内部主要是用动态代理 的方式，动态将网络请求接口的注解 解析 成HTTP请求，最后执行请求的过程。好了，至此，我们的Android主流三方库源码分析的网络库分析部分已经完毕。接下来，将为大家带来最流行的图片加载框架Glide的源码分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Retrofit V2.5.0源码</p><p>2、Android进阶之光</p><p>3、<a href="https://www.jianshu.com/p/0c055ad46b6c" target="_blank" rel="external">Android：手把手带你 深入读懂 Retrofit 2.0 源码</a></p><p>4、<a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（一、深入理解OKHttp源码）</title>
      <link>http://yoursite.com/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sat, 01 Dec 2018 11:49:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细分析了View的核心源码—<a href="https://jsonchao.github.io/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Android的触摸事件传递机制</a>和<a href="https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Android View的绘制流程</a>，从这篇开始，笔者接下来将会陪大家深入分析目前Android中大部分的主流开源框架源码，从而能够让我们真正地去理解这些优秀开源框架背后的思想，真真切切地提升自己的内功。目前，这一系列的分析顺序如下：</p><pre><code>主流三方库：网络：1、OKHttp2、Retrofit图片：3、Glide数据库：4、GreenDao响应式编程：5、RxJava内存泄露：6、LeakCanary依赖注入：7、ButterKnife8、Dagger2事件总线：9、EventBus</code></pre><p>这一篇将会对Android的三方网络库OKHttp源码进行深入的分析，在阅读过OKHttp源码和大量其它优秀的OKHttp源码分析文章后，我发现只要搞懂以下这三块，就能<strong>证明你对OKHttp有了一个深入的理解</strong>。</p><ul><li>OKHttp请求流程</li><li>网络请求缓存处理</li><li>连接池</li></ul><p>首先，补充一点网络知识：</p><p>一些常用的状态码</p><ul><li>100~199：指示信息，表示请求已接收，继续处理</li><li>200~299：请求成功，表示请求已被成功接收、理解、接受</li><li>300~399：重定向，要完成请求必须进行更进一步的操作</li><li>400~499：客户端错误，请求有语法错误或请求无法实现</li><li>500~599：服务器端错误，服务器未能实现合法的请求</li></ul><h3 id="一、OKHttp请求流程"><a href="#一、OKHttp请求流程" class="headerlink" title="一、OKHttp请求流程"></a>一、OKHttp请求流程</h3><p>OKHttp内部的大致请求流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1916953-fc6439af2bfefddc.jpg?imageMogr2/auto-orient/" alt="image"></p><p>如下为使用OKHttp进行Get请求的步骤：</p><pre><code>//1.新建OKHttpClient客户端OkHttpClient client = new OkHttpClient();//新建一个Request对象Request request = new Request.Builder()        .url(url)        .build();//2.Response为OKHttp中的响应Response response = client.newCall(request).execute();</code></pre><h4 id="1-新建OKHttpClient客户端"><a href="#1-新建OKHttpClient客户端" class="headerlink" title="1.新建OKHttpClient客户端"></a>1.新建OKHttpClient客户端</h4><pre><code>OkHttpClient client = new OkHttpClient();public OkHttpClient() {    this(new Builder());}OkHttpClient(Builder builder) {    ....}</code></pre><p>可以看到，OkHttpClient使用了建造者模式，Builder里面的可配置参数如下：</p><pre><code>public static final class Builder {    Dispatcher dispatcher;//分发器    @Nullable Proxy proxy;    List&lt;Protocol&gt; protocols;    List&lt;ConnectionSpec&gt; connectionSpecs;//传输层版本和连接协议    final List&lt;Interceptor&gt; interceptors = new     ArrayList&lt;&gt;();//拦截器    final List&lt;Interceptor&gt; networkInterceptors = new     ArrayList&lt;&gt;();    EventListener.Factory eventListenerFactory;    ProxySelector proxySelector;    CookieJar cookieJar;    @Nullable Cache cache;    @Nullable InternalCache internalCache;//内部缓存    SocketFactory socketFactory;    @Nullable SSLSocketFactory sslSocketFactory;//安全套接层socket 工厂，用于HTTPS    @Nullable CertificateChainCleaner     certificateChainCleaner;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。    HostnameVerifier hostnameVerifier;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。    CertificatePinner certificatePinner;// 验证确认响应证书 适用 HTTPS 请求连接的主机名。    Authenticator proxyAuthenticator;//代理身份验证    Authenticator authenticator;//代理身份验证    ConnectionPool connectionPool;//代理身份验证    Dns dns;    boolean followSslRedirects; //安全套接层重定向    boolean followRedirects;//本地重定向    boolean retryOnConnectionFailure;//重试连接失败    int callTimeout;    int connectTimeout;    int readTimeout;    int writeTimeout;    int pingInterval;    // 这里是默认配置的构建参数    public Builder() {        dispatcher = new Dispatcher();        protocols = DEFAULT_PROTOCOLS;        connectionSpecs = DEFAULT_CONNECTION_SPECS;        ...    }    // 这里传入自己配置的构建参数    Builder(OkHttpClient okHttpClient) {        this.dispatcher = okHttpClient.dispatcher;        this.proxy = okHttpClient.proxy;        this.protocols = okHttpClient.protocols;        this.connectionSpecs = okHttpClient.connectionSpecs;        this.interceptors.addAll(okHttpClient.interceptors);        this.networkInterceptors.addAll(okHttpClient.networkInterceptors);        ...    }</code></pre><h4 id="2-执行-同步-请求流程"><a href="#2-执行-同步-请求流程" class="headerlink" title="2.执行(同步)请求流程"></a>2.执行(同步)请求流程</h4><pre><code>Response response = client.newCall(request).execute();/*** Prepares the {@code request} to be executed at   some point in the future.*/@Override public Call newCall(Request request) {    return RealCall.newRealCall(this, request, false /*     for web socket */);}// RealCall为真正的请求执行者static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {    // Safely publish the Call instance to the EventListener.    RealCall call = new RealCall(client, originalRequest, forWebSocket);    call.eventListener = client.eventListenerFactory().create(call);    return call;}@Override public Response execute() throws IOException {    synchronized (this) {        // 每个Call只能执行一次        if (executed) throw new IllegalStateException(&quot;Already Executed&quot;);        executed = true;    }    captureCallStackTrace();    timeout.enter();    eventListener.callStart(this);    try {        // 通知dispatcher已经进入执行状态        client.dispatcher().executed(this);        // 通过一系列的拦截器请求处理和响应处理得到最终的返回结果        Response result =     getResponseWithInterceptorChain();        if (result == null) throw new     IOException(&quot;Canceled&quot;);        return result;    } catch (IOException e) {        e = timeoutExit(e);        eventListener.callFailed(this, e);        throw e;    } finally {        // 通知 dispatcher 自己已经执行完毕        client.dispatcher().finished(this);    }}Response getResponseWithInterceptorChain() throws IOException {    // Build a full stack of interceptors.    List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();    // 在配置 OkHttpClient 时设置的 interceptors；    interceptors.addAll(client.interceptors());    // 负责失败重试以及重定向    interceptors.add(retryAndFollowUpInterceptor);    // 请求时，对必要的Header进行一些添加，接受响应时，移除必要的Header    interceptors.add(new     BridgeInterceptor(client.cookieJar()));    // 负责读取缓存直接返回、更新缓存    interceptors.add(new     CacheInterceptor(client.internalCache()));    // 负责和服务器建立连接    interceptors.add(new ConnectInterceptor(client));    if (!forWebSocket) {        // 配置 OkHttpClient 时设置的 networkInterceptors        interceptors.addAll(client.networkInterceptors())  ;    }    // 负责向服务器发送请求数据、从服务器读取响应数据    interceptors.add(new CallServerInterceptor(forWebSocket));    Interceptor.Chain chain = new RealInterceptorChain(interceptors, null, null, null, 0,        originalRequest, this, eventListener, client.connectTimeoutMillis(),        client.readTimeoutMillis(), client.writeTimeoutMillis());    // 使用责任链模式开启链式调用    return chain.proceed(originalRequest);}// StreamAllocation 对象，它相当于一个管理类，维护了服务器连接、并发流// 和请求之间的关系，该类还会初始化一个 Socket 连接对象，获取输入/输出流对象。public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,  RealConnection connection) throws IOException {    ...    // Call the next interceptor in the chain.    // 实例化下一个拦截器对应的RealIterceptorChain对象    RealInterceptorChain next = new     RealInterceptorChain(interceptors,     streamAllocation, httpCodec,        connection, index + 1, request, call,     eventListener, connectTimeout, readTimeout,        writeTimeout);    // 得到当前的拦截器    Interceptor interceptor = interceptors.get(index);    // 调用当前拦截器的intercept()方法，并将下一个拦截器的RealIterceptorChain对象传递下去,最后得到响应    Response response = interceptor.intercept(next);    ...    return response;}</code></pre><h4 id="3-异步请求的流程"><a href="#3-异步请求的流程" class="headerlink" title="3.异步请求的流程"></a>3.异步请求的流程</h4><pre><code>Request request = new Request.Builder()    .url(&quot;http://publicobject.com/helloworld.txt&quot;)    .build();client.newCall(request).enqueue(new Callback() {    @Override     public void onFailure(Call call, IOException e) {      e.printStackTrace();    }    @Override     public void onResponse(Call call, Response   response) throws IOException {        ...    }void enqueue(AsyncCall call) {synchronized (this) {    readyAsyncCalls.add(call);}    promoteAndExecute();}// 正在准备中的异步请求队列private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;();// 运行中的异步请求private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;();// 同步请求private final Deque&lt;RealCall&gt; runningSyncCalls = new   ArrayDeque&lt;&gt;();//  Promotes eligible calls from {@link #readyAsyncCalls} to {@link #runningAsyncCalls} and runs// them on the executor service. Must not be called with synchronization because executing calls// can call into user code.private boolean promoteAndExecute() {    assert (!Thread.holdsLock(this));    List&lt;AsyncCall&gt; executableCalls = new     ArrayList&lt;&gt;();    boolean isRunning;    synchronized (this) {      for (Iterator&lt;AsyncCall&gt; i =   readyAsyncCalls.iterator(); i.hasNext(); ) {        AsyncCall asyncCall = i.next();        // 如果中的runningAsynCalls不满，且call占用的host小于最大数量，则将call加入到runningAsyncCalls中执行，        // 同时利用线程池执行call；否者将call加入到readyAsyncCalls中。        if (runningAsyncCalls.size() &gt;= maxRequests)     break; // Max capacity.        if (runningCallsForHost(asyncCall) &gt;=     maxRequestsPerHost) continue; // Host max     capacity.        i.remove();        executableCalls.add(asyncCall);        runningAsyncCalls.add(asyncCall);      }      isRunning = runningCallsCount() &gt; 0;    }    for (int i = 0, size = executableCalls.size(); i &lt;     size; i++) {      AsyncCall asyncCall = executableCalls.get(i);      asyncCall.executeOn(executorService());    }    return isRunning;}</code></pre><p>最后，我们在看看AsynCall的代码。</p><pre><code>final class AsyncCall extends NamedRunnable {    private final Callback responseCallback;    AsyncCall(Callback responseCallback) {      super(&quot;OkHttp %s&quot;, redactedUrl());      this.responseCallback = responseCallback;    }    String host() {      return originalRequest.url().host();    }    Request request() {      return originalRequest;    }    RealCall get() {      return RealCall.this;    }    /**     * Attempt to enqueue this async call on {@code    executorService}. This will attempt to clean up     * if the executor has been shut down by reporting    the call as failed.     */    void executeOn(ExecutorService executorService) {      assert (!Thread.holdsLock(client.dispatcher()));      boolean success = false;      try {        executorService.execute(this);        success = true;      } catch (RejectedExecutionException e) {        InterruptedIOException ioException = new     InterruptedIOException(&quot;executor rejected&quot;);        ioException.initCause(e);        eventListener.callFailed(RealCall.this,     ioException);        responseCallback.onFailure(RealCall.this,     ioException);      } finally {        if (!success) {          client.dispatcher().finished(this); // This   call is no longer running!        }      }    }    @Override protected void execute() {      boolean signalledCallback = false;      timeout.enter();      try {        // 跟同步执行一样，最后都会调用到这里        Response response =     getResponseWithInterceptorChain();        if (retryAndFollowUpInterceptor.isCanceled()) {          signalledCallback = true;          responseCallback.onFailure(RealCall.this, new   IOException(&quot;Canceled&quot;));        } else {          signalledCallback = true;          responseCallback.onResponse(RealCall.this,   response);        }      } catch (IOException e) {        e = timeoutExit(e);        if (signalledCallback) {          // Do not signal the callback twice!          Platform.get().log(INFO, &quot;Callback failure   for &quot; + toLoggableString(), e);        } else {          eventListener.callFailed(RealCall.this, e);          responseCallback.onFailure(RealCall.this, e);        }      } finally {        client.dispatcher().finished(this);      }    }}</code></pre><p>从上面的源码可以知道，拦截链的处理OKHttp帮我们默认做了五步拦截处理，其中RetryAndFollowUpInterceptor、BridgeInterceptor、CallServerInterceptor内部的源码很简洁易懂，此处不再多说，下面将对OKHttp最为核心的两部分缓存处理和连接处理（连接池）进行讲解。   </p><h3 id="二、网络请求缓存处理之CacheInterceptor"><a href="#二、网络请求缓存处理之CacheInterceptor" class="headerlink" title="二、网络请求缓存处理之CacheInterceptor"></a>二、网络请求缓存处理之CacheInterceptor</h3><pre><code>@Override public Response intercept(Chain chain) throws IOException {    // 根据request得到cache中缓存的response    Response cacheCandidate = cache != null        ? cache.get(chain.request())        : null;    long now = System.currentTimeMillis();    // request判断缓存的策略，是否要使用了网络，缓存或两者都使用    CacheStrategy strategy = new     CacheStrategy.Factory(now, chain.request(),     cacheCandidate).get();    Request networkRequest = strategy.networkRequest;    Response cacheResponse = strategy.cacheResponse;    if (cache != null) {      cache.trackResponse(strategy);    }    if (cacheCandidate != null &amp;&amp; cacheResponse ==     null) {      closeQuietly(cacheCandidate.body()); // The cache   candidate wasn&apos;t applicable. Close it.    }    // If we&apos;re forbidden from using the network and     the cache is insufficient, fail.    if (networkRequest == null &amp;&amp; cacheResponse ==     null) {      return new Response.Builder()          .request(chain.request())          .protocol(Protocol.HTTP_1_1)          .code(504)          .message(&quot;Unsatisfiable Request   (only-if-cached)&quot;)          .body(Util.EMPTY_RESPONSE)          .sentRequestAtMillis(-1L)          .receivedResponseAtMillis(System.currentTimeM  illis())          .build();    }    // If we don&apos;t need the network, we&apos;re done.    if (networkRequest == null) {      return cacheResponse.newBuilder()          .cacheResponse(stripBody(cacheResponse))          .build();    }    Response networkResponse = null;    try {        // 调用下一个拦截器，决定从网络上来得到response        networkResponse = chain.proceed(networkRequest);    } finally {        // If we&apos;re crashing on I/O or otherwise,   don&apos;t   leak the cache body.        if (networkResponse == null &amp;&amp; cacheCandidate   !=   null) {          closeQuietly(cacheCandidate.body());        }    }    // If we have a cache response too, then we&apos;re     doing a conditional get.    // 如果本地已经存在cacheResponse，那么让它和网络得到的networkResponse做比较，决定是否来更新缓存的cacheResponse    if (cacheResponse != null) {        if (networkResponse.code() ==   HTTP_NOT_MODIFIED)   {          Response response =     cacheResponse.newBuilder()                  .headers(combine(cacheResponse.headers(    ),     networkResponse.headers()))                  .sentRequestAtMillis(networkResponse.se    ntRe    questAtMillis())                  .receivedResponseAtMillis(networkRespon    se.r    eceivedResponseAtMillis())                  .cacheResponse(stripBody(cacheResponse)    )                  .networkResponse(stripBody(networkRespo    nse)    )              .build();          networkResponse.body().close();          // Update the cache after combining headers     but     before stripping the          // Content-Encoding header (as performed by         initContentStream()).          cache.trackConditionalCacheHit();          cache.update(cacheResponse, response);          return response;        } else {          closeQuietly(cacheResponse.body());        }    }    Response response = networkResponse.newBuilder()        .cacheResponse(stripBody(cacheResponse))        .networkResponse(stripBody(networkResponse))        .build();    if (cache != null) {      if (HttpHeaders.hasBody(response) &amp;&amp;   CacheStrategy.isCacheable(response,   networkRequest)) {        // Offer this request to the cache.        // 缓存未经缓存过的response        CacheRequest cacheRequest =     cache.put(response);        return cacheWritingResponse(cacheRequest,     response);      }      if (HttpMethod.invalidatesCache(networkRequest.me  thod())) {        try {          cache.remove(networkRequest);        } catch (IOException ignored) {          // The cache cannot be written.        }      }    }    return response;}</code></pre><p>缓存拦截器会根据请求的信息和缓存的响应的信息来判断是否存在缓存可用，如果有可以使用的缓存，那么就返回该缓存给用户，否则就继续使用责任链模式来从服务器中获取响应。当获取到响应的时候，又会把响应缓存到磁盘上面。</p><h3 id="三、ConnectInterceptor之连接池"><a href="#三、ConnectInterceptor之连接池" class="headerlink" title="三、ConnectInterceptor之连接池"></a>三、ConnectInterceptor之连接池</h3><pre><code>@Override public Response intercept(Chain chain) throws IOException {    RealInterceptorChain realChain =     (RealInterceptorChain) chain;    Request request = realChain.request();    StreamAllocation streamAllocation =     realChain.streamAllocation();    // We need the network to satisfy this request.     Possibly for validating a conditional GET.    boolean doExtensiveHealthChecks =     !request.method().equals(&quot;GET&quot;);    // HttpCodec是对 HTTP 协议操作的抽象，有两个实现：Http1Codec和Http2Codec，顾名思义，它们分别对应 HTTP/1.1 和 HTTP/2 版本的实现。在这个方法的内部实现连接池的复用处理    HttpCodec httpCodec =     streamAllocation.newStream(client, chain,     doExtensiveHealthChecks);    RealConnection connection =     streamAllocation.connection();    return realChain.proceed(request, streamAllocation,     httpCodec, connection);}// Returns a connection to host a new stream. This // prefers the existing connection if it exists,// then the pool, finally building a new connection.// 调用 streamAllocation 的 newStream() 方法的时候，最终会经过一系列// 的判断到达 StreamAllocation 中的 findConnection() 方法private RealConnection findConnection(int   connectTimeout, int readTimeout, int writeTimeout,    int pingIntervalMillis, boolean   connectionRetryEnabled) throws IOException {      ...      // Attempt to use an already-allocated       connection. We need to be careful here because       our      // already-allocated connection may have been       restricted from creating new streams.      // 尝试使用已分配的连接，已经分配的连接可能已经被限制创建新的流      releasedConnection = this.connection;      // 释放当前连接的资源，如果该连接已经被限制创建新的流，就返回一个Socket以关闭连接      toClose = releaseIfNoNewStreams();      if (this.connection != null) {        // We had an already-allocated connection and       it&apos;s good.        result = this.connection;        releasedConnection = null;      }      if (!reportedAcquired) {        // If the connection was never reported       acquired, don&apos;t report it as released!        // 如果该连接从未被标记为获得，不要标记为发布状态，reportedAcquired 通过 acquire()   方法修改        releasedConnection = null;      }      if (result == null) {        // Attempt to get a connection from the pool.        // 尝试供连接池中获取一个连接        Internal.instance.get(connectionPool,   address,     this, null);        if (connection != null) {          foundPooledConnection = true;          result = connection;        } else {          selectedRoute = route;        }      }    }    // 关闭连接    closeQuietly(toClose);    if (releasedConnection != null) {      eventListener.connectionReleased(call,       releasedConnection);    }    if (foundPooledConnection) {      eventListener.connectionAcquired(call, result);    }    if (result != null) {      // If we found an already-allocated or pooled       connection, we&apos;re done.      // 如果已经从连接池中获取到了一个连接，就将其返回      return result;    }    // If we need a route selection, make one. This   is     a blocking operation.    boolean newRouteSelection = false;    if (selectedRoute == null &amp;&amp; (routeSelection ==       null || !routeSelection.hasNext())) {      newRouteSelection = true;      routeSelection = routeSelector.next();    }    synchronized (connectionPool) {      if (canceled) throw new     IOException(&quot;Canceled&quot;);      if (newRouteSelection) {        // Now that we have a set of IP addresses,   make     another attempt at getting a   connection from        // the pool. This could match due to   connection     coalescing.         // 根据一系列的 IP地址从连接池中获取一个链接        List&lt;Route&gt; routes = routeSelection.getAll();        for (int i = 0, size = routes.size(); i &lt;   size;     i++) {          Route route = routes.get(i);          // 从连接池中获取一个连接          Internal.instance.get(connectionPool,       address, this, route);          if (connection != null) {            foundPooledConnection = true;            result = connection;            this.route = route;            break;          }        }      }      if (!foundPooledConnection) {        if (selectedRoute == null) {          selectedRoute = routeSelection.next();        }        // Create a connection and assign it to this       allocation immediately. This makes it   possible        // for an asynchronous cancel() to interrupt       the handshake we&apos;re about to do.        // 在连接池中如果没有该连接，则创建一个新的连接，并将其分配，这样我们就可以在握手之前进行终端        route = selectedRoute;        refusedStreamCount = 0;        result = new RealConnection(connectionPool,       selectedRoute);        acquire(result, false);      }    }    // If we found a pooled connection on the 2nd time around, we&apos;re done.    if (foundPooledConnection) {    // 如果我们在第二次的时候发现了一个池连接，那么我们就将其返回      eventListener.connectionAcquired(call, result);      return result;    }    // Do TCP + TLS handshakes. This is a blocking     operation.     // 进行 TCP 和 TLS 握手    result.connect(connectTimeout, readTimeout,     writeTimeout, pingIntervalMillis,        connectionRetryEnabled, call, eventListener);    routeDatabase().connected(result.route());    Socket socket = null;    synchronized (connectionPool) {      reportedAcquired = true;      // Pool the connection.      // 将该连接放进连接池中      Internal.instance.put(connectionPool, result);      // If another multiplexed connection to the same   address was created concurrently, then      // release this connection and acquire that one.      // 如果同时创建了另一个到同一地址的多路复用连接，释放这个连接并获取那个连接      if (result.isMultiplexed()) {        socket =     Internal.instance.deduplicate(connectionPool,     address, this);        result = connection;      }    }    closeQuietly(socket);    eventListener.connectionAcquired(call, result);    return result;}</code></pre><p>从以上的源码分析可知：</p><ul><li>判断当前的连接是否可以使用：流是否已经被关闭，并且已经被限制创建新的流；</li><li>如果当前的连接无法使用，就从连接池中获取一个连接；</li><li>连接池中也没有发现可用的连接，创建一个新的连接，并进行握手，然后将其放到连接池中。</li></ul><p>在从连接池中获取一个连接的时候，使用了 Internal 的 get() 方法。Internal 有一个静态的实例，会在 OkHttpClient 的静态代码快中被初始化。我们会在 Internal 的 get() 中调用连接池的 get() 方法来得到一个连接。并且，从中我们明白了连接复用的一个好处就是省去了进行 TCP 和 TLS 握手的一个过程。因为建立连接本身也是需要消耗一些时间的，连接被复用之后可以提升我们网络访问的效率。</p><p>接下来，我们来详细分析下ConnectionPool是如何实现连接管理的。</p><p>OkHttp 的缓存管理分成两个步骤，一边当我们创建了一个新的连接的时候，我们要把它放进缓存里面；另一边，我们还要来对缓存进行清理。在 ConnectionPool 中，当我们向连接池中缓存一个连接的时候，只要调用双端队列的 add() 方法，将其加入到双端队列即可，而清理连接缓存的操作则交给线程池来定时执行。</p><pre><code>private final Deque&lt;RealConnection&gt; connections = new ArrayDeque&lt;&gt;();void put(RealConnection connection) {assert (Thread.holdsLock(this));    if (!cleanupRunning) {      cleanupRunning = true;      // 使用线程池执行清理任务      executor.execute(cleanupRunnable);    }    // 将新建的连接插入到双端队列中    connections.add(connection);} private final Runnable cleanupRunnable = new Runnable() {@Override public void run() {    while (true) {        // 内部调用 cleanup() 方法来清理无效的连接        long waitNanos = cleanup(System.nanoTime());        if (waitNanos == -1) return;        if (waitNanos &gt; 0) {          long waitMillis = waitNanos / 1000000L;          waitNanos -= (waitMillis * 1000000L);          synchronized (ConnectionPool.this) {            try {              ConnectionPool.this.wait(waitMillis,     (int) waitNanos);            } catch (InterruptedException ignored) {            }          }        }    }};long cleanup(long now) {    int inUseConnectionCount = 0;    int idleConnectionCount = 0;    RealConnection longestIdleConnection = null;    long longestIdleDurationNs = Long.MIN_VALUE;    // Find either a connection to evict, or the time     that the next eviction is due.    synchronized (this) {        // 遍历所有的连接        for (Iterator&lt;RealConnection&gt; i =     connections.iterator(); i.hasNext(); ) {          RealConnection connection = i.next();          // If the connection is in use, keep     searching.          // 遍历所有的连接          if (pruneAndGetAllocationCount(connection,     now)     &gt; 0) {            inUseConnectionCount++;            continue;          }          idleConnectionCount++;          // If the connection is ready to be     evicted,     we&apos;re done.          // 如果找到了一个可以被清理的连接，会尝试去寻找闲置时间最久的连接来释放          long idleDurationNs = now -         connection.idleAtNanos;          if (idleDurationNs &gt; longestIdleDurationNs)     {            longestIdleDurationNs = idleDurationNs;            longestIdleConnection = connection;          }        }        // maxIdleConnections 表示最大允许的闲置的连接的数量,keepAliveDurationNs表示连接允许存活的最长的时间。默认空闲连接最大数目为5个，keepalive 时间最长为5分钟。        if (longestIdleDurationNs &gt;=     this.keepAliveDurationNs            || idleConnectionCount &gt;     this.maxIdleConnections) {          // We&apos;ve found a connection to evict.     Remove it     from the list, then close it     below (outside          // of the synchronized block).          // 该连接的时长超出了最大的活跃时长或者闲置的连接数量超出了最大允许的范围，直接移除          connections.remove(longestIdleConnection);        } else if (idleConnectionCount &gt; 0) {          // A connection will be ready to evict     soon.          // 闲置的连接的数量大于0，停顿指定的时间（等会儿会将其清理掉，现在还不是时候）          return keepAliveDurationNs -         longestIdleDurationNs;        } else if (inUseConnectionCount &gt; 0) {          // All connections are in use. It&apos;ll be at         least the keep alive duration &apos;til we     run     again.          // 所有的连接都在使用中，5分钟后再清理          return keepAliveDurationNs;        } else {          // No connections, idle or in use.           // 没有连接          cleanupRunning = false;          return -1;      }}</code></pre><p>从以上的源码分析可知，首先会对缓存中的连接进行遍历，以寻找一个闲置时间最长的连接，然后根据该连接的闲置时长和最大允许的连接数量等参数来决定是否应该清理该连接。同时注意上面的方法的返回值是一个时间，如果闲置时间最长的连接仍然需要一段时间才能被清理的时候，会返回这段时间的时间差，然后会在这段时间之后再次对连接池进行清理。</p><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>经过上面对OKHttp内部工作机制的一系列分析，我相信你已经对OKHttp已经有了一个很深入的理解了。首先，我们会在请求的时候初始化一个Call的实例，然后执行它的execute()方法或enqueue()方法，内部最后都会执行到getResponseWithInterceptorChain()方法，这个方法里面通过拦截器组成的责任链，依次经过用户自定义普通拦截器、重试拦截器、桥接拦截器、缓存拦截器、连接拦截器和用户自定义网络拦截器以及访问服务器拦截器等拦截处理过程，来获取到一个响应并交给用户。其中，除了OKHttp的内部请求流程这点之外，缓存和连接这两部分内容也是两个很重要的点，相信经过本文的讲解，读者对着三部分重点内容已经有了自己的理解。后面，将会为大家带来OKHttp的封装框架Retrofit源码的深入分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、OKHttp V3.12.0源码</p><p>1、Android进阶之光</p><p>2、<a href="https://www.jianshu.com/p/27c1554b7fee" target="_blank" rel="external">OKHttp源码解析</a></p><p>3、<a href="https://juejin.im/post/5bc89fbc5188255c713cb8a5#heading-10" target="_blank" rel="external">Andriod 网络框架 OkHttp 源码解析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android View的绘制流程</title>
      <link>http://yoursite.com/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</link>
      <guid>http://yoursite.com/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</guid>
      <pubDate>Sun, 28 Oct 2018 12:41:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>上一篇中我们讲到了<a href="https://jsonchao.github.io/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Android的触摸事件传递机制</a>，除此之外，关于Android View的绘制流程这一块也是View相关的核心知识点。我们都知道，PhoneWindow是Android系统中最基本的窗口系统，每个Activity会创建一个。同时，PhoneWindow也是Activity和View系统交互的接口。DecorView本质上是一个FrameLayout，是Activity中所有View的祖先。</p><h3 id="一、开始：DecorView被加载到Window中"><a href="#一、开始：DecorView被加载到Window中" class="headerlink" title="一、开始：DecorView被加载到Window中"></a>一、开始：DecorView被加载到Window中</h3><p>从Activity的startActivity开始，最终调用到ActivityThread的handleLaunchActivity方法来创建Activity，相关核心代码如下：</p><pre><code>private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {    ....    // 创建Activity，会调用Activity的onCreate方法    // 从而完成DecorView的创建    Activity a = performLaunchActivity(r, customIntent);    if (a != null) {        r.createdConfig = new Configuration(mConfiguration);        Bundle oldState = r.state;        handleResumeActivity(r.tolen, false, r.isForward, !r.activity..mFinished &amp;&amp; !r.startsNotResumed);    }}final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) {    unscheduleGcIdler();    mSomeActivitiesChanged = true;    // 调用Activity的onResume方法    ActivityClientRecord r = performResumeActivity(token, clearHide);    if (r != null) {        final Activity a = r.activity;        ...        if (r.window == null &amp;&amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {            r.window = r.activity.getWindow();            // 得到DecorView            View decor = r.window.getDecorView();            decor.setVisibility(View.INVISIBLE);            // 得到了WindowManager，WindowManager是一个接口            // 并且继承了接口ViewManager            ViewManager wm = a.getWindowManager();            WindowManager.LayoutParams l = r.window.getAttributes();            a.mDecor = decor;            l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;            l.softInputMode |= forwardBit;            if (a.mVisibleFromClient) {                a.mWindowAdded = true;                // WindowManager的实现类是WindowManagerImpl，                // 所以实际调用的是WindowManagerImpl的addView方法                wm.addView(decor, l);            }        }    }}public final class WindowManagerImpl implements WindowManager {    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();    ...    @Override    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {        applyDefaultToken(params);        mGlobal.addView(view, params, mDisplay, mParentWindow);    }    ...}</code></pre><p>在了解View绘制的整体流程之前，我们必须先了解下ViewRoot和DecorView的概念。ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成的。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，相关源码如下所示：</p><pre><code>// WindowManagerGlobal的addView方法public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) {    ...    ViewRootImpl root;    View pannelParentView = null;    synchronized (mLock) {        ...        // 创建ViewRootImpl实例        root = new ViewRootImpl(view..getContext(), display);        view.setLayoutParams(wparams);        mViews.add(view);        mRoots.add(root);        mParams.add(wparams);    }    try {        // 把DecorView加载到Window中        root.setView(view, wparams, panelParentView);    } catch (RuntimeException e) {        synchronized (mLock) {            final int index = findViewLocked(view, false);            if (index &gt;= 0) {                removeViewLocked(index, true);            }        }        throw e;    }}</code></pre><h3 id="二、了解绘制的整体流程"><a href="#二、了解绘制的整体流程" class="headerlink" title="二、了解绘制的整体流程"></a>二、了解绘制的整体流程</h3><p>绘制会从根视图ViewRoot的performTraversals()方法开始，从上到下遍历整个视图树，每个View控件负责绘制自己，而ViewGroup还需要负责通知自己的子View进行绘制操作。performTraversals()的核心代码如下。</p><pre><code>private void performTraversals() {    ...    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);    ...    //执行测量流程    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);    ...    //执行布局流程    performLayout(lp, desiredWindowWidth, desiredWindowHeight);    ...    //执行绘制流程    performDraw();}</code></pre><p>performTraversals的大致工作流程图如下所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/1967257-f245ffbefe056fb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>注意：</p><ul><li>preformLayout和performDraw的传递流程和performMeasure是类似的，唯一不同的是，performDraw的传递过程是在draw方法中通过dispatchDraw来实现的，不过这并没有本质区别。</li><li>获取content：</li></ul><pre><code>ViewGroup content = (ViewGroup)findViewById(android.R.id.content);</code></pre><ul><li>获取设置的View：</li></ul><pre><code>content.getChildAt(0);</code></pre><h3 id="三、理解MeasureSpec"><a href="#三、理解MeasureSpec" class="headerlink" title="三、理解MeasureSpec"></a>三、理解MeasureSpec</h3><h5 id="1-MeasureSpec源码解析"><a href="#1-MeasureSpec源码解析" class="headerlink" title="1.MeasureSpec源码解析"></a>1.MeasureSpec源码解析</h5><p>MeasureSpec表示的是一个32位的整形值，它的高2位表示测量模式SpecMode，低30位表示某种测量模式下的规格大小SpecSize。MeasureSpec是View类的一个静态内部类，用来说明应该如何测量这个View。MeasureSpec的核心代码如下。</p><pre><code>public static class MeasureSpec {    private static final int MODE_SHIFT = 30;    private static final int MODE_MASK = 0X3 &lt;&lt; MODE_SHIFT;    // 不指定测量模式, 父视图没有限制子视图的大小，子视图可以是想要    // 的任何尺寸，通常用于系统内部，应用开发中很少用到。    public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT;    // 精确测量模式，视图宽高指定为match_parent或具体数值时生效，    // 表示父视图已经决定了子视图的精确大小，这种模式下View的测量    // 值就是SpecSize的值。    public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT;    // 最大值测量模式，当视图的宽高指定为wrap_content时生效，此时    // 子视图的尺寸可以是不超过父视图允许的最大尺寸的任何尺寸。    public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT;    // 根据指定的大小和模式创建一个MeasureSpec    public static int makeMeasureSpec(int size, int mode) {        if (sUseBrokenMakeMeasureSpec) {            return size + mode;        } else {            return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);        }    }    // 微调某个MeasureSpec的大小    static int adjust(int measureSpec, int delta) {        final int mode = getMode(measureSpec);        if (mode == UNSPECIFIED) {            // No need to adjust size for UNSPECIFIED mode.            return make MeasureSpec(0, UNSPECIFIED);        }        int size = getSize(measureSpec) + delta;        if (size &lt; 0) {            size = 0;        }        return makeMeasureSpec(size, mode);    }}</code></pre><p>MeasureSpec通过将SpecMode和SpecSize打包成一个int值来避免过多的对象内存分配，为了方便操作，其提供了打包和解包的方法，打包方法为上述源码中的makeMeasureSpec，解包方法源码如下：</p><pre><code>public static int getMode(int measureSpec) {    return (measureSpec &amp; MODE_MASK);}public static int getSize(int measureSpec) {    return (measureSpec &amp; ~MODE_MASK);}</code></pre><h5 id="2-DecorView的MeasureSpec的创建过程："><a href="#2-DecorView的MeasureSpec的创建过程：" class="headerlink" title="2.DecorView的MeasureSpec的创建过程："></a>2.DecorView的MeasureSpec的创建过程：</h5><pre><code>//desiredWindowWidth和desiredWindowHeight是屏幕的尺寸childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);private static int getRootMeaureSpec(int windowSize, int rootDimension) {    int measureSpec;    switch (rootDimension) {        case ViewGroup.LayoutParams.MATRCH_PARENT:            // Window can&apos;t resize. Force root view to be windowSize.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);            break;        case ViewGroup.LayoutParams.WRAP_CONTENT：            // Window can resize. Set max size for root view.            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);            break        default:            // Window wants to be an exact size. Force root view to be that size.            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);            break;    }    return measureSpec;}</code></pre><h5 id="3-子元素的MeasureSpec的创建过程"><a href="#3-子元素的MeasureSpec的创建过程" class="headerlink" title="3.子元素的MeasureSpec的创建过程"></a>3.子元素的MeasureSpec的创建过程</h5><pre><code>// ViewGroup的measureChildWithMargins方法protected void measureChildWithMargins(View child,int parentWidthMeasureSpec, int widthUsed,int parentHeightMeasureSpec, int heightUsed) {    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();    // 子元素的MeasureSpec的创建与父容器的MeasureSpec和子元素本身    // 的LayoutParams有关，此外还和View的margin及padding有关    final int childWidthMeasureSpec = getChildMeasureSpec(    parentWidthMeasureSpec,    mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed,     lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(    parentHeightMeasureSpec,    mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed,     lp.height);    child..measure(childWidthMeasureSpec, childHeightMeasureSpec);}public static int getChildMeasureSpec(int spec, int padding, int childDimesion) {    int specMode = MeasureSpec.getMode(spec);    int specSize = MeasureSpec.getSize(spec);    // padding是指父容器中已占用的空间大小，因此子元素可用的    // 大小为父容器的尺寸减去padding    int size = Math.max(0, specSize - padding);    int resultSize = 0;    int resultMode = 0;    switch (sepcMode) {        // Parent has imposed an exact size on us        case MeasureSpec.EXACTLY:            if (childDimension &gt;= 0) {                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size. So be it.                resultSize = size;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimesion == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&apos;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // Parent has imposed a maximum size on us         case MeasureSpec.AT_MOST:            if (childDimension &gt;= 0) {                // Child wants a specific size... so be it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size, but our size is not fixed.                // Constrain child to not be bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&apos;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;        // Parent asked to see how big we want to be        case MeasureSpec.UNSPECIFIED:            if (childDimension &gt;= 0) {                // Child wants a specific size... let him have it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size... find out how big it should be                resultSize = 0;                resultMode = MeasureSpec.UNSPECIFIED;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size....                // find out how big it should be                resultSize = 0;                resultMode == MeasureSpec.UNSPECIFIED;            }            break;        }    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}</code></pre><p>普通View的MeasureSpec的创建规则如下：</p><p><img src="https://images2015.cnblogs.com/blog/918357/201706/918357-20170618234001337-203688773.png" alt="image"></p><p>注意：UNSPECIFIED模式主要用于系统内部多次Measure的情形，一般不需关注。</p><p>结论：对于DecorView而言，它的MeasureSpec由窗口尺寸和其自身的LayoutParams共同决定；对于普通的View，它的MeasureSpec由父视图的MeasureSpec和其自身的LayoutParams共同决定。</p><h3 id="四、View绘制流程之Measure"><a href="#四、View绘制流程之Measure" class="headerlink" title="四、View绘制流程之Measure"></a>四、View绘制流程之Measure</h3><h5 id="1-Measure的基本流程"><a href="#1-Measure的基本流程" class="headerlink" title="1.Measure的基本流程"></a>1.Measure的基本流程</h5><p>由前面的分析可知，页面的测量流程是从performMeasure方法开始的，相关的核心代码流程如下。</p><pre><code>private void perormMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {    ...    // 具体的测量操作分发给ViewGroup    mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);    ...}// 在ViewGroup中的measureChildren()方法中遍历测量ViewGroup中所有的Viewprotected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) {    final int size = mChildrenCount;    final View[] children = mChildren;    for (int i = 0; i &lt; size; ++i) {        final View child = children[i];        // 当View的可见性处于GONE状态时，不对其进行测量        if ((child.mViewFlags &amp; VISIBILITY_MASK) != GONE) {            measureChild(child, widthMeasureSpec, heightMeasureSpec);        }    }}// 测量某个指定的Viewprotected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) {    final LayoutParams lp = child.getLayoutParams();    // 根据父容器的MeasureSpec和子View的LayoutParams等信息计算    // 子View的MeasureSpec    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width);    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height);    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);}// View的measure方法public final void measure(int widthMeasureSpec, int heightMeasureSpec) {    ...    // ViewGroup没有定义测量的具体过程，因为ViewGroup是一个    // 抽象类，其测量过程的onMeasure方法需要各个子类去实现    onMeasure(widthMeasureSpec, heightMeasureSpec);    ...}// 不同的ViewGroup子类有不同的布局特性，这导致它们的测量细节各不相同，如果需要自定义测量过程，则子类可以重写这个方法protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    // setMeasureDimension方法用于设置View的测量宽高    setMeasureDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),     getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));}// 如果View没有重写onMeasure方法，则会默认调用getDefaultSize来获得View的宽高public static int getDefaultSize(int size, int measureSpec) {    int result = size;    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {        case MeasureSpec.UNSPECIFIED:            result = size;            break;        case MeasureSpec.AT_MOST:        case MeasureSpec.EXACTLY:            result = sepcSize;            break;    }    return result;}</code></pre><h5 id="2-对getSuggestMinimumWidth的分析"><a href="#2-对getSuggestMinimumWidth的分析" class="headerlink" title="2.对getSuggestMinimumWidth的分析"></a>2.对getSuggestMinimumWidth的分析</h5><pre><code>protected int getSuggestedMinimumWidth() {    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinmumWidth());}protected int getSuggestedMinimumHeight() {    return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight());}public int getMinimumWidth() {    final int intrinsicWidth = getIntrinsicWidth();    return intrinsicWidth &gt; 0 ? intrinsicWidth : 0;}</code></pre><p>如果View没有设置背景，那么返回android:minWidth这个属性所指定的值，这个值可以为0；如果View设置了背景，则返回android:minWidth和背景的最小宽度这两者中的最大值。</p><h5 id="3-自定义View时手动处理wrap-content时的情形"><a href="#3-自定义View时手动处理wrap-content时的情形" class="headerlink" title="3.自定义View时手动处理wrap_content时的情形"></a>3.自定义View时手动处理wrap_content时的情形</h5><p>直接继承View的控件需要重写onMeasure方法并设置wrap_content时的自身大小，否则在布局中使用wrap_content就相当于使用match_parent。解决方式如下：</p><pre><code>protected void onMeasure(int widthMeasureSpec, int height MeasureSpec) {    super.onMeasure(widthMeasureSpec, heightMeasureSpec);    int widthSpecMode = MeasureSpec.getMode(widthMeasureSpec);    int widtuhSpecSize = MeasureSpec.getSize(widthMeasureSpec);    int heightSpecMode = MeasureSpec.getMode(heightMeasureSpec);    // 在wrap_content的情况下指定内部宽/高(mWidth和mHeight)    int heightSpecSize = MeasureSpec.AT_MOST &amp;&amp; heightSpecMode == MeasureSpec.AT_MOST) {        setMeasuredDimension(mWidth, mHeight);    } else if (widthSpecMode == MeasureSpec.AT_MOST) {        setMeasureDimension(mWidth, heightSpecSize);    } else if (heightSpecMode == MeasureSpec.AT_MOST) {        setMeasureDimension(widthSpecSize, mHeight);    }}</code></pre><h5 id="4-LinearLayout的onMeasure方法实现解析"><a href="#4-LinearLayout的onMeasure方法实现解析" class="headerlink" title="4.LinearLayout的onMeasure方法实现解析"></a>4.LinearLayout的onMeasure方法实现解析</h5><pre><code>protected void onMeasure(int widthMeasureSpec, int hegithMeasureSpec) {    if (mOrientation == VERTICAL) {        measureVertical(widthMeasureSpec, heightMeasureSpec);    } else {        measureHorizontal(widthMeasureSpec, heightMeasureSpec);    }}// measureVertical核心源码// See how tall everyone is. Also remember max width.for (int i = 0; i &lt; count; ++i) {    final View child = getVirtualChildAt(i);    ...    // Determine how big this child would like to be. If this or     // previous children have given a weight, then we allow it to     // use all available space (and we will shrink things later     // if need)    measureChildBeforeLayout(            child, i, widthMeasureSpec, 0, heightMeasureSpec,            totalWeight == 0 ? mTotalLength : 0);    if (oldHeight != Integer.MIN_VALUE) {        lp.height = oldHeight;    }    final int childHeight = child.getMeasuredHeight();    final int totalLength = mTotalLength;    mTotalLength = Math.max(totalLength, totalLength + childHeight + lp.topMargin +     lp.bottomMargin + getNextLocationOffset(child));}</code></pre><p>系统会遍历子元素并对每个子元素执行measureChildBeforeLayout方法，这个方法内部会调用子元素的measure方法，这样各个子元素就开始依次进入measure过程，并且系统会通过mTotalLength这个变量来存储LinearLayout在竖直方向的初步高度。每测量一个子元素，mTotalLength就会增加，增加的部分主要包括了子元素的高度以及子元素在竖直方向上的margin等。</p><pre><code>// LinearLayout测量自己大小的核心源码// Add in our paddingmTotalLength += mPaddingTop + mPaddingBottom;int heightSize = mTotalLength;// Check against our minimum heightheightSize = Math.max(heightSize, getSuggestedMinimumHeight());// Reconcile our calculated size with the heightMeasureSpecint heightSizeAndState = resolveSizeAndState(heightSize, heightMeasureSpec, 0);heightSize = heightSizeAndState &amp; MEASURED_SIZE_MASK；...setMeasuredDimension(resolveSizeAndSize(maxWidth, widthMeasureSpec, childState),heightSizeAndState);public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {    int result = size;    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {        case MeasureSpec.UNSPECIFIED:            result = size;            break;        case MeasureSpec.AT_MOST:            // 高度不能超过父容器的剩余空间            if (specSize &lt; size) {                result = specSize | MEASURED_STATE_TOO_SMALL；            } else {                result = size;            }            break;        case MeasureSpec.EXACTLY:            result = specSize;            break;    }    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);}</code></pre><h5 id="5-在Activity中获取某个View的宽高"><a href="#5-在Activity中获取某个View的宽高" class="headerlink" title="5.在Activity中获取某个View的宽高"></a>5.在Activity中获取某个View的宽高</h5><p>由于View的measure过程和Activity的生命周期方法不是同步执行的，如果View还没有测量完毕，那么获得的宽/高就是0。所以在onCreate、onStart、onResume中均无法正确得到某个View的宽高信息。解决方式如下：</p><ul><li>Activity/View#onWindowFocusChanged</li></ul><pre><code>// 此时View已经初始化完毕// 当Activity的窗口得到焦点和失去焦点时均会被调用一次// 如果频繁地进行onResume和onPause，那么onWindowFocusChanged也会被频繁地调用public void onWindowFocusChanged(boolean hasFocus) {    super.onWindowFocusChanged(hasFocus);    if (hasFocus) {        int width = view.getMeasureWidth();        int height = view.getMeasuredHeight();    }}</code></pre><ul><li>view.post(runnable)</li></ul><pre><code>// 通过post可以将一个runnable投递到消息队列的尾部，// 然后等待Looper调用次runnable的时候，View也已经初// 始化好了protected void onStart() {    super.onStart();    view.post(new Runnable() {        @Override        public void run() {            int width = view.getMeasuredWidth();            int height = view.getMeasuredHeight();        }    });}</code></pre><ul><li>ViewTreeObserver</li></ul><pre><code>// 当View树的状态发生改变或者View树内部的View的可见// 性发生改变时，onGlobalLayout方法将被回调protected void onStart() {    super.onStart();    ViewTreeObserver observer = view.getViewTreeObserver();    observer.addOnGlobalLayoutListener(new OnGlobalLayoutListener() {        @SuppressWarnings(&quot;deprecation&quot;)        @Override        public void onGlobalLayout() {            view.getViewTreeObserver().removeGlobalOnLayoutListener(this);            int width = view.getMeasuredWidth();            int height = view.getMeasuredHeight();        }    });}</code></pre><ul><li>View.measure(int widthMeasureSpec, int heightMeasureSpec)</li></ul><h3 id="五、View的绘制流程之Layout"><a href="#五、View的绘制流程之Layout" class="headerlink" title="五、View的绘制流程之Layout"></a>五、View的绘制流程之Layout</h3><h5 id="1-Layout的基本流程"><a href="#1-Layout的基本流程" class="headerlink" title="1.Layout的基本流程"></a>1.Layout的基本流程</h5><pre><code>// ViewRootImpl.javaprivate void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) {    ...    host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());    ...}// View.javapublic void layout(int l, int t, int r, int b) {    ...    // 通过setFrame方法来设定View的四个顶点的位置，即View在父容器中的位置    boolean changed = isLayoutModeOptical(mParent) ?     set OpticalFrame(l, t, r, b) : setFrame(l, t, r, b);    ...    onLayout(changed, l, t, r, b);    ...}// 空方法，子类如果是ViewGroup类型，则重写这个方法，实现ViewGroup// 中所有View控件布局流程protected void onLayout(boolean changed, int left, int top, int right, int bottom) {}</code></pre><h5 id="2-LinearLayout的onLayout方法实现解析"><a href="#2-LinearLayout的onLayout方法实现解析" class="headerlink" title="2.LinearLayout的onLayout方法实现解析"></a>2.LinearLayout的onLayout方法实现解析</h5><pre><code>protected void onlayout(boolean changed, int l, int t, int r, int b) {    if (mOrientation == VERTICAL) {        layoutVertical(l, t, r, b);    } else {        layoutHorizontal(l,)    }}// layoutVertical核心源码void layoutVertical(int left, int top, int right, int bottom) {    ...    final int count = getVirtualChildCount();    for (int i = 0; i &lt; count; i++) {        final View child = getVirtualChildAt(i);        if (child == null) {            childTop += measureNullChild(i);        } else if (child.getVisibility() != GONE) {            final int childWidth = child.getMeasureWidth();            final int childHeight = child.getMeasuredHeight();            final LinearLayout.LayoutParams lp =                     (LinearLayout.LayoutParams) child.getLayoutParams();            ...            if (hasDividerBeforeChildAt(i)) {                childTop += mDividerHeight;            }            childTop += lp.topMargin;            // 为子元素确定对应的位置            setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight);            // childTop会逐渐增大，意味着后面的子元素会被            // 放置在靠下的位置            childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child);            i += getChildrenSkipCount(child,i)        }    }}private void setChildFrame(View child, int left, int top, int width, int height) {    child.layout(left, top, left + width, top + height);}</code></pre><p>注意：在View的默认实现中，View的测量宽/高和最终宽/高是相等的，只不过测量宽/高形成于View的measure过程，而最终宽/高形成于View的layout过程，即两者的赋值时机不同，测量宽/高的赋值时机稍微早一些。在一些特殊的情况下则两者不相等：</p><ul><li>重写View的layout方法,使最终宽度总是比测量宽/高大100px</li></ul><pre><code>public void layout(int l, int t, int r, int b) {    super.layout(l, t, r + 100, b + 100);}</code></pre><ul><li>View需要多长measure才能确定自己的测量宽/高,在前几次测量的过程中，其得出的测量宽/高有可能和最终宽/高不一致，但最终来说，测量宽/高还是和最终宽/高相同</li></ul><h3 id="六、View的绘制流程之Draw"><a href="#六、View的绘制流程之Draw" class="headerlink" title="六、View的绘制流程之Draw"></a>六、View的绘制流程之Draw</h3><h5 id="1-Draw的基本流程"><a href="#1-Draw的基本流程" class="headerlink" title="1.Draw的基本流程"></a>1.Draw的基本流程</h5><pre><code>private void performDraw() {    ...    draw(fullRefrawNeeded);    ...}private void draw(boolean fullRedrawNeeded) {    ...    if (!drawSoftware(surface, mAttachInfo, xOffest, yOffset,     scalingRequired, dirty)) {        return;    }    ...}private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scallingRequired, Rect dirty) {    ...    mView.draw(canvas);    ...}// 绘制基本上可以分为六个步骤public void draw(Canvas canvas) {    ...    // 步骤一：绘制View的背景    drawBackground(canvas);    ...    // 步骤二：如果需要的话，保持canvas的图层，为fading做准备    saveCount = canvas.getSaveCount();    ...    canvas.saveLayer(left, top, right, top + length, null, flags);    ...    // 步骤三：绘制View的内容    onDraw(canvas);    ...    // 步骤四：绘制View的子View    dispatchDraw(canvas);    ...    // 步骤五：如果需要的话，绘制View的fading边缘并恢复图层    canvas.drawRect(left, top, right, top + length, p);    ...    canvas.restoreToCount(saveCount);    ...    // 步骤六：绘制View的装饰(例如滚动条等等)    onDrawForeground(canvas)}</code></pre><h5 id="2-setWillNotDraw的作用"><a href="#2-setWillNotDraw的作用" class="headerlink" title="2.setWillNotDraw的作用"></a>2.setWillNotDraw的作用</h5><pre><code>// 如果一个View不需要绘制任何内容，那么设置这个标记位为true以后，// 系统会进行相应的优化。public void setWillNotDraw(boolean willNotDraw) {    setFlags(willNotDraw ? WILL_NOT_DRAW : 0, DRAW_MASK);}</code></pre><ul><li>默认情况下，View没有启用这个优化标记位，但是ViewGroup会默认启用这个优化标记位。</li><li>当我们的自定义控件继承于ViewGroup并且本身不具备绘制功能时，就可以开启这个标记位从而便于系统进行后续的优化。</li><li>当明确知道一个ViewGroup需要通过onDraw来绘制内容时，我们需要显示地关闭WILL_NOT_DRAW这个标记位。</li></ul><h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>View的绘制流程和事件分发机制都是Android开发中的核心知识点，也是自定义View高手的内功心法。对于一名优秀的Android开发来说，主流三方源码分析和Android核心源码分析可以说是必修课，下一篇，将会带领大家更进一步深入Android。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Android开发艺术探索</p><p>2、Android进阶之光</p><p>3、Android高级进阶</p><p>4、<a href="https://blog.csdn.net/yanbober/article/details/46128379" target="_blank" rel="external">Android应用层View绘制流程与源码分析</a></p><p>5、<a href="https://blog.csdn.net/sinat_35938012/article/details/81055380" target="_blank" rel="external">Android中View绘制流程浅析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
