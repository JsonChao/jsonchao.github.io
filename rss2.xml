<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Tue, 01 Jan 2019 15:26:48 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Android主流三方库源码分析（五、深入理解RxJava源码）</title>
      <link>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Tue, 01 Jan 2019 15:26:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>到目前为止笔者分析了Android中最热门的网络底层和封装框架：<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>，Android中使用最广泛的图片加载框架Glide的加载流程：<a href="https://jsonchao.github.io/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>以及Android中性能最好的数据库框架<a href="https://jsonchao.github.io/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（四、深入理解GreenDao源码）</a>。本篇，我将会对近几年比较热门的函数式编程框架RxJava的源码进行详细的分析。</p><h3 id="一、RxJava到底是什么？"><a href="#一、RxJava到底是什么？" class="headerlink" title="一、RxJava到底是什么？"></a>一、RxJava到底是什么？</h3><p>RxJava是基于Java虚拟机上的响应式扩展库，它通过<strong>使用可观察的序列将异步和基于事件的程序组合起来</strong>。<br>与此同时，它<strong>扩展了观察者模式来支持数据/事件序列</strong>，并且添加了操作符，这些<strong>操作符允许你声明性地组合序列</strong>，同时抽象出要关注的问题：比如低级线程、同步、线程安全和并发数据结构等。</p><p>从RxJava的官方定义来看，我们如果要想真正地理解RxJava，就必须对它以下两个部分进行深入的分析：</p><ul><li>1、<strong>订阅流程</strong>。</li><li>2、<strong>线程切换</strong>。</li></ul><p>当然，RxJava操作符的源码也是很不错的学习资源，特别是FlatMap、Zip等操作符的源码，有很多可以借鉴的地方，但是它们内部的实现比较复杂，限于篇幅，本文只讲解RxJava的订阅流程和线程切换原理。接下来，笔者一一对以上RxJava的两个关键部分来进行详细地讲解。</p><h3 id="二、RxJava的订阅流程"><a href="#二、RxJava的订阅流程" class="headerlink" title="二、RxJava的订阅流程"></a>二、RxJava的订阅流程</h3><p>首先给出RxJava消息订阅的例子：</p><pre><code>Observable.create(newObservableOnSubscribe&lt;String&gt;() {    @Override    public void subscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }}).subscribe(new Observer&lt;String&gt;() {    @Override    public void onSubscribe(Disposable d) {        Log.d(TAG, &quot;onSubscribe&quot;);    }    @Override    public void onNext(String s) {        Log.d(TAG, &quot;onNext : &quot; + s);    }    @Override    public void onError(Throwable e) {        Log.d(TAG, &quot;onError : &quot; + e.toString());    }    @Override    public void onComplete() {        Log.d(TAG, &quot;onComplete&quot;);    }});</code></pre><p>可以看到，这里首先创建了一个被观察者，然后创建一个观察者订阅了这个被观察者，因此下面分两个部分对RxJava的订阅流程进行分析：</p><ul><li>1、<strong>创建被观察者过程</strong>。</li><li>2、<strong>订阅过程；</strong>。</li></ul><h4 id="1、创建被观察者过程"><a href="#1、创建被观察者过程" class="headerlink" title="1、创建被观察者过程"></a>1、创建被观察者过程</h4><p>首先，上面使用了Observable类的create()方法创建了一个被观察者，看看里面做了什么。</p><h5 id="1-1、Observable-create"><a href="#1-1、Observable-create" class="headerlink" title="1.1、Observable#create()"></a>1.1、Observable#create()</h5><pre><code>// 省略一些检测性的注解public static &lt;T&gt; Observable&lt;T&gt; create(ObservableOnSubscribe&lt;T&gt; source) {    ObjectHelper.requireNonNull(source, &quot;source is null&quot;);    return RxJavaPlugins.onAssembly(new ObservableCreate&lt;T&gt;(source));}</code></pre><p>在Observable的create()里面实际上是创建了一个新的ObservableCreate对象，同时，把我们定义好的ObservableOnSubscribe对象传入了ObservableCreate对象中，最后调用了RxJavaPlugins.onAssembly()方法。接下来看看这个ObservableCreate是干什么的。</p><h5 id="1-2、ObservableCreate"><a href="#1-2、ObservableCreate" class="headerlink" title="1.2、ObservableCreate"></a>1.2、ObservableCreate</h5><pre><code>public final class ObservableCreate&lt;T&gt; extends Observable&lt;T&gt; {    final ObservableOnSubscribe&lt;T&gt; source;    public ObservableCreate(ObservableOnSubscribe&lt;T&gt; source) {        this.source = source;    }    ...}</code></pre><p>这里仅仅是把ObservableOnSubscribe这个对象保存在ObservableCreate中了。然后看看RxJavaPlugins.onAssembly()这个方法的处理。</p><h5 id="1-3、RxJavaPlugins-onAssembly"><a href="#1-3、RxJavaPlugins-onAssembly" class="headerlink" title="1.3、RxJavaPlugins#onAssembly()"></a>1.3、RxJavaPlugins#onAssembly()</h5><pre><code>public static &lt;T&gt; Observable&lt;T&gt; onAssembly(@NonNull Observable&lt;T&gt; source) {    // 应用hook函数的一些处理，一般用到不到    ...    return source;}</code></pre><p>最终仅仅是把我们的ObservableCreate给返回了。</p><h5 id="1-4、创建被观察者过程小结"><a href="#1-4、创建被观察者过程小结" class="headerlink" title="1.4、创建被观察者过程小结"></a>1.4、创建被观察者过程小结</h5><p>从以上分析可知，Observable.create()方法仅仅是<strong>先将我们自定义的ObservableOnSubscribe对象重新包装成了一个ObservableCreate对象</strong>。</p><h4 id="2、订阅过程"><a href="#2、订阅过程" class="headerlink" title="2、订阅过程"></a>2、订阅过程</h4><p>接着，看看Observable.subscribe()的订阅过程是如何实现的。</p><h5 id="2-1、Observable-subscribe"><a href="#2-1、Observable-subscribe" class="headerlink" title="2.1、Observable#subscribe()"></a>2.1、Observable#subscribe()</h5><pre><code>public final void subscribe(Observer&lt;? super T&gt; observer) {    ...    // 1    observer = RxJavaPlugins.onSubscribe(this,observer);    ...    // 2    subscribeActual(observer);    ...}</code></pre><p>在Observable的subscribe()方法内部首先调用了RxJavaPlugins的onSubscribe()方法。</p><h5 id="2-2、RxJavaPlugins-onSubscribe"><a href="#2-2、RxJavaPlugins-onSubscribe" class="headerlink" title="2.2、RxJavaPlugins#onSubscribe()"></a>2.2、RxJavaPlugins#onSubscribe()</h5><pre><code>public static &lt;T&gt; Observer&lt;? super T&gt; onSubscribe(@NonNull Observable&lt;T&gt; source, @NonNull Observer&lt;? super T&gt; observer) {    // 应用hook函数的一些处理，一般用到不到    ...    return observer;}</code></pre><p>除去hook应用的逻辑，这里仅仅是将observer返回了。接着来分析下subscribeActual()方法，</p><h5 id="2-3、Observable-subscribeActual"><a href="#2-3、Observable-subscribeActual" class="headerlink" title="2.3、Observable#subscribeActual()"></a>2.3、Observable#subscribeActual()</h5><pre><code>protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);</code></pre><p>这是一个抽象的方法，很明显，它对应的具体实现类就是我们在第一步创建的ObservableCreate类，接下来看到ObservableCreate的subscribeActual()方法。</p><h5 id="2-4、ObservableCreate-subscribeActual"><a href="#2-4、ObservableCreate-subscribeActual" class="headerlink" title="2.4、ObservableCreate#subscribeActual()"></a>2.4、ObservableCreate#subscribeActual()</h5><pre><code>@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) {    // 1    CreateEmitter&lt;T&gt; parent = new CreateEmitter&lt;T&gt;(observer);    // 2    observer.onSubscribe(parent);    try {        // 3        source.subscribe(parent);    } catch (Throwable ex) {        Exceptions.throwIfFatal(ex);        parent.onError(ex);    }}</code></pre><p>在注释1处，首先新创建了一个CreateEmitter对象，同时传入了我们自定义的observer对象进去。</p><h5 id="2-4-1、CreateEmitter"><a href="#2-4-1、CreateEmitter" class="headerlink" title="2.4.1、CreateEmitter"></a>2.4.1、CreateEmitter</h5><pre><code>static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable {    ...    final Observer&lt;? super T&gt; observer;    CreateEmitter(Observer&lt;? super T&gt; observer) {        this.observer = observer;    }    ...}</code></pre><p>从上面可以看出，<strong>CreateEmitter通过继承了Java并发包中的原子引用类AtomicReference<disposable>保证了事件流切断状态Dispose的一致性</disposable></strong>（这里不理解的话，看到后面讲解Dispose的时候就明白了），并<strong>实现了ObservableEmitter接口和Disposable接口</strong>，接着我们分析下注释2处的observer.onSubscribe(parent)，这个onSubscribe回调的含义其实就是<strong>告诉观察者已经成功订阅了被观察者</strong>。再看到注释3处的source.subscribe(parent)这行代码，这里的source其实是ObservableOnSubscribe对象，我们看到ObservableOnSubscribe的subscribe()方法。</p><h5 id="2-4-2、ObservableOnSubscribe-subscribe"><a href="#2-4-2、ObservableOnSubscribe-subscribe" class="headerlink" title="2.4.2、ObservableOnSubscribe#subscribe()"></a>2.4.2、ObservableOnSubscribe#subscribe()</h5><pre><code>Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() {    @Override    public voidsubscribe(ObservableEmitter&lt;String&gt; emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }});</code></pre><p>这里面使用到了ObservableEmitter的onNext()方法将事件流发送出去，最后调用了onComplete()方法完成了订阅过程。ObservableEmitter是一个抽象类，实现类就是我们传入的CreateEmitter对象，接下来我们看看CreateEmitter的onNext()方法和onComplete()方法的处理。</p><h5 id="2-4-3、CreateEmitter-onNext-amp-amp-CreateEmitter-onComplete"><a href="#2-4-3、CreateEmitter-onNext-amp-amp-CreateEmitter-onComplete" class="headerlink" title="2.4.3、CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()"></a>2.4.3、CreateEmitter#onNext() &amp;&amp; CreateEmitter#onComplete()</h5><pre><code>static final class CreateEmitter&lt;T&gt;extends AtomicReference&lt;Disposable&gt;implements ObservableEmitter&lt;T&gt;, Disposable {...@Overridepublic void onNext(T t) {    ...    if (!isDisposed()) {        //调用观察者的onNext()        observer.onNext(t);    }}@Overridepublic void onComplete() {    if (!isDisposed()) {        try {            observer.onComplete();        } finally {            dispose();        }    }}...}</code></pre><p>在CreateEmitter的onNext和onComplete方法中首先都要经过一个<strong>isDisposed</strong>的判断，作用就是看<strong>当前的事件流是否被切断（废弃）掉了</strong>，默认是不切断的，如果想要切断，可以调用Disposable的dispose()方法将此状态设置为切断（废弃）状态。我们继续看看这个isDisposed内部的处理。</p><h5 id="2-4-4、ObservableEmitter-isDisposed"><a href="#2-4-4、ObservableEmitter-isDisposed" class="headerlink" title="2.4.4、ObservableEmitter#isDisposed()"></a>2.4.4、ObservableEmitter#isDisposed()</h5><pre><code>@Overridepublic boolean isDisposed() {    return DisposableHelper.isDisposed(get());}</code></pre><p>注意到这里通过get()方法首先从ObservableEmitter的AtomicReference<disposable>中拿到了保存的Disposable状态。然后交给了DisposableHelper进行判断处理。接下来看看DisposableHelper的处理。</disposable></p><h5 id="2-4-5、DisposableHelper-isDisposed-amp-amp-DisposableHelper-set"><a href="#2-4-5、DisposableHelper-isDisposed-amp-amp-DisposableHelper-set" class="headerlink" title="2.4.5、DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()"></a>2.4.5、DisposableHelper#isDisposed() &amp;&amp; DisposableHelper#set()</h5><pre><code>public enum DisposableHelper implements Disposable {    DISPOSED;    public static boolean isDisposed(Disposable d) {        // 1        return d == DISPOSED;    }    public static boolean set(AtomicReference&lt;Disposable&gt; field, Disposable d) {        for (;;) {            Disposable current = field.get();            if (current == DISPOSED) {                if (d != null) {                    d.dispose();                }                return false;            }            // 2            if (field.compareAndSet(current, d)) {                if (current != null) {                    current.dispose();                }                return true;            }        }    }    ...    public static boolean dispose(AtomicReference&lt;Disposable&gt; field) {        Disposable current = field.get();        Disposable d = DISPOSED;        if (current != d) {            // ...            current = field.getAndSet(d);            if (current != d) {                if (current != null) {                    current.dispose();                }                return true;            }        }        return false;    }    ...}</code></pre><p>DisposableHelper是一个枚举类，内部只有一个值即DISPOSED, 从上面的分析可知它就是用来<strong>标记事件流被切断（废弃）状态的</strong>。先看到注释2和注释3处的代码<strong>field.compareAndSet(current, d)和field.getAndSet(d)</strong>，这里使用了<strong>原子引用AtomicReference<disposable>内部包装的CAS方法处理了标志Disposable的并发读写问题</disposable></strong>，最后看到注释3处，将我们传入的CreateEmitter这个原子引用类保存的Dispable状态和DisposableHelper内部的DISPOSED进行比较，如果相等，就证明数据流被切断了。为了更进一步理解Disposed的作用，再来看看CreateEmitter中剩余的关键方法。</p><h5 id="2-4-6、CreateEmitter"><a href="#2-4-6、CreateEmitter" class="headerlink" title="2.4.6、CreateEmitter"></a>2.4.6、CreateEmitter</h5><pre><code>@Overridepublic void onNext(T t) {    ...    // 1    if (!isDisposed()) {        observer.onNext(t);    }}@Overridepublic void onError(Throwable t) {    if (!tryOnError(t)) {        // 2        RxJavaPlugins.onError(t);    }}@Overridepublic boolean tryOnError(Throwable t) {    ...    // 3    if (!isDisposed()) {        try {            observer.onError(t);        } finally {            // 4            dispose();        }        return true;    }    return false;}@Overridepublic void onComplete() {    // 5    if (!isDisposed()) {        try {            observer.onComplete();        } finally {            // 6            dispose();        }    }}</code></pre><p>在注释1、3、5处，onNext()和onError()、onComplete()方法首先都会判断事件流是否被切断的处理，如果事件流此时被切断了，那么onNext()和onComplete()则会退出方法体，不做处理，<strong>onError()则会执行到RxJavaPlugins.onError(t)这句代码，内部会直接抛出异常，导致崩溃</strong>。如果事件流没有被切断，那么在onError()和onComplete()内部最终会调用到注释4、6处的这句dispose()代码，将事件流进行切断，由此可知，<strong>onError()和onComplete()只能调用一个，如果先执行的是onComplete()，再调用onError()的话就会导致异常崩溃</strong>。</p><h3 id="三、RxJava的线程切换"><a href="#三、RxJava的线程切换" class="headerlink" title="三、RxJava的线程切换"></a>三、RxJava的线程切换</h3><p>首先给出RxJava线程切换的例子：</p><pre><code>Observable.create(new ObservableOnSubscribe&lt;String&gt;() {    @Override    public voidsubscribe(ObservableEmitter&lt;String&gt;emitter) throws Exception {        emitter.onNext(&quot;1&quot;);        emitter.onNext(&quot;2&quot;);        emitter.onNext(&quot;3&quot;);        emitter.onComplete();    }})     .subscribeOn(Schedulers.io())    .observeOn(AndroidSchedulers.mainThread())    .subscribe(new Observer&lt;String&gt;() {        @Override        public void onSubscribe(Disposable d) {            Log.d(TAG, &quot;onSubscribe&quot;);        }        @Override        public void onNext(String s) {            Log.d(TAG, &quot;onNext : &quot; + s);        }        @Override        public void onError(Throwable e) {            Log.d(TAG, &quot;onError : &quot; +e.toString());        }        @Override        public void onComplete() {            Log.d(TAG, &quot;onComplete&quot;);        }});</code></pre><p>可以看到，RxJava的线程切换主要分为subscribeOn()和observeOn()方法，首先，来分析下subscribeOn()方法。</p><h4 id="3-1-1、subscribeOn-Schedulers-io"><a href="#3-1-1、subscribeOn-Schedulers-io" class="headerlink" title="3.1.1、subscribeOn(Schedulers.io())"></a>3.1.1、subscribeOn(Schedulers.io())</h4><p>在Schedulers.io()方法中，我们需要先传入一个Scheduler调度类，这里是传入了一个调度到io子线程的调度类，我们看看这个Schedulers.io()方法内部是怎么构造这个调度器的。</p><h4 id="3-1-2、Schedulers-io"><a href="#3-1-2、Schedulers-io" class="headerlink" title="3.1.2、Schedulers#io()"></a>3.1.2、Schedulers#io()</h4><pre><code>static final Scheduler IO;...public static Scheduler io() {    // 1    return RxJavaPlugins.onIoScheduler(IO);}static {    ...    // 2    IO = RxJavaPlugins.initIoScheduler(new IOTask());}static final class IOTask implements Callable&lt;Scheduler&gt; {    @Override    public Scheduler call() throws Exception {        // 3        return IoHolder.DEFAULT;    }}static final class IoHolder {    // 4    static final Scheduler DEFAULT = new IoScheduler();}</code></pre><p>Schedulers这个类的代码很多，这里我只拿出有关Schedulers。io这个方法涉及的逻辑代码进行讲解。首先，在注释1处，同前面分析的订阅流程的处理一样，只是一个处理hook的逻辑，最终返回的还是传入的这个IO对象。再看到注释2处，在Schedulers的静态代码块中将IO对象进行了初始化，其实质就是新建了一个IOTask的静态内部类，在IOTask的call方法中，也就是注释3处，可以了解到使用了静态内部类的方式把创建的IOScheduler对象给返回出去了。绕了这么大圈子，<strong>Schedulers.io方法其实质就是返回了一个IOScheduler对象</strong>。</p><h4 id="3-1-3、Observable-subscribeOn"><a href="#3-1-3、Observable-subscribeOn" class="headerlink" title="3.1.3、Observable#subscribeOn()"></a>3.1.3、Observable#subscribeOn()</h4><pre><code>  public final Observable&lt;T&gt; subscribeOn(Scheduler scheduler) {    ...    return RxJavaPlugins.onAssembly(new ObservableSubscribeOn&lt;T&gt;(this, scheduler));}</code></pre><p>在subscribeOn()方法里面，又将ObservableCreate包装成了一个ObservableSubscribeOn对象。我们关注到ObservableSubscribeOn类。</p><h4 id="3-1-4、ObservableSubscribeOn"><a href="#3-1-4、ObservableSubscribeOn" class="headerlink" title="3.1.4、ObservableSubscribeOn"></a>3.1.4、ObservableSubscribeOn</h4><pre><code>public final class ObservableSubscribeOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; {    final Scheduler scheduler;    public ObservableSubscribeOn(ObservableSource&lt;T&gt; source, Scheduler scheduler) {        // 1        super(source);        this.scheduler = scheduler;    }    @Override    public void subscribeActual(final Observer&lt;? super T&gt; observer) {        // 2        final SubscribeOnObserver&lt;T&gt; parent = new SubscribeOnObserver&lt;T&gt;(observer);        // 3        observer.onSubscribe(parent);        // 4        parent.setDisposable(scheduler.scheduleDirect(new SubscribeTask(parent)));    }...}</code></pre><p>首先，在注释1处，将传进来的source和scheduler保存起来。接着，等到实际订阅的时候，就会执行到这个subscribeActual方法，在注释2处，将我们自定义的Observer包装成了一个SubscribeOnObserver对象。在注释3处，通知观察者订阅了被观察者。在注释4处，内部先创建了一个SubscribeTask对象，来看看它的实现。</p><h4 id="3-1-5、ObservableSubscribeOn-SubscribeTask"><a href="#3-1-5、ObservableSubscribeOn-SubscribeTask" class="headerlink" title="3.1.5、ObservableSubscribeOn#SubscribeTask"></a>3.1.5、ObservableSubscribeOn#SubscribeTask</h4><pre><code>final class SubscribeTask implements Runnable {    private final SubscribeOnObserver&lt;T&gt; parent;    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) {        this.parent = parent;    }    @Override    public void run() {        source.subscribe(parent);    }}</code></pre><p>SubscribeTask是ObservableSubscribeOn的内部类，它实质上就是一个任务类，在它的run方法中会执行到source.subscribe(parent)的订阅方法，<strong>这个source其实就是我们在ObservableSubscribeOn构造方法中传进来的ObservableCreate对象</strong>。接下来看看scheduler.scheduleDirect()内部的处理。</p><h4 id="3-1-6、Scheduler-scheduleDirect"><a href="#3-1-6、Scheduler-scheduleDirect" class="headerlink" title="3.1.6、Scheduler#scheduleDirect()"></a>3.1.6、Scheduler#scheduleDirect()</h4><pre><code>public Disposable scheduleDirect(@NonNull Runnable run) {    return scheduleDirect(run, 0L, TimeUnit.NANOSECONDS);}public Disposable scheduleDirect(@NonNull Runnable run, long delay, @NonNull TimeUnit unit) {    // 1    final Worker w = createWorker();    // 2    final Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    // 3    DisposeTask task = new DisposeTask(decoratedRun, w);    // 4    w.schedule(task, delay, unit);    return task;}</code></pre><p>这里最后会执行到上面这个scheduleDirect()重载方法。首先，在注释1处，会调用createWorker()方法创建一个工作者对象Worker，它是一个抽象类，这里的实现类就是IoScheduler，下面，我们看看IoScheduler类的createWorker()方法。</p><h4 id="3-1-6-1、IOScheduler-createWorker"><a href="#3-1-6-1、IOScheduler-createWorker" class="headerlink" title="3.1.6.1、IOScheduler#createWorker()"></a>3.1.6.1、IOScheduler#createWorker()</h4><pre><code>final AtomicReference&lt;CachedWorkerPool&gt; pool;...public IoScheduler(ThreadFactory threadFactory) {    this.threadFactory = threadFactory;    this.pool = new AtomicReference&lt;CachedWorkerPool&gt;(NONE);    start();}...@Overridepublic Worker createWorker() {    // 1    return new EventLoopWorker(pool.get());}static final class EventLoopWorker extends Scheduler.Worker {    ...    EventLoopWorker(CachedWorkerPool pool) {        this.pool = pool;        this.tasks = new CompositeDisposable();        // 2        this.threadWorker = pool.get();    }}</code></pre><p>首先，在注释1处调用了pool.get()这个方法，pool是一个CachedWorkerPool类型的原子引用对象，它的作用就是<strong>用于缓存工作者对象Worker的</strong>。然后，将得到的CachedWorkerPool传入新创建的EventLoopWorker对象中。重点关注一下注释2处，这里讲CachedWorkerPool缓存的threadWorker对象保存起来了。</p><p>下面，我们继续分析3.6处代码段的注释2处的代码，这里又是一个关于hook的封装处理，最终还是返回的当前的Runnable对象。在注释3处新建了一个切断任务DisposeTask将decoratedRun和w包装了起来。最后在注释4处调用了工作者的schedule()方法。下面我们来分析下它内部的处理。</p><h4 id="3-1-6-2、IoScheduler-schedule"><a href="#3-1-6-2、IoScheduler-schedule" class="headerlink" title="3.1.6.2、IoScheduler#schedule()"></a>3.1.6.2、IoScheduler#schedule()</h4><pre><code>@Overridepublic Disposable schedule(@NonNull Runnableaction, long delayTime, @NonNull TimeUnit unit){    ...    return threadWorker.scheduleActual(action,delayTime, unit, tasks);}</code></pre><p>内部调用了threadWorker的scheduleActual()方法，实际上是调用到了父类NewThreadWorker的scheduleActual()方法，我们继续看看NewThreadWorker的scheduleActual()方法中做的事情。</p><h4 id="3-1-6-2-1、NewThreadWorker-scheduleActual"><a href="#3-1-6-2-1、NewThreadWorker-scheduleActual" class="headerlink" title="3.1.6.2.1、NewThreadWorker#scheduleActual()"></a>3.1.6.2.1、NewThreadWorker#scheduleActual()</h4><pre><code>public NewThreadWorker(ThreadFactory threadFactory) {    executor = SchedulerPoolFactory.create(threadFactory);}@NonNullpublic ScheduledRunnable scheduleActual(final Runnable run, long delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent) {    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);    // 1    ScheduledRunnable sr = new ScheduledRunnable(decoratedRun, parent);    if (parent != null) {        if (!parent.add(sr)) {            return sr;        }    }    Future&lt;?&gt; f;    try {        // 2        if (delayTime &lt;= 0) {            // 3            f = executor.submit((Callable&lt;Object&gt;)sr);        } else {            // 4            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);        }        sr.setFuture(f);    } catch (RejectedExecutionException ex) {        if (parent != null) {            parent.remove(sr);        }        RxJavaPlugins.onError(ex);    }    return sr;}</code></pre><p>在NewThreadWorker的scheduleActual()方法的内部，在注释1处首先会新建一个ScheduledRunnable对象，将Runnable对象和parent包装起来了，<strong>这里parent是一个DisposableContainer对象，它实际的实现类是CompositeDisposable类，即一个保存所有事件流是否被切断状态的容器，它内部的实现是使用了RxJava自己定义的一个简单的OpenHashSet类ji进行存储</strong>。最后注释2处，判断是否设置了延迟时间，如果设置了，则调用线程池的submit()方法立即进行线程切换，否则，调用schedule()方法进行延时执行线程切换。</p><h4 id="3-1-7、为什么多次执行subscribeOn-，只有第一次有效？"><a href="#3-1-7、为什么多次执行subscribeOn-，只有第一次有效？" class="headerlink" title="3.1.7、为什么多次执行subscribeOn()，只有第一次有效？"></a>3.1.7、为什么多次执行subscribeOn()，只有第一次有效？</h4><p>从上面的分析，我们可以很容易了解到<strong>被观察者被订阅时是从最外面的一层（ObservableSubscribeOn）通知到里面的一层（ObservableOnSubscribe）</strong>，当连续执行了到多次subscribeOn()的时候，其实就是先执行倒数第一次的subscribeOn()方法，直到最后一次执行的subscribeOn()方法肯定会覆盖前面的线程切换。</p><h4 id="3-2-1、observeOn-AndroidSchedulers-mainThread"><a href="#3-2-1、observeOn-AndroidSchedulers-mainThread" class="headerlink" title="3.2.1、observeOn(AndroidSchedulers.mainThread())"></a>3.2.1、observeOn(AndroidSchedulers.mainThread())</h4><pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler) {    return observeOn(scheduler, false, bufferSize());}public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {    ....    return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));}</code></pre><p>可以看到，observeOn()方法内部最终也是返回了一个ObservableObserveOn对象，我们直接来看看ObservableObserveOn的subscribeActual()方法。</p><h4 id="3-2-2、ObservableObserveOn-subscribeActual"><a href="#3-2-2、ObservableObserveOn-subscribeActual" class="headerlink" title="3.2.2、ObservableObserveOn#subscribeActual()"></a>3.2.2、ObservableObserveOn#subscribeActual()</h4><pre><code>@Overrideprotected void subscribeActual(Observer&lt;? super T&gt; observer) {    // 1    if (scheduler instanceof TrampolineScheduler) {        // 2        source.subscribe(observer);    } else {        // 3        Scheduler.Worker w = scheduler.createWorker();        // 4        source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));    }}</code></pre><p>首先，在注释1处，判断指定的调度器是不是TrampolineScheduler，这是一个不进行线程切换，立即执行当前代码的调度器，。如果是，则会直接调用调用ObservableSubscribeOn的subscribe()方法，如果不是，则会在注释3处创建一个工作者对象。然后在注释4处创建一个新的ObserveOnObserver将SubscribeOnobserver对象包装起来，并传入ObservableSubscribeOn的subscribe()方法进行订阅。接下来看看ObserveOnObserver类的重点方法。</p><h4 id="3-2-3、ObserveOnObserver"><a href="#3-2-3、ObserveOnObserver" class="headerlink" title="3.2.3、ObserveOnObserver"></a>3.2.3、ObserveOnObserver</h4><pre><code>@Overridepublic void onNext(T t) {    ...    if (sourceMode != QueueDisposable.ASYNC) {        // 1        queue.offer(t);    }    schedule();}@Overridepublic void onError(Throwable t) {    ...    schedule();}@Overridepublic void onComplete() {    ...    schedule();}</code></pre><p>去除非主线逻辑的代码，在ObserveOnObserver的onNext()和onError()、onComplete()方法中最后都会调用到schedule()方法。接着看schedule()方法，其中onNext()还会把消息存放到队列中。</p><h4 id="3-2-4、ObserveOnObserver-schedule"><a href="#3-2-4、ObserveOnObserver-schedule" class="headerlink" title="3.2.4、ObserveOnObserver#schedule()"></a>3.2.4、ObserveOnObserver#schedule()</h4><pre><code>void schedule() {    if (getAndIncrement() == 0) {        worker.schedule(this);    }}</code></pre><p>这里使用了worker进行调度ObserveOnObserver这个实现了Runnable的任务。worker就是在AndroidSchedulers.mainThread()中创建的，内部其实就是<strong>使用Handler进行线程切换的</strong>，此处不再赘述了。接着看ObserveOnObserver的run()方法。</p><h4 id="3-2-5、ObserveOnObserver-run"><a href="#3-2-5、ObserveOnObserver-run" class="headerlink" title="3.2.5、ObserveOnObserver#run()"></a>3.2.5、ObserveOnObserver#run()</h4><pre><code>@Overridepublic void run() {    // 1    if (outputFused) {        drainFused();    } else {        // 2        drainNormal();    }}</code></pre><p>在注释1处会先判断outputFused这个标志位，它表示事件流是否被融化掉，默认是false，所以，最后会执行到drainNormal()方法。接着看看drainNormal()方法内部的处理。</p><h4 id="3-2-6、ObserveOnObserver-drainNormal"><a href="#3-2-6、ObserveOnObserver-drainNormal" class="headerlink" title="3.2.6、ObserveOnObserver#drainNormal()"></a>3.2.6、ObserveOnObserver#drainNormal()</h4><pre><code>void drainNormal() {    int missed = 1;    final SimpleQueue&lt;T&gt; q = queue;    // 1    final Observer&lt;? super T&gt; a = downstream;    ...    // 2    v = q.poll();    ...    // 3    a.onNext(v);    ...}</code></pre><p>在注释1处，这里的downstream实际上是从外面传进来的SubscribeOnObserver对象。在注释2处将队列中的消息取出来，接着在注释3处调用了SubscribeOnObserver的onNext方法。<strong>最终，会从我们包装类的最外层一直调用到最里面的我们自定义的Observer中的onNext()方法，所以，在observeOn()方法下面的链式代码都会执行到它所指定的线程中，噢，原来如此</strong>。</p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>其实笔者使用了RxJava也已经有一年多的时间了，但是一直没有去深入去了解过它的内部实现原理，如今细细品尝，的确是酣畅淋漓。从一开始的OkHttp到现如今的RxJava源码分析，到此为止，Android主流三方库源码分析系列文章已经发布了五篇了，我们的征途已经过半，接下来，我将会对Android中的内存泄露框架LeakCanary源码进行深入地讲解，尽请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、RxJava V2.2.5 源码</p><p>2、Android 进阶之光</p><p>3、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492749&amp;idx=1&amp;sn=a4d2e79afd8257b57c6efa57cbff4404&amp;chksm=8eec86f2b99b0fe46f61f324e032af335fbe02c7db1ef4eca60abb4bc99b4d216da7ba32dc88&amp;scene=38#wechat_redirect" target="_blank" rel="external">详解 RxJava 的消息订阅和线程切换原理</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%94%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3RxJava%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2018年终总结</title>
      <link>http://yoursite.com/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <guid>http://yoursite.com/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sat, 29 Dec 2018 14:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>今天，已经是2018年最后一天的工作日了，回想2018学习路上的点点滴滴，有收获和喜悦，也有烦恼与焦虑，但是，总的来说，这一年，我在技术上的提升还是比较大的，因此，我感觉，我的付出是值得的，接下来，回顾一下2018年我的成长轨迹。</p><h3 id="一、回顾我的2018年"><a href="#一、回顾我的2018年" class="headerlink" title="一、回顾我的2018年"></a>一、回顾我的2018年</h3><h3 id="第一季度（1-3月）："><a href="#第一季度（1-3月）：" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、开源Awesome-WanAndroid（开源时间-2018年3月9日）"><a href="#1、开源Awesome-WanAndroid（开源时间-2018年3月9日）" class="headerlink" title="1、开源Awesome-WanAndroid（开源时间 2018年3月9日）"></a>1、开源Awesome-WanAndroid（开源时间 2018年3月9日）</h4><p><a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid项目地址</a></p><p>这是我在Github开源的第一个项目，也是第一个达到1K Star的项目。在这之前，我对开源的理解和大多数普通Android开发者的理解一样，认为它只是一个免费的仓库聚集地，其实，开源所包含的意义是巨大的，它对 <strong>整个Android社区的推动和发展</strong> ，以及与 <strong>个人的成长紧密关联</strong> ，而我自身，也 <strong>因为开源，对Android本身的热爱也更加浓厚了</strong> 。因此，希望每个人都能加入到这个大环境来，这能在某种程度上影响自身的发展。</p><p>再来说说这个项目，这个项目是基于鸿洋大神的个人网站<a href="http://www.wanandroid.com/" target="_blank" rel="external">WanAndroid</a>进行开发的Android客户端。它是一款会让您觉得很nice的<strong>技术学习APP</strong>，所用技术基本涵盖了<strong>当前Android开发中常用的主流技术框架</strong>，阅读内容主要面向想在Android开发领域成为专家的朋友们，有兴趣的朋友可以点击上面的链接进行查看。</p><h3 id="第二季度（4-6月）："><a href="#第二季度（4-6月）：" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、开源Awesome-Android-Notebook（开源时间-2018年5月1日）"><a href="#1、开源Awesome-Android-Notebook（开源时间-2018年5月1日）" class="headerlink" title="1、开源Awesome-Android-Notebook（开源时间 2018年5月1日）"></a>1、开源Awesome-Android-Notebook（开源时间 2018年5月1日）</h4><p><a href="https://github.com/JsonChao/Awesome-Android-Notebook" target="_blank" rel="external">Awesome-Android-Notebook项目地址</a></p><p>这个项目的发起还得从我的第一个开源项目<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>说起，在开源了这个项目之后，我收到了很多朋友的鼓励，但同时，因为自身技术实力的薄弱，对很多项目本身所用技术和Android的理解层次不够使我产生了一个将自己打造成为一个优秀Android开发的念头，由此，<a href="https://github.com/JsonChao/Awesome-Android-Notebook" target="_blank" rel="external">Awesome-Android-Notebook</a>诞生了，它是一份通往优秀Android开发的完备的计划，有兴趣的朋友可以参考下。</p><h4 id="2、计算机网络系统学习"><a href="#2、计算机网络系统学习" class="headerlink" title="2、计算机网络系统学习"></a>2、计算机网络系统学习</h4><p>主要基于《计算机网络：自顶向下方法》一书对计算机网络OSI中的五层架构模型相关知识进行了较为深入的学习与理解。</p><h4 id="3、系统学习Android单元测试"><a href="#3、系统学习Android单元测试" class="headerlink" title="3、系统学习Android单元测试"></a>3、系统学习Android单元测试</h4><p>基于<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a><br>项目对Android单元测试的相关技术进行了系统学习，有兴趣的可以查看该项目的test测试目录进行学习。</p><h3 id="第三季度（7-9月）："><a href="#第三季度（7-9月）：" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、开源Awesome-Android-Interview项目（开源时间-2018年7月29日）"><a href="#1、开源Awesome-Android-Interview项目（开源时间-2018年7月29日）" class="headerlink" title="1、开源Awesome-Android-Interview项目（开源时间 2018年7月29日）"></a>1、开源Awesome-Android-Interview项目（开源时间 2018年7月29日）</h4><p><a href="https://github.com/JsonChao/Awesome-Android-Interview" target="_blank" rel="external">Awesome-Android-Interview项目地址</a></p><p>随着Android技术发展的成熟，Kotlin、大前端技术RN、Flutter、小程序等一下子就进入了我们的视野内，同时，Android自身的技术栈也正在不断扩展，比如前段时间Google推出的Jetpack。因此，Android开发者们越来越焦虑，越来越迷茫，每个人的<strong>时间和精力是有限的</strong>，我们到底该学什么才能有效地提高自身的竞争力呢?其实，首先我们应该优先深入学习工作中用到的技术，其次，关注这2年来<strong>Android最新的面试题所涉及的知识点</strong>，根据<strong>自身的实际情况有选择地进行针对性的学习和提升</strong>。只有这样，自身才不会被所谓的 <strong>互联网寒冬</strong> 吓倒。</p><h4 id="2、Python基础-amp-amp-数据分析基础学习"><a href="#2、Python基础-amp-amp-数据分析基础学习" class="headerlink" title="2、Python基础 &amp;&amp; 数据分析基础学习"></a>2、Python基础 &amp;&amp; 数据分析基础学习</h4><p>这一块主要是基于公司的后台算法项目为目的对Python基础知识和数据分析相关基础进行了学习。</p><h3 id="第四季度（10-12月）："><a href="#第四季度（10-12月）：" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、Android核心知识点学习"><a href="#1、Android核心知识点学习" class="headerlink" title="1、Android核心知识点学习"></a>1、Android核心知识点学习</h4><p>基于 <strong>《Android开发艺术探索》</strong> 、 <strong>《Android开发进阶》</strong> 对Android应用开发涉及的核心知识点进行了系统的学习 &amp; 复习 &amp; 理解，并对其中的重难点知识进行了博客输出：</p><ul><li><a href="https://jsonchao.github.io/2018/10/17/Android%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6/" target="_blank" rel="external">Android触摸事件传递机制</a></li><li><a href="https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Android View的绘制流程</a></li><li>Android中的消息机制Handler</li><li>Android中的线程和线程池</li><li>…</li></ul><h4 id="2、开源Awesome-Third-Library-Source-Analysis项目（开源时间-2018年12月18日）"><a href="#2、开源Awesome-Third-Library-Source-Analysis项目（开源时间-2018年12月18日）" class="headerlink" title="2、开源Awesome-Third-Library-Source-Analysis项目（开源时间 2018年12月18日）"></a>2、开源Awesome-Third-Library-Source-Analysis项目（开源时间 2018年12月18日）</h4><p><a href="https://github.com/JsonChao/Awesome-Third-Library-Source-Analysis" target="_blank" rel="external">Awesome-Third-Library-Source-Analysis项目地址</a></p><p>众所周知，优秀源码的阅读与理解是最能提升自身功力的途径，如果想要成为一名优秀的Android工程师，那么Android优秀三方库源码的分析和理解则是必备技能。因此，为了将知识成体系地聚合起来，笔者创建了Awesome-Third-Library-Source-Analysis这个项目，为的就是让每一个Android工程师能够从以下七方面全方位地提升自己：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Android_hot_third_source_analysis.png" alt="image"></p><p>这个项目目前已进行进行到第四步——响应式编程，最近几天就会输出RxJava的源码分析文章，此前，已经对Android中的网络、图片加载、数据库热门框架源码进行了分析，感兴趣的可以<a href="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Android_hot_third_source_analysis.png" target="_blank" rel="external">点此查看</a>，目前，估计在2019年1月底此系列将会完结，后续会马上推出Android核心源码的分析系列，敬请期待。</p><h4 id="3、C-C-核心基础知识复习"><a href="#3、C-C-核心基础知识复习" class="headerlink" title="3、C/C++核心基础知识复习"></a>3、C/C++核心基础知识复习</h4><p>要想深入研究Android源码，C/C++基础则是必备之一，因此，我重新捡起了C/C++，下面是C/C++的核心知识速记笔记:</p><ul><li><a href="https://github.com/JsonChao/Awesome-Android-Notebook/blob/master/notes/C%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md" target="_blank" rel="external">C核心速记笔记</a></li><li><a href="https://github.com/JsonChao/Awesome-Android-Notebook/blob/master/notes/C%2B%2B%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.md" target="_blank" rel="external">C++核心速记笔记</a></li></ul><p>接下来，下面对我的2019年做了<strong>最核心的学习计划</strong>，所以会尽可能地去完成好它。</p><h3 id="二、初始化我的2019年"><a href="#二、初始化我的2019年" class="headerlink" title="二、初始化我的2019年"></a>二、初始化我的2019年</h3><h3 id="第一季度（1-3月）：-1"><a href="#第一季度（1-3月）：-1" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、Android主流开源库源码分析系列博客"><a href="#1、Android主流开源库源码分析系列博客" class="headerlink" title="1、Android主流开源库源码分析系列博客"></a>1、Android主流开源库源码分析系列博客</h4><p>Android高级开发者必须了解的核心开源库源码：</p><ul><li>内存泄露：LeakCanary</li><li>依赖注入：ButterKnife、Dagger2</li><li>事件总线：EventBus</li></ul><h4 id="2、Android核心源码"><a href="#2、Android核心源码" class="headerlink" title="2、Android核心源码"></a>2、Android核心源码</h4><p>与Android应用开发紧密相关的Framework核心源码：</p><ul><li>Context家族</li><li>AMS</li><li>WMS</li><li>PMS</li><li>JNI原理</li></ul><h4 id="3、Android插件化知识相关"><a href="#3、Android插件化知识相关" class="headerlink" title="3、Android插件化知识相关"></a>3、Android插件化知识相关</h4><p>学习和理解插件化知识能将FrameWork核心源码的相关知识融会贯通：</p><ul><li>JVM核心知识</li><li>Davilk/ART核心知识</li><li>类加载</li><li>热修复</li><li>插件化（基于VirtualAPK）</li></ul><h4 id="4、组件化"><a href="#4、组件化" class="headerlink" title="4、组件化"></a>4、组件化</h4><p>结合公司新版项目系统学习组件化架构的设计与理念。</p><h4 id="5、算法"><a href="#5、算法" class="headerlink" title="5、算法"></a>5、算法</h4><p>LetteCode 每日一题 ==&gt; 思考&amp;练习&amp;记录，基于以下学习课程：</p><ul><li><a href="https://coding.imooc.com/learn/list/207.html" target="_blank" rel="external">玩转数据结构 从入门到进阶</a></li><li><a href="https://coding.imooc.com/learn/list/71.html" target="_blank" rel="external">学习算法思想，修炼编程内功</a></li><li><a href="https://coding.imooc.com/learn/list/82.html" target="_blank" rel="external">玩转算法面试，从真题到思维全面提升算法思维</a></li></ul><h3 id="第二季度（4-6月）：-1"><a href="#第二季度（4-6月）：-1" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、Android源码设计模式"><a href="#1、Android源码设计模式" class="headerlink" title="1、Android源码设计模式"></a>1、Android源码设计模式</h4><p>主要基于 <strong>Android源码</strong> 和 <strong>《Android源码设计模式解析与实战》</strong> 一书进一步加深对Android FrameWork层的的理解与思考。</p><h4 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录，基于以下学习课程：</p><ul><li>极客时间之《数据结构和算法之美》</li></ul><h3 id="第三季度（7-9月）：-1"><a href="#第三季度（7-9月）：-1" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、深入理解Android热修复"><a href="#1、深入理解Android热修复" class="headerlink" title="1、深入理解Android热修复"></a>1、深入理解Android热修复</h4><p>主要基于 <strong>现有的热修复技术</strong> 和 <strong>《深入探索Android热修复技术原理》</strong> 一书进一步加深对Android热修复技术的的理解与思考解。</p><h4 id="2、深入理解Android插件化"><a href="#2、深入理解Android插件化" class="headerlink" title="2、深入理解Android插件化"></a>2、深入理解Android插件化</h4><p>主要基于 <strong>现有的插件化技术</strong> 和 <strong>《Android插件化开发指南》</strong> 一书进一步加深对Android插件化技术的理解与思考。</p><h4 id="3、算法"><a href="#3、算法" class="headerlink" title="3、算法"></a>3、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录，基于以下学习课程：</p><ul><li>极客时间之《算法面试通关40讲》</li></ul><h3 id="第四季度（10-12月）：-1"><a href="#第四季度（10-12月）：-1" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、深入学习Android性能优化"><a href="#1、深入学习Android性能优化" class="headerlink" title="1、深入学习Android性能优化"></a>1、深入学习Android性能优化</h4><p>主要基于 <strong>极客时间之《Android开发高手课》</strong> 和 <strong>《Android应用性能优化最佳实践》</strong>、收藏的其它性能优化博文对Android性能优化相关知识进行全面、系统、深入地学习。</p><h4 id="2、算法-1"><a href="#2、算法-1" class="headerlink" title="2、算法"></a>2、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>如果想要成为一名优秀甚至卓越的Android工程师，就必须给自己 <strong>制定好切合自身的计划</strong> ，并 <strong>不断地刻意练习和思考</strong> ，只有这样，我们才能像锻炼肌肉一样去强化我们的大脑，最终，我们便会拥有 <strong>一通百通、快速学习的能力</strong> 。</p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（四、深入理解GreenDao源码）</title>
      <link>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sat, 22 Dec 2018 14:44:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>，除了热门的网络库之外，我们还分析了使用最广泛的图片加载框架Glide的加载流程，大家读完这篇源码分析会有不少提升，有兴趣可以看看<a href="https://jsonchao.github.io/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>。本篇，我们将会来对目前Android数据库框架中性能最好的GreenDao来进行较为深入地讲解。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><h4 id="1、导入GreenDao的代码生成插件和库"><a href="#1、导入GreenDao的代码生成插件和库" class="headerlink" title="1、导入GreenDao的代码生成插件和库"></a>1、导入GreenDao的代码生成插件和库</h4><pre><code>// 项目下的build.gradlebuildscript {    ...    dependencies {        classpath &apos;com.android.tools.build:gradle:2.3.0&apos;        classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.1&apos;     }}// app模块下的build.gradleapply plugin: &apos;com.android.application&apos;apply plugin: &apos;org.greenrobot.greendao&apos;...dependencies {    ...    compile &apos;org.greenrobot:greendao:3.2.0&apos; }</code></pre><h4 id="2、创建一个实体类，这里为HistoryData"><a href="#2、创建一个实体类，这里为HistoryData" class="headerlink" title="2、创建一个实体类，这里为HistoryData"></a>2、创建一个实体类，这里为HistoryData</h4><pre><code>@Entitypublic class HistoryData {    @Id(autoincrement = true)    private Long id;    private long date;    private String data;}</code></pre><h4 id="3、选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"><a href="#3、选择ReBuild-Project，HistoryData会被自动添加Set-get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。" class="headerlink" title="3、选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。"></a>3、选择ReBuild Project，HistoryData会被自动添加Set/get方法，并生成整个项目的DaoMaster、DaoSession类，以及与该实体HistoryData对应的HistoryDataDao。</h4><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/greendao_auto_generate_class.png" alt="image"></p><pre><code>@Entitypublic class HistoryData {    @Id(autoincrement = true)    private Long id;    private long date;    private String data;    @Generated(hash = 1371145256)    public HistoryData(Long id, long date, String data) {        this.id = id;        this.date = date;        this.data = data;    }    @Generated(hash = 422767273)    public HistoryData() {    }    public Long getId() {        return this.id;    }    public void setId(Long id) {        this.id = id;    }    public long getDate() {        return this.date;    }    public void setDate(long date) {        this.date = date;    }    public String getData() {        return this.data;    }    public void setData(String data) {        this.data = data;    }}</code></pre><p>这里点明一下这几个类的作用：</p><ul><li>DaoMaster：所有Dao类的主人，负责整个库的运行，内部的静态抽象子类DevOpenHelper继承并重写了Android的SqliteOpenHelper。</li><li>DaoSession：作为一个会话层的角色，用于生成相应的Dao对象、Dao对象的注册，操作Dao的具体对象。</li><li>xxDao（HistoryDataDao）：生成的Dao对象，用于进行具体的数据库操作。</li></ul><h4 id="4、获取并使用相应的Dao对象进行增删改查操作"><a href="#4、获取并使用相应的Dao对象进行增删改查操作" class="headerlink" title="4、获取并使用相应的Dao对象进行增删改查操作"></a>4、获取并使用相应的Dao对象进行增删改查操作</h4><pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME);SQLiteDatabase database = devOpenHelper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(database);mDaoSession = daoMaster.newSession();HistoryDataDao historyDataDao = daoSession.getHistoryDataDao();// 省略创建historyData的代码...// 增historyDataDao.insert(historyData);// 删historyDataDao.delete(historyData);// 改historyDataDao.update(historyData);// 查List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll();</code></pre><p>本篇文章将会以上述使用流程来对GreenDao的源码进行逐步分析，最后会分析下GreenDao中一些优秀的特性，让读者朋友们对GreenDao的理解有更一步的加深。</p><h3 id="二、GreenDao使用流程分析"><a href="#二、GreenDao使用流程分析" class="headerlink" title="二、GreenDao使用流程分析"></a>二、GreenDao使用流程分析</h3><h4 id="1、创建数据库帮助类对象DaoMaster-DevOpenHelper"><a href="#1、创建数据库帮助类对象DaoMaster-DevOpenHelper" class="headerlink" title="1、创建数据库帮助类对象DaoMaster.DevOpenHelper"></a>1、创建数据库帮助类对象DaoMaster.DevOpenHelper</h4><pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(this, Constants.DB_NAME);</code></pre><p>创建GreenDao内部实现的数据库帮助类对象devOpenHelper，核心源码如下：</p><pre><code>public class DaoMaster extends AbstractDaoMaster {    ...    public static abstract class OpenHelper extends DatabaseOpenHelper {    ...         @Override        public void onCreate(Database db) {            Log.i(&quot;greenDAO&quot;, &quot;Creating tables for schema version &quot; + SCHEMA_VERSION);            createAllTables(db, false);        }    }    public static class DevOpenHelper extends OpenHelper {        ...        @Override        public void onUpgrade(Database db, int oldVersion, int newVersion) {            Log.i(&quot;greenDAO&quot;, &quot;Upgrading schema from version &quot; + oldVersion + &quot; to &quot; + newVersion + &quot; by dropping all tables&quot;);            dropAllTables(db, true);            onCreate(db);        }    }}</code></pre><p>DevOpenHelper自身实现了更新的逻辑，这里是弃置了所有的表，并且调用了OpenHelper实现的onCreate方法用于创建所有的表，其中DevOpenHelper继承于OpenHelper，而OpenHelper自身又继承于DatabaseOpenHelper，那么，这个DatabaseOpenHelper这个类的作用是什么呢？</p><pre><code>public abstract class DatabaseOpenHelper extends SQLiteOpenHelper {    ...    // 关注点1    public Database getWritableDb() {        return wrap(getWritableDatabase());    }    public Database getReadableDb() {        return wrap(getReadableDatabase());    }       protected Database wrap(SQLiteDatabase sqLiteDatabase) {        return new StandardDatabase(sqLiteDatabase);    }    ...    // 关注点2    public Database getEncryptedWritableDb(String password) {        EncryptedHelper encryptedHelper = checkEncryptedHelper();        return encryptedHelper.wrap(encryptedHelper.getWritableDatabase(password));    }    public Database getEncryptedReadableDb(String password) {        EncryptedHelper encryptedHelper = checkEncryptedHelper();        return encryptedHelper.wrap(encryptedHelper.getReadableDatabase(password));    }    ...    private class EncryptedHelper extends net.sqlcipher.database.SQLiteOpenHelper {        ...        protected Database wrap(net.sqlcipher.database.SQLiteDatabase     sqLiteDatabase) {            return new EncryptedDatabase(sqLiteDatabase);        }    }</code></pre><p>其实，DatabaseOpenHelper也是实现了SQLiteOpenHelper的一个帮助类，它内部可以获取到两种不同的数据库类型，一种是标准型的数据库==StandardDatabase==，另一种是加密型的数据库==EncryptedDatabase==，从以上源码可知，它们内部都通过wrap这样一个包装的方法，返回了对应的数据库类型，我们大致看一下StandardDatabase和EncryptedDatabase的内部实现。</p><pre><code>public class StandardDatabase implements Database {    // 这里的SQLiteDatabase是android.database.sqlite.SQLiteDatabase包下的    private final SQLiteDatabase delegate;    public StandardDatabase(SQLiteDatabase delegate) {        this.delegate = delegate;    }    @Override    public Cursor rawQuery(String sql, String[] selectionArgs) {        return delegate.rawQuery(sql, selectionArgs);    }    @Override    public void execSQL(String sql) throws SQLException {        delegate.execSQL(sql);    }    ...}public class EncryptedDatabaseStatement implements DatabaseStatement     {    // 这里的SQLiteStatement是net.sqlcipher.database.SQLiteStatement包下的    private final SQLiteStatement delegate;    public EncryptedDatabaseStatement(SQLiteStatement delegate) {        this.delegate = delegate;    }    @Override    public void execute() {        delegate.execute();    }    ...}</code></pre><p>StandardDatabase和EncryptedDatabase这两个类内部都使用了<strong>代理模式</strong>给相同的接口添加了不同的具体实现，StandardDatabase自然是使用的Android包下的SQLiteDatabase，而EncryptedDatabaseStatement为了实现加密数据库的功能，则使用了一个叫做==sqlcipher==的数据库加密三方库，如果你项目下的数据库需要保存比较重要的数据，则可以使用getEncryptedWritableDb方法来代替getdWritableDb方法对数据库进行加密，这样，我们之后的数据库操作则会以代理模式的形式间接地使用sqlcipher提供的API去操作数据库。</p><h4 id="2、创建DaoMaster对象"><a href="#2、创建DaoMaster对象" class="headerlink" title="2、创建DaoMaster对象"></a>2、创建DaoMaster对象</h4><pre><code>SQLiteDatabase database = devOpenHelper.getWritableDatabase();DaoMaster daoMaster = new DaoMaster(database);</code></pre><p>首先，DaoMaster作为所有Dao对象的主人，它内部肯定是需要一个SQLiteDatabase对象的，因此，先由DaoMaster的帮助类对象devOpenHelper的getWritableDatabase方法得到一个标准的数据库类对象database，再由此创建一个DaoMaster对象。</p><pre><code>public class DaoMaster extends AbstractDaoMaster {    ...    public DaoMaster(SQLiteDatabase db) {        this(new StandardDatabase(db));    }    public DaoMaster(Database db) {        super(db, SCHEMA_VERSION);        registerDaoClass(HistoryDataDao.class);    }    ...}</code></pre><p>在DaoMaster的构造方法中，它首先执行了super(db, SCHEMA_VERSION)方法，即它的父类AbstractDaoMaster的构造方法。</p><pre><code>public abstract class AbstractDaoMaster {    ...    public AbstractDaoMaster(Database db, int schemaVersion) {        this.db = db;        this.schemaVersion = schemaVersion;        daoConfigMap = new HashMap&lt;Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt;();    }    protected void registerDaoClass(Class&lt;? extends AbstractDao&lt;?, ?&gt;&gt; daoClass) {        DaoConfig daoConfig = new DaoConfig(db, daoClass);        daoConfigMap.put(daoClass, daoConfig);    }    ...}</code></pre><p>在AbstractDaoMaster对象的构造方法中，除了记录当前的数据库对象db和版本schemaVersion之外，还创建了一个类型为HashMap<class<? extends="" abstractdao<?,="" ?="">&gt;, DaoConfig&gt;()的daoConfigMap对象<strong>用于保存每一个DAO对应的数据配置对象DaoConfig</strong>，Daoconfig对象存储了对应的Dao对象所必需的数据。最后，在DaoMaster的构造方法中使用了registerDaoClass(HistoryDataDao.class)方法将HistoryDataDao类对象进行了注册，实际上，就是为HistoryDataDao这个Dao对象创建了相应的DaoConfig对象并将它放入daoConfigMap对象中保存起来。</class<?></p><h4 id="3、创建DaoSession对象"><a href="#3、创建DaoSession对象" class="headerlink" title="3、创建DaoSession对象"></a>3、创建DaoSession对象</h4><pre><code>mDaoSession = daoMaster.newSession();</code></pre><p>在DaoMaster对象中使用了newSession方法新建了一个DaoSession对象。</p><pre><code>public DaoSession newSession() {    return new DaoSession(db, IdentityScopeType.Session, daoConfigMap);}</code></pre><p>在DaoSeesion的构造方法中，又做了哪些事情呢？</p><pre><code>public class DaoSession extends AbstractDaoSession {    ...    public DaoSession(Database db, IdentityScopeType type, Map&lt;Class&lt;?     extends AbstractDao&lt;?, ?&gt;&gt;, DaoConfig&gt;            daoConfigMap) {        super(db);        historyDataDaoConfig = daoConfigMap.get(HistoryDataDao.class).clone();        historyDataDaoConfig.initIdentityScope(type);        historyDataDao = new HistoryDataDao(historyDataDaoConfig, this);        registerDao(HistoryData.class, historyDataDao);    }    ...}</code></pre><p>首先，调用了父类AbstractDaoSession的构造方法。</p><pre><code>public class AbstractDaoSession {    ...    public AbstractDaoSession(Database db) {        this.db = db;        this.entityToDao = new HashMap&lt;Class&lt;?&gt;, AbstractDao&lt;?, ?&gt;&gt;();    }    protected &lt;T&gt; void registerDao(Class&lt;T&gt; entityClass, AbstractDao&lt;T, ?&gt; dao) {        entityToDao.put(entityClass, dao);    }    ...}</code></pre><p>在AbstractDaoSession构造方法里面<strong>创建了一个实体与Dao对象的映射集合</strong>。接下来，在DaoSession的构造方法中还做了2件事：</p><ul><li>1、创建每一个Dao对应的DaoConfig对象，这里是historyDataDaoConfig，并且根据IdentityScopeType的类型初始化创建一个相应的IdentityScope，根据type的不同，它有两种类型，分别是==IdentityScopeObject==和==IdentityScopeLong==，它的作用是根据主键缓存对应的实体数据。当主键是数字类型的时候，如long/Long、int/Integer、short/Short、byte/Byte，则使用IdentityScopeLong缓存实体数据，当主键不是数字类型的时候，则使用IdentityScopeObject缓存实体数据。</li><li>2、根据DaoSession对象和每一个Dao对应的DaoConfig对象，创建与之对应的historyDataDao对象，由于这个项目只创建了一个实体类HistoryData，因此这里只有一个Dao对象historyDataDao，然后就是注册Dao对象，其实就是将实体和对应的Dao对象放入entityToDao这个映射集合中保存起来了。</li></ul><h4 id="4、插入源码分析"><a href="#4、插入源码分析" class="headerlink" title="4、插入源码分析"></a>4、插入源码分析</h4><pre><code>HistoryDataDao historyDataDao = daoSession.getHistoryDataDao();// 增historyDataDao.insert(historyData);</code></pre><p>这里首先在会话层DaoSession中获取了我们要操作的Dao对象HistoryDataDao，然后插入了一个我们预先创建好的historyData实体对象。其中HistoryDataDao继承了AbstractDao<historydata, long=""> 。</historydata,></p><pre><code>public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; {    ...}</code></pre><p>那么，这个AbstractDao是干什么的呢？</p><pre><code>public abstract class AbstractDao&lt;T, K&gt; {    ...    public List&lt;T&gt; loadAll() {        Cursor cursor = db.rawQuery(statements.getSelectAll(), null);        return loadAllAndCloseCursor(cursor);    }    ...    public long insert(T entity) {        return executeInsert(entity, statements.getInsertStatement(),     true);    }    ...    public void delete(T entity) {        assertSinglePk();        K key = getKeyVerified(entity);        deleteByKey(key);    }    ...}</code></pre><p>看到这里，根据程序员优秀的直觉，大家应该能猜到，AbstractDao是所有Dao对象的基类，它实现了实体数据的操作如增删改查。我们接着分析insert是如何实现的，在AbstractDao的insert方法中又调用了executeInsert这个方法。在这个方法中，第二个参里的statements是一个==TableStatements==对象，它是在AbstractDao初始化构造器时从DaoConfig对象中取出来的，是一个<strong>根据指定的表格创建SQL语句的一个帮助类</strong>。使用statements.getInsertStatement()则是获取了一个插入的语句。而第三个参数则是判断是否是主键的标志。</p><pre><code>public class TableStatements {    ...    public DatabaseStatement getInsertStatement() {        if (insertStatement == null) {            String sql = SqlUtils.createSqlInsert(&quot;INSERT INTO &quot;, tablename, allColumns);            DatabaseStatement newInsertStatement = db.compileStatement(sql);            ...        }        return insertStatement;    }    ...}</code></pre><p>在TableStatements的getInsertStatement方法中，主要做了两件事：</p><ul><li>1、使用SqlUtils创建了插入的sql语句。</li><li>2、根据不同的数据库类型（标准数据库或加密数据库）将sql语句编译成当前数据库对应的语句。</li></ul><p>我们继续往下分析executeInsert的执行流程。</p><pre><code>private long executeInsert(T entity, DatabaseStatement stmt, boolean setKeyAndAttach) {    long rowId;    if (db.isDbLockedByCurrentThread()) {        rowId = insertInsideTx(entity, stmt);    } else {        db.beginTransaction();        try {            rowId = insertInsideTx(entity, stmt);            db.setTransactionSuccessful();        } finally {            db.endTransaction();        }    }    if (setKeyAndAttach) {        updateKeyAfterInsertAndAttach(entity, rowId, true);    }    return rowId;}</code></pre><p>这里首先是判断数据库是否被当前线程锁定，如果是，则直接插入数据，否则为了避免死锁，则开启一个数据库事务，再进行插入数据的操作。最后如果设置了主键，则在插入数据之后更新主键的值并将对应的实体缓存到相应的identityScope中，这一块的代码流程如下所示：</p><pre><code>protected void updateKeyAfterInsertAndAttach(T entity, long rowId, boolean lock) {    if (rowId != -1) {        K key = updateKeyAfterInsert(entity, rowId);        attachEntity(key, entity, lock);    } else {       ...    }}protected final void attachEntity(K key, T entity, boolean lock) {    attachEntity(entity);    if (identityScope != null &amp;&amp; key != null) {        if (lock) {            identityScope.put(key, entity);        } else {            identityScope.putNoLock(key, entity);        }    }}</code></pre><p>接着，我们还是继续追踪主线流程，在executeInsert这个方法中调用了insertInsideTx进行数据的插入。</p><pre><code>private long insertInsideTx(T entity, DatabaseStatement stmt) {    synchronized (stmt) {        if (isStandardSQLite) {            SQLiteStatement rawStmt = (SQLiteStatement) stmt.getRawStatement();            bindValues(rawStmt, entity);            return rawStmt.executeInsert();        } else {            bindValues(stmt, entity);            return stmt.executeInsert();        }    }}</code></pre><p>为了防止并发，这里使用了悲观锁保证了数据的一致性，在AbstractDao这个类中，大量使用了这种锁保证了它的线程安全性。接着，如果当前是标准数据库，则直接获取stmt这个DatabaseStatement类对应的原始语句进行实体字段属性的绑定和最后的执行插入操作。如果是加密数据库，则直接使用当前的加密数据库所属的插入语句进行实体字段属性的绑定和执行最后的插入操作。其中bindValues这个方法对应的实现类就是我们的HistoryDataDao类。</p><pre><code>public class HistoryDataDao extends AbstractDao&lt;HistoryData, Long&gt; {    ...    @Override    protected final void bindValues(DatabaseStatement stmt, HistoryData     entity) {        stmt.clearBindings();        Long id = entity.getId();        if (id != null) {            stmt.bindLong(1, id);        }        stmt.bindLong(2, entity.getDate());        String data = entity.getData();        if (data != null) {            stmt.bindString(3, data);        }    }    @Override    protected final void bindValues(SQLiteStatement stmt, HistoryData     entity) {        stmt.clearBindings();        Long id = entity.getId();        if (id != null) {            stmt.bindLong(1, id);        }        stmt.bindLong(2, entity.getDate());        String data = entity.getData();        if (data != null) {            stmt.bindString(3, data);        }    }    ...}</code></pre><p>可以看到，这里对HistoryData的所有字段使用对应的数据库语句进行了绑定操作。这里最后再提及一下，如果当前数据库是加密型时，则会使用最开始提及的DatabaseStatement的加密实现类EncryptedDatabaseStatement应用代理模式去使用sqlcipher这个加密型数据库的insert方法。</p><h4 id="5、查询源码分析"><a href="#5、查询源码分析" class="headerlink" title="5、查询源码分析"></a>5、查询源码分析</h4><p>经过对插入源码的分析，我相信大家对GreenDao内部的机制已经有了一些自己的理解，由于删除和更新内部的流程比较简单，且与插入源码有异曲同工之妙，这里就不在赘述了。最后我们再分析下查询的源码，查询的流程调用链较长，所以将它的核心流程源码直接给出。</p><pre><code>List&lt;HistoryData&gt; historyDataList = historyDataDao.loadAll();public List&lt;T&gt; loadAll() {    Cursor cursor = db.rawQuery(statements.getSelectAll(), null);    return loadAllAndCloseCursor(cursor);}protected List&lt;T&gt; loadAllAndCloseCursor(Cursor cursor) {    try {        return loadAllFromCursor(cursor);    } finally {        cursor.close();    }}protected List&lt;T&gt; loadAllFromCursor(Cursor cursor) {    int count = cursor.getCount();    ...    boolean useFastCursor = false;    if (cursor instanceof CrossProcessCursor) {        window = ((CrossProcessCursor) cursor).getWindow();        if (window != null) {              if (window.getNumRows() == count) {                cursor = new FastCursor(window);                useFastCursor = true;            } else {              ...            }        }    }    if (cursor.moveToFirst()) {        ...        try {            if (!useFastCursor &amp;&amp; window != null &amp;&amp; identityScope != null) {                loadAllUnlockOnWindowBounds(cursor, window, list);            } else {                do {                    list.add(loadCurrent(cursor, 0, false));                } while (cursor.moveToNext());            }        } finally {            ...        }    }    return list;}</code></pre><p>最终，loadAll方法将会调用到loadAllFromCursor这个方法，首先，如果<strong>当前的游标cursor是跨进程的cursor</strong>，并且cursor的行数没有偏差的话，则使用一个加快版的==FastCursor==对象进行游标遍历。接着，不管是执行loadAllUnlockOnWindowBounds这个方法还是直接加载当前的数据列表list.add(loadCurrent(cursor, 0, false))，最后都会调用到这行list.add(loadCurrent(cursor, 0, false))代码，很明显，loadCurrent方法就是加载数据的方法。</p><pre><code>final protected T loadCurrent(Cursor cursor, int offset, boolean lock) {    if (identityScopeLong != null) {        ...        T entity = lock ? identityScopeLong.get2(key) : identityScopeLong.get2NoLock(key);        if (entity != null) {            return entity;        } else {            entity = readEntity(cursor, offset);            attachEntity(entity);            if (lock) {                identityScopeLong.put2(key, entity);            } else {                identityScopeLong.put2NoLock(key, entity);            }            return entity;        }    } else if (identityScope != null) {        ...        T entity = lock ? identityScope.get(key) : identityScope.getNoLock(key);        if (entity != null) {            return entity;        } else {            entity = readEntity(cursor, offset);            attachEntity(key, entity, lock);            return entity;        }    } else {        ...        T entity = readEntity(cursor, offset);        attachEntity(entity);        return entity;    }}</code></pre><p>我们来理解下loadCurrent这个方法内部的执行策略。<strong>首先，如果有实体数据缓存identityScopeLong/identityScope，则先从缓存中取，如果缓存中没有，会使用该实体对应的Dao对象，这里的是HistoryDataDao，它在内部根据游标取出的数据新建了一个新的HistoryData实体对象返回。</strong></p><pre><code>@Overridepublic HistoryData readEntity(Cursor cursor, int offset) {    HistoryData entity = new HistoryData( //        cursor.isNull(offset + 0) ? null : cursor.getLong(offset + 0), // id        cursor.getLong(offset + 1), // date        cursor.isNull(offset + 2) ? null : cursor.getString(offset + 2) // data    );    return entity;}</code></pre><p><strong>最后，如果是非identityScopeLong缓存类型，即是属于identityScope的情况下，则还会在identityScope中将上面获得的数据进行缓存。如果没有实体数据缓存的话，则直接调用readEntity组装数据返回即可。</strong></p><p>注意：对于GreenDao缓存的特性，可能会出现没有拿到最新数据的bug，因此，如果遇到这种情况，可以使用DaoSession的clear方法删除缓存。</p><h3 id="三、GreenDao是如何与ReactiveX结合？"><a href="#三、GreenDao是如何与ReactiveX结合？" class="headerlink" title="三、GreenDao是如何与ReactiveX结合？"></a>三、GreenDao是如何与ReactiveX结合？</h3><p>首先，看下与rx结合的使用流程：</p><pre><code>RxDao&lt;HistoryData, Long&gt; xxDao = daoSession.getHistoryDataDao().rx();xxDao.insert(historyData)        .observerOn(AndroidSchedulers.mainThread())        .subscribe(new Action1&lt;HistoryData&gt;() {            @Override            public void call(HistoryData entity) {                // insert success            }        });</code></pre><p>在AbstractDao对象的.rx()方法中，创建了一个默认执行在io线程的rxDao对象。</p><pre><code>@Experimentalpublic RxDao&lt;T, K&gt; rx() {    if (rxDao == null) {        rxDao = new RxDao&lt;&gt;(this, Schedulers.io());    }    return rxDao;}</code></pre><p>接着分析rxDao的insert方法。</p><pre><code>@Experimentalpublic Observable&lt;T&gt; insert(final T entity) {    return wrap(new Callable&lt;T&gt;() {        @Override        public T call() throws Exception {            dao.insert(entity);            return entity;        }    });}</code></pre><p>起实质作用的就是这个wrap方法了，在这个方法里面主要是调用了RxUtils.fromCallable(callable)这个方法。</p><pre><code>@Internalclass RxBase {    ...    protected &lt;R&gt; Observable&lt;R&gt; wrap(Callable&lt;R&gt; callable) {        return wrap(RxUtils.fromCallable(callable));    }    protected &lt;R&gt; Observable&lt;R&gt; wrap(Observable&lt;R&gt; observable) {        if (scheduler != null) {            return observable.subscribeOn(scheduler);        } else {            return observable;        }    }    ...}</code></pre><p>在RxUtils的fromCallable这个方法内部，其实就是<strong>使用defer这个延迟操作符来进行被观察者事件的发送，主要目的就是为了确保Observable被订阅后才执行</strong>。最后，如果调度器scheduler存在的话，将通过外部的wrap方法将执行环境调度到io线程。</p><pre><code>@Internalclass RxUtils {    @Internal    static &lt;T&gt; Observable&lt;T&gt; fromCallable(final Callable&lt;T&gt; callable) {        return Observable.defer(new Func0&lt;Observable&lt;T&gt;&gt;() {            @Override            public Observable&lt;T&gt; call() {                T result;                try {                    result = callable.call();                } catch (Exception e) {                    return Observable.error(e);                }                return Observable.just(result);            }        });    }}</code></pre><h3 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h3><p>在分析完GreenDao的大致源码之后，我发现，GreenDao作为最好的数据库框架之一，是有一定道理的。首先，它通过使用自身的插件配套相应的freemarker模板生成所需的静态代码，避免了反射等消耗性能的操作。其次，它内部提供了实体数据的映射缓存机制，能够进一步加快查询速度。对于不同数据库对应的SQL语句，也使用了不同的DataBaseStatement实现类结合代理模式进行了封装，屏蔽了数据库操作等繁琐的细节。最后，它使用了sqlcipher提供了加密数据库的功能，在一定程度确保了安全性，同时，结合RxJava，我们便能更简洁地实现异步的数据库操作。GreenDao源码分析到这里就真的完结了，下一篇，笔者将会对RxJava的核心源码进行细致地讲解，以此能让大家对RxJava有一个更为深入的理解。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、GreenDao V3.2.2源码</p><p>2、<a href="https://mp.weixin.qq.com/s?__biz=MzIwMTAzMTMxMg==&amp;mid=2649492577&amp;idx=1&amp;sn=b35b0ef0f3769efa8c5d49fc5d60dd80&amp;chksm=8eec879eb99b0e8881dd83cac912192df742ad547ccd274b7fccd2995edd08b095e1fd556cfe&amp;scene=38#wechat_redirect" target="_blank" rel="external">GreenDao源码分析</a></p><p>3、<a href="http://www.voidcn.com/article/p-ksrtulcy-brp.html" target="_blank" rel="external">GreenDao源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/22/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3GreenDao%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（三、深入理解Glide源码）</title>
      <link>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 16 Dec 2018 12:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前两篇我们详细地分析了Android的网络底层框架OKHttp和封装框架Retrofit的核心源码，如果对OKHttp或Retrofit内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>和<a href="https://jsonchao.github.io/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（二、深入理解Retrofit源码）</a>。本篇，我们将会来深入地分析下目前Android使用最广泛的图片加载框架框架Glide的源码加载流程。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><p>Glide最基本的使用流程就是下面这行代码，其它所有扩展的额外功能都是以其建造者链式调用的基础上增加的。</p><pre><code>GlideApp.with(context).load(url).into(iv);</code></pre><p>其中的GlideApp是注解处理器自动生成的，要使用GlideApp，必须先配置应用的AppGlideModule模块，里面可以为空配置，也可以根据实际情况添加指定配置。</p><pre><code>@GlideModulepublic class MyAppGlideModule extends AppGlideModule {    @Override    public void applyOptions(Context context, GlideBuilder builder) {        // 实际使用中根据情况可以添加如下配置        &lt;!--builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));--&gt;        &lt;!--int memoryCacheSizeBytes = 1024 * 1024 * 20;--&gt;        &lt;!--builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));--&gt;        &lt;!--int bitmapPoolSizeBytes = 1024 * 1024 * 30;--&gt;        &lt;!--builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));--&gt;        &lt;!--int diskCacheSizeBytes = 1024 * 1024 * 100;--&gt;        &lt;!--builder.setDiskCache(new InternalCacheDiskCacheFactory(context, diskCacheSizeBytes));--&gt;    }}</code></pre><p>接下来，本文将针对Glide的最新源码版本V4.8.0对Glide加载网络图片的流程进行详细地分析与讲解，力争做到让读者朋友们知其然也知其所以然。</p><h3 id="二、GlideApp-with-context-源码详解"><a href="#二、GlideApp-with-context-源码详解" class="headerlink" title="二、GlideApp.with(context)源码详解"></a>二、GlideApp.with(context)源码详解</h3><p>首先，用<strong>艽野尘梦</strong>绘制的这份Glide框架图让我们对Glide的总体框架有一个初步的了解。</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Glide%E6%A1%86%E6%9E%B6%E5%9B%BE.jpg" alt="image"></p><p>从GlideApp.with这行代码开始，内部主线执行流程如下。</p><h4 id="1、GlideApp-with"><a href="#1、GlideApp-with" class="headerlink" title="1、GlideApp#with"></a>1、GlideApp#with</h4><pre><code>return (GlideRequests) Glide.with(context);</code></pre><h4 id="2、Glide-with"><a href="#2、Glide-with" class="headerlink" title="2、Glide#with"></a>2、Glide#with</h4><pre><code>return getRetriever(context).get(context);return Glide.get(context).getRequestManagerRetriever();// 外部使用了双重检锁的同步方式确保同一时刻只执一次Glide的初始化checkAndInitializeGlide(context);initializeGlide(context);// 最终执行到Glide的另一个重载方法initializeGlide(context, new GlideBuilder());@SuppressWarnings(&quot;deprecation&quot;)  private static void initializeGlide(@NonNull Context   context, @NonNull GlideBuilder builder) {    Context applicationContext =     context.getApplicationContext();    // 1、获取前面应用中带注解的GlideModule    GeneratedAppGlideModule annotationGeneratedModule =     getAnnotationGeneratedGlideModules();    // 2、如果GlideModule为空或者可配置manifest里面的标志为true，则获取manifest里面    // 配置的GlideModule模块（manifestModules）。    List&lt;com.bumptech.glide.module.GlideModule&gt;     manifestModules = Collections.emptyList();    if (annotationGeneratedModule == null ||     annotationGeneratedModule.isManifestParsingEnabled(    )) {      manifestModules = new   ManifestParser(applicationContext).parse();    }    ...    RequestManagerRetriever.RequestManagerFactory     factory =        annotationGeneratedModule != null            ? annotationGeneratedModule.getRequestManag    erFactory() : null;    builder.setRequestManagerFactory(factory);    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {      module.applyOptions(applicationContext, builder);    }    if (annotationGeneratedModule != null) {      annotationGeneratedModule.applyOptions(applicatio  nContext, builder);    }    // 3、初始化各种配置信息    Glide glide = builder.build(applicationContext);    // 4、把manifestModules以及annotationGeneratedModule里面的配置信息放到builder    // 里面（applyOptions）替换glide默认组件（registerComponents）    for (com.bumptech.glide.module.GlideModule module :     manifestModules) {      module.registerComponents(applicationContext,   glide, glide.registry);    }    if (annotationGeneratedModule != null) {      annotationGeneratedModule.registerComponents(appl  icationContext, glide, glide.registry);    }    applicationContext.registerComponentCallbacks(glide    );    Glide.glide = glide;}</code></pre><h4 id="3、GlideBuilder-build"><a href="#3、GlideBuilder-build" class="headerlink" title="3、GlideBuilder#build"></a>3、GlideBuilder#build</h4><pre><code>@NonNull  Glide build(@NonNull Context context) {    // 创建请求图片线程池sourceExecutor    if (sourceExecutor == null) {      sourceExecutor =   GlideExecutor.newSourceExecutor();    }    // 创建硬盘缓存线程池diskCacheExecutor    if (diskCacheExecutor == null) {      diskCacheExecutor =   GlideExecutor.newDiskCacheExecutor();    }    // 创建动画线程池animationExecutor    if (animationExecutor == null) {      animationExecutor =   GlideExecutor.newAnimationExecutor();    }    if (memorySizeCalculator == null) {      memorySizeCalculator = new   MemorySizeCalculator.Builder(context).build();    }    if (connectivityMonitorFactory == null) {      connectivityMonitorFactory = new   DefaultConnectivityMonitorFactory();    }    if (bitmapPool == null) {      // 依据设备的屏幕密度和尺寸设置各种pool的size      int size =   memorySizeCalculator.getBitmapPoolSize();      if (size &gt; 0) {        // 创建图片线程池LruBitmapPool，缓存所有被释放的bitmap        // 缓存策略在API大于19时，为SizeConfigStrategy，小于为AttributeStrategy。        // 其中SizeConfigStrategy是以bitmap的size和config为key，value为bitmap的HashMap        bitmapPool = new LruBitmapPool(size);      } else {        bitmapPool = new BitmapPoolAdapter();      }    }    // 创建对象数组缓存池LruArrayPool，默认4M    if (arrayPool == null) {      arrayPool = new   LruArrayPool(memorySizeCalculator.getArrayPoolSiz  eInBytes());    }    // 创建LruResourceCache，内存缓存    if (memoryCache == null) {      memoryCache = new   LruResourceCache(memorySizeCalculator.getMemoryCa  cheSize());    }    if (diskCacheFactory == null) {      diskCacheFactory = new   InternalCacheDiskCacheFactory(context);    }    // 创建任务和资源管理引擎（线程池，内存缓存和硬盘缓存对象）    if (engine == null) {      engine =          new Engine(              memoryCache,              diskCacheFactory,              diskCacheExecutor,              sourceExecutor,              GlideExecutor.newUnlimitedSourceExecutor(  ),              GlideExecutor.newAnimationExecutor(),              isActiveResourceRetentionAllowed);    }    RequestManagerRetriever requestManagerRetriever =    new RequestManagerRetriever(requestManagerFactory);    return new Glide(        context,        engine,        memoryCache,        bitmapPool,        arrayPool,        requestManagerRetriever,        connectivityMonitorFactory,        logLevel,        defaultRequestOptions.lock(),        defaultTransitionOptions);}</code></pre><h4 id="4、Glide-Glide构造方法"><a href="#4、Glide-Glide构造方法" class="headerlink" title="4、Glide#Glide构造方法"></a>4、Glide#Glide构造方法</h4><pre><code>Glide(...) {    ...    // 注册管理任务执行对象的类(Registry)    // Registry是一个工厂，而其中所有注册的对象都是一个工厂员工，当任务分发时，    // 根据当前任务的性质，分发给相应员工进行处理    registry = new Registry();    ...    // 这里大概有60余次的append或register员工组件（解析器、编解码器、工厂类、转码类等等组件）    registry    .append(ByteBuffer.class, new ByteBufferEncoder())    .append(InputStream.class, new StreamEncoder(arrayPool))    // 根据给定子类产出对应类型的target（BitmapImageViewTarget / DrawableImageViewTarget)    ImageViewTargetFactory imageViewTargetFactory = new ImageViewTargetFactory();    glideContext =        new GlideContext(            context,            arrayPool,            registry,            imageViewTargetFactory,            defaultRequestOptions,            defaultTransitionOptions,            engine,            logLevel);}</code></pre><h4 id="5、RequestManagerRetriever-get"><a href="#5、RequestManagerRetriever-get" class="headerlink" title="5、RequestManagerRetriever#get"></a>5、RequestManagerRetriever#get</h4><pre><code>@NonNullpublic RequestManager get(@NonNull Context context) {  if (context == null) {    throw new IllegalArgumentException(&quot;You cannot start a load on a null Context&quot;);  } else if (Util.isOnMainThread() &amp;&amp; !(context instanceof Application)) {    // 如果当前线程是主线程且context不是Application走相应的get重载方法    if (context instanceof FragmentActivity) {      return get((FragmentActivity) context);    } else if (context instanceof Activity) {      return get((Activity) context);    } else if (context instanceof ContextWrapper) {      return get(((ContextWrapper) context).getBaseContext());    }  }  // 否则直接将请求与ApplicationLifecycle关联  return getApplicationManager(context);}</code></pre><p>这里总结一下，对于当前传入的context是application或当前线程是子线程时，请求的生命周期和ApplicationLifecycle关联，否则，context是FragmentActivity或Fragment时，在当前组件添加一个SupportFragment（SupportRequestManagerFragment），context是Activity时，在当前组件添加一个Fragment(RequestManagerFragment)。</p><h5 id="6、GlideApp-with小结"><a href="#6、GlideApp-with小结" class="headerlink" title="6、GlideApp#with小结"></a>6、GlideApp#with小结</h5><h5 id="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"><a href="#1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，" class="headerlink" title="1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，"></a>1、初始化各式各样的配置信息（包括缓存，请求线程池，大小，图片格式等等）以及glide对象，</h5><h5 id="2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。"><a href="#2、将glide请求和applicat-SupportFragment-Fragment的生命周期绑定在一块。" class="headerlink" title="2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。"></a>2、将glide请求和applicat/SupportFragment/Fragment的生命周期绑定在一块。</h5><h5 id="这里我们再回顾一下with方法的执行流程。"><a href="#这里我们再回顾一下with方法的执行流程。" class="headerlink" title="这里我们再回顾一下with方法的执行流程。"></a>这里我们再回顾一下with方法的执行流程。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_with%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p><h3 id="三、load-url-源码详解"><a href="#三、load-url-源码详解" class="headerlink" title="三、load(url)源码详解"></a>三、load(url)源码详解</h3><h4 id="1、GlideRequest-RequestManager-load"><a href="#1、GlideRequest-RequestManager-load" class="headerlink" title="1、GlideRequest(RequestManager)#load"></a>1、GlideRequest(RequestManager)#load</h4><pre><code>return (GlideRequest&lt;Drawable&gt;) super.load(string);return asDrawable().load(string);// 1、asDrawable部分return (GlideRequest&lt;Drawable&gt;) super.asDrawable();return as(Drawable.class);// 最终返回了一个GlideRequest（RequestManager的子类）return new GlideRequest&lt;&gt;(glide, this, resourceClass, context);// 2、load部分return (GlideRequest&lt;TranscodeType&gt;) super.load(string);return loadGeneric(string);@NonNullprivate RequestBuilder&lt;TranscodeType&gt; loadGeneric(@Nullable Object model) {    // model则为设置的url    this.model = model;    // 记录url已设置    isModelSet = true;    return this;}</code></pre><p>可以看到，load这部分的源码很简单，就是给GlideRequest（RequestManager）设置了要请求的mode（url），并记录了url已设置的状态。</p><h5 id="这里，我们再看看load方法的执行流程。"><a href="#这里，我们再看看load方法的执行流程。" class="headerlink" title="这里，我们再看看load方法的执行流程。"></a>这里，我们再看看load方法的执行流程。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide_load%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p><h3 id="四、into-iv-源码详解"><a href="#四、into-iv-源码详解" class="headerlink" title="四、into(iv)源码详解"></a>四、into(iv)源码详解</h3><p>前方预警，真正复杂的地方开始了。</p><h4 id="1、RequestBuilder-into"><a href="#1、RequestBuilder-into" class="headerlink" title="1、RequestBuilder.into"></a>1、RequestBuilder.into</h4><pre><code> @NonNullpublic ViewTarget&lt;ImageView, TranscodeType&gt;   into(@NonNull ImageView view) {  Util.assertMainThread();  Preconditions.checkNotNull(view);  RequestOptions requestOptions =     this.requestOptions;  if (!requestOptions.isTransformationSet()      &amp;&amp; requestOptions.isTransformationAllowed()      &amp;&amp; view.getScaleType() != null) {    // Clone in this method so that if we use this   RequestBuilder to load into a View and then    // into a different target, we don&apos;t retain the   transformation applied based on the previous    // View&apos;s scale type.    switch (view.getScaleType()) {      // 这个RequestOptions里保存了要设置的scaleType，Glide自身封装了CenterCrop、CenterInside、      // FitCenter、CenterInside四种规格。      case CENTER_CROP:        requestOptions =   requestOptions.clone().optionalCenterCrop();        break;      case CENTER_INSIDE:        requestOptions =   requestOptions.clone().optionalCenterInside()  ;        break;      case FIT_CENTER:      case FIT_START:      case FIT_END:        requestOptions =   requestOptions.clone().optionalFitCenter();        break;      case FIT_XY:        requestOptions =   requestOptions.clone().optionalCenterInside()  ;        break;      case CENTER:      case MATRIX:      default:        // Do nothing.    }  }  // 注意，这个transcodeClass是指的drawable或bitmap  return into(      glideContext.buildImageViewTarget(view,     transcodeClass),      /*targetListener=*/ null,      requestOptions);}</code></pre><h4 id="2、GlideContext-buildImageViewTarget"><a href="#2、GlideContext-buildImageViewTarget" class="headerlink" title="2、GlideContext#buildImageViewTarget"></a>2、GlideContext#buildImageViewTarget</h4><pre><code>return imageViewTargetFactory.buildTarget(imageView, transcodeClass);</code></pre><h4 id="3、ImageViewTargetFactory-buildTarget"><a href="#3、ImageViewTargetFactory-buildTarget" class="headerlink" title="3、ImageViewTargetFactory#buildTarget"></a>3、ImageViewTargetFactory#buildTarget</h4><pre><code>@NonNull@SuppressWarnings(&quot;unchecked&quot;)public &lt;Z&gt; ViewTarget&lt;ImageView, Z&gt;   buildTarget(@NonNull ImageView view,    @NonNull Class&lt;Z&gt; clazz) {  // 返回展示Bimtap/Drawable资源的目标对象  if (Bitmap.class.equals(clazz)) {    return (ViewTarget&lt;ImageView, Z&gt;) new   BitmapImageViewTarget(view);  } else if (Drawable.class.isAssignableFrom(clazz))     {    return (ViewTarget&lt;ImageView, Z&gt;) new   DrawableImageViewTarget(view);  } else {    throw new IllegalArgumentException(        &quot;Unhandled class: &quot; + clazz + &quot;, try   .as*(Class).transcode(ResourceTranscoder)&quot;);  }}</code></pre><p>可以看到，Glide内部只维护了两种target，一种是BitmapImageViewTarget，另一种则是DrawableImageViewTarget，接下来继续深入。</p><h4 id="4、RequestBuilder-into"><a href="#4、RequestBuilder-into" class="headerlink" title="4、RequestBuilder#into"></a>4、RequestBuilder#into</h4><pre><code>private &lt;Y extends Target&lt;TranscodeType&gt;&gt; Y into(      @NonNull Y target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      @NonNull RequestOptions options) {    Util.assertMainThread();    Preconditions.checkNotNull(target);    if (!isModelSet) {      throw new IllegalArgumentException(&quot;You must call   #load() before calling #into()&quot;);    }    options = options.autoClone();    // 分析1.建立请求    Request request = buildRequest(target,     targetListener, options);    Request previous = target.getRequest();    if (request.isEquivalentTo(previous)        &amp;&amp; !isSkipMemoryCacheWithCompletePreviousReques    t(options, previous)) {      request.recycle();      // If the request is completed, beginning again   will ensure the result is re-delivered,      // triggering RequestListeners and Targets. If   the request is failed, beginning again will      // restart the request, giving it another chance   to complete. If the request is already      // running, we can let it continue running   without interruption.      if (!Preconditions.checkNotNull(previous).isRunni  ng()) {        // Use the previous request rather than the new     one to allow for optimizations like skipping        // setting placeholders, tracking and     un-tracking Targets, and obtaining View     dimensions        // that are done in the individual Request.        previous.begin();      }      return target;    }    requestManager.clear(target);    target.setRequest(request);    // 分析2.真正追踪请求的地方    requestManager.track(target, request);    return target;}// 分析1private Request buildRequest(      Target&lt;TranscodeType&gt; target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      RequestOptions requestOptions) {    return buildRequestRecursive(        target,        targetListener,        /*parentCoordinator=*/ null,        transitionOptions,        requestOptions.getPriority(),        requestOptions.getOverrideWidth(),        requestOptions.getOverrideHeight(),        requestOptions);}// 分析1private Request buildRequestRecursive(      Target&lt;TranscodeType&gt; target,      @Nullable RequestListener&lt;TranscodeType&gt;   targetListener,      @Nullable RequestCoordinator parentCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight,      RequestOptions requestOptions) {    // Build the ErrorRequestCoordinator first if     necessary so we can update parentCoordinator.    ErrorRequestCoordinator errorRequestCoordinator =     null;    if (errorBuilder != null) {      // 创建errorRequestCoordinator（异常处理对象）      errorRequestCoordinator = new   ErrorRequestCoordinator(parentCoordinator);      parentCoordinator = errorRequestCoordinator;    }    // 递归建立缩略图请求    Request mainRequest =        buildThumbnailRequestRecursive(            target,            targetListener,            parentCoordinator,            transitionOptions,            priority,            overrideWidth,            overrideHeight,            requestOptions);    if (errorRequestCoordinator == null) {      return mainRequest;    }    ...    Request errorRequest =     errorBuilder.buildRequestRecursive(        target,        targetListener,        errorRequestCoordinator,        errorBuilder.transitionOptions,        errorBuilder.requestOptions.getPriority(),        errorOverrideWidth,        errorOverrideHeight,        errorBuilder.requestOptions);    errorRequestCoordinator.setRequests(mainRequest,     errorRequest);    return errorRequestCoordinator;}// 分析1private Request buildThumbnailRequestRecursive(      Target&lt;TranscodeType&gt; target,      RequestListener&lt;TranscodeType&gt; targetListener,      @Nullable RequestCoordinator parentCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt; transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight,      RequestOptions requestOptions) {    if (thumbnailBuilder != null) {      // Recursive case: contains a potentially recursive thumbnail request builder.      ...      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);      // 获取一个正常请求对象      Request fullRequest =          obtainRequest(              target,              targetListener,              requestOptions,              coordinator,              transitionOptions,              priority,              overrideWidth,              overrideHeight);      isThumbnailBuilt = true;      // Recursively generate thumbnail requests.      // 使用递归的方式建立一个缩略图请求对象      Request thumbRequest =          thumbnailBuilder.buildRequestRecursive(              target,              targetListener,              coordinator,              thumbTransitionOptions,              thumbPriority,              thumbOverrideWidth,              thumbOverrideHeight,              thumbnailBuilder.requestOptions);      isThumbnailBuilt = false;      // coordinator（ThumbnailRequestCoordinator）是作为两者的协调者，      // 能够同时加载缩略图和正常的图的请求      coordinator.setRequests(fullRequest, thumbRequest);      return coordinator;    } else if (thumbSizeMultiplier != null) {      // Base case: thumbnail multiplier generates a thumbnail request, but cannot recurse.      // 当设置了缩略的比例thumbSizeMultiplier(0 ~  1)时，      // 不需要递归建立缩略图请求      ThumbnailRequestCoordinator coordinator = new ThumbnailRequestCoordinator(parentCoordinator);      Request fullRequest =          obtainRequest(              target,              targetListener,              requestOptions,              coordinator,              transitionOptions,              priority,              overrideWidth,              overrideHeight);      RequestOptions thumbnailOptions = requestOptions.clone()          .sizeMultiplier(thumbSizeMultiplier);      Request thumbnailRequest =          obtainRequest(              target,              targetListener,              thumbnailOptions,              coordinator,              transitionOptions,              getThumbnailPriority(priority),              overrideWidth,              overrideHeight);      coordinator.setRequests(fullRequest, thumbnailRequest);      return coordinator;    } else {      // Base case: no thumbnail.      // 没有缩略图请求时，直接获取一个正常图请求      return obtainRequest(          target,          targetListener,          requestOptions,          parentCoordinator,          transitionOptions,          priority,          overrideWidth,          overrideHeight);    }}private Request obtainRequest(      Target&lt;TranscodeType&gt; target,      RequestListener&lt;TranscodeType&gt; targetListener,      RequestOptions requestOptions,      RequestCoordinator requestCoordinator,      TransitionOptions&lt;?, ? super TranscodeType&gt;   transitionOptions,      Priority priority,      int overrideWidth,      int overrideHeight) {    // 最终实际返回的是一个SingleRequest对象（将制定的资源加载进对应的Target    return SingleRequest.obtain(        context,        glideContext,        model,        transcodeClass,        requestOptions,        overrideWidth,        overrideHeight,        priority,        target,        targetListener,        requestListeners,        requestCoordinator,        glideContext.getEngine(),        transitionOptions.getTransitionFactory());}</code></pre><p>从上源码分析可知，我们在分析1处的buildRequest()方法里建立了请求，且最多可同时进行缩略图和正常图的请求，最后，调用了requestManager.track(target, request)方法，接着看看track里面做了什么。</p><h4 id="5、RequestManager-track"><a href="#5、RequestManager-track" class="headerlink" title="5、RequestManager#track"></a>5、RequestManager#track</h4><pre><code>// 分析2void track(@NonNull Target&lt;?&gt; target, @NonNull Request request) {    // 加入一个target目标集合(Set)    targetTracker.track(target);    requestTracker.runRequest(request);}</code></pre><h4 id="6、RequestTracker-runRequest"><a href="#6、RequestTracker-runRequest" class="headerlink" title="6、RequestTracker#runRequest"></a>6、RequestTracker#runRequest</h4><pre><code>/*** Starts tracking the given request.*/// 分析2public void runRequest(@NonNull Request request) {    requests.add(request);    if (!isPaused) {      // 如果不是暂停状态则开始请求      request.begin();    } else {      request.clear();      if (Log.isLoggable(TAG, Log.VERBOSE)) {        Log.v(TAG, &quot;Paused, delaying request&quot;);      }      // 否则清空请求，加入延迟请求队列（为了对这些请求维持一个强引用，使用了ArrayList实现）      pendingRequests.add(request);    }}</code></pre><h4 id="7、SingleRequest-begin"><a href="#7、SingleRequest-begin" class="headerlink" title="7、SingleRequest#begin"></a>7、SingleRequest#begin</h4><pre><code>// 分析2@Overridepublic void begin() {  ...  if (model == null) {    ...    // model（url）为空，回调加载失败    onLoadFailed(new GlideException(&quot;Received null   model&quot;), logLevel);    return;  }  if (status == Status.RUNNING) {    throw new IllegalArgumentException(&quot;Cannot   restart a running request&quot;);  }  if (status == Status.COMPLETE) {    onResourceReady(resource,   DataSource.MEMORY_CACHE);    return;  }  status = Status.WAITING_FOR_SIZE;  if (Util.isValidDimensions(overrideWidth, overrideHeight)) {    // 当使用override() API为图片指定了一个固定的宽高时直接执行onSizeReady，    // 最终的核心处理位于onSizeReady    onSizeReady(overrideWidth, overrideHeight);  } else {    // 根据imageView的宽高算出图片的宽高，最终也会走到onSizeReady    target.getSize(this);  }  if ((status == Status.RUNNING || status ==     Status.WAITING_FOR_SIZE)      &amp;&amp; canNotifyStatusChanged()) {    // 预先加载设置的缩略图    target.onLoadStarted(getPlaceholderDrawable());  }  if (IS_VERBOSE_LOGGABLE) {    logV(&quot;finished run method in &quot; +   LogTime.getElapsedMillis(startTime));  }}</code></pre><p>从requestManager.track(target, request)开始，最终会执行到SingleRequest#begin()方法的onSizeReady，可以猜到（因为后面只做了预加载缩略图的处理），真正的请求就是从这里开始的，咱们进去一探究竟~</p><h4 id="8、SingleRequest-onSizeReady"><a href="#8、SingleRequest-onSizeReady" class="headerlink" title="8、SingleRequest#onSizeReady"></a>8、SingleRequest#onSizeReady</h4><pre><code>// 分析2@Overridepublic void onSizeReady(int width, int height) {  stateVerifier.throwIfRecycled();  ...  status = Status.RUNNING;  float sizeMultiplier =     requestOptions.getSizeMultiplier();  this.width = maybeApplySizeMultiplier(width,     sizeMultiplier);  this.height = maybeApplySizeMultiplier(height,     sizeMultiplier);  ...  // 根据给定的配置进行加载，engine是一个负责加载、管理活跃和缓存资源的引擎类  loadStatus = engine.load(      glideContext,      model,      requestOptions.getSignature(),      this.width,      this.height,      requestOptions.getResourceClass(),      transcodeClass,      priority,      requestOptions.getDiskCacheStrategy(),      requestOptions.getTransformations(),      requestOptions.isTransformationRequired(),      requestOptions.isScaleOnlyOrNoTransform(),      requestOptions.getOptions(),      requestOptions.isMemoryCacheable(),      requestOptions.getUseUnlimitedSourceGeneratorsP    ool(),      requestOptions.getUseAnimationPool(),      requestOptions.getOnlyRetrieveFromCache(),      this);  ...}</code></pre><p>终于看到Engine类了，感觉距离成功不远了，继续~</p><h4 id="9、Engine-load"><a href="#9、Engine-load" class="headerlink" title="9、Engine#load"></a>9、Engine#load</h4><pre><code>public &lt;R&gt; LoadStatus load(    GlideContext glideContext,    Object model,    Key signature,    int width,    int height,    Class&lt;?&gt; resourceClass,    Class&lt;R&gt; transcodeClass,    Priority priority,    DiskCacheStrategy diskCacheStrategy,    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,    boolean isTransformationRequired,    boolean isScaleOnlyOrNoTransform,    Options options,    boolean isMemoryCacheable,    boolean useUnlimitedSourceExecutorPool,    boolean useAnimationPool,    boolean onlyRetrieveFromCache,    ResourceCallback cb) {  ...  // 先从弱引用中查找，如果有的话回调onResourceReady并直接返回  EngineResource&lt;?&gt; active = loadFromActiveResources(key, isMemoryCacheable);  if (active != null) {    cb.onResourceReady(active,   DataSource.MEMORY_CACHE);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Loaded resource from active     resources&quot;, startTime, key);    }    return null;  }  // 没有再从内存中查找,有的话会取出并放到ActiveResources（内部维护的弱引用缓存map）里面  EngineResource&lt;?&gt; cached = loadFromCache(key,     isMemoryCacheable);  if (cached != null) {    cb.onResourceReady(cached,   DataSource.MEMORY_CACHE);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Loaded resource from cache&quot;,     startTime, key);    }    return null;  }  EngineJob&lt;?&gt; current = jobs.get(key,     onlyRetrieveFromCache);  if (current != null) {    current.addCallback(cb);    if (VERBOSE_IS_LOGGABLE) {      logWithTimeAndKey(&quot;Added to existing load&quot;,     startTime, key);    }    return new LoadStatus(cb, current);  }  // 如果内存中没有，则创建engineJob（decodejob的回调类，管理下载过程以及状态）  EngineJob&lt;R&gt; engineJob =      engineJobFactory.build(          key,          isMemoryCacheable,          useUnlimitedSourceExecutorPool,          useAnimationPool,          onlyRetrieveFromCache);  // 创建解析工作对象  DecodeJob&lt;R&gt; decodeJob =      decodeJobFactory.build(          glideContext,          model,          key,          signature,          width,          height,          resourceClass,          transcodeClass,          priority,          diskCacheStrategy,          transformations,          isTransformationRequired,          isScaleOnlyOrNoTransform,          onlyRetrieveFromCache,          options,          engineJob);  // 放在Jobs内部维护的HashMap中  jobs.put(key, engineJob);  // 关注点8 后面分析会用到  // 注册ResourceCallback接口  engineJob.addCallback(cb);  // 内部开启线程去请求  engineJob.start(decodeJob);  if (VERBOSE_IS_LOGGABLE) {    logWithTimeAndKey(&quot;Started new load&quot;, startTime,   key);  }  return new LoadStatus(cb, engineJob);}public void start(DecodeJob&lt;R&gt; decodeJob) {    this.decodeJob = decodeJob;    // willDecodeFromCache方法内部根据不同的阶段stage，如果是RESOURCE_CACHE/DATA_CACHE则返回true，使用diskCacheExecutor，否则调用getActiveSourceExecutor，内部会根据相应的条件返回sourceUnlimitedExecutor/animationExecutor/sourceExecutor    GlideExecutor executor =       decodeJob.willDecodeFromCache()        ? diskCacheExecutor        : getActiveSourceExecutor();    executor.execute(decodeJob);}</code></pre><p>可以看到，最终Engine(引擎)类内部会执行到自身的start方法，它会根据不同的配置采用不同的线程池使用diskCacheExecutor/sourceUnlimitedExecutor/animationExecutor/sourceExecutor来执行最终的解码任务decodeJob。</p><h4 id="10、DecodeJob-run"><a href="#10、DecodeJob-run" class="headerlink" title="10、DecodeJob#run"></a>10、DecodeJob#run</h4><pre><code>runWrapped();private void runWrapped() {    switch (runReason) {      case INITIALIZE:        stage = getNextStage(Stage.INITIALIZE);        // 关注点1        currentGenerator = getNextGenerator();        // 关注点2 内部会调用相应Generator的startNext()        runGenerators();        break;      case SWITCH_TO_SOURCE_SERVICE:        runGenerators();        break;      case DECODE_DATA:        // 关注点3 将获取的数据解码成对应的资源        decodeFromRetrievedData();        break;      default:        throw new IllegalStateException(&quot;Unrecognized     run reason: &quot; + runReason);    }}// 关注点1，完整情况下，会异步依次生成这里的ResourceCacheGenerator、DataCacheGenerator和SourceGenerator对象，并在之后执行其中的startNext()private DataFetcherGenerator getNextGenerator() {    switch (stage) {      case RESOURCE_CACHE:        return new ResourceCacheGenerator(decodeHelper, this);      case DATA_CACHE:        return new DataCacheGenerator(decodeHelper, this);      case SOURCE:        return new SourceGenerator(decodeHelper, this);      case FINISHED:        return null;      default:        throw new IllegalStateException(&quot;Unrecognized     stage: &quot; + stage);    }}</code></pre><h4 id="11、SourceGenerator-startNext"><a href="#11、SourceGenerator-startNext" class="headerlink" title="11、SourceGenerator#startNext"></a>11、SourceGenerator#startNext</h4><pre><code>// 关注点2@Overridepublic boolean startNext() {  // dataToCache数据不为空的话缓存到硬盘（第一执行该方法是不会调用的）  if (dataToCache != null) {    Object data = dataToCache;    dataToCache = null;    cacheData(data);  }  if (sourceCacheGenerator != null &amp;&amp;     sourceCacheGenerator.startNext()) {    return true;  }  sourceCacheGenerator = null;  loadData = null;  boolean started = false;  while (!started &amp;&amp; hasNextModelLoader()) {    // 关注点4 getLoadData()方法内部会在modelLoaders里面找到ModelLoder对象    // （每个Generator对应一个ModelLoader），    // 并使用modelLoader.buildLoadData方法返回一个loadData列表    loadData =   helper.getLoadData().get(loadDataListIndex++);    if (loadData != null        &amp;&amp; (helper.getDiskCacheStrategy().isDataCache  able(loadData.fetcher.getDataSource())        || helper.hasLoadPath(loadData.fetcher.getDat  aClass()))) {      started = true;      // 关注点6 通过loadData对象的fetcher对象（有关注点3的分析可知其实现类为HttpUrlFetcher）的      // loadData方法来获取图片数据      loadData.fetcher.loadData(helper.getPriority(),     this);    }  }  return started;}</code></pre><h4 id="12、DecodeHelper-getLoadData"><a href="#12、DecodeHelper-getLoadData" class="headerlink" title="12、DecodeHelper#getLoadData"></a>12、DecodeHelper#getLoadData</h4><pre><code>List&lt;LoadData&lt;?&gt;&gt; getLoadData() {    if (!isLoadDataSet) {      isLoadDataSet = true;      loadData.clear();      List&lt;ModelLoader&lt;Object, ?&gt;&gt; modelLoaders =   glideContext.getRegistry().getModelLoaders(model)  ;      //noinspection ForLoopReplaceableByForEach to   improve perf      for (int i = 0, size = modelLoaders.size(); i &lt;   size; i++) {        ModelLoader&lt;Object, ?&gt; modelLoader =     modelLoaders.get(i);        // 注意：这里最终是通过HttpGlideUrlLoader的buildLoadData获取到实际的loadData对象        LoadData&lt;?&gt; current =            modelLoader.buildLoadData(model, width,     height, options);        if (current != null) {          loadData.add(current);        }      }    }    return loadData;}</code></pre><h4 id="13、HttpGlideUrlLoader-buildLoadData"><a href="#13、HttpGlideUrlLoader-buildLoadData" class="headerlink" title="13、HttpGlideUrlLoader#buildLoadData"></a>13、HttpGlideUrlLoader#buildLoadData</h4><pre><code>@Overridepublic LoadData&lt;InputStream&gt; buildLoadData(@NonNull   GlideUrl model, int width, int height,    @NonNull Options options) {  // GlideUrls memoize parsed URLs so caching them     saves a few object instantiations and time  // spent parsing urls.  GlideUrl url = model;  if (modelCache != null) {    url = modelCache.get(model, 0, 0);    if (url == null) {      // 关注点5      modelCache.put(model, 0, 0, model);      url = model;    }  }  int timeout = options.get(TIMEOUT);  // 注意，这里创建了一个DataFetcher的实现类HttpUrlFetcher  return new LoadData&lt;&gt;(url, new HttpUrlFetcher(url,     timeout));}// 关注点5public void put(A model, int width, int height, B value) {    ModelKey&lt;A&gt; key = ModelKey.get(model, width,     height);    // 最终是通过LruCache来缓存对应的值，key是一个ModelKey对象（由model、width、height三个属性组成）    cache.put(key, value);}</code></pre><p>从这里的分析，我们明白了HttpUrlFetcher实际上就是最终的请求执行者，而且，我们知道了Glide会使用LruCache来对解析后的url来进行缓存，以便后续可以省去解析url的时间。</p><h4 id="14、HttpUrlFetcher-loadData"><a href="#14、HttpUrlFetcher-loadData" class="headerlink" title="14、HttpUrlFetcher#loadData"></a>14、HttpUrlFetcher#loadData</h4><pre><code>@Overridepublic void loadData(@NonNull Priority priority,    @NonNull DataCallback&lt;? super InputStream&gt;   callback) {  long startTime = LogTime.getLogTime();  try {    // 关注点6    // loadDataWithRedirects内部是通过HttpURLConnection网络请求数据    InputStream result =   loadDataWithRedirects(glideUrl.toURL(), 0, null,   glideUrl.getHeaders());    // 请求成功回调onDataReady()    callback.onDataReady(result);  } catch (IOException e) {    if (Log.isLoggable(TAG, Log.DEBUG)) {      Log.d(TAG, &quot;Failed to load data for url&quot;, e);    }    callback.onLoadFailed(e);  } finally {    if (Log.isLoggable(TAG, Log.VERBOSE)) {      Log.v(TAG, &quot;Finished http url fetcher fetch in     &quot; + LogTime.getElapsedMillis(startTime));    }  }}private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,  Map&lt;String, String&gt; headers) throws IOException {    ...    urlConnection.connect();    // Set the stream so that it&apos;s closed in cleanup to avoid resource leaks. See #2352.    stream = urlConnection.getInputStream();    if (isCancelled) {      return null;    }    final int statusCode = urlConnection.getResponseCode();    // 只要是2xx形式的状态码则判断为成功    if (isHttpOk(statusCode)) {      // 从urlConnection中获取资源流      return getStreamForSuccessfulRequest(urlConnection);    } else if (isHttpRedirect(statusCode)) {      ...      // 重定向请求      return loadDataWithRedirects(redirectUrl, redirects + 1, url,   headers);    } else if (statusCode == INVALID_STATUS_CODE) {      throw new HttpException(statusCode);    } else {      throw new HttpException(urlConnection.getResponseMessage(),   statusCode);    }}private InputStream getStreamForSuccessfulRequest(HttpURLConnection urlConnection)  throws IOException {    if (TextUtils.isEmpty(urlConnection.getContentEncoding())) {      int contentLength = urlConnection.getContentLength();      stream = ContentLengthInputStream.obtain(urlConnection.getInputStr  eam(), contentLength);    } else {      if (Log.isLoggable(TAG, Log.DEBUG)) {        Log.d(TAG, &quot;Got non empty content encoding: &quot; +     urlConnection.getContentEncoding());      }      stream = urlConnection.getInputStream();    }    return stream;}</code></pre><p>在HttpUrlFetcher#loadData方法的loadDataWithRedirects里面，Glide通过原生的HttpURLConnection进行请求后，并调用getStreamForSuccessfulRequest()方法获取到了最终的图片流。</p><h4 id="15、DecodeJob-run"><a href="#15、DecodeJob-run" class="headerlink" title="15、DecodeJob#run"></a>15、DecodeJob#run</h4><p>在我们通过HtttpUrlFetcher的loadData()方法请求得到对应的流之后，我们还必须对流进行处理得到最终我们想要的资源。这里我们回到第10步DecodeJob#run方法的关注点3处，这行代码将会对流进行解码。</p><pre><code>decodeFromRetrievedData();</code></pre><p>接下来，继续看看他内部的处理。</p><pre><code>private void decodeFromRetrievedData() {    if (Log.isLoggable(TAG, Log.VERBOSE)) {      logWithTimeAndKey(&quot;Retrieved data&quot;, startFetchTime,          &quot;data: &quot; + currentData              + &quot;, cache key: &quot; + currentSourceKey              + &quot;, fetcher: &quot; + currentFetcher);    }    Resource&lt;R&gt; resource = null;    try {      //  核心代码       // 从数据中解码得到资源      resource = decodeFromData(currentFetcher, currentData,   currentDataSource);    } catch (GlideException e) {      e.setLoggingDetails(currentAttemptingKey, currentDataSource);      throwables.add(e);    }    if (resource != null) {      // 关注点8       // 编码和发布最终得到的Resource&lt;Bitmap&gt;对象      notifyEncodeAndRelease(resource, currentDataSource);    } else {      runGenerators();    }} private &lt;Data&gt; Resource&lt;R&gt; decodeFromData(DataFetcher&lt;?&gt; fetcher, Data data,  DataSource dataSource) throws GlideException {    try {      if (data == null) {        return null;      }      long startTime = LogTime.getLogTime();      // 核心代码      // 进一步包装了解码方法      Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);      if (Log.isLoggable(TAG, Log.VERBOSE)) {        logWithTimeAndKey(&quot;Decoded result &quot; + result, startTime);      }      return result;    } finally {      fetcher.cleanup();    }}@SuppressWarnings(&quot;unchecked&quot;)private &lt;Data&gt; Resource&lt;R&gt; decodeFromFetcher(Data data, DataSource dataSource)  throws GlideException {    LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());    // 核心代码    // 将解码任务分发给LoadPath    return runLoadPath(data, dataSource, path);}private &lt;Data, ResourceType&gt; Resource&lt;R&gt; runLoadPath(Data data, DataSource dataSource,  LoadPath&lt;Data, ResourceType, R&gt; path) throws GlideException {    Options options = getOptionsWithHardwareConfig(dataSource);    // 将数据进一步包装    DataRewinder&lt;Data&gt; rewinder =     glideContext.getRegistry().getRewinder(data);    try {      // ResourceType in DecodeCallback below is required for   compilation to work with gradle.      // 核心代码      // 将解码任务分发给LoadPath      return path.load(          rewinder, options, width, height, new   DecodeCallback&lt;ResourceType&gt;(dataSource));    } finally {      rewinder.cleanup();    }}</code></pre><h4 id="16、LoadPath-load"><a href="#16、LoadPath-load" class="headerlink" title="16、LoadPath#load"></a>16、LoadPath#load</h4><pre><code>public Resource&lt;Transcode&gt; load(DataRewinder&lt;Data&gt; rewinder, @NonNull Options options, int width,  int height, DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback) throws GlideException {List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());try {  // 核心代码  return loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);} finally {  listPool.release(throwables);}</code></pre><p>  }</p><pre><code>private Resource&lt;Transcode&gt; loadWithExceptionList(DataRewinder&lt;Data&gt; rewinder,      @NonNull Options options,      int width, int height, DecodePath.DecodeCallback&lt;ResourceType&gt;   decodeCallback,      List&lt;Throwable&gt; exceptions) throws GlideException {    Resource&lt;Transcode&gt; result = null;    //noinspection ForLoopReplaceableByForEach to improve perf    for (int i = 0, size = decodePaths.size(); i &lt; size; i++) {      DecodePath&lt;Data, ResourceType, Transcode&gt; path =   decodePaths.get(i);      try {        // 核心代码        // 将解码任务又进一步分发给DecodePath的decode方法去解码        result = path.decode(rewinder, width, height, options,     decodeCallback);      } catch (GlideException e) {        exceptions.add(e);      }      if (result != null) {        break;      }    }    if (result == null) {      throw new GlideException(failureMessage, new   ArrayList&lt;&gt;(exceptions));    }    return result;}</code></pre><h4 id="17、DecodePath-decode"><a href="#17、DecodePath-decode" class="headerlink" title="17、DecodePath#decode"></a>17、DecodePath#decode</h4><pre><code>public Resource&lt;Transcode&gt; decode(DataRewinder&lt;DataType&gt; rewinder,     int width, int height,      @NonNull Options options, DecodeCallback&lt;ResourceType&gt; callback)   throws GlideException {    // 核心代码    // 继续调用DecodePath的decodeResource方法去解析出数据    Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width,     height, options);    Resource&lt;ResourceType&gt; transformed =     callback.onResourceDecoded(decoded);    return transcoder.transcode(transformed, options);}@NonNullprivate Resource&lt;ResourceType&gt; decodeResource(DataRewinder&lt;DataType&gt;   rewinder, int width,    int height, @NonNull Options options) throws GlideException {  List&lt;Throwable&gt; exceptions =     Preconditions.checkNotNull(listPool.acquire());  try {    // 核心代码    return decodeResourceWithList(rewinder, width, height, options,   exceptions);  } finally {    listPool.release(exceptions);  }}@NonNullprivate Resource&lt;ResourceType&gt;   decodeResourceWithList(DataRewinder&lt;DataType&gt; rewinder, int width,    int height, @NonNull Options options, List&lt;Throwable&gt; exceptions)   throws GlideException {  Resource&lt;ResourceType&gt; result = null;  //noinspection ForLoopReplaceableByForEach to improve perf  for (int i = 0, size = decoders.size(); i &lt; size; i++) {    ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);    try {      DataType data = rewinder.rewindAndGet();      if (decoder.handles(data, options)) {        // 获取包装的数据        data = rewinder.rewindAndGet();        // 核心代码         // 根据DataType和ResourceType的类型分发给不同的解码器Decoder        result = decoder.decode(data, width, height, options);      }    } catch (IOException | RuntimeException | OutOfMemoryError e) {      if (Log.isLoggable(TAG, Log.VERBOSE)) {        Log.v(TAG, &quot;Failed to decode data for &quot; + decoder, e);      }      exceptions.add(e);    }    if (result != null) {      break;    }  }  if (result == null) {    throw new GlideException(failureMessage, new   ArrayList&lt;&gt;(exceptions));  }  return result;}</code></pre><p>可以看到，经过一连串的嵌套调用，最终执行到了decoder.decode()这行代码，decode是一个ResourceDecoder<datatype, resourcetype="">接口（资源解码器），根据不同的DataType和ResourceType它会有不同的实现类，这里的实现类是ByteBufferBitmapDecoder，接下来让我们来看看这个解码器内部的解码流程。</datatype,></p><h4 id="18、ByteBufferBitmapDecoder-decode"><a href="#18、ByteBufferBitmapDecoder-decode" class="headerlink" title="18、ByteBufferBitmapDecoder#decode"></a>18、ByteBufferBitmapDecoder#decode</h4><pre><code>/** * Decodes {@link android.graphics.Bitmap Bitmaps} from {@link    java.nio.ByteBuffer ByteBuffers}. */public class ByteBufferBitmapDecoder implements     ResourceDecoder&lt;ByteBuffer, Bitmap&gt; {  ...  @Override  public Resource&lt;Bitmap&gt; decode(@NonNull ByteBuffer source, int width,   int height,      @NonNull Options options)      throws IOException {    InputStream is = ByteBufferUtil.toStream(source);    // 核心代码    return downsampler.decode(is, width, height, options);  }}</code></pre><p>可以看到，最终是使用了一个downsampler，它是一个压缩器，主要是对流进行解码，压缩，圆角等处理。</p><h4 id="19、DownSampler-decode"><a href="#19、DownSampler-decode" class="headerlink" title="19、DownSampler#decode"></a>19、DownSampler#decode</h4><pre><code>public Resource&lt;Bitmap&gt; decode(InputStream is, int outWidth, int outHeight,  Options options) throws IOException {    return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);} @SuppressWarnings({&quot;resource&quot;, &quot;deprecation&quot;})public Resource&lt;Bitmap&gt; decode(InputStream is, int requestedWidth, int requestedHeight,      Options options, DecodeCallbacks callbacks) throws IOException {    Preconditions.checkArgument(is.markSupported(), &quot;You must provide an     InputStream that supports&quot;        + &quot; mark()&quot;);    ...    try {      // 核心代码      Bitmap result = decodeFromWrappedStreams(is, bitmapFactoryOptions,          downsampleStrategy, decodeFormat, isHardwareConfigAllowed,   requestedWidth,          requestedHeight, fixBitmapToRequestedDimensions, callbacks);      // 关注点7         // 解码得到Bitmap对象后，包装成BitmapResource对象返回，      // 通过内部的get方法得到Resource&lt;Bitmap&gt;对象      return BitmapResource.obtain(result, bitmapPool);    } finally {      releaseOptions(bitmapFactoryOptions);      byteArrayPool.put(bytesForOptions);    }}private Bitmap decodeFromWrappedStreams(InputStream is,      BitmapFactory.Options options, DownsampleStrategy downsampleStrategy,      DecodeFormat decodeFormat, boolean isHardwareConfigAllowed, int requestedWidth,      int requestedHeight, boolean fixBitmapToRequestedDimensions,      DecodeCallbacks callbacks) throws IOException {    // 省去计算压缩比例等一系列非核心逻辑    ...    // 核心代码    Bitmap downsampled = decodeStream(is, options, callbacks, bitmapPool);    callbacks.onDecodeComplete(bitmapPool, downsampled);    ...    // Bimtap旋转处理    ...    return rotated;}private static Bitmap decodeStream(InputStream is,     BitmapFactory.Options options,      DecodeCallbacks callbacks, BitmapPool bitmapPool) throws   IOException {    ...    TransformationUtils.getBitmapDrawableLock().lock();    try {      // 核心代码      result = BitmapFactory.decodeStream(is, null, options);    } catch (IllegalArgumentException e) {      ...    } finally {      TransformationUtils.getBitmapDrawableLock().unlock();    }    if (options.inJustDecodeBounds) {      is.reset();    }    return result;}</code></pre><p>从以上源码流程我们知道，最后是在DownSampler的decodeStream()方法中使用了BitmapFactory.decodeStream()来得到Bitmap对象。然后，我们来分析下图片时如何显示的，我们回到步骤19的DownSampler#decode方法，看到关注点7，这里是将Bitmap包装成BitmapResource对象返回，通过内部的get方法可以得到Resource<bitmap>对象，再回到步骤15的DecodeJob#run方法，这是使用了notifyEncodeAndRelease()方法对Resource<bitmap>对象进行了发布。</bitmap></bitmap></p><h4 id="20、DecodeJob-notifyEncodeAndRelease"><a href="#20、DecodeJob-notifyEncodeAndRelease" class="headerlink" title="20、DecodeJob#notifyEncodeAndRelease"></a>20、DecodeJob#notifyEncodeAndRelease</h4><pre><code>private void notifyEncodeAndRelease(Resource&lt;R&gt; resource, DataSource     dataSource) {    ...    notifyComplete(result, dataSource);    ...}private void notifyComplete(Resource&lt;R&gt; resource, DataSource     dataSource) {    setNotifiedOrThrow();    callback.onResourceReady(resource, dataSource);}</code></pre><p>从以上EngineJob的源码可知，它实现了DecodeJob.CallBack<r>这个接口。</r></p><pre><code>class EngineJob&lt;R&gt; implements DecodeJob.Callback&lt;R&gt;,    Poolable {    ...}</code></pre><h4 id="21、EngineJob-onResourceReady"><a href="#21、EngineJob-onResourceReady" class="headerlink" title="21、EngineJob#onResourceReady"></a>21、EngineJob#onResourceReady</h4><pre><code>@Overridepublic void onResourceReady(Resource&lt;R&gt; resource, DataSource   dataSource) {  this.resource = resource;  this.dataSource = dataSource;  MAIN_THREAD_HANDLER.obtainMessage(MSG_COMPLETE, this).sendToTarget();}private static class MainThreadCallback implements Handler.Callback{    ...    @Override    public boolean handleMessage(Message message) {      EngineJob&lt;?&gt; job = (EngineJob&lt;?&gt;) message.obj;      switch (message.what) {        case MSG_COMPLETE:          // 核心代码          job.handleResultOnMainThread();          break;        ...      }      return true;    }}</code></pre><p>从以上源码可知，通过主线程Handler对象进行切换线程，然后在主线程调用了handleResultOnMainThread这个方法。</p><pre><code>@Syntheticvoid handleResultOnMainThread() {  ...  //noinspection ForLoopReplaceableByForEach to improve perf  for (int i = 0, size = cbs.size(); i &lt; size; i++) {    ResourceCallback cb = cbs.get(i);    if (!isInIgnoredCallbacks(cb)) {      engineResource.acquire();      cb.onResourceReady(engineResource, dataSource);    }  }  ...}</code></pre><p>这里又通过一个循环调用了所有ResourceCallback的方法，让我们回到步骤9处Engine#load方法的关注点8这行代码，这里对ResourceCallback进行了注册，在步骤8出SingleRequest#onSizeReady方法里的engine.load中，我们看到最后一个参数，传入的是this，可以明白，engineJob.addCallback(cb)这里的cb的实现类就是SingleRequest。接下来，让我们看看SingleRequest的onResourceReady方法。</p><h4 id="22、SingleRequest-onResourceReady"><a href="#22、SingleRequest-onResourceReady" class="headerlink" title="22、SingleRequest#onResourceReady"></a>22、SingleRequest#onResourceReady</h4><pre><code>/** * A callback method that should never be invoked directly. */@SuppressWarnings(&quot;unchecked&quot;)@Overridepublic void onResourceReady(Resource&lt;?&gt; resource, DataSource   dataSource) {  ...  // 从Resource&lt;Bitmap&gt;中得到Bitmap对象  Object received = resource.get();  ...  onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);}private void onResourceReady(Resource&lt;R&gt; resource, R resultDataSource dataSource) {    ...    try {      ...      if (!anyListenerHandledUpdatingTarget) {        Transition&lt;? super R&gt; animation =            animationFactory.build(dataSource, isFirstResource);        // 核心代码        target.onResourceReady(result, animation);      }    } finally {      isCallingCallbacks = false;    }    notifyLoadSuccess();}</code></pre><p>在SingleRequest#onResourceReady方法中又调用了target.onResourceReady(result, animation)方法，这里的target其实就是我们在into方法中建立的那个BitmapImageViewTarget，看到ImageViewTarget类，我们并没有发现onResourceReady方法，但是我们从它的子类ImageViewTarget中发现了onResourceReady方法，从这里我们继续往下看。</p><h4 id="23、ImageViewTarget-onResourceReady"><a href="#23、ImageViewTarget-onResourceReady" class="headerlink" title="23、ImageViewTarget#onResourceReady"></a>23、ImageViewTarget#onResourceReady</h4><pre><code>public abstract class ImageViewTarget&lt;Z&gt; extends ViewTarget&lt;ImageView, Z&gt;implements Transition.ViewAdapter {    ...    @Override    public void onResourceReady(@NonNull Z resource, @Nullable       Transition&lt;? super Z&gt; transition) {      if (transition == null || !transition.transition(resource, this))   {        // 核心代码        setResourceInternal(resource);      } else {        maybeUpdateAnimatable(resource);      }    }    ...    private void setResourceInternal(@Nullable Z resource) {        // Order matters here. Set the resource first to make sure that the         Drawable has a valid and        // non-null Callback before starting it.        // 核心代码        setResource(resource);        maybeUpdateAnimatable(resource);    }    // 核心代码    protected abstract void setResource(@Nullable Z resource);}</code></pre><p>这里我们在回到BitmapImageViewTarget的setResource方法中，我们终于看到Bitmap被设置到了当前的imageView上了。</p><pre><code>public class BitmapImageViewTarget extends ImageViewTarget&lt;Bitmap&gt; {    ...    @Override    protected void setResource(Bitmap resource) {      view.setImageBitmap(resource);    }}</code></pre><p>到这里，我们的分析就结束了，从以上的分析可知，Glide将大部分的逻辑处理都放在了最后一个into方法中，里面经过了20多个分析步骤才将请求图片流、解码出图片，到最终设置到对应的imageView上。</p><h5 id="最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。"><a href="#最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。" class="headerlink" title="最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。"></a>最后，这里给出一份我花费了数个小时绘制的完整Glide加载流程图，非常珍贵，大家可以仔仔细细再把Glide的主体流程在梳理一遍。</h5><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Notebook/master/screenshots/Glide%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B.png" alt="image"></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>到此，Glide整个的加载流程分析就结束了，可以看到，Glide最核心的逻辑都聚集在into()方法中，它里面的设计精巧而复杂，这部分的源码分析非常耗时，但是，如果你真真正正地去一步步去深入其中，你也许在Android进阶之路上将会有顿悟的感觉。目前，Android主流三方库源码分析系列已经对网络库（OkHttp、Retrofit）和图片加载库（Glide）进行了详细的源码分析，接下来，将会对数据库框架GreenDao的核心源码进行深入的分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Glide V4.8.0源码</p><p>2、<a href="https://blog.csdn.net/guolin_blog/article/details/53939176" target="_blank" rel="external">从源码的角度理解Glide的执行流程</a></p><p>3、<a href="https://zhuanlan.zhihu.com/p/37297719" target="_blank" rel="external">glide源码分析</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/16/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Glide%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Android主流三方库源码分析（二、深入理解Retrofit源码）</title>
      <link>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/</guid>
      <pubDate>Sun, 09 Dec 2018 14:19:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>前篇我们详细地分析了OKHttp的核心源码，如果对OKHttp内部机制不了解的可以看看<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>。这篇，将会来深入地分析下目前Android最优秀的网络封装框架Retrofit的源码流程。</p><h3 id="一、基本使用流程"><a href="#一、基本使用流程" class="headerlink" title="一、基本使用流程"></a>一、基本使用流程</h3><h4 id="1、定义HTTP-API，用于描述请求"><a href="#1、定义HTTP-API，用于描述请求" class="headerlink" title="1、定义HTTP API，用于描述请求"></a>1、定义HTTP API，用于描述请求</h4><pre><code>public interface GitHubService {     @GET(&quot;users/{user}/repos&quot;)     Call&lt;List&lt;Repo&gt;&gt; listRepos(@Path(&quot;user&quot;) String user);}</code></pre><h4 id="2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）"><a href="#2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）" class="headerlink" title="2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）"></a>2、创建Retrofit并生成API的实现（注意：方法上面的注解表示请求的接口部分，返回类型是请求的返回值类型，方法的参数即是请求的参数）</h4><pre><code>// 1.Retrofit构建过程Retrofit retrofit = new Retrofit.Builder().baseUrl(&quot;https://api.github.com/&quot;).build();// 2.创建网络请求接口类实例过程GitHubService service = retrofit.create(GitHubService.class);</code></pre><h4 id="3、调用API方法，生成Call，执行请求"><a href="#3、调用API方法，生成Call，执行请求" class="headerlink" title="3、调用API方法，生成Call，执行请求"></a>3、调用API方法，生成Call，执行请求</h4><pre><code>// 3.生成并执行请求过程Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);repos.execute() or repos.enqueue()</code></pre><p>Retrofit的基本使用流程很简洁，但是简洁并不代表简单，Retrofit为了实现这种简洁的使用流程，内部使用了优秀的架构设计和大量的设计模式，在我分析过Retrofit最新版的源码和大量优秀的Retrofit源码分析文章后，我发现，要想真正理解Retrofit内部的核心源码流程和设计思想，首先，需要对这九大设计模式有一定的了解，如下：</p><pre><code>1.Retrofit构建过程 建造者模式、工厂方法模式2.创建网络请求接口实例过程外观模式、代理模式、单例模式、策略模式、装饰模式（建造者模式）3.生成并执行请求过程适配器模式（代理模式、装饰模式）</code></pre><p>其次，需要对OKHttp源码有一定的了解，如果不了解的可以看看这篇<a href="https://jsonchao.github.io/2018/12/01/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3OKHttp%E6%BA%90%E7%A0%81%EF%BC%89/" target="_blank" rel="external">Android主流三方库源码分析（一、深入理解OKHttp源码）</a>。最后，让我们按以上流程去深入Retrofit源码内部，领悟它带给我们的<strong>设计之美</strong>。</p><h3 id="二、Retrofit构建过程"><a href="#二、Retrofit构建过程" class="headerlink" title="二、Retrofit构建过程"></a>二、Retrofit构建过程</h3><h4 id="1、Retrofit核心对象解析"><a href="#1、Retrofit核心对象解析" class="headerlink" title="1、Retrofit核心对象解析"></a>1、Retrofit核心对象解析</h4><p>首先Retrofit中有一个全局变量非常关键，在V2.5之前的版本，使用的是LinkedHashMap()，它是一个网络请求配置对象，是由网络请求接口中方法注解进行解析后得到的。</p><pre><code>public final class Retrofit {    // 网络请求配置对象，存储网络请求相关的配置，如网络请求的方法、数据转换器、网络请求适配器、网络请求工厂、基地址等    private final Map&lt;Method, ServiceMethod&lt;?&gt;&gt; serviceMethodCache = new ConcurrentHashMap&lt;&gt;();</code></pre><p>Retrofit使用了建造者模式通过内部类Builder类建立一个Retrofit实例，如下：</p><pre><code>public static final class Builder {    // 平台类型对象（Platform -&gt; Android)    private final Platform platform;    // 网络请求工厂，默认使用OkHttpCall（工厂方法模式）    private @Nullable okhttp3.Call.Factory callFactory;    // 网络请求的url地址    private @Nullable HttpUrl baseUrl;    // 数据转换器工厂的集合    private final List&lt;Converter.Factory&gt; converterFactories = new     ArrayList&lt;&gt;();    // 网络请求适配器工厂的集合，默认是ExecutorCallAdapterFactory    private final List&lt;CallAdapter.Factory&gt; callAdapterFactories = new     ArrayList&lt;&gt;();    // 回调方法执行器，在 Android 上默认是封装了 handler 的 MainThreadExecutor, 默认作用是：切换线程（子线程 -&gt; 主线程）    private @Nullable Executor callbackExecutor;    // 一个开关，为true则会缓存创建的ServiceMethod    private boolean validateEagerly;</code></pre><h4 id="2、Builder内部构造"><a href="#2、Builder内部构造" class="headerlink" title="2、Builder内部构造"></a>2、Builder内部构造</h4><p>下面看看Builder内部构造做了什么。</p><pre><code>public static final class Builder {    ...    Builder(Platform platform) {        this.platform = platform;    }    public Builder() {        this(Platform.get());    }    ...}class Platform {    private static final Platform PLATFORM = findPlatform();    static Platform get() {      return PLATFORM;    }    private static Platform findPlatform() {      try {        // 使用JVM加载类的方式判断是否是Android平台        Class.forName(&quot;android.os.Build&quot;);        if (Build.VERSION.SDK_INT != 0) {          return new Android();        }      } catch (ClassNotFoundException ignored) {      }      try {        // 同时支持Java平台        Class.forName(&quot;java.util.Optional&quot;);        return new Java8();      } catch (ClassNotFoundException ignored) {      }      return new Platform();    }static class Android extends Platform {    ...    @Override public Executor defaultCallbackExecutor() {        //切换线程（子线程 -&gt; 主线程）        return new MainThreadExecutor();    }    // 创建默认的网络请求适配器工厂，如果是Android7.0或Java8上，则使    // 用了并发包中的CompletableFuture保证了回调的同步    // 在Retrofit中提供了四种CallAdapterFactory(策略模式)：    // ExecutorCallAdapterFactory（默认）、GuavaCallAdapterFactory、    // va8CallAdapterFactory、RxJavaCallAdapterFactory    @Override List&lt;? extends CallAdapter.Factory&gt;     defaultCallAdapterFactories(        @Nullable Executor callbackExecutor) {      if (callbackExecutor == null) throw new AssertionError();      ExecutorCallAdapterFactory executorFactory = new   ExecutorCallAdapterFactory(callbackExecutor);      return Build.VERSION.SDK_INT &gt;= 24        ? asList(CompletableFutureCallAdapterFactory.INSTANCE,     executorFactory)        : singletonList(executorFactory);    }    ...    @Override List&lt;? extends Converter.Factory&gt;     defaultConverterFactories() {      return Build.VERSION.SDK_INT &gt;= 24          ? singletonList(OptionalConverterFactory.INSTANCE)          : Collections.&lt;Converter.Factory&gt;emptyList();    }    ...    static class MainThreadExecutor implements Executor {        // 获取Android 主线程的Handler         private final Handler handler = new   Handler(Looper.getMainLooper());        @Override public void execute(Runnable r) {            // 在UI线程对网络请求返回数据处理            handler.post(r);        }    }}</code></pre><p>可以看到，在Builder内部构造时设置了默认Platform、callAdapterFactories和callbackExecutor。</p><h4 id="3、添加baseUrl"><a href="#3、添加baseUrl" class="headerlink" title="3、添加baseUrl"></a>3、添加baseUrl</h4><p>很简单，就是将String类型的url转换为OkHttp的HttpUrl过程如下：</p><pre><code>/** * Set the API base URL. * * @see #baseUrl(HttpUrl) */public Builder baseUrl(String baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    return baseUrl(HttpUrl.get(baseUrl));}public Builder baseUrl(HttpUrl baseUrl) {    checkNotNull(baseUrl, &quot;baseUrl == null&quot;);    List&lt;String&gt; pathSegments = baseUrl.pathSegments();    if (!&quot;&quot;.equals(pathSegments.get(pathSegments.size() - 1))) {      throw new IllegalArgumentException(&quot;baseUrl must end in /: &quot; +     baseUrl);    }    this.baseUrl = baseUrl;    return this;}</code></pre><h4 id="4、添加GsonConverterFactory"><a href="#4、添加GsonConverterFactory" class="headerlink" title="4、添加GsonConverterFactory"></a>4、添加GsonConverterFactory</h4><p>首先，看到GsonConverterFactory.creat()的源码。</p><pre><code>public final class GsonConverterFactory extends Converter.Factory {    public static GsonConverterFactory create() {        return create(new Gson());    }    public static GsonConverterFactory create(Gson gson) {        if (gson == null) throw new NullPointerException(&quot;gson ==   null&quot;);        return new GsonConverterFactory(gson);    }    private final Gson gson;    // 创建了一个含有Gson对象实例的GsonConverterFactory    private GsonConverterFactory(Gson gson) {        this.gson = gson;    }</code></pre><p>然后，看看addConverterFactory()方法内部。</p><pre><code>public Builder addConverterFactory(Converter.Factory factory) {    converterFactories.add(checkNotNull(factory, &quot;factory null&quot;));    return this;}</code></pre><p>可知，这一步是将一个含有Gson对象实例的GsonConverterFactory放入到了数据转换器工厂converterFactories里。</p><h4 id="5、build过程"><a href="#5、build过程" class="headerlink" title="5、build过程"></a>5、build过程</h4><pre><code>public Retrofit build() {    if (baseUrl == null) {      throw new IllegalStateException(&quot;Base URL required.&quot;);    }    okhttp3.Call.Factory callFactory = this.callFactory;    if (callFactory == null) {        // 默认使用okhttp         callFactory = new OkHttpClient();    }    Executor callbackExecutor = this.callbackExecutor;    if (callbackExecutor == null) {        // Android默认的callbackExecutor        callbackExecutor = platform.defaultCallbackExecutor();    }    // Make a defensive copy of the adapters and add the defaultCall  adapter.    List&lt;CallAdapter.Factory&gt; callAdapterFactories = new ArrayList&lt;&gt;(this.callAdapterFactories);    // 添加默认适配器工厂在集合尾部    callAdapterFactories.addAll(platform.defaultCallAdapterFactorisca  llbackExecutor));    // Make a defensive copy of the converters.    List&lt;Converter.Factory&gt; converterFactories = new ArrayList&lt;&gt;(        1 + this.converterFactories.size() + platform.defaultConverterFactoriesSize());    // Add the built-in converter factory first. This prevents overriding its behavior but also    // ensures correct behavior when using converters thatconsumeall   types.    converterFactories.add(new BuiltInConverters());    converterFactories.addAll(this.converterFactories);    converterFactories.addAll(platform.defaultConverterFactories();    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),        unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);}</code></pre><p>可以看到，最终我们在Builder类中看到的6大核心对象都已经配置到Retrofit对象中了。</p><h3 id="三、创建网络请求接口实例过程"><a href="#三、创建网络请求接口实例过程" class="headerlink" title="三、创建网络请求接口实例过程"></a>三、创建网络请求接口实例过程</h3><p>retrofit.create()使用了外观模式和代理模式创建了网络请求的接口实例，我们分析下create方法。</p><pre><code>public &lt;T&gt; T create(final Class&lt;T&gt; service) {    Utils.validateServiceInterface(service);    if (validateEagerly) {        // 判断是否需要提前缓存ServiceMethod对象        eagerlyValidateMethods(service);    }    // 使用动态代理拿到请求接口所有注解配置后，创建网络请求接口实例    return (T) Proxy.newProxyInstance(service.getClassLoader(), new     Class&lt;?&gt;[] { service },        new InvocationHandler() {          private final Platform platform = Platform.get();          private final Object[] emptyArgs = new Object[0];          @Override public Object invoke(Object proxy, Method method,   @Nullable Object[] args)              throws Throwable {            // If the method is a method from Object then defer to normal     invocation.            if (method.getDeclaringClass() == Object.class) {              return method.invoke(this, args);            }            if (platform.isDefaultMethod(method)) {              return platform.invokeDefaultMethod(method, service, proxy,   args);            }            return loadServiceMethod(method).invoke(args != null ? args : emptyArgs);          }    }); }private void eagerlyValidateMethods(Class&lt;?&gt; service) {  Platform platform = Platform.get();  for (Method method : service.getDeclaredMethods()) {    if (!platform.isDefaultMethod(method)) {      loadServiceMethod(method);    }  }}</code></pre><p>继续看看loadServiceMethod的内部流程</p><pre><code>ServiceMethod&lt;?&gt; loadServiceMethod(Method method) {    ServiceMethod&lt;?&gt; result = serviceMethodCache.get(method);    if (result != null) return result;    synchronized (serviceMethodCache) {      result = serviceMethodCache.get(method);      if (result == null) {            // 解析注解配置得到了ServiceMethod            result = ServiceMethod.parseAnnotations(this, method);            // 可以看到，最终加入到ConcurrentHashMap缓存中            serviceMethodCache.put(method, result);      }    }    return result;}abstract class ServiceMethod&lt;T&gt; {  static &lt;T&gt; ServiceMethod&lt;T&gt; parseAnnotations(Retrofit retrofit, Method   method) {        // 通过RequestFactory解析注解配置（工厂模式、内部使用了建造者模式）        RequestFactory requestFactory =         RequestFactory.parseAnnotations(retrofit, method);        Type returnType = method.getGenericReturnType();        if (Utils.hasUnresolvableType(returnType)) {          throw methodError(method,              &quot;Method return type must not include a type variable or      wildcard: %s&quot;, returnType);        }        if (returnType == void.class) {          throw methodError(method, &quot;Service methods cannot return    void.&quot;);        }        // 最终是通过HttpServiceMethod构建的请求方法        return HttpServiceMethod.parseAnnotations(retrofit, method,         requestFactory);    }    abstract T invoke(Object[] args);}</code></pre><h4 id="以下为请求构造核心流程"><a href="#以下为请求构造核心流程" class="headerlink" title="以下为请求构造核心流程"></a>以下为请求构造核心流程</h4><p>根据RequestFactory#Builder构造方法和parseAnnotations方法的源码，可知的它的作用就是用来解析注解配置的。</p><pre><code>Builder(Retrofit retrofit, Method method) {    this.retrofit = retrofit;    this.method = method;    // 获取网络请求接口方法里的注释    this.methodAnnotations = method.getAnnotations();    // 获取网络请求接口方法里的参数类型           this.parameterTypes = method.getGenericParameterTypes();    // 获取网络请求接口方法里的注解内容        this.parameterAnnotationsArray = method.getParameterAnnotations();}</code></pre><p>接着看HttpServiceMethod.parseAnnotations()的内部流程。</p><pre><code>static &lt;ResponseT, ReturnT&gt; HttpServiceMethod&lt;ResponseT, ReturnT&gt;     parseAnnotations(      Retrofit retrofit, Method method, RequestFactory requestFactory) {        // 1.根据网络请求接口方法的返回值和注解类型，        // 从Retrofit对象中获取对应的网络请求适配器         CallAdapter&lt;ResponseT, ReturnT&gt; callAdapter =         createCallAdapter(retrofit, method);        // 得到响应类型        Type responseType = callAdapter.responseType();        ...        // 2.根据网络请求接口方法的返回值和注解类型，从Retrofit对象中获取对应的数据转换器         Converter&lt;ResponseBody, ResponseT&gt; responseConverter =            createResponseConverter(retrofit, method, responseType);        okhttp3.Call.Factory callFactory = retrofit.callFactory;        return new HttpServiceMethod&lt;&gt;(requestFactory, callFactory,         callAdapter, responseConverter);}</code></pre><h5 id="1-createCallAdapter-retrofit-method"><a href="#1-createCallAdapter-retrofit-method" class="headerlink" title="1.createCallAdapter(retrofit, method)"></a>1.createCallAdapter(retrofit, method)</h5><pre><code>private static &lt;ResponseT, ReturnT&gt; CallAdapter&lt;ResponseT, ReturnT&gt;     createCallAdapter(      Retrofit retrofit, Method method) {    // 获取网络请求接口里方法的返回值类型    Type returnType = method.getGenericReturnType();    // 获取网络请求接口接口里的注解    Annotation[] annotations = method.getAnnotations();    try {      //noinspection unchecked      return (CallAdapter&lt;ResponseT, ReturnT&gt;)  retrofit.callAdapter(returnType, annotations);    } catch (RuntimeException e) { // Wide exception range because         factories are user code.      throw methodError(method, e, &quot;Unable to create call adapter  for     %s&quot;, returnType);    }}public CallAdapter&lt;?, ?&gt; callAdapter(Type returnType, Annotation[] annotations) {    return nextCallAdapter(null, returnType, annotations);}public CallAdapter&lt;?, ?&gt; nextCallAdapter(@Nullable CallAdapter.Factory skipPast, Type returnType,  Annotation[] annotations) {    ...    int start = callAdapterFactories.indexOf(skipPast) + 1;    // 遍历 CallAdapter.Factory 集合寻找合适的工厂    for (int i = start, count = callAdapterFactories.size(); i &lt;count; i++) {        CallAdapter&lt;?, ?&gt; adapter =    callAdapterFactories.get(i).get(returnType, annotations, this);        if (adapter != null) {          return adapter;        }    }}</code></pre><h5 id="2-createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType"><a href="#2-createResponseConverter-Retrofit-retrofit-Method-method-Type-responseType" class="headerlink" title="2.createResponseConverter(Retrofit retrofit, Method method, Type responseType)"></a>2.createResponseConverter(Retrofit retrofit, Method method, Type responseType)</h5><pre><code> private static &lt;ResponseT&gt; Converter&lt;ResponseBody, ResponseT&gt;  createResponseConverter(     Retrofit retrofit, Method method, Type responseType) {   Annotation[] annotations = method.getAnnotations();   try {     return retrofit.responseBodyConverter(responseType,annotations);   } catch (RuntimeException e) { // Wide exception range because    factories are user code.     throw methodError(method, e, &quot;Unable to create converter for%s&quot;,   responseType);   }}public &lt;T&gt; Converter&lt;ResponseBody, T&gt; responseBodyConverter(Type type, Annotation[] annotations) {    return nextResponseBodyConverter(null, type, annotations);}public &lt;T&gt; Converter&lt;ResponseBody, T&gt; nextResponseBodyConverter(  @Nullable Converter.Factory skipPast, Type type, Annotation[] annotations) {...int start = converterFactories.indexOf(skipPast) + 1;// 遍历 Converter.Factory 集合并寻找合适的工厂, 这里是GsonResponseBodyConverterfor (int i = start, count = converterFactories.size(); i &lt; count; i++) {  Converter&lt;ResponseBody, ?&gt; converter =      converterFactories.get(i).responseBodyConverter(type, annotations, this);  if (converter != null) {    //noinspection unchecked    return (Converter&lt;ResponseBody, T&gt;) converter;  }}</code></pre><h4 id="最终，执行HttpServiceMethod的invoke方法"><a href="#最终，执行HttpServiceMethod的invoke方法" class="headerlink" title="最终，执行HttpServiceMethod的invoke方法"></a>最终，执行HttpServiceMethod的invoke方法</h4><pre><code>@Override ReturnT invoke(Object[] args) {    return callAdapter.adapt(        new OkHttpCall&lt;&gt;(requestFactory, args, callFactory,     responseConverter));}</code></pre><p>最终在adapt中创建了一个ExecutorCallbackCall对象，它是一个装饰者，而在它内部真正去执行网络请求的还是OkHttpCall。</p><h3 id="四、创建网络请求接口类实例并执行请求过程"><a href="#四、创建网络请求接口类实例并执行请求过程" class="headerlink" title="四、创建网络请求接口类实例并执行请求过程"></a>四、创建网络请求接口类实例并执行请求过程</h3><h4 id="1、service-listRepos"><a href="#1、service-listRepos" class="headerlink" title="1、service.listRepos()"></a>1、service.listRepos()</h4><pre><code>1、Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(&quot;octocat&quot;);</code></pre><p>service对象是动态代理对象Proxy.newProxyInstance()，当调用getCall()时会被<br>它拦截，然后调用自身的InvocationHandler#invoke()，得到最终的Call对象。</p><h4 id="2、同步执行流程-repos-execute"><a href="#2、同步执行流程-repos-execute" class="headerlink" title="2、同步执行流程 repos.execute()"></a>2、同步执行流程 repos.execute()</h4><pre><code>@Override public Response&lt;T&gt; execute() throws IOException {    okhttp3.Call call;    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already     executed.&quot;);      executed = true;      if (creationFailure != null) {        if (creationFailure instanceof IOException) {          throw (IOException) creationFailure;        } else if (creationFailure instanceof RuntimeException) {          throw (RuntimeException) creationFailure;        } else {          throw (Error) creationFailure;        }      }      call = rawCall;      if (call == null) {        try {          // 创建一个OkHttp的Request对象请求          call = rawCall = createRawCall();        } catch (IOException | RuntimeException | Error e) {          throwIfFatal(e); //  Do not assign a fatal error to     creationFailure.          creationFailure = e;          throw e;        }      }    }    if (canceled) {      call.cancel();    }    // 调用OkHttpCall的execute()发送网络请求（同步），    // 并解析网络请求返回的数据    return parseResponse(call.execute());}private okhttp3.Call createRawCall() throws IOException {    // 创建 一个okhttp3.Request    okhttp3.Call call =    callFactory.newCall(requestFactory.create(args));    if (call == null) {      throw new NullPointerException(&quot;Call.Factory returned null.&quot;);    }    return call;}Response&lt;T&gt; parseResponse(okhttp3.Response rawResponse) throws IOException {    ResponseBody rawBody = rawResponse.body();     // Remove the body&apos;s source (the only stateful object) so we can   pass the response along.    rawResponse = rawResponse.newBuilder()        .body(new NoContentResponseBody(rawBody.contentType(),     rawBody.contentLength()))        .build();        // 根据响应返回的状态码进行处理        int code = rawResponse.code();    if (code &lt; 200 || code &gt;= 300) {      try {        // Buffer the entire body to avoid future I/O.        ResponseBody bufferedBody = Utils.buffer(rawBody);        return Response.error(bufferedBody, rawResponse);      } finally {        rawBody.close();      }    }        if (code == 204 || code == 205) {      rawBody.close();      return Response.success(null, rawResponse);    }        ExceptionCatchingResponseBody catchingBody = new    ExceptionCatchingResponseBody(rawBody);    try {      // 将响应体转为Java对象      T body = responseConverter.convert(catchingBody);      return Response.success(body, rawResponse);    } catch (RuntimeException e) {      // If the underlying source threw an exception, propagate that     rather than indicating it was      // a runtime exception.      catchingBody.throwIfCaught();      throw e;    }}</code></pre><h4 id="3、异步请求流程-repos-enqueque"><a href="#3、异步请求流程-repos-enqueque" class="headerlink" title="3、异步请求流程 repos.enqueque"></a>3、异步请求流程 repos.enqueque</h4><pre><code>@Override public void enqueue(final Callback&lt;T&gt; callback) {    // 使用静态代理 delegate进行异步请求     delegate.enqueue(new Callback&lt;T&gt;() {      @Override       public void onResponse(Call&lt;T&gt; call, finalResponse&lt;T&gt;response)     {        // 线程切换，在主线程显示结果        callbackExecutor.execute(new Runnable() {            @Override              public void run() {            if (delegate.isCanceled()) {              callback.onFailure(ExecutorCallbackCall.this, newIOException(&quot;Canceled&quot;));            } else {              callback.onResponse(ExecutorCallbackCall.this,respons);            }          }        });      }      @Override       public void onFailure(Call&lt;T&gt; call, final Throwable t) {        callbackExecutor.execute(new Runnable() {          @Override public void run() {            callback.onFailure(ExecutorCallbackCall.this, t);          }        });      }    });}</code></pre><p>看看 delegate.enqueue 内部流程。</p><pre><code>@Override public void enqueue(final Callback&lt;T&gt; callback) {    okhttp3.Call call;    Throwable failure;    synchronized (this) {      if (executed) throw new IllegalStateException(&quot;Already executed.&quot;);      executed = true;      call = rawCall;      failure = creationFailure;      if (call == null &amp;&amp; failure == null) {        try {          // 创建OkHttp的Request对象，再封装成OkHttp.call          // 方法同发送同步请求，此处上面已分析          call = rawCall = createRawCall();         } catch (Throwable t) {          failure = creationFailure = t;        }      }@Override public void enqueue(final Callback&lt;T&gt; callback) {  checkNotNull(callback, &quot;callback == null&quot;);  okhttp3.Call call;  Throwable failure;  ...  call.enqueue(new okhttp3.Callback() {    @Override public void onResponse(okhttp3.Call call,   okhttp3.Response rawResponse) {      Response&lt;T&gt; response;      try {        // 此处上面已分析        response = parseResponse(rawResponse);      } catch (Throwable e) {        throwIfFatal(e);        callFailure(e);        return;      }      try {        callback.onResponse(OkHttpCall.this, response);      } catch (Throwable t) {        t.printStackTrace();      }    }    @Override public void onFailure(okhttp3.Call call, IOException e) {      callFailure(e);    }    private void callFailure(Throwable e) {      try {        callback.onFailure(OkHttpCall.this, e);      } catch (Throwable t) {        t.printStackTrace();      }    }  });}</code></pre><p>如果你看到这里的话，恭喜你，你已经对Retrofit已经有一个比较深入的了解了，但是，笔者还是要建议大家自己主动配合着Retrofit最新版的源码一步步去彻底地认识它，只要这样，你才能看到它真实的内心，最后附上一张Stay的Retrofit源码流程图，要注意的是，这是V2.5之前版本的流程，但是，在看完上面的源码分析后，我们知道，主体流程是没有变化的。</p><p><img src="https://upload-images.jianshu.io/upload_images/625299-29a632638d9f518f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/891/format/webp" alt="image"></p><h3 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h3><p>从本质上来说，Retrofit虽然只是一个RESTful 的HTTP 网络请求框架的封装库。但是，它内部通过 大量的设计模式 封装了 OkHttp，让使用者感到它非常简洁、易懂。它内部主要是用动态代理 的方式，动态将网络请求接口的注解 解析 成HTTP请求，最后执行请求的过程。好了，至此，我们的Android主流三方库源码分析的网络库分析部分已经完毕。接下来，将为大家带来最流行的图片加载框架Glide的源码分析，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、Retrofit V2.5.0源码</p><p>2、Android进阶之光</p><p>3、<a href="https://www.jianshu.com/p/0c055ad46b6c" target="_blank" rel="external">Android：手把手带你 深入读懂 Retrofit 2.0 源码</a></p><p>4、<a href="https://www.jianshu.com/p/45cb536be2f4" target="_blank" rel="external">Retrofit分析-漂亮的解耦套路</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/12/09/Android%E4%B8%BB%E6%B5%81%E4%B8%89%E6%96%B9%E5%BA%93%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Retrofit%E6%BA%90%E7%A0%81%EF%BC%89/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
