<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Mon, 10 Feb 2020 12:58:08 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>深入探索Android卡顿优化（下）</title>
      <link>http://yoursite.com/2020/02/05/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/</link>
      <guid>http://yoursite.com/2020/02/05/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/</guid>
      <pubDate>Wed, 05 Feb 2020 09:43:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>在上篇文章中，笔者带领大家学习了卡顿优化分析方法与工具、自动化卡顿检测方案及优化这两块内容。如果对这块内容还不了解的同学建议先看看<a href="">《深入探索Android卡顿优化（上）》</a>。本篇，为深入探索Android卡顿优化的下篇。这篇文章包含的主要内容如下所示：</p><ul><li>1、ANR分析与实战</li><li>2、卡顿单点问题检测方案</li><li>3、高效实现界面秒开</li><li>4、优雅监控耗时盲区</li><li>5、卡顿优化技巧总结</li><li>6、常见卡顿问题解决方案总结</li><li>7、卡顿优化的常见问题</li></ul><p>卡顿时间过长，一定会造成应用发生ANR。下面，我们就来从应用的ANR分析与实战来开始今天的探索之旅。</p><h2 id="一、ANR分析与实战"><a href="#一、ANR分析与实战" class="headerlink" title="一、ANR分析与实战"></a>一、ANR分析与实战</h2><h3 id="1、ANR介绍与实战"><a href="#1、ANR介绍与实战" class="headerlink" title="1、ANR介绍与实战"></a>1、ANR介绍与实战</h3><p>首先，我们再来回顾一下ANR的几种常见的类型，如下所示：</p><ul><li>1、KeyDispatchTimeout：按键事件在<strong>5s</strong>的时间内没有处理完成。</li><li>2、BroadcastTimeout：广播接收器在<strong>前台10s，后台60s</strong>的时间内没有响应完成。</li><li>3、ServiceTimeout：服务在<strong>前台20s，后台200s</strong>的时间内没有处理完成。</li></ul><p>具体的时间定义我们可以在AMS（ActivityManagerService）中找到：</p><pre><code>// How long we allow a receiver to run before giving up on it.static final int BROADCAST_FG_TIMEOUT = 10*1000;static final int BROADCAST_BG_TIMEOUT = 60*1000;// How long we wait until we timeout on key dispatching.static final int KEY_DISPATCHING_TIMEOUT = 5*1000;</code></pre><p>接下来，我们来看一下ANR的执行流程。</p><h4 id="ANR执行流程"><a href="#ANR执行流程" class="headerlink" title="ANR执行流程"></a>ANR执行流程</h4><ul><li>1、首先，我们的应用发生了ANR。</li><li>2、然后，我们的进程就会接受到异常终止信息，并开始写入进程ANR信息，也就是当时应用的场景信息，它包含了应用所有的堆栈信息、CPU、IO等使用的情况等待。</li><li>3、最后，会弹出一个ANR提示框，看你是要选择继续等待还是退出应用，需要注意这个ANR提示框不一定会弹出，根据不同ROM，它的表现情况也不同。因为有些手机厂商它会默认去掉这个提示框，以避免带来不好的用户体验。</li></ul><p>分析完ANR的执行流程之后，我们来分析下怎样去解决ANR，究竟哪里可以作为我们的一个突破点。</p><p>在上面我们说过，当应用发生ANR时，会写入当时发生ANR的场景信息到文件中，<strong>那么，我们可不可以通过这个文件来判断是否发生了ANR呢？</strong></p><p>关于根据ANR log进行ANR问题的排查与解决的方式笔者已经在<a href="https://jsonchao.github.io/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android稳定性优化</a>的第三节ANR优化中讲解过了，这里就不多赘述了。</p><h4 id="线上ANR监控方式"><a href="#线上ANR监控方式" class="headerlink" title="线上ANR监控方式"></a>线上ANR监控方式</h4><p>在<a href="https://jsonchao.github.io/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android稳定性优化</a>的第三节ANR优化中我说到了使用FileObserver可以监听 /data/anr/traces.txt的变化，利用它可以实现线上ANR的监控，但是它有一个致命的缺点，就是高版本ROM需要root权限，解决方案是只能通过海外Google Play服务、国内Hardcoder的方式去规避。但是，这在国内显然是不现实的，那么，有没有更好的实现方式呢？</p><p>那就是ANR-WatchDog，下面我就来详细地介绍一下它。</p><p><a href="https://github.com/SalomonBrys/ANR-WatchDog" target="_blank" rel="external">ANR-WatchDog项目地址</a></p><p>ANR-WatchDog是一种非侵入式的ANR监控组件，可以用于线上ANR的监控，接下来，我们就使用ANR-WatchDog来监控ANR。</p><p>首先，在我们项目的app/build.gradle中添加如下依赖：</p><pre><code>implementation &apos;com.github.anrwatchdog:anrwatchdog:1.4.0&apos;</code></pre><p>然后，在应用的Application的onCreate方法中添加如下代码启动ANR-WatchDog：</p><pre><code>new ANRWatchDog().start();</code></pre><p>可以看到，它的初始化方式非常地简单，同时，它内部的实现也非常简单，整个库只有两个类，一个是ANRWatchDog，另一个是ANRError。</p><p>接下来我们来看一下ANRWatchDog的实现方式。</p><pre><code>/*** A watchdog timer thread that detects when the UI thread has frozen.*/public class ANRWatchDog extends Thread {</code></pre><p>可以看到，ANRWatchDog实际上是继承了Thread类，也就是它是一个线程，对于线程来说，最重要的就是其run方法，如下所示：</p><pre><code>private static final int DEFAULT_ANR_TIMEOUT = 5000;private volatile long _tick = 0;private volatile boolean _reported = false;private final Runnable _ticker = new Runnable() {    @Override public void run() {        _tick = 0;        _reported = false;    }};@Overridepublic void run() {    // 1、首先，将线程命名为|ANR-WatchDog|。    setName(&quot;|ANR-WatchDog|&quot;);    // 2、接着，声明了一个默认的超时间隔时间，默认的值为5000ms。    long interval = _timeoutInterval;    // 3、然后，在while循环中通过_uiHandler去post一个_ticker Runnable。    while (!isInterrupted()) {        // 3.1 这里的_tick默认是0，所以needPost即为true。        boolean needPost = _tick == 0;        // 这里的_tick加上了默认的5000ms        _tick += interval;        if (needPost) {            _uiHandler.post(_ticker);        }        // 接下来，线程会sleep一段时间，默认值为5000ms。        try {            Thread.sleep(interval);        } catch (InterruptedException e) {            _interruptionListener.onInterrupted(e);            return ;        }        // 4、如果主线程没有处理Runnable，即_tick的值没有被赋值为0，则说明发生了ANR，第二个_reported标志位是为了避免重复报道已经处理过的ANR。        if (_tick != 0 &amp;&amp; !_reported) {            //noinspection ConstantConditions            if (!_ignoreDebugger &amp;&amp; (Debug.isDebuggerConnected() || Debug.waitingForDebugger())) {                Log.w(&quot;ANRWatchdog&quot;, &quot;An ANR was detected but ignored because the debugger is connected (you can prevent this with setIgnoreDebugger(true))&quot;);                _reported = true;                continue ;            }            interval = _anrInterceptor.intercept(_tick);            if (interval &gt; 0) {                continue;            }            final ANRError error;            if (_namePrefix != null) {                error = ANRError.New(_tick, _namePrefix, _logThreadsWithoutStackTrace);            } else {                // 5、如果没有主动给ANR_Watchdog设置线程名，则会默认会使用ANRError的NewMainOnly方法去处理ANR。                error = ANRError.NewMainOnly(_tick);            }           // 6、最后会通过ANRListener调用它的onAppNotResponding方法，其默认的处理会直接抛出当前的ANRError，导致程序崩溃。 _anrListener.onAppNotResponding(error);            interval = _timeoutInterval;            _reported = true;        }    }}</code></pre><p>首先，在注释1处，我们将线程命名为了|ANR-WatchDog|。接着，在注释2处，声明了一个默认的超时间隔时间，默认的值为5000ms。然后，注释3处，在while循环中通过_uiHandler去post一个_ticker Runnable。注意这里的_tick默认是0，所以needPost即为true。接下来，线程会sleep一段时间，默认值为5000ms。在注释4处，如果主线程没有处理Runnable，即_tick的值没有被赋值为0，则说明发生了ANR，第二个_reported标志位是为了避免重复报道已经处理过的ANR。如果发生了ANR，就会调用接下来的代码，开始会处理debug的情况，然后，我们看到注释5处，如果没有主动给ANR_Watchdog设置线程名，则会默认会使用ANRError的NewMainOnly方法去处理ANR。ANRError的NewMainOnly方法如下所示：</p><pre><code>/** * The minimum duration, in ms, for which the main thread has been blocked. May be more. */public final long duration;static ANRError NewMainOnly(long duration) {    // 1、获取主线程的堆栈信息    final Thread mainThread = Looper.getMainLooper().getThread();    final StackTraceElement[] mainStackTrace = mainThread.getStackTrace();    // 2、返回一个包含主线程名、主线程堆栈信息以及发生ANR的最小时间值的实例。    return new ANRError(new $(getThreadTitle(mainThread), mainStackTrace).new _Thread(null), duration);}</code></pre><p>可以看到，在注释1处，首先获了主线程的堆栈信息，然后返回了一个包含主线程名、主线程堆栈信息以及发生ANR的最小时间值的实例。（我们可以改造其源码在此时添加更多的卡顿现场信息，如CPU 使用率和调度信息、内存相关信息、I/O 和网络相关的信息等等）</p><p>接下来，我们再回到ANRWatchDog的run方法中的注释6处，最后这里会通过ANRListener调用它的onAppNotResponding方法，其默认的处理会直接抛出当前的ANRError，导致程序崩溃。对应的代码如下所示：</p><pre><code>private static final ANRListener DEFAULT_ANR_LISTENER = new ANRListener() {    @Override public void onAppNotResponding(ANRError error) {        throw error;    }};</code></pre><p>了解了ANRWatchDog的实现原理之后，我们试一试它的效果如何。首先，我们给MainActivity中的悬浮按钮添加主线程休眠10s的代码，如下所示：</p><pre><code>@OnClick({R.id.main_floating_action_btn})void onClick(View view) {    switch (view.getId()) {        case R.id.main_floating_action_btn:            try {                // 对应项目中的第170行                Thread.sleep(10000);            } catch (InterruptedException e) {                e.printStackTrace();            }            jumpToTheTop();            break;        default:            break;    }}</code></pre><p>然后，我们重新安装运行项目，点击悬浮按钮，发现在10s内都不能触发屏幕点击和触摸事件，并且在10s之后，应用直接发生了崩溃。接着，我们在Logcat过滤栏中输入<strong>fatal</strong>关键字，找出致命的错误，log如下所示：</p><pre><code>2020-01-18 09:55:53.459 29924-29969/? E/AndroidRuntime: FATAL EXCEPTION: |ANR-WatchDog|Process: json.chao.com.wanandroid, PID: 29924com.github.anrwatchdog.ANRError: Application Not Responding for at least 5000 ms.Caused by: com.github.anrwatchdog.ANRError$$$_Thread: main (state = TIMED_WAITING)    at java.lang.Thread.sleep(Native Method)    at java.lang.Thread.sleep(Thread.java:373)    at java.lang.Thread.sleep(Thread.java:314)    // 1    at json.chao.com.wanandroid.ui.main.activity.MainActivity.onClick(MainActivity.java:170)    at json.chao.com.wanandroid.ui.main.activity.MainActivity_ViewBinding$1.doClick(MainActivity_ViewBinding.java:45)    at butterknife.internal.DebouncingOnClickListener.onClick(DebouncingOnClickListener.java:22)    at android.view.View.performClick(View.java:6311)    at android.view.View$PerformClick.run(View.java:24833)    at android.os.Handler.handleCallback(Handler.java:794)    at android.os.Handler.dispatchMessage(Handler.java:99)    at android.os.Looper.loop(Looper.java:173)    at android.app.ActivityThread.main(ActivityThread.java:6653)    at java.lang.reflect.Method.invoke(Native Method)    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:821) Caused by: com.github.anrwatchdog.ANRError$$$_Thread: AndroidFileLogger./storage/emulated/0/Android/data/json.chao.com.wanandroid/log/ (state = RUNNABLE)</code></pre><p>可以看到，发生崩溃的线程正是|ANR-WatchDog|。我们重点关注注释1，这里发生崩溃的位置是在MainActivity的onClick方法，对应的行数为170行，从前可知，这里正是线程休眠的地方。</p><p>接下来，我们来分析一下ANR-WatchDog的实现原理。</p><h3 id="2、ANR-WatchDog原理"><a href="#2、ANR-WatchDog原理" class="headerlink" title="2、ANR-WatchDog原理"></a>2、ANR-WatchDog原理</h3><ul><li>首先，我们调用了ANR-WatchDog的start方法，然后这个线程就会开始工作。</li><li>然后，我们通过主线程的Handler post一个消息将主线程的某个值进行一个加值的操作。</li><li>post完成之后呢，我们这个线程就sleep一段时间。</li><li>在sleep之后呢，它就会来检测我们这个值有没有被修改，如果这个值被修改了，那就说明我们在主线程中执行了这个message，即表明主线程没有发生卡顿，否则，则说明主线程发生了卡顿。</li><li>最后，ANR-WatchDog就会判断发生了ANR，抛出一个异常给我们。</li></ul><p>最后，ANR-WatchDog的工作流程简图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/anr_watch_dog_implement.png" alt="image"></p><p>上面我们最后说到，如果检测到主线程发生了卡顿，则会抛出一个ANR异常，这将会导致应用崩溃，这显然不能将这种方案带到线上，那么，<strong>有什么方式能够自定义最后发生卡顿时的处理过程吗？</strong></p><p>其实ANR-WatchDog自身就实现了一个我们自身也可以去实现的<strong>ANRListener，通过它，我们就可以对ANR事件去做一个自定义的处理</strong>，比如将堆栈信息压缩后保存到本地，并在适当的时间上传到APM后台。</p><h3 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h3><p>ANR-WatchDog是一种非侵入式的ANR监控方案，它能够弥补我们在高版本中没有权限去读取traces.txt文件的问题，需要注意的是，在线上这两种方案我们是结合使用的。</p><p>在之前，我们还讲到了<strong>AndroidPerformanceMonitor，那么它和ANR-WatchDog有什么区别呢？</strong></p><p>对于AndroidPerformanceMonitor来说，它是监控我们主线程中每一个message的执行，它会在主线程的每一个message的前后打印一个时间戳，然后，我们就可以据此计算每一个message的具体执行时间，但是我们需要注意的是一个message的执行时间通常是非常短暂的，也就是很难达到ANR这个级别。然后我们来看看ANR-WatchDog的原理，它是不管应用是如何执行的，它只会看最终的结果，即sleep 5s之后，我就看主线程的这个值有没有被更改。如果说被改过，就说明没有发生ANR，否则，就表明发生了ANR。</p><p>根据这两个库的原理，我们便可以判断出它们分别的适用场景，对于AndroidPerformanceMonitor来说，它适合监控卡顿，因为每一个message它执行的时间并不长。对于ANR-WatchDog来说，它更加适合于ANR监控的补充。</p><p>此外，虽然ANR-WatchDog解决了在高版本系统没有权限读取 /data/anr/traces.txt 文件的问题，但是在Java层去获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适，它可能会进一步加剧用户的卡顿。如果是对性能要求比较高的应用,可以通过Hook Native层的方式去获得所有线程的堆栈信息，具体为如下两个步骤：</p><ul><li>通过libart.so、dlsym调用<a href="http://androidxref.com/9.0.0_r3/xref/art/runtime/thread_list.cc#1501" target="_blank" rel="external">ThreadList::ForEach</a>方法，拿到所有的 Native 线程对象。</li><li>遍历线程对象列表，调用<a href="http://androidxref.com/9.0.0_r3/xref/art/runtime/thread.cc#1615" target="_blank" rel="external">Thread::DumpState</a>方法。</li></ul><p>通过这种方式就大致模拟了系统打印 ANR 日志的流程，但是由于采用的是Hook方式，所以可能会产生一些异常甚至崩溃的情况，这个时候就需要通过 fork 子进程方式去避免这种问题，而且使用 子进程去获取堆栈信息的方式可以做到完全不卡住我们主进程。</p><p>但是需要注意的是，fork 进程会导致进程号发生改变，此时需要通过指定 /proc/[父进程 id]的方式重新获取应用主进程的堆栈信息。</p><p>通过 Native Hook 的 方式我们实现了一套“无损”获取所有 Java 线程堆栈与详细信息的卡顿监控体系。为了降低上报数据量，建议只有主线程的 Java 线程状态是 WAITING、TIME_WAITING 或者 BLOCKED 的时候，才去使用这套方案。</p><h2 id="二、卡顿单点问题检测方案"><a href="#二、卡顿单点问题检测方案" class="headerlink" title="二、卡顿单点问题检测方案"></a>二、卡顿单点问题检测方案</h2><p>除了自动化的卡顿与ANR监控之外，我们还需要进行卡顿单点问题的检测，因为上述两种检测方案的并不能满足所有场景的检测要求，这里我举一个小栗子：</p><pre><code>比如我有很多的message要执行，但是每一个message的执行时间都不到卡顿的阈值，那自动化卡顿检测方案也就不能够检测出卡顿，但是对用户来说，用户就觉得你的App就是有些卡顿。</code></pre><p>除此之外，为了建立体系化的监控解决方案，我们就必须在上线之前将问题尽可能地暴露出来。</p><h3 id="1、IPC单点问题检测方案"><a href="#1、IPC单点问题检测方案" class="headerlink" title="1、IPC单点问题检测方案"></a>1、IPC单点问题检测方案</h3><p>常见的单点问题有主线程IPC、DB操作等等，这里我就拿主线程IPC来说，因为IPC其实是一个很耗时的操作，但是在实际开发过程中，我们可能对IPC操作没有足够的重视，所以，我们经常在主程序中去做频繁IPC操作，所以说，这种耗时它可能并不到你设定卡顿的一个阈值，接下来，我们看一下，对于IPC问题，我们应该去监测哪些指标。</p><ul><li>1、IPC调用类型：如PackageManager、TelephoneManager的调用。</li><li>2、每一个的调用次数与耗时。</li><li>3、IPC的调用堆栈（表明哪行代码调用的）、发生线程。</li></ul><h4 id="常规方案"><a href="#常规方案" class="headerlink" title="常规方案"></a>常规方案</h4><p>常规方案就是在IPC的前后加上埋点。但是，这种方式不够优雅，而且，在平常开发过程中我们经常忘记某个埋点的真正用处，同时它的维护成本也非常大。</p><p>接下来，我们讲解一下IPC问题监测的技巧。</p><h4 id="IPC问题监测技巧"><a href="#IPC问题监测技巧" class="headerlink" title="IPC问题监测技巧"></a>IPC问题监测技巧</h4><p>在线下，我们可以通过adb命令的方式来进行监测，如下所示：</p><pre><code>// 1、首先，对IPC操作开始进行监控adb shell am trace-ipc start// 2、然后，结束IPC操作的监控，同时，将监控到的信息存放到指定的文件当中adb shell am trace-ipc stop -dump-file /data/local/tmp/ipc-trace.txt// 3、最后，将监控到的ipc-trace导出到电脑查看adb pull /data/local/tmp/ipc-trace.txt</code></pre><p>然后，这里我们介绍一种优雅的实现方案，看过<a href="https://juejin.im/post/5e1d15a851882536ca666a49" target="_blank" rel="external">深入探索Android布局优化（上）</a>的同学可能知道这里的实现方案无非就是ARTHook或AspectJ这两种方案，这里我们需要去监控IPC操作，那么，我们应该选用哪种方式会更好一些呢？</p><p>要回答这个问题，就需要我们对ARTHook和AspectJ这两者的思想有足够的认识，对应ARTHook来说，其实我们可以用它来去Hook系统的一些方法，因为对于系统代码来说，我们无法对它进行更改，但是我们可以Hook住它的一个方法，在它的方法体里面去加上自己的一些代码。但是，对于AspectJ来说，它只能针对于哪些非系统方法，也就是我们App自己的源码，或者是我们所引用到的一些jar、aar包。因为AspectJ实际上是往我们的具体方法里面插入相对于的代码，所以说，他不能够针对于我们的系统方法去做操作，在这里，我们就需要采用ARTHook的方式去进行IPC操作的监控。</p><p>在使用ARTHook去监控IPC操作之前，我们首先思考一下，哪些操作是IPC操作呢？</p><p>比如说，我们通过PackageManager去拿到我们应用的一些信息，或者去拿到设备的DeviceId这样的信息以及AMS相关的信息等等，这些其实都涉及到了IPC的操作，而这些操作都会通过固定的方式进行IPC，并最终会调用到<strong>android.os.BinderProxy</strong>，接下来，我们来看看它的transact方法，如下所示：</p><pre><code>public boolean transact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {</code></pre><p>这里我们仅仅关注transact方法的参数即可，第一个参数是一个行动编码，为int类型，它是在FIRST_CALL_TRANSACTION与LAST_CALL_TRANSACTION之间的某个值，第二、三个参数都是Parcel类型的参数，用于获取和回复相应的数据，第四个参数为一个int类型的标记值，为0表示一个正常的IPC调用，否则表明是一个单向的IPC调用。然后，我们在项目中的Application的onCreate方法中使用ARTHook对android.os.BinderProxy类的transact方法进行Hook，代码如下所示：</p><pre><code>try {        DexposedBridge.findAndHookMethod(Class.forName(&quot;android.os.BinderProxy&quot;), &quot;transact&quot;,                int.class, Parcel.class, Parcel.class, int.class, new XC_MethodHook() {                    @Override                    protected void beforeHookedMethod(MethodHookParam param) throws Throwable {                        LogHelper.i( &quot;BinderProxy beforeHookedMethod &quot; + param.thisObject.getClass().getSimpleName()                                + &quot;\n&quot; + Log.getStackTraceString(new Throwable()));                        super.beforeHookedMethod(param);                    }                });    } catch (ClassNotFoundException e) {        e.printStackTrace();    }</code></pre><p>重新安装应用，即可看到如下的Log信息：</p><pre><code>2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │ WanAndroidApp$1.beforeHookedMethod  (WanAndroidApp.java:160)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │    LogHelper.i  (LogHelper.java:37)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │ [WanAndroidApp.java | 160 | beforeHookedMethod] BinderProxy beforeHookedMethod BinderProxy2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │ java.lang.Throwable2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at json.chao.com.wanandroid.app.WanAndroidApp$1.beforeHookedMethod(WanAndroidApp.java:160)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at com.taobao.android.dexposed.DexposedBridge.handleHookedArtMethod(DexposedBridge.java:237)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at me.weishu.epic.art.entry.Entry64.onHookBoolean(Entry64.java:72)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at me.weishu.epic.art.entry.Entry64.referenceBridge(Entry64.java:237)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at me.weishu.epic.art.entry.Entry64.booleanBridge(Entry64.java:86)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.os.ServiceManagerProxy.getService(ServiceManagerNative.java:123)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.os.ServiceManager.getService(ServiceManager.java:56)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.os.ServiceManager.getServiceOrThrow(ServiceManager.java:71)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.UiModeManager.&lt;init&gt;(UiModeManager.java:127)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.SystemServiceRegistry$42.createService(SystemServiceRegistry.java:511)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.SystemServiceRegistry$42.createService(SystemServiceRegistry.java:509)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.SystemServiceRegistry$CachedServiceFetcher.getService(SystemServiceRegistry.java:970)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.SystemServiceRegistry.getSystemService(SystemServiceRegistry.java:920)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.ContextImpl.getSystemService(ContextImpl.java:1677)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.view.ContextThemeWrapper.getSystemService(ContextThemeWrapper.java:171)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.Activity.getSystemService(Activity.java:6003)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegateImplV23.&lt;init&gt;(AppCompatDelegateImplV23.java:33)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegateImplN.&lt;init&gt;(AppCompatDelegateImplN.java:31)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegate.create(AppCompatDelegate.java:198)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.support.v7.app.AppCompatDelegate.create(AppCompatDelegate.java:183)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.support.v7.app.AppCompatActivity.getDelegate(AppCompatActivity.java:519)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.support.v7.app.AppCompatActivity.onCreate(AppCompatActivity.java:70)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at me.yokeyword.fragmentation.SupportActivity.onCreate(SupportActivity.java:38)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at json.chao.com.wanandroid.base.activity.AbstractSimpleActivity.onCreate(AbstractSimpleActivity.java:29)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at json.chao.com.wanandroid.base.activity.BaseActivity.onCreate(BaseActivity.java:37)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.Activity.performCreate(Activity.java:7098)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.Activity.performCreate(Activity.java:7089)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1215)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2770)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2895)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.ActivityThread.-wrap11(Unknown Source:0)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.ActivityThread$H.handleMessage(ActivityThread.java:1616)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.os.Handler.dispatchMessage(Handler.java:106)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.os.Looper.loop(Looper.java:173)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at android.app.ActivityThread.main(ActivityThread.java:6653)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at java.lang.reflect.Method.invoke(Native Method)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)2020-01-22 19:52:47.657 10683-10683/json.chao.com.wanandroid I/WanAndroid-LOG: │     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:821)</code></pre><p>可以看出，这里弹出了应用中某一个IPC调用的所有堆栈信息。在这里，具体是在AbstractSimpleActivity的onCreate方法中调用了ServiceManager的getService方法，它是一个IPC调用的方法。这样，应用的IPC调用我们就能很方便地捕获到了。</p><p>大家可以看到，通过这种方式我们可以很方便地拿到应用中所有的IPC操作，并可以获得到IPC调用的类型、调用耗时、发生次数、调用的堆栈等等一系列信息。当然，除了IPC调用的问题之外，还有IO、DB、View绘制等一系列单点问题需要去建立与之对应的检测方案。</p><h4 id="2、卡顿问题检测方案"><a href="#2、卡顿问题检测方案" class="headerlink" title="2、卡顿问题检测方案"></a>2、卡顿问题检测方案</h4><p>对于卡顿问题检测方案的建设，主要是利用ARTHook去完善线下的检测工具，尽可能地去Hook相对应的操作，以暴露、分析问题。这样，才能更好地实现卡顿的体系还解决方案。</p><h2 id="三、如何实现界面秒开？"><a href="#三、如何实现界面秒开？" class="headerlink" title="三、如何实现界面秒开？"></a>三、如何实现界面秒开？</h2><p>界面的打开速度对用户体验来说是至关重要的，那么如何实现界面秒开呢？</p><p>其实界面秒开就是一个小的启动优化，其优化的思想可以借鉴启动速度优化与布局优化的一些实现思路。</p><h3 id="1、界面秒开实现"><a href="#1、界面秒开实现" class="headerlink" title="1、界面秒开实现"></a>1、界面秒开实现</h3><p>首先，我们可以通过Systrace来观察CPU的运行状况，比如有没有跑满CPU；然后，我们在启动优化中学习到的优雅异步以及优雅延迟初始化等等一些方案；其次，针对于我们的界面布局，我们可以使用异步Inflate、X2C、其它的绘制优化措施等等；最后，我们可以使用预加载的方式去提前获取页面的数据，以避免网络或磁盘IO速度的影响，或者也可以将获取数据的方法放到onCreate方法的第一行。</p><h4 id="那么我们如何去衡量界面的打开速度呢？"><a href="#那么我们如何去衡量界面的打开速度呢？" class="headerlink" title="那么我们如何去衡量界面的打开速度呢？"></a>那么我们如何去衡量界面的打开速度呢？</h4><p>通常，我们是通过界面秒开率去统计页面的打开速度的，具体就是计算onCreate到onWindowFocusChanged的时间。当然，在某些特定的场景下，把onWindowFocusChanged作为页面打开的结束点并不是特别的精确，那我们可以去实现一个特定的接口来适配我们的Activity或Fragment，我们可以把那个接口方法作为页面打开的结束点。</p><p>那么，除了以上说到的一些界面秒开的实现方式之外，还没有更好的方式呢？</p><p>那就是Lancet。</p><h3 id="2、Lancet"><a href="#2、Lancet" class="headerlink" title="2、Lancet"></a>2、Lancet</h3><p>Lancet是一个轻量级的Android AOP框架，它具有如下优势：</p><ul><li>1、编译速度快，支持增量编译。</li><li>2、API简单，没有任何多余代码插入apk。（这一点对应包体积优化时至关重要的）</li></ul><p>然后，我来简单地讲解下Lancet的用法。Lancet自身提供了一些注解用于Hook，如下所示：</p><ul><li>@Prxoy：通常是用于对系统API调用的Hook。</li><li>@Insert：经常用于操作App或者是Library当中的一些类。</li></ul><p>接下来，我们就是使用Lancet来进行一下实战演练。</p><p>首先，我们需要在项目根目录的 build.gradle 添加如下依赖:</p><pre><code>dependencies{    classpath &apos;me.ele:lancet-plugin:1.0.5&apos;}</code></pre><p>然后，在 app 目录的’build.gradle’ 添加：</p><pre><code>apply plugin: &apos;me.ele.lancet&apos;dependencies {    compileOnly &apos;me.ele:lancet-base:1.0.5&apos;}</code></pre><p>接下来，我们就可以使用Lancet了，这里我们需要先新建一个类去进行专门的Hook操作，如下所示：</p><pre><code>public class ActivityHooker {    @Proxy(&quot;i&quot;)    @TargetClass(&quot;android.util.Log&quot;)    public static int i(String tag, String msg) {        msg = msg + &quot;JsonChao&quot;;        return (int) Origin.call();    }}</code></pre><p>上述的方法就是对android.util.Log的i方法进行Hook，并在所有的msg后面加上”JsonChao”字符串，注意这里的i方法我们需要从android.util.Log里面将它的i方法复制过来，确保方法名和对应的参数信息一致；然后，方法上面的@TargetClass与@Proxy分别是指定对应的全路径类名与方法名；最后，我们需要通过Lancet提供的Origin类去调用它的call方法来实现返回原来的调用信息。完成之后，我们重新运行项目，会出现如下log信息：</p><pre><code>2020-01-23 13:13:34.124 7277-7277/json.chao.com.wanandroid I/MultiDex: VM with version 2.1.0 has multidex supportJsonChao2020-01-23 13:13:34.124 7277-7277/json.chao.com.wanandroid I/MultiDex: Installing applicationJsonChao</code></pre><p>可以看到，log后面都加上了我们预先添加的字符串，说明Hook成功了。下面，我们就可以用Lancet来统计一下项目界面的秒开率了，代码如下所示：</p><pre><code>public static ActivityRecord sActivityRecord;static {    sActivityRecord = new ActivityRecord();}@Insert(value = &quot;onCreate&quot;,mayCreateSuper = true)@TargetClass(value = &quot;android.support.v7.app.AppCompatActivity&quot;,scope = Scope.ALL)protected void onCreate(Bundle savedInstanceState) {    sActivityRecord.mOnCreateTime = System.currentTimeMillis();    // 调用当前Hook类方法中原先的逻辑    Origin.callVoid();}@Insert(value = &quot;onWindowFocusChanged&quot;,mayCreateSuper = true)@TargetClass(value = &quot;android.support.v7.app.AppCompatActivity&quot;,scope = Scope.ALL)public void onWindowFocusChanged(boolean hasFocus) {    sActivityRecord.mOnWindowsFocusChangedTime = System.currentTimeMillis();    LogHelper.i(getClass().getCanonicalName() + &quot; onWindowFocusChanged cost &quot;+(sActivityRecord.mOnWindowsFocusChangedTime - sActivityRecord.mOnCreateTime));    Origin.callVoid();}</code></pre><p>上面，我们通过@TargetClass和@Insert两个注解实现Hook了android.support.v7.app.AppCompatActivity的onCreate与onWindowFocusChanged方法。我们注意到，这里@Insert注解可以指定两个参数，其源码如下所示：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Insert {    String value();    boolean mayCreateSuper() default false;}</code></pre><p>第二个参数mayCreateSuper设定为true则表明如果没有重写父类的方法，则会默认去重写这个方法。对应到我们ActivityHooker里面实现的@Insert注解方法就是如果当前的Activity没有重写父类的onCreate和<br>onWindowFocusChanged方法，则此时默认回去重写父类的这个方法，以避免因某些Activity不存在该方法而Hook失败的情况。</p><p>然后，我们注意到@TargetClass也可以指定两个参数，其源码如下所示：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@java.lang.annotation.Target({ElementType.TYPE, ElementType.METHOD})public @interface TargetClass {    String value();    Scope scope() default Scope.SELF;}</code></pre><p>第二个参数scope指定的值是一个枚举，可选的值如下所示：</p><pre><code>public enum Scope {    SELF,    DIRECT,    ALL,    LEAF}</code></pre><p>对于Scope.SELF，它代表仅匹配目标value所指定的一个匹配类；对于DIRECT，它代表匹配value所指定的类的一个直接子类；如果是Scope.ALL，它就表明会去匹配value所指定的类的所有子类，而我们上面指定的value值为android.support.v7.app.AppCompatActivity，因为scope指定为了Scope.ALL，则说明会去匹配AppCompatActivity的所有子类。而最后的Scope.LEAF 代表匹配 value 指定类的最终子类，因为java是单继承，所以继承关系是树形结构，所以这里代表了指定类为顶点的继承树的所有叶子节点。</p><p>最后，我们设定了一个ActivityRecord类去记录onCreate与onWindowFocusChanged的时间戳，如下所示：</p><pre><code>public class ActivityRecord {    /**    * 避免没有仅执行onResume就去统计界面打开速度的情况，如息屏、亮屏等等    */    public boolean isNewCreate;    public long mOnCreateTime;    public long mOnWindowsFocusChangedTime;}</code></pre><p>通过sActivityRecord.mOnWindowsFocusChangedTime - sActivityRecord.mOnCreateTime得到的时间即为界面的打开速度，最后，重新运行项目，会得到如下log信息：</p><pre><code>2020-01-23 14:12:16.406 15098-15098/json.chao.com.wanandroid I/WanAndroid-LOG: │ [null | 57 | json_chao_com_wanandroid_aop_ActivityHooker_onWindowFocusChanged] json.chao.com.wanandroid.ui.main.activity.SplashActivity onWindowFocusChanged cost 2572020-01-23 14:12:18.930 15098-15098/json.chao.com.wanandroid I/WanAndroid-LOG: │ [null | 57 | json_chao_com_wanandroid_aop_ActivityHooker_onWindowFocusChanged] json.chao.com.wanandroid.ui.main.activity.MainActivity onWindowFocusChanged cost 608</code></pre><p>从上面的log信息，我们就可以知道 SplashActivity 和 MainActivity 的界面打开速度分别是257ms和608ms。</p><p>最后，我们来看下界面秒开的监控纬度。</p><h3 id="3、界面秒开监控纬度"><a href="#3、界面秒开监控纬度" class="headerlink" title="3、界面秒开监控纬度"></a>3、界面秒开监控纬度</h3><p>对于界面秒开的监控纬度，主要分为以下三个方面：</p><ul><li>总体耗时</li><li>生命周期耗时</li><li>生命周期间隔耗时</li></ul><p>首先，我们会监控界面打开的整体耗时，也就是onCreate到onWindowFocusChanged这个方法的耗时；当然，如果我们是在一个特殊的界面，我们需要更精确的知道界面打开的一个时间，这个我们可以用自定义的接口去实现。其次，我们也需要去监控生命周期的一个耗时，如onCreate、onStart、onResume等等。最后，我们也需要去做生命周期间隔的耗时监控，这点经常被我们所忽略，比如onCreate的结束到onStart开始的这一段时间，也是有时间损耗的，我们可以监控它是不是在一个合理的范围之内。通过这三个方面的监控纬度，我们就能够非常细粒度地去检测页面秒开各个方面的情况。</p><h2 id="四、优雅监控耗时盲区"><a href="#四、优雅监控耗时盲区" class="headerlink" title="四、优雅监控耗时盲区"></a>四、优雅监控耗时盲区</h2><p>尽管我们在应用中监控了很多的耗时区间，但是还是有一些耗时区间我们还没有捕捉到，如onResume到列表展示的间隔时间，这些时间在我们的统计过程中很容易被忽视，这里我们举一个小栗子：</p><pre><code>我们在Activity的生命周期中post了一个message，那这个message很可能其中执行了一段耗时操作，那你知道这个message它的具体执行时间吗？这个message其实很有可能在列表展示之前就执行了，如果这个message耗时1s，那么列表的展示时间就会延迟1s，如果是200ms，那么我们设定的自动化卡顿检测就无法发现它，那么列表的展示时间就会延迟200ms。</code></pre><p>其实这种场景非常常见，接下来，我们就在项目中来进行实战演练。</p><p>首先，我们在MainActivity的onCreate中加上post消息的一段代码，其中模拟了延迟1000ms的耗时操作，代码如下所示：</p><pre><code>// 以下代码是为了演示Msg导致的主线程卡顿    new Handler().post(() -&gt; {        LogHelper.i(&quot;Msg 执行&quot;);        try {            Thread.sleep(1000);        } catch (InterruptedException e) {            e.printStackTrace();        }    });</code></pre><p>接着，我们在RecyclerView对应的Adapter中将列表展示的时间打印出来，如下所示：</p><pre><code>if (helper.getLayoutPosition() == 1 &amp;&amp; !mHasRecorded) {        mHasRecorded = true;        helper.getView(R.id.item_search_pager_group).getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() {            @Override            public boolean onPreDraw() {                helper.getView(R.id.item_search_pager_group).getViewTreeObserver().removeOnPreDrawListener(this);                LogHelper.i(&quot;FeedShow&quot;);                return true;            }        });    }</code></pre><p>最后，我们重新运行下项目，看看两者的执行时间，log信息如下：</p><pre><code>2020-01-23 15:21:55.076 19091-19091/json.chao.com.wanandroid I/WanAndroid-LOG: │ [MainActivity.java | 108 | lambda$initEventAndData$1$MainActivity] Msg 执行2020-01-23 15:21:56.264 19091-19091/json.chao.com.wanandroid I/WanAndroid-LOG: │ [null | 57 | json_chao_com_wanandroid_aop_ActivityHooker_onWindowFocusChanged] json.chao.com.wanandroid.ui.main.activity.MainActivity onWindowFocusChanged cost 15852020-01-23 15:21:57.207 19091-19091/json.chao.com.wanandroid I/WanAndroid-LOG: │ ArticleListAdapter$1.onPreDraw  (ArticleListAdapter.java:93)2020-01-23 15:21:57.208 19091-19091/json.chao.com.wanandroid I/WanAndroid-LOG: │    LogHelper.i  (LogHelper.java:37)2020-01-23 15:21:57.208 19091-19091/json.chao.com.wanandroid I/WanAndroid-LOG: ├┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄2020-01-23 15:21:57.208 19091-19091/json.chao.com.wanandroid I/WanAndroid-LOG: │ [ArticleListAdapter.java | 93 | onPreDraw] FeedShow</code></pre><p>从log信息中可以看到，MAinActivity的onWindowFocusChanged方法延迟了1000ms才被调用，与此同时，列表页时延迟了1000ms才展示出来。也就是说，post的这个message消息是执行在界面、列表展示之前的。因为任何一个开发都有可能在某一个生命周期或者是某一个阶段以及一些第三方的SDK里面，回去做一些handler post的相关操作，这样，他的handler post的message的执行，很有可能在我们的界面或列表展示之前就被执行，所以说，出现这种耗时的盲区是非常普遍的，而且也不好排查，下面，我们分析下耗时盲区存在的难点。</p><h3 id="1、耗时盲区监控难点"><a href="#1、耗时盲区监控难点" class="headerlink" title="1、耗时盲区监控难点"></a>1、耗时盲区监控难点</h3><p>首先，我们可以通过细化监控的方式去获取耗时的一些盲区，但是我们却不知道在这个盲区中它执行了什么操作。其次，对于线上的一些耗时盲区，我们是无法进行排查的。</p><p>这里，我们先来看看如何建立耗时盲区监控的线下方案。</p><h3 id="2、耗时盲区监控线下方案"><a href="#2、耗时盲区监控线下方案" class="headerlink" title="2、耗时盲区监控线下方案"></a>2、耗时盲区监控线下方案</h3><p>这里我们直接使用TraceView去检测即可，因为它能够清晰地记录线程在具体的时间内到底做了什么操作，特别适合一段时间内的盲区监控。</p><p>然后，我们来看下如何建立耗时盲区监控的线上方案。</p><h3 id="3、耗时盲区监控线上方案"><a href="#3、耗时盲区监控线上方案" class="headerlink" title="3、耗时盲区监控线上方案"></a>3、耗时盲区监控线上方案</h3><p>我们知道主线程的所有方法都是通过message来执行的，还记得在之前我们学习了一个库：AndroidPerformanceMonitor，我们是否可以通过这个mLogging来做盲区检测呢？通过这个mLogging确实可以知道我们主线程发生的message，但是通过mLogging无法获取具体的调用栈信息，因为它所获取的调用栈信息都是系统回调回来的，它并不知道当前的message是被谁抛出来的，所以说，这个方案并不够完美。</p><p>那么，我们是否可以通过AOP的方式去切Handler方法呢？比如sendMessage、sendMessageDeleayd方法等等，这样我们就可以知道发生message的一个堆栈，但是这种方案也存在着一个问题，就是它不清楚准确的执行时间，我们切了这个handler的方法，仅仅只知道它具体是在那个地方被发的和它所对应的堆栈信息，但是无法获取准确的执行时间。如果我们想知道在onResume到列表展示之间执行了哪些message，那么通过AOP的方式也无法实现。</p><p>那么，最终的耗时盲区监控的一个线上方案就是使用一个统一的Handler，定制了它的两个方法，一个是sendMessageAtTime，另外一个是dispatchMessage方法。因为对于发送message，不管调用哪个方法最终都会调用到一个是sendMessageAtTime这个方法，而处理message呢，它最终会调用dispatchMessage方法。然后，我们需要定制一个gradle插件，来实现自动化的接入我们定制好的handler，通过这种方式，我们就能在编译期间去动态地替换所有使用Handler的父类为我们定制好的这个handler。这样，在整个项目中，所有的sendMessage和handleMessage都会经过我们的回调方法。接下来，我们来进行一下实战演练。</p><p>首先，我这里给出定制好的全局Handler类，如下所示：</p><pre><code>public class GlobalHandler extends Handler {    private long mStartTime = System.currentTimeMillis();    public GlobalHandler() {        super(Looper.myLooper(), null);    }    public GlobalHandler(Callback callback) {        super(Looper.myLooper(), callback);    }    public GlobalHandler(Looper looper, Callback callback) {        super(looper, callback);    }    public GlobalHandler(Looper looper) {        super(looper);    }    @Override    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {        boolean send = super.sendMessageAtTime(msg, uptimeMillis);        // 1        if (send) {            GetDetailHandlerHelper.getMsgDetail().put(msg, Log.getStackTraceString(new Throwable()).replace(&quot;java.lang.Throwable&quot;, &quot;&quot;));        }        return send;    }    @Override    public void dispatchMessage(Message msg) {        mStartTime = System.currentTimeMillis();        super.dispatchMessage(msg);        if (GetDetailHandlerHelper.getMsgDetail().containsKey(msg)            &amp;&amp; Looper.myLooper() == Looper.getMainLooper()) {            JSONObject jsonObject = new JSONObject();            try {                // 2                jsonObject.put(&quot;Msg_Cost&quot;, System.currentTimeMillis() - mStartTime);                jsonObject.put(&quot;MsgTrace&quot;, msg.getTarget() + &quot; &quot; + GetDetailHandlerHelper.getMsgDetail().get(msg));                // 3                LogHelper.i(&quot;MsgDetail &quot; + jsonObject.toString());                GetDetailHandlerHelper.getMsgDetail().remove(msg);            } catch (Exception e) {            }        }    }}</code></pre><p>上面的GlobalHandler将会是我们项目中所有Handler的一个父类。在注释1处，我们在sendMessageAtTime这个方法里面判断如果message发送成功，将会把当前message对象对应的调用栈信息都保存到一个ConcurrentHashMap中，GetDetailHandlerHelper类的代码如下所示：</p><pre><code>public class GetDetailHandlerHelper {    private static ConcurrentHashMap&lt;Message, String&gt; sMsgDetail = new ConcurrentHashMap&lt;&gt;();    public static ConcurrentHashMap&lt;Message, String&gt; getMsgDetail() {        return sMsgDetail;    }}</code></pre><p>这样，我们就能够知道这个message它是被谁发送过来的。然后，在dispatchMessage方法里面，我们可以计算拿到其处理消息的一个耗时，并在注释2处将这个耗时保存到一个jsonObject对象中，同时，我们也可以通过GetDetailHandlerHelper类的ConcurrentHashMap对象拿到这个message对应的堆栈信息，并在注释3处将它们输出到log控制台上，当然，如果是线上监控，则会把这些信息保存到本地，然后选择合适的时间去上传。最后，我们还可以在方法体里面做一个判断，我们设置一个阈值，比如阈值为20ms，超过了20ms就把这些保存好的信息上报到APM后台。</p><p>在前面的实战演练中，我们使用了handler post的方式去发送一个消息，通过gradle插件将所有handler的父类替换为我们定制好的GlobalHandler之后，我们就可以优雅地去监控应用中的耗时盲区了。</p><p>对于实现全局替换handler的gradle插件，除了使用AspectJ实现之外，这里推荐一个已有的项目：<a href="https://github.com/didi/DroidAssist" target="_blank" rel="external">DroidAssist</a>。</p><p>然后，重新运行项目，关键的log信息如下所示：</p><pre><code>MsgDetail {&quot;Msg_Cost&quot;:1001,&quot;MsgTrace&quot;:&quot;Handler (com.json.chao.com.wanandroid.performance.handler.GlobalHandler) {b0d4d48} \n\tat com.json.chao.com.wanandroid.performance.handler.GlobalHandler.sendMessageAtTime(GlobalHandler.java:36)\n\tatjson.chao.com.wanandroid.ui.main.activity.MainActivity.initEventAndData$__twin__(MainActivity.java:107)\n\tat&quot;</code></pre><p>从以上信息我们不仅可以知道message执行的时间，还可以从对应的堆栈信息中得到发送message的位置，这里的位置是MainActivity的107行，也就是new Handler().post()这一行代码。使用这种方式我们就可以知道在列表展示之前到底执行了哪些自定义的message，我们一眼就可以知道哪些message其实是不符合我们预期的，比如说message的执行时间过长，或者说这个message其实可以延后执行，这个我们都可以根据实际的项目和业务需求进行相应地修改。</p><h3 id="4、耗时盲区监控方案总结"><a href="#4、耗时盲区监控方案总结" class="headerlink" title="4、耗时盲区监控方案总结"></a>4、耗时盲区监控方案总结</h3><p>耗时盲区监控是我们卡顿监控中不可或缺的一个环节，也是卡顿监控全面性的一个重要保障。而需要注意的是，TraceView仅仅适用于线下的一个场景，同时对于TraceView来说，它可以用于监控我们系统的message。而最后介绍的动态替换的方式其实是适合于线上的，同时，它只有应用自身的一个message。</p><h2 id="五、卡顿优化技巧总结"><a href="#五、卡顿优化技巧总结" class="headerlink" title="五、卡顿优化技巧总结"></a>五、卡顿优化技巧总结</h2><h3 id="1、卡顿优化实践经验"><a href="#1、卡顿优化实践经验" class="headerlink" title="1、卡顿优化实践经验"></a>1、卡顿优化实践经验</h3><p>如果应用出现了卡顿现象，那么可以考虑以下方式进行优化：</p><ul><li>首先，对于耗时的操作，我们可以考虑异步或延迟初始化的方式，这样可以解决大多数的问题。但是，大家一定要注意代码的优雅性。</li><li>对于布局加载优化，可以采用AsyncLayoutInflater或者是X2C的方式来优化主线程IO以及反射导致的消耗，同时，需要注意，对于重绘问题，要给与一定的重视。</li><li>此外，内存问题也可能会导致应用界面的卡顿，我们可以通过降低内存占用的方式来减少GC的次数以及时间，而GC的次数和时间我们可以通过log查看。</li></ul><p>然后，我们来看看卡顿优化的工具建设。</p><h3 id="2、卡顿优化工具建设"><a href="#2、卡顿优化工具建设" class="headerlink" title="2、卡顿优化工具建设"></a>2、卡顿优化工具建设</h3><p>工具建设这块经常容易被大家所忽视，但是它的收益却非常大，也是卡顿优化的一个重点。首先，对于系统工具而言，我们要有一个认识，同时一定要学会使用它，这里我们再回顾一下。</p><ul><li>对于Systrace来说，我们可以很方便地看出来它的CPU使用情况。另外，它的开销也比较小。</li><li>对于TraceView来说，我们可以很方便地看出来每一个线程它在特定的时间内做了什么操作，但是TraceView它的开销相对比较大，有时候可能会被带偏优化方向。</li><li>同时，需要注意，StrictMode也是一个非常强大的工具。</li></ul><p>然后，我们介绍了自动化工具建设以及优化方案。我们介绍了两个工具，AndroidPerformanceMonitor以及ANR-WatchDog。同时针对于AndroidPerformanceMonitor的问题，我们采用了高频采集，以找出重复率高的堆栈这样一种方式进行优化，在学习的过程中，我们不仅需要学会怎样去使用工具，更要去理解它们的实现原理以及各自的使用场景。</p><p>同时，我们对于卡顿优化工具的建设也做了细化，对于单点问题，比如说IPC监控，我们通过AOP或者是Hook的手段来做到尽早的发现问题。对于耗时盲区的监控，我们在线上采用的是替换Handler的方式来监控所有子线程message执行的耗时以及调用堆栈。</p><p>最后，我们来看一下卡顿监控的指标。我们会计算应用整体的卡顿率，ANR率、界面秒开率以及交换时间、生命周期时间等等。在上报ANR信息的同时，我们也需要上报环境和场景信息，这样不仅方便我们在不同版本之家进行横向对比，同时，也可以结合我们的报警平台在第一时间感知到异常。</p><h2 id="六、常见卡顿问题解决方案总结"><a href="#六、常见卡顿问题解决方案总结" class="headerlink" title="六、常见卡顿问题解决方案总结"></a>六、常见卡顿问题解决方案总结</h2><h3 id="1、CPU资源争抢引发的卡顿问题如何解决？"><a href="#1、CPU资源争抢引发的卡顿问题如何解决？" class="headerlink" title="1、CPU资源争抢引发的卡顿问题如何解决？"></a>1、CPU资源争抢引发的卡顿问题如何解决？</h3><p>此时，我们的应用不仅应该控制好核心功能的CPU消耗，也需要尽量减少非核心需求的CPU消耗。</p><h3 id="2、要注意Android-Java中提供的哪些低效的API？"><a href="#2、要注意Android-Java中提供的哪些低效的API？" class="headerlink" title="2、要注意Android Java中提供的哪些低效的API？"></a>2、要注意Android Java中提供的哪些低效的API？</h3><p>比如List.removeall方法，它内部会遍历一次需要过滤的消息列表，在已经存在循环列表的情况下会造成CPU资源的冗余使用，此时应该去优化相关的算法，避免使用List.removeall这个方法。</p><h3 id="3、如何减少图形处理的CPU消耗？"><a href="#3、如何减少图形处理的CPU消耗？" class="headerlink" title="3、如何减少图形处理的CPU消耗？"></a>3、如何减少图形处理的CPU消耗？</h3><p>这个时候我们需要使用神器renderscript来图形处理的相关运算，将CPU转换到GPU。关于renderscript的背景知识可以看看笔者之前写的<a href="https://juejin.im/post/5e1e6cf66fb9a0301828ca0a#heading-25" target="_blank" rel="external">深入探索Android布局优化（下）</a>。</p><h3 id="4、硬件加速长中文字体渲染时造成的卡顿如何解决？"><a href="#4、硬件加速长中文字体渲染时造成的卡顿如何解决？" class="headerlink" title="4、硬件加速长中文字体渲染时造成的卡顿如何解决？"></a>4、硬件加速长中文字体渲染时造成的卡顿如何解决？</h3><p>此时只能关闭文本TextView的硬件加速，如下所示：</p><pre><code>textView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</code></pre><p>当开启了硬件加速进行长中文字体的渲染时，首先会调用ViewRootImpl.draw()方法，最后会调用GLES20Canvas.nDrawDisplayList()方法开始通过JNI调整到Native层。在这个方法里，会继续调用OpenGLRenderer.drawDisplayList()方法，它通过调用DisplayList的replay方法，以回放前面录制的DisplayList执行绘制操作。</p><p>DisplayList的replay方法会遍历DisplayList中保存的每一个操作。其中渲染字体的操作名是DrawText，当遍历到一个DrawText操作时，会调用OpenGLRender::drawText方法区渲染字体。最终，会在OpenGLRender::drawText方法里去调用Font::render()方法渲染字体，而在这个方法中有一个很关键的操作，即获取字体缓存。我们都知道每一个中文的编码都是不同的，因此中文的缓存效果非常不理想，但是对于英文而言，只需要缓存26个字母就可以了。在Android 4.1.2版本之前对文本的Buffer设置过小，所以情况比较严重，如果你的应用在其它版本的渲染性能尚可，就可以仅仅把Android 4.0.x的硬件加速关闭，代码如下所示：</p><pre><code>// AndroidManifest中&lt;Applicaiton        ...        android:hardwareAccelerated=&quot;@bool/hardware_acceleration&quot;&gt;// value-v14、value-v15中设置相应的Bool值即可&lt;bool name=&quot;hardware_acceleration&quot;&gt;false&lt;/bool&gt;</code></pre><p>此外，硬件渲染还有一些其它的问题在使用时需要注意，具体为如下所示：</p><ul><li>1、在软件渲染的情况下，如果需要重绘某个父View的所有子View，只需要调用这个Parent View的invalidate()方法即可，但如果开启了硬件加速，这么做是行不通的，需要遍历整个子View并调用invalidate()。</li><li>2、在软件渲染的情况下，会常常使用Bitmap重用的方式来节省内存，但是如果开启了硬件加速，这将会无效。</li><li>3、当开启硬件加速的UI在前台运行时，需要耗费额外的内存。当硬件加速的UI切换到后台时，上述额外内存有可能不会释放，这大多存在于Android 4.1.2版本中。</li><li>4、长或宽大于2048像素的Bitmap无法绘制，显示为一片透明。原因是OpenGL的材质大小上限为2048<em>2048，因此对于超过2048像素的Bitmap，需要将其切割成2048</em>2048以内的图片块，最后在显示的时候拼起来。</li><li>5、当UI中存在过渡绘制时，可能会发生花屏，一般来说绘制少于5层不会出现花屏现象，如果有大块红色区域就要十分小心了。</li><li>6、需要注意，关于LAYER_TYPE_SOFTWARE，虽然无论在App打开硬件加速或没有打开硬件加速的时候，都会通过软件绘制Bitmap作为离屏缓存，但区别在于打开硬件加速的时候，Bitmap最终还会通过硬件加速方式drawDisplayList去渲染这个Bitmap。</li></ul><h2 id="七、卡顿优化的常见问题"><a href="#七、卡顿优化的常见问题" class="headerlink" title="七、卡顿优化的常见问题"></a>七、卡顿优化的常见问题</h2><h3 id="1、你是怎么做卡顿优化的？"><a href="#1、你是怎么做卡顿优化的？" class="headerlink" title="1、你是怎么做卡顿优化的？"></a>1、你是怎么做卡顿优化的？</h3><p>从项目的初期到壮大期，最后再到成熟期，每一个阶段都针对卡顿优化做了不同的处理。各个阶段所做的事情如下所示：</p><ul><li>1、系统工具定位、解决</li><li>2、自动化卡顿方案及优化</li><li>3、线上监控及线下监测工具的建设</li></ul><p>我做卡顿优化也是经历了一些阶段，最初我们的项目当中的一些模块出现了卡顿之后，我是通过系统工具进行了定位，我使用了Systrace，然后看了卡顿周期内的CPU状况，同时结合代码，对这个模块进行了重构，将部分代码进行了异步和延迟，在项目初期就是这样解决了问题。但是呢，随着我们项目的扩大，线下卡顿的问题也越来越多，同时，在线上，也有卡顿的反馈，但是线上的反馈卡顿，我们在线下难以复现，于是我们开始寻找自动化的卡顿监测方案，其思路是来自于Android的消息处理机制，主线程执行任何代码都会回到Looper.loop方法当中，而这个方法中有一个mLogging对象，它会在每个message的执行前后都会被调用，我们就是利用这个前后处理的时机来做到的自动化监测方案的。同时，在这个阶段，我们也完善了线上ANR的上报，我们采取的方式就是监控ANR的信息，同时结合了ANR-WatchDog，作为高版本没有文件权限的一个补充方案。在做完这个卡顿检测方案之后呢，我们还做了线上监控及线下检测工具的建设，最终实现了一整套完善，多维度的解决方案。</p><h3 id="2、你是怎么样自动化的获取卡顿信息？"><a href="#2、你是怎么样自动化的获取卡顿信息？" class="headerlink" title="2、你是怎么样自动化的获取卡顿信息？"></a>2、你是怎么样自动化的获取卡顿信息？</h3><p>我们的思路是来自于Android的消息处理机制，主线程执行任何代码它都会走到Looper.loop方法当中，而这个函数当中有一个<strong>mLogging</strong>对象，它会在每个message处理前后都会被调用，而主线程发生了卡顿，那就一定会在dispatchMessage方法中执行了耗时的代码，那我们在这个message执行之前呢，我们可以在子线程当中去postDelayed一个任务，这个Delayed的时间就是我们设定的阈值，如果主线程的messaege在这个阈值之内完成了，那就取消掉这个子线程当中的任务，如果主线程的message在阈值之内没有被完成，那子线程当中的任务就会被执行，它会获取到当前主线程执行的一个堆栈，那我们就可以知道哪里发生了卡顿。</p><p>经过实践，我们发现这种方案获取的堆栈信息它不一定是准确的，因为获取到的堆栈信息它很可能是主线程最终执行的一个位置，而真正耗时的地方其实已经执行完成了，于是呢，我们就对这个方案做了一些优化，我们采取了<strong>高频采集</strong>的方案，也就是在一个周期内我们会多次采集主线程的堆栈信息，如果发生了卡顿，那我们就将这些卡顿信息压缩之后上报给APM后台，然后找出重复的堆栈信息，这些重复发生的堆栈大概率就是卡顿发生的一个位置，这样就提高了获取卡顿信息的一个准确性。</p><h3 id="3、卡顿的一整套解决方案是怎么做的？"><a href="#3、卡顿的一整套解决方案是怎么做的？" class="headerlink" title="3、卡顿的一整套解决方案是怎么做的？"></a>3、卡顿的一整套解决方案是怎么做的？</h3><p>首先，针对卡顿，我们采用了<strong>线上、线下工具相结合</strong>的方式，线下工具我们册中医药尽可能早地去暴露问题，而针对于线上工具呢，我们侧重于监控的全面性、自动化以及异常感知的灵敏度。</p><p>同时呢，卡顿问题还有很多的难题。比如说<strong>有的代码呢，它不到你卡顿的一个阈值，但是执行过多，或者它错误地执行了很多次，它也会导致用户感官上的一个卡顿</strong>，所以我们在线下通过AOP的方式对常见的耗时代码进行了Hook，然后对一段时间内获取到的数据进行分析，我们就可以知道这些耗时的代码发生的时机和次数以及耗时情况。然后，看它是不是满足我们的一个预期，不满足预期的话，我们就可以直接到线下进行修改。同时，卡顿监控它还有很多容易被忽略的一个<strong>盲区</strong>，比如说生命周期的一个间隔，那对于这种特定的问题呢，我们就采用了编译时注解的方式修改了项目当中所有Handler的父类，对于其中的两个方法进行了监控，我们就可以知道主线程message的执行时间以及它们的调用堆栈。</p><p>对于<strong>线上卡顿</strong>，我们除了计算App的卡顿率、ANR率等常规指标之外呢，我们还计算了页面的秒开率、生命周期的执行时间等等。而且，在卡顿发生的时刻，我们也尽可能多地保存下来了当前的一个场景信息，这为我们之后解决或者复现这个卡顿留下了依据。</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>恭喜你，如果你看到了这里，你会发现要做好应用的卡顿优化的确不是一件简单的时，它需要你有成体系的知识构建基底。最后，我们再来回顾一下面对卡顿优化，我们已经探索的以下九大主题：</p><ul><li>1、卡顿优化分析方法与工具：背景介绍、卡顿分析方法之使用shell命令分析CPU耗时、卡顿优化工具。</li><li>2、自动化卡顿检测方案及优化：卡顿检测方案原理、AndroidPerformanceMonitor实战及其优化。</li><li>3、ANR分析与实战：ANR执行流程、线上ANR监控方式、ANR-WatchDog原理。</li><li>4、卡顿单点问题检测方案：IPC单点问题检测方案、卡顿问题检测方案。</li><li>5、如何实现界面秒开？：界面秒开实现、Lancet、界面秒开监控纬度。</li><li>6、优雅监控耗时盲区：耗时盲区监控难点以及线上与线下的监控方案。</li><li>7、卡顿优化技巧总结：卡顿优化实践经验、卡顿优化工具建设。</li><li>8︎、常见卡顿问题解决方案总结</li><li>9、卡顿优化的常见问题</li></ul><p>相信看到这里，你一定收获满满，但是要记住，方案再好，也只有自己动手去实践，才能真正地掌握它。<strong>只有重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。</strong></p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第6章 卡顿优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="external">极客时间之Android开发高手课 卡顿优化</a></p><p>3、《Android移动性能实战》第四章 CPU</p><p>4、《Android移动性能实战》第七章 流畅度</p><p>5、<a href="https://blog.csdn.net/lindroid/article/details/90904947" target="_blank" rel="external">Android dumpsys cpuinfo 信息解读</a></p><p>6、<a href="https://www.zhihu.com/question/20448467" target="_blank" rel="external">如何清楚易懂的解释“UV和PV＂的定义？</a></p><p>7、<a href="https://github.com/uber/nanoscope" target="_blank" rel="external">nanoscope-An extremely accurate Android method tracing tool</a></p><p>8、<a href="https://github.com/didi/DroidAssist" target="_blank" rel="external">DroidAssist-A lightweight Android Studio gradle plugin based on Javassist for editing bytecode in Android.</a></p><p>9、<a href="https://github.com/eleme/lancet" target="_blank" rel="external">lancet-A lightweight and fast AOP framework for Android App and SDK developers</a></p><p>10、<a href="https://github.com/zhengcx/MethodTraceMan" target="_blank" rel="external">MethodTraceMan-用于快速找到高耗时方法，定位解决Android App卡顿问题</a></p><p>11、<a href="http://www.samirchen.com/linux-cpu-performance/" target="_blank" rel="external">Linux环境下进程的CPU占用率</a></p><p>12、<a href="https://source.android.com/devices/tech/debug/ftrace?hl=zh-cn" target="_blank" rel="external">使用 ftrace</a></p><p>13、<a href="https://github.com/facebookincubator/profilo" target="_blank" rel="external">profilo-A library for performance traces from production</a></p><p>14、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html" target="_blank" rel="external">ftrace 简介</a></p><p>15、<a href="https://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp" target="_blank" rel="external">atrace源码</a></p><p>16、<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06" target="_blank" rel="external">AndroidAdvanceWithGeektime<br>/ Chapter06</a></p><p>17、<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus" target="_blank" rel="external">AndroidAdvanceWithGeektime<br>/ Chapter06-plus</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/Awesome-Android.png" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/02/05/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android卡顿优化（上）</title>
      <link>http://yoursite.com/2020/01/26/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/</link>
      <guid>http://yoursite.com/2020/01/26/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/</guid>
      <pubDate>Sun, 26 Jan 2020 12:12:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>在上篇，笔者详细分析了目前的App绘制与布局优化的相关优化方案，如果对绘制优化与布局优化还不是非常熟悉的可以仔细看看前几篇文章的<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>、<a href="https://juejin.im/post/5e1d15a851882536ca666a49" target="_blank" rel="external">深入探索Android布局优化（上）</a>、<a href="https://juejin.im/post/5e1e6cf66fb9a0301828ca0a" target="_blank" rel="external">深入探索Android布局优化（下）</a>。由于卡顿优化这一主题包含的内容太多，因此，笔者将它分为了上、下两篇，本篇，即为深入探索Android卡顿优化的上篇。本篇包含的主要内容如下所示：</p><ul><li>1、卡顿优化分析方法与工具</li><li>2、自动化卡顿检测方案及优化</li></ul><p>在我们使用各种各样的App的时候，有时会看见有些App运行起来并不流畅，即出现了卡顿现象，那么如何去定义发生了卡顿现象呢？如果App的FPS平均值小于30，最小值小于24，即表明应用发生了卡顿。那我么又如何去分析应用是否出现了卡顿呢？下面，我们就先来了解一下解决卡顿问题时常用到的分析方法与工具。</p><h2 id="一、卡顿优化分析方法与工具"><a href="#一、卡顿优化分析方法与工具" class="headerlink" title="一、卡顿优化分析方法与工具"></a>一、卡顿优化分析方法与工具</h2><h3 id="1、背景介绍"><a href="#1、背景介绍" class="headerlink" title="1、背景介绍"></a>1、背景介绍</h3><ul><li>很多性能问题不易被发现，但是卡顿问题很容易被直观感受。</li><li>卡顿问题难以定位。</li></ul><h4 id="那么卡顿问题到底难在哪里呢？"><a href="#那么卡顿问题到底难在哪里呢？" class="headerlink" title="那么卡顿问题到底难在哪里呢？"></a>那么卡顿问题到底难在哪里呢？</h4><ul><li>1、卡顿产生的原因是错综复杂的，它涉及到代码、内存、绘制、IO、CPU等等。</li><li>2、线上的卡顿问题在线下是很难复现的，因为它与当时的场景是强相关的，比如说线上用户的磁盘IO空间不足了，它影响了磁盘IO的写入性能，所以导致卡顿。针对这种问题，我们最好在发现卡顿的时候尽量地去记录用户当时发生卡顿时的具体的场景信息。</li></ul><h3 id="2、卡顿分析方法之使用shell命令分析CPU耗时"><a href="#2、卡顿分析方法之使用shell命令分析CPU耗时" class="headerlink" title="2、卡顿分析方法之使用shell命令分析CPU耗时"></a>2、卡顿分析方法之使用shell命令分析CPU耗时</h3><p>造成卡顿的原因有很多种，不过最终都会反映到CPU时间上。</p><p>CPU时间包含用户时间和系统时间。</p><ul><li>用户时间：执行用户态应用程序代码所消耗的时间。</li><li>系统时间：执行内核态系统调用所消耗的时间，包括I/O、锁、中断和其它系统调用所消耗的时间。</li></ul><p>CPU的问题可以分为以下三类：</p><p><strong>1、CPU资源冗余使用</strong></p><ul><li>算法效率太低：明明可以遍历一次的却需要去遍历两次，主要出现在查找、排序、删除等环节。</li><li>没有使用cache：明明解码过一次的图片还去重复解码。</li><li>计算时使用的基本类型不对：明明使用int就足够，却要使用long，这会导致CPU的运算压力多出4倍。</li></ul><p><strong>2、CPU资源争抢</strong></p><ul><li>抢主线程的CPU资源：这是最常见的问题，并且在Android 6.0版本之前没有renderthread的时候，主线程的繁忙程度就决定了是否会引发用户的卡顿问题。</li><li>抢音视频的CPU资源：音视频编解码本身会消耗大量的CPU资源，并且其对于解码的速度是由硬要求的，达不到就可能产生播放流畅度的问题。我们可以采取两种方式去优化：1、尽量排除非核心业务的消耗。2、优化自身的性能消耗，把CPU负载转化为GPU负载，如使用renderscript来处理视频中的影像信息。</li><li>大家平等，互相抢：比如在自定义的相册中，我开了20个线程做图片解码，那就是互相抢CPU了，结果就是会导致图片的显示速度非常慢。这简直就是三个和尚没水喝的典型案例。因此，我们需要按照系统核心数去控制线程数。</li></ul><p><strong>3、CPU资源利用率低</strong></p><p>对于启动、界面切换、音视频编解码这些场景，为了保证其速度，我们需要去好好利用CPU。而导致无法充分利用CPU的因素，不仅有磁盘和网络I/O，还有锁操作、sleep等等。对于锁的优化，通常是尽可能地缩减锁的范围。</p><h4 id="1、了解CPU-性能"><a href="#1、了解CPU-性能" class="headerlink" title="1、了解CPU 性能"></a>1、了解CPU 性能</h4><p>我们可以通过CPU的主频、核心数、缓存等参数去评估CPU的性能，这些参数的好坏能表现出CPU计算能力和指令执行能力的强弱，也就是CPU每秒执行的浮点计算数和每秒执行的指令数的多少。</p><p>此外，现在最新的主流机型都使用了多级能效的CPU架构（即多核分层架构），以确保在平常低负荷工作时能仅使用低频核心来节省电量。</p><p>此外，我们还可以通过shell命令直接查看手机的CPU核心数与频率等信息，如下所示：</p><pre><code>// 先输入adb shell进入手机的shell环境adb shell// 获取 CPU 核心数，我的手机是8核platina:/ $ cat /sys/devices/system/cpu/possible0-7// 获取第一个 CPU 的最大频率platina:/ $ cat/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq                         &lt;1843200// 获取第二个CPU的最小频率platina:/ $ cat/sys/devices/system/cpu/cpu1/cpufreq/cpuinfo_min_freq                         &lt;633600</code></pre><p>从 CPU 到 GPU 再到 AI 芯片（如专为神经网络计算打造的 NPU（Neural network Processing Unit）），随着手机 CPU 整体性能的飞跃，医疗诊断、图像超清化等一些 AI 应用场景也可以在移动端更好地落地。我们可以充分利用移动端的计算能力来降低高昂的服务器成本。</p><p>此外，CPU的性能越好，应用就能获得更好的支持，如线程池可以根据不同手机的CPU核心数来配备不同的线程数,仅在手机主频比较高或者带有NPU的设备去开启一些高级的AI功能。</p><h4 id="2、通过读取-proc-stat与-proc-PID-stat文件来计算并评估系统的CPU耗时情况"><a href="#2、通过读取-proc-stat与-proc-PID-stat文件来计算并评估系统的CPU耗时情况" class="headerlink" title="2、通过读取/proc/stat与/proc/[PID]/stat文件来计算并评估系统的CPU耗时情况"></a>2、通过读取/proc/stat与/proc/[PID]/stat文件来计算并评估系统的CPU耗时情况</h4><p>当应用出现卡顿问题之后，首先我们应该查看系统CPU的使用率。</p><p>首先，我们通过读取 /proc/stat 文件获取总的 CPU 时间，并读取 /proc/[PID]/stat 获取应用进程 的CPU 时间，然后，采样两个足够短的时间间隔的 CPU 快照与进程快照来计算其 CPU 使用率。</p><h5 id="计算总的-CPU-使用率"><a href="#计算总的-CPU-使用率" class="headerlink" title="计算总的 CPU 使用率"></a>计算总的 CPU 使用率</h5><p>1、采样两个足够短的时间间隔的 CPU 快照，即需要前后两次去读取 /proc/stat 文件，获取两个时间点对应的数据，如下所示：</p><pre><code>// 第一次采样platina:/ $ cat /proc/statcpu  9931551 1082101 9002534 174463041 340947 1060438 1088978 0 0 0cpu0 2244962 280573 2667000 22414199 99651 231869 439918 0 0 0cpu1 2672378 421880 2943791 21540302 121818 236850 438733 0 0 0cpu2 1648512 76856 1431036 25868789 46970 107094 52025 0 0 0cpu3 1418757 41280 1397203 25772984 40292 110168 41667 0 0 0cpu4 573203 79498 178263 19618235 9577 307949 10875 0 0 0cpu5 522638 67978 155454 19684358 8793 19787 4603 0 0 0cpu6 458438 64085 132252 19749439 8143 19942 98241 0 0 0cpu7 392663 49951 97535 19814735 5703 26779 2916 0 0 0intr...// 第二次采样platina:/ $ cat /proc/statcpu  9931673 1082113 9002679 174466561 340954 1060446 1088994 0 0 0cpu0 2244999 280578 2667032 22414604 99653 231869 439918 0 0 0cpu1 2672434 421881 2943861 21540606 121822 236855 438747 0 0 0cpu2 1648525 76859 1431054 25869234 46971 107095 52026 0 0 0cpu3 1418773 41283 1397228 25773412 40292 110170 41668 0 0 0cpu4 573203 79498 178263 19618720 9577 307949 10875 0 0 0cpu5 522638 67978 155454 19684842 8793 19787 4603 0 0 0cpu6 458438 64085 132252 19749923 8143 19942 98241 0 0 0cpu7 392663 49951 97535 19815220 5703 26779 2916 0 0 0int...    </code></pre><p>因为我的手机是8核，所以这里的cpu个数是8个，从cpu0到cpu7，第一行的cpu即是8个cpu的指标数据汇总，因为是要计算系统cpu的使用率，那当然应该以cpu为基准了。两次采样的CPU指标数据如下：</p><pre><code>cpu1  9931551 1082101 9002534 174463041 340947 1060438 1088978 0 0 0cpu2  9931673 1082113 9002679 174466561 340954 1060446 1088994 0 0 0</code></pre><p>其对应的各项指标如下：</p><pre><code>CPU (user, nice, system, idle, iowait, irq, softirq, stealstolen, guest);</code></pre><p>拿cpu1（9931551 1082101 9002534 174463041 340947 1060438 1088978 0 0 0）的数据来说，下面，我就来详细解释下这些指标的含义。</p><ul><li>user(9931551)： 表示从系统启动开始至今处于用户态的运行时间，注意不包含 nice 值为负的进程。</li><li>nice(1082101) ：表示从系统启动开始至今nice 值为负的进程所占用的 CPU 时间。</li><li>system(9002534)： 表示从系统启动开始至今处于内核态的运行时间。</li><li>idle(174463041) ：表示从系统启动开始至今除 IO 等待时间以外的其他等待时间。</li><li>iowait(340947)：表示从系统启动开始至今的IO 等待时间。(从Linux V2.5.41开始)</li><li>irq(1060438)：表示从系统启动开始至今的硬中断时间。(从Linux V2.6.0-test4开始)</li><li>softirq(1088978)：表示从系统启动开始至今的软中断时间。(从Linux V2.6.0-test4开始)</li><li>stealstolen(0) ：表示当在虚拟化环境中运行时在其他操作系统中所花费的时间。在Android系统下此值为0。(从Linux V2.6.11开始)</li><li>guest(0) ：表示当在Linux内核的控制下为其它操作系统运行虚拟CPU所花费的时间。在Android系统下此值为0。(从 V2.6.24开始)</li></ul><p>此外，这些数值的单位都是 jiffies，<strong>jiffies 是内核中的一个全局变量，用来记录系统启动以来产生的节拍数，在 Linux 中，一个节拍大致可以理解为操作系统进程调度的最小时间片，不同的 Linux 系统内核这个值可能不同，通常在 1ms 到 10ms 之间</strong>。</p><p>了解了/proc/stat命令下各项参数的含义之后，我们就可以由前后两次时间点的CPU数据计算得到cpu1与cpu2的活动时间，如下所示：</p><pre><code>totalCPUTime = user + nice + system + idle + iowait + irq + softirq + stealstolen + guest cpu1 = 9931551 + 1082101 + 9002534 +  174463041 + 340947 + 1060438 + 1088978 + 0  + 0 + 0 = 196969590jiffiescpu2 = 9931673 + 1082113 + 9002679 +  174466561 + 340954 + 1060446 + 1088994 + 0 + 0 + 0 = 196973420jiffies</code></pre><p>因此可得出总的CPU时间如下所示：</p><pre><code>totalCPUTime = CPU2 – CPU1 = 3830jiffies</code></pre><p>最后，我们就可以计算出系统CPU的使用率，如下所示：</p><pre><code>// 先计算得到CPU的空闲时间idleCPUTime = idle2 – idle1 = 3520jiffies// 最后得到系统CPU的使用率totalCPUUse = (totalCPUTime – idleCPUTime) / totalCPUTime = （3830 - 3520）/ 3830 = 8%</code></pre><p>可以看到，前后两次时间点间的CPU使用率大概为8%，说明我们系统的CPU是处于空闲状态的，如果CPU 使用率一直大于 60% ，则表示系统处于繁忙状态，此时就需要进一步分析用户时间和系统时间的比例，看看到底是系统占用了CPU还是应用占用了CPU。</p><h4 id="3、使用top命令查看应用进程的CPU消耗情况"><a href="#3、使用top命令查看应用进程的CPU消耗情况" class="headerlink" title="3、使用top命令查看应用进程的CPU消耗情况"></a>3、使用top命令查看应用进程的CPU消耗情况</h4><p>此外，由于Android是基于Linux内核改造而成的操作系统，自然而然也能使用Linux的一些常用命令。比如我们可以使用top命令查看哪些进程是 CPU 的主要消耗者。</p><pre><code>1|platina:/ $ topPID USER         PR  NI VIRT  RES  SHR S[%CPU] %MEM     TIME+ ARGS12700 u0_a945      10 -10 4.3G 122M  67M S 15.6   2.1   1:06.41 json.chao.com.w+753 system       RT   0  90M 1.1M 1.0M S 13.6   0.0 127:47.73 android.hardwar+2064 system       18  -2 4.6G 309M 215M S 12.3   5.4 978:15.18 system_server22142 u0_a163      20   0 2.0G  97M  41M S 10.3   1.6   2:22.99 com.tencent.mob+2293 system       20   0 4.7G 250M  87M S  8.6   4.3 353:15.77 com.android.sys+</code></pre><p>从以上可知我们的Awesome-WanAndroid应用进程占用了15%的CPU。此外，这里列举下最常用的top命令，如下所示：</p><pre><code>// 排除0%的进程信息adb shell top | grep -v &apos;0% S&apos;// 只打印1次按CPU排序的TOP 10的进程信息adb shell top -m 10 -s cpu -n 1|platina:/ $ top -d 1|grep json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S 13.8   2.2   1:04.46 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S 19.0   2.2   1:04.51 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S 15.0   2.2   1:04.70 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S  9.0   2.2   1:04.85 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S 26.0   2.2   1:04.94 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S  9.0   2.2   1:05.20 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M R 17.0   2.2   1:05.29 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S 20.0   2.2   1:05.46 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S  9.0   2.2   1:05.66 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M R 21.0   2.2   1:05.75 json.chao.com.w+5689 u0_a945      10 -10 4.3G 129M  71M S 14.0   2.2   1:05.96 json.chao.com.w+</code></pre><h4 id="4、PS软件"><a href="#4、PS软件" class="headerlink" title="4、PS软件"></a>4、PS软件</h4><p>除了top命令可以比较全面地查看整体的CPU信息之外，如果我们只想查看当前指定进程已经消耗的CPU时间占系统总时间的百分比和其它的状态信息的话，可以使用ps命令，常用的ps命令如下所示：</p><pre><code>// 查看指定进程的状态信息platina:/ $ ps -p 31333USER           PID  PPID     VSZ    RSS WCHAN            ADDR S NAMEu0_a945      31333  1277 4521308 127460 0                   0 S json.chao.com.w+// 查看指定进程已经消耗的CPU时间占系统总时间的百分比platina:/ $ ps -o PCPU -p 31333%CPU10.8</code></pre><p>其中输出参数的含义如下所示：</p><ul><li>USER：用户名</li><li>PID：进程ID</li><li>PPID：父进程ID</li><li>VSZ：虚拟内存大小（1k为单位）</li><li>RSS：常驻内存大小（正在使用的页）</li><li>WCHAN：进程在内核态中的运行时间</li><li>Instruction pointer：指令指针</li><li>NAME：进程名字</li></ul><p>最后的输出参数S表示的是进程当前的状态，总共有10种可能的状态，如下所示：</p><pre><code>R (running) S (sleeping) D (device I/O) T (stopped)  t (traced)Z (zombie)  X (deader)   x (dead)       K (wakekill) W (waking)</code></pre><p>可以看到，我们当前主进程是休眠的状态。</p><h4 id="5、dumpsys-cpuinfo"><a href="#5、dumpsys-cpuinfo" class="headerlink" title="5、dumpsys cpuinfo"></a>5、dumpsys cpuinfo</h4><p>使用dumpsys cpuinfo命令获得的信息比起top命令得到的信息要更加精炼，如下所示：</p><pre><code>platina:/ $ dumpsys cpuinfoLoad: 1.92 / 1.59 / 0.97CPU usage from 45482ms to 25373ms ago (2020-02-04 17:00:37.666 to 2020-02-04 17:00:57.775):33% 2060/system_server: 22% user + 10% kernel / faults: 8152 minor 6 major17% 2292/com.android.systemui: 12% user + 4.7% kernel / faults: 21636 minor 3 major14% 750/android.hardware.sensors@1.0-service: 4.4% user + 10% kernel6.1% 778/surfaceflinger: 3.3% user + 2.7% kernel / faults: 128 minor3.3% 2598/com.miui.home: 2.8% user + 0.4% kernel / faults: 7655 minor 11 major2.2% 2914/cnss_diag: 1.6% user + 0.6% kernel1.9% 745/android.hardware.graphics.composer@2.1-service: 1.4% user + 0.5% kernel / faults: 5 minor1.7% 4525/kworker/u16:6: 0% user + 1.7% kernel1.6% 748/android.hardware.memtrack@1.0-service: 0.6% user + 0.9% kernel1.4% 4551/kworker/u16:14: 0% user + 1.4% kernel1.4% 31333/json.chao.com.wanandroid: 0.9% user + 0.4% kernel / faults: 3995 minor 22 major1.1% 6670/kworker/u16:0: 0% user + 1.1% kernel0.9% 448/mmc-cmdqd/0: 0% user + 0.9% kernel0.7% 95/system: 0% user + 0.7% kernel0.6% 4512/mdss_fb0: 0% user + 0.6% kernel0.6% 7393/com.android.incallui: 0.6% user + 0% kernel / faults: 2272 minor0.6% 594/logd: 0.4% user + 0.1% kernel / faults: 38 minor 3 major0.5% 3108/com.xiaomi.xmsf: 0.2% user + 0.2% kernel / faults: 1812 minor0.5% 4526/kworker/u16:9: 0% user + 0.5% kernel0.5% 4621/com.gotokeep.keep: 0.3% user + 0.1% kernel / faults: 55 minor0.5% 354/irq/267-NVT-ts: 0% user + 0.5% kernel0.5% 2572/com.android.phone: 0.3% user + 0.1% kernel / faults: 323 minor0.5% 4554/kworker/u16:15: 0% user + 0.5% kernel0.4% 290/kgsl_worker_thr: 0% user + 0.4% kernel0.3% 2933/irq/61-1008000.: 0% user + 0.3% kernel0.3% 3932/com.tencent.mm: 0.2% user + 0% kernel / faults: 647 minor 1 major0.3% 4550/kworker/u16:13: 0% user + 0.3% kernel0.3% 744/android.hardware.graphics.allocator@2.0-service: 0% user + 0.3% kernel / faults: 48 minor0.3% 8906/com.tencent.mm:appbrand0: 0.2% user + 0% kernel / faults: 45 minor0.2% 79/smem_native_rpm: 0% user + 0.2% kernel0.2% 759/vendor.qti.hardware.perf@1.0-service: 0% user + 0.2% kernel / faults: 46 minor0.2% 3197/com.miui.powerkeeper: 0% user + 0.1% kernel / faults: 141 minor0.2% 4489/kworker/1:1: 0% user + 0.2% kernel0.2% 595/servicemanager: 0% user + 0.2% kernel0.2% 754/android.hardware.wifi@1.0-service: 0.1% user + 0% kernel0.2% 1258/jbd2/dm-2-8: 0% user + 0.2% kernel0.2% 5800/com.eg.android.AlipayGphone: 0.1% user + 0% kernel / faults: 48 minor0.2% 21590/iptables-restore: 0% user + 0.1% kernel / faults: 563 minor0.2% 21592/ip6tables-restore: 0% user + 0.1% kernel / faults: 647 minor0.1% 3/ksoftirqd/0: 0% user + 0.1% kernel0.1% 442/cfinteractive: 0% user + 0.1% kernel0.1% 568/ueventd: 0% user + 0% kernel0.1% 1295/netd: 0% user + 0.1% kernel / faults: 250 minor0.1% 3002/com.miui.securitycenter.remote: 0.1% user + 0% kernel / faults: 818 minor 1 major0.1% 20555/com.eg.android.AlipayGphone:push: 0% user + 0% kernel / faults: 20 minor0.1% 7/rcu_preempt: 0% user + 0.1% kernel0.1% 15/ksoftirqd/1: 0% user + 0.1% kernel0.1% 76/lpass_smem_glin: 0% user + 0.1% kernel0.1% 1299/rild: 0.1% user + 0% kernel / faults: 12 minor0.1% 1448/android.process.acore: 0.1% user + 0% kernel / faults: 1719 minor0% 4419/com.google.android.webview:s: 0% user + 0% kernel / faults: 602 minor0% 20465/com.miui.hybrid: 0% user + 0% kernel / faults: 1575 minor0% 10/rcuop/0: 0% user + 0% kernel0% 75/smem_native_lpa: 0% user + 0% kernel0% 90/kcompactd0: 0% user + 0% kernel0% 1508/msm_irqbalance: 0% user + 0% kernel0% 1745/cds_mc_thread: 0% user + 0% kernel0% 2899/charge_logger: 0% user + 0% kernel0% 3612/com.tencent.mm:tools: 0% user + 0% kernel / faults: 29 minor0% 4203/kworker/0:0: 0% user + 0% kernel0% 7377/com.android.server.telecom:ui: 0% user + 0% kernel / faults: 1083 minor0% 32113/com.tencent.mobileqq: 0% user + 0% kernel / faults: 49 minor0% 8/rcu_sched: 0% user + 0% kernel0% 22/ksoftirqd/2: 0% user + 0% kernel0% 25/rcuop/2: 0% user + 0% kernel0% 29/ksoftirqd/3: 0% user + 0% kernel0% 39/rcuop/4: 0% user + 0% kernel0% 53/rcuop/6: 0% user + 0% kernel0% 487/irq/715-ima-rdy: 0% user + 0% kernel0% 749/android.hardware.power@1.0-service: 0% user + 0% kernel0% 764/healthd: 0% user + 0% kernel / faults: 2 minor0% 845/wlan_logging_th: 0% user + 0% kernel0% 860/mm-pp-dpps: 0% user + 0% kernel0% 1297/wificond: 0% user + 0% kernel / faults: 12 minor 0% 1309/com.miui.weather2: 0% user + 0% kernel / faults: 729 minor 23 major0% 1542/rild: 0% user + 0% kernel / faults: 3 minor0% 2915/tcpdump: 0% user + 0% kernel / faults: 6 minor0% 2974/com.tencent.mobileqq:MSF: 0% user + 0% kernel / faults: 121 minor0% 3044/com.miui.contentcatcher: 0% user + 0% kernel / faults: 315 minor0% 3057/com.miui.dmregservice: 0% user + 0% kernel / faults: 332 minor0% 3095/com.xiaomi.mircs: 0% user + 0% kernel0% 3115/com.xiaomi.finddevice: 0% user + 0% kernel / faults: 270 minor 3 major0% 3513/com.xiaomi.metoknlp: 0% user + 0% kernel / faults: 136 minor0% 3603/com.tencent.mm:toolsmp: 0% user + 0% kernel / faults: 35 minor0% 4527/kworker/u16:11: 0% user + 0% kernel0% 4841/com.gotokeep.keep:xg_service_v4: 0% user + 0% kernel / faults: 275 minor0% 5064/com.sohu.inputmethod.sogou.xiaomi: 0% user + 0% kernel / faults: 102 minor0% 5257/kworker/0:1: 0% user + 0% kernel0% 5839/com.tencent.mm:push: 0% user + 0% kernel / faults: 98 minor0% 6644/kworker/3:2: 0% user + 0% kernel0% 6657/com.miui.wmsvc: 0% user + 0% kernel / faults: 52 minor0% 6945/com.xiaomi.account:accountservice: 0% user + 0% kernel / faults: 1 minor0% 9387/com.tencent.mm:appbrand1: 0% user + 0% kernel / faults: 27 minor13% TOTAL: 6.8% user + 5.3% kernel + 0.2% iowait + 0.3% irq + 0.4% softirq</code></pre><p>从上述信息可知，第一行显示的是cpuload （负载平均值）信息：Load: 1.92 / 1.59 / 0.97<br>这三个数字表示逐渐变长的时间段（平均一分钟，五分钟和十五分钟）的平均值，而较低的数字则更好。数字越大表示问题或机器过载。需要注意的是，这里的Load需要除以核心数，这里的系统核心数为8核，所以最终每一个单核CPU的Load为0.24 / 0.20 / 0.12，如果Load超过1，则表示出现了问题。</p><p>此外，占用系统CPU资源最高的是system_server进程，而我们的wanandroid应用进程仅占用了<br>1.4%的CPU资源，其中有0.9%的是用户态所占用的时间，0.4%是内核态所占用的时间。最后，我们可以看到系统总占用的CPU时间是13%，这个值是根据<strong>前面所有值加起来 / 系统CPU数</strong>的处理的，也就是<strong>104% /  8 = 13%</strong>。</p><p>除了上述方式来分析系统与应用的CPU使用情况之外，我们还应该关注卡顿率与卡顿树这两个指标。它们能帮助我们有效地去评估、并且更有针对性地去优化应用发生的卡顿。</p><h5 id="卡顿率"><a href="#卡顿率" class="headerlink" title="卡顿率"></a>卡顿率</h5><p>类似于<a href="https://jsonchao.github.io/2019/11/24/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E7%A8%B3%E5%AE%9A%E6%80%A7%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android稳定性优化</a>一文中讲到的UV、PV崩溃率，卡顿也可以有其对应的UV、PV卡顿率，UV就是Unique visitor，指的就是一台手机客户端为一个访客，00:00-24:00内相同的客户端只被计算一次。而PV即Page View，即页面浏览量或点击量。所以UV、PV卡顿率的定义即为如下所示：</p><pre><code>// UV 卡顿率可以评估卡顿的影响范围UV 卡顿率 = 发生过卡顿 UV / 开启卡顿采集 UV// PV 卡顿率评估卡顿的严重程度PV 卡顿率 = 发生过卡顿 PV / 启动采集 PV</code></pre><p>因为卡顿问题的采样规则跟内存问题是相似的，一般都是采取抽样上报的方式，并且都应该按照单个用户来抽样。一个用户如果命中采集，那么在一天内都会持续的采集数据。</p><h5 id="卡顿树"><a href="#卡顿树" class="headerlink" title="卡顿树"></a>卡顿树</h5><p>我们可以实现卡顿的火焰图，即卡顿树，在一张图里就可以看到卡顿的整体信息。由于卡顿的具体耗时跟手机性能与当时的使用场景与环境密切相关，而且卡顿问题在日活大应用上出现的场景非常多，所以对于大于我们指定的卡顿阈值如1s\2s\3s时，我们就可以抛弃具体的耗时，只按照相同堆栈出现的比例来聚合各类卡顿信息。这样我们就能够很直观地从卡顿树上看到到底哪些堆栈出现的卡顿问题最多，以便于我们能够优先去解决 Top 的卡顿问题，达到使用最少的精力获取最大的优化效果的目的。</p><h3 id="3、卡顿优化工具"><a href="#3、卡顿优化工具" class="headerlink" title="3、卡顿优化工具"></a>3、卡顿优化工具</h3><h4 id="1、CPU-Profiler回顾"><a href="#1、CPU-Profiler回顾" class="headerlink" title="1、CPU Profiler回顾"></a>1、CPU Profiler回顾</h4><p>CPU Profiler的使用笔者已经在<a href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android启动速度优化</a>中详细分析过了，如果对CPU Profiler还不是很熟悉的话，可以去看看这篇文章。</p><p>下面我们来简单来回顾一下CPU Profiler。</p><h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><ul><li>图形的形式展示执行时间、调用栈等。</li><li>信息全面，包含所有线程。</li></ul><h5 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h5><p>运行时开销严重，整体都会变慢，可能会带偏我们的优化方向。</p><h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><pre><code>Debug.startMethodTracing(&quot;&quot;);// 需要检测的代码片段...Debug.stopMethodTracing();</code></pre><p>最终生成的生成文件在sd卡：Android/data/packagename/files。</p><h4 id="2、Systrace回顾"><a href="#2、Systrace回顾" class="headerlink" title="2、Systrace回顾"></a>2、Systrace回顾</h4><p>systrace 利用了 Linux 的ftrace调试工具（ftrace是用于了解Linux内核内部运行情况的调试工具），相当于在系统各个关键位置都添加了一些性能探针，也就是在代码里加了一些性能监控的埋点。Android 在 ftrace 的基础上封装了atrace，并增加了更多特有的探针，比如Graphics、Activity Manager、Dalvik VM、System Server 等等。对于Systrace的使用笔者在<a href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android启动速度优化</a>这篇文章中已经详细分析过了，如果对Systrace还不是很熟悉的话可以去看看这篇文章。</p><p>下面我们来简单回顾一下Systrace。</p><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>监控和跟踪API调用、线程运行情况，生成HTML报告。</p><h5 id="建议："><a href="#建议：" class="headerlink" title="建议："></a>建议：</h5><p>API 18以上使用，推荐使用TraceCompat。</p><h5 id="使用方式：-1"><a href="#使用方式：-1" class="headerlink" title="使用方式："></a>使用方式：</h5><p>使用python命令执行脚本，后面加上一系列参数，如下所示：</p><pre><code>python systrace.py -t 10 [other-options] [categories]</code></pre><h5 id="优势：-1"><a href="#优势：-1" class="headerlink" title="优势："></a>优势：</h5><ul><li>1、轻量级，开销小。</li><li>2、 它能够直观地反映CPU的利用率。</li><li>3、根据右侧的Alerts能够根据我们的问题给出具体的建议，比如说，它会告诉我们App界面的绘制比较慢或者GC比较频繁。</li></ul><p>最后，我们还可以通过编译时给每个函数插桩的方式来实现线下自动增加应用程序的耗时分析，但是要注意需过滤大部分的短函数，以减少性能损耗（这一点可以通过黑名单配置的方式去过滤短函数或调用非常频繁的函数）。使用这种方式我们就可以看到整个应用程序的调用流程。包括应用关键线程的函数调用，例如渲染耗时、线程锁，GC 耗时等等。</p><p>基于性能的考虑，如果要在线上使用此方案，最好只去监控主线程的耗时。虽然插桩方案对性能的影响并不是很大，但是建议仅在线下或灰度环境中使用。</p><p>此外，如果你需要分析Native 函数的调用，请使用Android 5.0 新增的<a href="https://android.googlesource.com/platform/system/extras/+/master/simpleperf/doc/README.md" target="_blank" rel="external">Simpleperf</a>性能分析工具，它利用了 CPU 的性能监控单元（PMU）提供的硬件 perf 事件。使用 Simpleperf 可以看到所有的 Native 代码的耗时，对一些 Android 系统库的调用对分析问题有比较大的帮助，例如加载 dex、verify class 的耗时等等。此外，在 Android Studio 3.2 中的 Profiler 也直接支持了 Simpleper（SampleNative性能分析工具 (API Level 26+)），这更加方便了native代码的调试。</p><h4 id="3、StrictMode"><a href="#3、StrictMode" class="headerlink" title="3、StrictMode"></a>3、StrictMode</h4><p>StrictMode是Android 2.3引入的一个工具类，它被称为严苛模式，是Android提供的一种运行时检测机制，可以用来帮助开发人员用来检测代码中一些不规范的问题。对于我们的项目当中，可能会成千上万行代码，如果我们用肉眼Review，这样不仅效率非常低效，而且比较容易出问题。使用StrictMode之后，系统会自动检测出来在主线程中的一些异常情况，并按照我们的配置给出相应的反应。</p><p>StrictMode这个工具是非常强大的，但是我们可能因为对它不熟悉而忽略掉它。StrictMode主要用来检测两大问题：</p><h5 id="1、线程策略"><a href="#1、线程策略" class="headerlink" title="1、线程策略"></a>1、线程策略</h5><p>线程策略的检测内容，是一些自定义的耗时调用、磁盘读取操作以及网络请求等。</p><h5 id="2、虚拟机策略"><a href="#2、虚拟机策略" class="headerlink" title="2、虚拟机策略"></a>2、虚拟机策略</h5><p>虚拟机策略的检测内容如下：</p><ul><li>Activity泄漏</li><li>Sqlite对象泄漏</li><li>检测实例数量</li></ul><h5 id="StrictMode实战"><a href="#StrictMode实战" class="headerlink" title="StrictMode实战"></a>StrictMode实战</h5><p>如果要在应用中使用StrictMode，只需要在Applicaitoin的onCreate方法中对StrictMode进行统一配置，代码如下所示：</p><pre><code>private void initStrictMode() {    // 1、设置Debug标志位，仅仅在线下环境才使用StrictMode    if (DEV_MODE) {        // 2、设置线程策略        StrictMode.setThreadPolicy(new StrictMode.ThreadPolicy.Builder()                .detectCustomSlowCalls() //API等级11，使用StrictMode.noteSlowCode                .detectDiskReads()                .detectDiskWrites()                .detectNetwork()// or .detectAll() for all detectable problems                .penaltyLog() //在Logcat 中打印违规异常信息//              .penaltyDialog()//也可以直接跳出警报dialog//              .penaltyDeath()//或者直接崩溃                .build());        // 3、设置虚拟机策略        StrictMode.setVmPolicy(new StrictMode.VmPolicy.Builder()                .detectLeakedSqlLiteObjects()                // 给NewsItem对象的实例数量限制为1                .setClassInstanceLimit(NewsItem.class, 1)                .detectLeakedClosableObjects() //API等级11                .penaltyLog()                .build());    }}</code></pre><p>注意使用“StrictMode”关键字过滤出对应的log。</p><h3 id="4、Profilo"><a href="#4、Profilo" class="headerlink" title="4、Profilo"></a>4、Profilo</h3><p>Profilo是一个用于收集应用程序生产版本的性能跟踪的Android库。</p><p>对于Profilo来说，它集成了atrace功能，ftrace 所有的性能埋点数据都会通过 trace_marker 文件写入到内核缓冲区，Profilo 使用了 PLT Hook 拦截了写入操作，以选择部分关心的事件去做特定的分析。这样所有的 systrace 的探针我们都可以拿到，例如四大组件生命周期、锁等待时间、类校验、GC 时间等等。不过大部分的 atrace 事件都比较笼统，从事件“B|pid|activityStart”，我们无法明确知道该事件具体是由哪个 Activity 来创建的。</p><p>此外，并能够快速获取Java堆栈。由于获取堆栈需要暂停主线程的运行，所以profilo通过间隔发送 SIGPROF 信号这样一种类似 Native 崩溃捕捉的方式去快速获取 Java 堆栈。能够低耗时地快速获取Java堆栈的具体实现原理为当Signal Handler 捕获到信号后，它就会获取到当前正在执行的 Thread，通过 Thread 对象就可以拿到当前线程的 ManagedStack，ManagedStack 是一个单链表，它保存了当前的 ShadowFrame 或者 QuickFrame 栈指针，先依次遍历 ManagedStack 链表，然后遍历其内部的 ShadowFrame 或者 QuickFrame 还原一个可读的调用栈，从而 unwind 出当前的 Java 堆栈。关于ManagedStack与ShadowFrame、QuickFrame三者的关系如下图所示:</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/profilo_get_java_stack.jpg" alt="image"></p><p>Profilo通过这种方式，就可以实现线程同步运行的同时，我们还可以去帮它做检查，并且耗时基本可以忽略不计。但是目前 Profilo 快速获取堆栈的功能不支持 Android 8.0 和 Android 9.0，并且它内部使用了Hook等大量的黑科技手段，鉴于稳定性问题，建议采取抽样部分用户的方式来开启该功能。</p><p><a href="https://github.com/facebookincubator/profilo" target="_blank" rel="external">Profilo项目地址</a></p><p>Systrace主要是根据Linux的ftrace机制来实现的，而ftrace的作用是帮助我们了解 Linux 内核的运行时行为，以便进行故障调试或性能分析。ftrace的整体架构如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/ftrace_architecture.jpg" alt="image"></p><p>由上图可知，Ftrace 有两大组成部分，一是 framework，另外就是一系列的 tracer 。每个 tracer 用于完成不同的功能，并且它们统一由 framework 管理。 ftrace 的 trace 信息保存在 ring buffer 中，由 framework 负责管理。 Framework 利用 debugfs 系统在 /debugfs 下建立 tracing 目录，并提供了一系列的控制文件。</p><p>下面，我们这里给出使用 PLTHook 技术来获取 Atrace 的日志的一个项目。</p><h4 id="1、使用profilo的PLTHook来hook-libc-so的-write-与-write-chk-方法"><a href="#1、使用profilo的PLTHook来hook-libc-so的-write-与-write-chk-方法" class="headerlink" title="1、使用profilo的PLTHook来hook libc.so的 write 与 __write_chk 方法"></a>1、使用profilo的PLTHook来hook libc.so的 write 与 __write_chk 方法</h4><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06" target="_blank" rel="external">使用 PLTHook 技术来获取 Atrace 的日志-项目地址</a></p><p>运行项目后，我们点击按钮开启Atrace日志，然后就可以在Logcat中看到如下的native层日志信息：</p><pre><code>2020-02-05 10:58:00.873 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ===============install systrace hoook==================2020-02-05 10:58:00.879 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|inflate2020-02-05 10:58:00.880 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|LinearLayout2020-02-05 10:58:00.881 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.882 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|TextView2020-02-05 10:58:00.884 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.885 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.888 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|notifyFramePending2020-02-05 10:58:00.888 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.889 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|Choreographer#doFrame2020-02-05 10:58:00.889 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|input2020-02-05 10:58:00.889 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.889 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|traversal2020-02-05 10:58:00.889 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|draw2020-02-05 10:58:00.890 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|Record View#draw()2020-02-05 10:58:00.891 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|DrawFrame2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|syncFrameState2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|prepareTree2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|query2020-02-05 10:58:00.891 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|query2020-02-05 10:58:00.891 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|query2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|query2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13052/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|query2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|query2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|setBuffersDimensions2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.892 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|dequeueBuffer2020-02-05 10:58:00.894 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|importBuffer2020-02-05 10:58:00.894 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|HIDL::IMapper::importBuffer::passthrough2020-02-05 10:58:00.894 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.894 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.894 13052-13058/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|Compiling2020-02-05 10:58:00.894 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= E2020-02-05 10:58:00.894 13052-13075/com.dodola.atrace I/HOOOOOOOOK: ========= B|13052|query</code></pre><p>需要注意的是，日志中的B代表begin，也就是对应时间开始的时间，而E代表End，即对应事件结束的时间，并且，B|事件和E|事件是成对出现的，这样我们就可以通过该事件的结束时间减去对应的开始时间来获得每个事件使用的时间。例如，上述log中我们可以看出TextView的draw方法显示使用了3ms。</p><p>此外，在下面这个项目里展示了如何使用 PLTHook 技术来获取线程创建的堆栈。</p><h4 id="2、使用PLTHook技术来获取线程创建的堆栈"><a href="#2、使用PLTHook技术来获取线程创建的堆栈" class="headerlink" title="2、使用PLTHook技术来获取线程创建的堆栈"></a>2、使用PLTHook技术来获取线程创建的堆栈</h4><p><a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus" target="_blank" rel="external">使用 PLTHook 技术来获取线程创建的堆栈-项目地址</a></p><p>运行项目后，我们点击开启 Thread Hook按钮，然后点击新建 Thread按钮。最后可以在Logcat 中看到Thread创建的堆栈信息：</p><pre><code>2020-02-05 13:47:59.006 20159-20159/com.dodola.thread E/HOOOOOOOOK: stack:com.dodola.thread.ThreadHook.getStack(ThreadHook.java:16)com.dodola.thread.MainActivity$2.onClick(MainActivity.java:40)android.view.View.performClick(View.java:6311)android.view.View$PerformClick.run(View.java:24833)android.os.Handler.handleCallback(Handler.java:794)android.os.Handler.dispatchMessage(Handler.java:99)android.os.Looper.loop(Looper.java:173)android.app.ActivityThread.main(ActivityThread.java:6653)java.lang.reflect.Method.invoke(Native Method)com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:547)com.android.internal.os.ZygoteInit.main(ZygoteInit.java:821)2020-02-05 13:47:59.007 20159-20339/com.dodola.thread E/HOOOOOOOOK: thread name:Thread-22020-02-05 13:47:59.008 20159-20339/com.dodola.thread E/HOOOOOOOOK: thread id:10572020-02-05 13:47:59.009 20159-20339/com.dodola.thread E/HOOOOOOOOK: stack:com.dodola.thread.ThreadHook.getStack(ThreadHook.java:16)com.dodola.thread.MainActivity$2$1.run(MainActivity.java:38)2020-02-05 13:47:59.011 20159-20340/com.dodola.thread E/HOOOOOOOOK: inner thread name:Thread-32020-02-05 13:47:59.012 20159-20340/com.dodola.thread E/HOOOOOOOOK: inner thread id:1058</code></pre><p>由于Profilo与PLT Hook涉及了大量的C/C++、NDK开发的知识，所以这部分不做详细讲解，如对NDK开发感兴趣的同学可以期待下我后面的<a href="https://github.com/JsonChao/Awesome-Android-NDK" target="_blank" rel="external">Awesome-Android-NDK系列文章</a>，等性能优化系列文章更新完毕之后，就会开始去系统学习NDK相关的开发知识，敬请期待。</p><h2 id="二、自动化卡顿检测方案及优化"><a href="#二、自动化卡顿检测方案及优化" class="headerlink" title="二、自动化卡顿检测方案及优化"></a>二、自动化卡顿检测方案及优化</h2><h3 id="1、为什么需要自动化卡顿检测方案？"><a href="#1、为什么需要自动化卡顿检测方案？" class="headerlink" title="1、为什么需要自动化卡顿检测方案？"></a>1、为什么需要自动化卡顿检测方案？</h3><ul><li>1、Cpu Profiler、Systrace等系统工具仅适合线下针对性分析。</li><li>2、线上及测试环境需要自动化的卡顿检方案来定位卡顿，同时，更重要的是，它能记录卡顿发生时的场景。</li></ul><h3 id="2、卡顿检测方案原理"><a href="#2、卡顿检测方案原理" class="headerlink" title="2、卡顿检测方案原理"></a>2、卡顿检测方案原理</h3><p>它的原理源于Android的消息处理机制，一个线程不管有多少Handler，它只会有一个Looper存在，主线程执行的任何代码都会通过Looper.loop()方法执行。而在Looper函数中，它有一个mLogging对象，这个对象在每个message处理前后都会被调用。主线程发生了卡顿，那一定是在dispatchMessage()方法中执行了耗时操作。那么，我们就可以通过这个mLogging对象对dispatchMessage()进行监控。</p><h4 id="卡顿检测方案的具体实现步骤"><a href="#卡顿检测方案的具体实现步骤" class="headerlink" title="卡顿检测方案的具体实现步骤"></a>卡顿检测方案的具体实现步骤</h4><p>首先，我们看下Looper用于执行消息循环的loop()方法，关键代码如下所示：</p><pre><code>/** * Run the message queue in this thread. Be sure to call * {@link #quit()} to end the loop. */public static void loop() {    ...    for (;;) {        Message msg = queue.next(); // might block        if (msg == null) {            // No message indicates that the message queue is quitting.            return;        }        // This must be in a local variable, in case a UI event sets the logger        final Printer logging = me.mLogging;        if (logging != null) {            // 1            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +                    msg.callback + &quot;: &quot; + msg.what);        }        ...        try {             // 2              msg.target.dispatchMessage(msg);            dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;        } finally {            if (traceTag != 0) {                Trace.traceEnd(traceTag);            }        }        ...        if (logging != null) {            // 3            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);        }</code></pre><p>在Looper的loop()方法中，在其执行每一个消息（注释2处）的前后都由logging进行了一次打印输出。可以看到，在执行消息前是输出的”&gt;&gt;&gt;&gt;&gt; Dispatching to “，在执行消息后是输出的”&lt;&lt;&lt;&lt;&lt; Finished to “,它们打印的日志是不一样的，我们就可以由此来判断消息执行的前后。</p><p>所以，具体的实现可以归纳为如下步骤：</p><ul><li>1、首先，我们需要使用Looper.getMainLooper().setMessageLogging()去设置我们自己的Printer实现类去打印输出logging。这样，在每个message执行的之前和之后都会调用我们设置的这个Printer实现类。</li><li>2、如果我们匹配到”&gt;&gt;&gt;&gt;&gt; Dispatching to “之后，我们就可以执行一行代码，也就是在指定的时间阈值之后，我们在子线程去执行一个任务，这个任务就是去获取当前主线程的堆栈信息以及当前的一些场景信息，比如：内存大小、电脑、网络状态等。</li><li>3、如果匹配到了”&lt;&lt;&lt;&lt;&lt; Finished to “，那么说明在指定的阈值之内，message就被执行完成了，说明此时没有产生我们认为的卡顿效果，那我们就可以将这个子线程任务取消掉。</li></ul><h3 id="3、AndroidPerformanceMonitor"><a href="#3、AndroidPerformanceMonitor" class="headerlink" title="3、AndroidPerformanceMonitor"></a>3、AndroidPerformanceMonitor</h3><p>它是一个非侵入式的性能监控组件，可以通过通知的形式弹出卡顿信息。它的原理就是我们刚刚讲述到的卡顿监控的实现原理。</p><p>接下我们通过一个简单的示例来讲解一下它的使用。</p><p>首先，我们需要在moudle的build.gradle下配置它的依赖，如下所示：</p><pre><code>// release：项目中实现了线上监控体系的时候去使用api &apos;com.github.markzhai:blockcanary-android:1.5.0&apos;// 仅在debug包启用BlockCanary进行卡顿监控和提示的话，可以这么用debugApi &apos;com.github.markzhai:blockcanary-android:1.5.0&apos;releaseApi &apos;com.github.markzhai:blockcanary-no-op:1.5.0&apos;</code></pre><p>其次，在Application的onCreate方法中开启卡顿监控：</p><pre><code> // 注意在主进程初始化调用BlockCanary.install(this, new AppBlockCanaryContext()).start();</code></pre><p>最后，继承BlockCanaryContext类去实现自己的监控配置上下文类：</p><pre><code>public class AppBlockCanaryContext extends BlockCanaryContext {    // 实现各种上下文，包括应用标识符，用户uid，网络类型，卡顿判断阙值，Log保存位置等等    /**    * 提供应用的标识符    *    * @return 标识符能够在安装的时候被指定，建议为 version + flavor.    */    public String provideQualifier() {        return &quot;unknown&quot;;    }    /**    * 提供用户uid，以便在上报时能够将对应的    * 用户信息上报至服务器     *    * @return user id    */    public String provideUid() {        return &quot;uid&quot;;    }    /**    * 提供当前的网络类型    *    * @return {@link String} like 2G, 3G, 4G, wifi, etc.    */    public String provideNetworkType() {        return &quot;unknown&quot;;    }    /**    * 配置监控的时间区间，超过这个时间区间    ，BlockCanary将会停止, use    * with {@code BlockCanary}&apos;s isMonitorDurationEnd    *    * @return monitor last duration (in hour)    */    public int provideMonitorDuration() {        return -1;    }    /**    * 指定判定为卡顿的阈值threshold (in millis),      * 你可以根据不同设备的性能去指定不同的阈值    *    * @return threshold in mills    */    public int provideBlockThreshold() {        return 1000;    }    /**    * 设置线程堆栈dump的间隔, 当阻塞发生的时候使用, BlockCanary 将会根据    * 当前的循环周期在主线程去dump堆栈信息    * &lt;p&gt;    * 由于依赖于Looper的实现机制, 真实的dump周期     * 将会比设定的dump间隔要长(尤其是当CPU很繁忙的时候).    * &lt;/p&gt;    *    * @return dump interval (in millis)    */    public int provideDumpInterval() {        return provideBlockThreshold();    }    /**    * 保存log的路径, 比如 &quot;/blockcanary/&quot;, 如果权限允许的话，    * 会保存在本地sd卡中    *    * @return path of log files    */    public String providePath() {        return &quot;/blockcanary/&quot;;    }    /**    * 是否需要通知去通知用户发生阻塞    *    * @return true if need, else if not need.    */    public boolean displayNotification() {        return true;    }    /**    * 用于将多个文件压缩为一个.zip文件    *    * @param src  files before compress    * @param dest files compressed    * @return true if compression is successful    */    public boolean zip(File[] src, File dest) {        return false;    }    /**    * 用于将已经被压缩好的.zip log文件上传至    * APM后台    *    * @param zippedFile zipped file    */    public void upload(File zippedFile) {        throw new UnsupportedOperationException();    }    /**    * 用于设定包名, 默认使用进程名，    *    * @return null if simply concern only package with process name.    */    public List&lt;String&gt; concernPackages() {        return null;    }    /**    * 使用 @{code concernPackages}方法指定过滤的堆栈信息     *    * @return true if filter, false it not.    */    public boolean filterNonConcernStack() {        return false;    }    /**    * 指定一个白名单, 在白名单的条目将不会出现在展示阻塞信息的UI中    *    * @return return null if you don&apos;t need white-list filter.    */    public List&lt;String&gt; provideWhiteList() {        LinkedList&lt;String&gt; whiteList = new LinkedList&lt;&gt;();        whiteList.add(&quot;org.chromium&quot;);        return whiteList;    }    /**    * 使用白名单的时候，是否去删除堆栈在白名单中的文件    *    * @return true if delete, false it not.    */    public boolean deleteFilesInWhiteList() {        return true;    }    /**    * 阻塞拦截器, 我们可以指定发生阻塞时应该做的工作    */    public void onBlock(Context context, BlockInfo blockInfo) {    }}</code></pre><p>可以看到，在上述配置中，我们指定了卡顿的阈值为1000ms。接下来，我们可以测试一下BlockCanary监测卡顿时的效果，这里我在Activity的onCreate方法中添加如下代码使线程休眠3s：</p><pre><code>try {    Thread.sleep(3000);} catch (InterruptedException e) {    e.printStackTrace();}</code></pre><p>然后，我们运行项目，打开App，即可看到类似LeakCanary那样的对应的卡顿信息堆栈。</p><p>除了发生卡顿时BlockCanary提供的图形界面可供开发和测试人员直接查看卡顿原因之外。其最大的作用还是在线上环境或者自动化monkey测试的环节进行大范围的log采集与分析，对于分析的纬度，可以从以下两个纬度来进行：</p><ul><li>卡顿时间。</li><li>根据同堆栈出现的卡顿次数来进行排序和归类。</li></ul><h4 id="BlockCanary的优势如下"><a href="#BlockCanary的优势如下" class="headerlink" title="BlockCanary的优势如下"></a>BlockCanary的优势如下</h4><ul><li>非侵入式。</li><li>方便精准，能够定位到代码的某一行代码。</li></ul><h4 id="那么这种自动检测卡顿的方案有什么问题吗？"><a href="#那么这种自动检测卡顿的方案有什么问题吗？" class="headerlink" title="那么这种自动检测卡顿的方案有什么问题吗？"></a>那么这种自动检测卡顿的方案有什么问题吗？</h4><p>在卡顿的周期之内，应用确实发生了卡顿，但是获取到的卡顿信息可能会不准确，和我们的OOM一样，也就是最后的堆栈信息仅仅只是一个表象，并不是真正发生问题时的一个堆栈。下面，我们先看下如下的一个示意图：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/looper_logging_problem.png" alt="image"></p><p>假设主线程在T1到T2的时间段内发生了卡顿，卡顿检测方案获取卡顿时的堆栈信息是T2时刻，但是实际上发生卡顿的时刻可能是在这段时间区域内某个函数的耗时过长，那么可能在我们捕获卡顿的时刻时，真正的卡顿时机已经执行完成了，所以在T2时刻捕获到的一个卡顿信息并不能够反映卡顿的现场，也就是最后呈现出来的堆栈信息仅仅只是一个表象，并不是真正问题的藏身之处。</p><h4 id="那么，我们如何对这种情况进行优化呢？"><a href="#那么，我们如何对这种情况进行优化呢？" class="headerlink" title="那么，我们如何对这种情况进行优化呢？"></a>那么，我们如何对这种情况进行优化呢？</h4><p>我们可以获取卡顿周期内的多个堆栈，而不仅仅是最后一个，这样的话，如果发生了卡顿，我们就可以根据这些堆栈信息来清晰地还原整个卡顿现场。因为我们有卡顿现场的多个堆栈信息，我们完全知道卡顿时究竟发生了什么，到底哪些函数它的调用时间比较长。接下来，我们看看下面的卡顿检测优化流程图：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/looper_logging_optimize.png" alt="image"></p><p>根据图中，可以梳理出优化后的具体实现步骤为：</p><ul><li>1、首先，我们会通过startMonitor方法对这个过程进行监控。</li><li>2、接着，我们就开始高频采集堆栈信息。如果发生了卡顿，我们就会调用endMonitor方法。</li><li>3、然后，将之前我们采集的多个堆栈信息记录到文件中。</li><li>4、最后，在合适的时机上报给我们的服务器。</li></ul><p>通过上述的优化，我们就可以知道在整个卡顿周期之内，究竟是哪些方法在执行，哪些方法比较耗时。</p><p>但是这种海量卡顿堆栈的处理又存在着另一个问题，那就是高频卡顿上报量太大，服务器压力较大，这里我们来分析下如何减少服务端对堆栈信息的处理量。</p><p>在出现卡顿的情况下，我们采集到了多个堆栈，大概率的情况下，可能会存在多个重复的堆栈，而这个重复的堆栈信息才是我们应该关注的地方。我们可以对一个卡顿下的堆栈进行能hash排重，找出重复的堆栈。这样，服务器需要处理的数据量就会大大减少，同时也过滤出了我们需要重点关注的对象。对于开发人员来说，就能更快地找到卡顿的原因。</p><h3 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h3><p>在本节中，我们学习了自动化卡顿检测的原理，然后，我们使用这种方案进行了实战，最后，我介绍了这种方案的问题和它的优化思路。</p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>在本篇文章中，我们主要对卡顿优化分析方法与工具<br>、自动化卡顿检测方案及优化相关的知识进行了全面的讲解，这里再简单总结一下本篇文章涉及的两大主题：</p><ul><li>1、卡顿优化分析方法与工具：背景介绍、卡顿分析方法之使用shell命令分析CPU耗时、卡顿优化工具。</li><li>2、自动化卡顿检测方案及优化：卡顿检测方案原理、AndroidPerformanceMonitor实战及其优化。</li></ul><p>下篇，笔者将带领大家更加深入地去学习卡顿优化的相关知识，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第6章 卡顿优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/71982" target="_blank" rel="external">极客时间之Android开发高手课 卡顿优化</a></p><p>3、《Android移动性能实战》第四章 CPU</p><p>4、《Android移动性能实战》第七章 流畅度</p><p>5、<a href="https://blog.csdn.net/lindroid/article/details/90904947" target="_blank" rel="external">Android dumpsys cpuinfo 信息解读</a></p><p>6、<a href="https://www.zhihu.com/question/20448467" target="_blank" rel="external">如何清楚易懂的解释“UV和PV＂的定义？</a></p><p>7、<a href="https://github.com/uber/nanoscope" target="_blank" rel="external">nanoscope-An extremely accurate Android method tracing tool</a></p><p>8、<a href="https://github.com/didi/DroidAssist" target="_blank" rel="external">DroidAssist-A lightweight Android Studio gradle plugin based on Javassist for editing bytecode in Android.</a></p><p>9、<a href="https://github.com/eleme/lancet" target="_blank" rel="external">lancet-A lightweight and fast AOP framework for Android App and SDK developers</a></p><p>10、<a href="https://github.com/zhengcx/MethodTraceMan" target="_blank" rel="external">MethodTraceMan-用于快速找到高耗时方法，定位解决Android App卡顿问题</a></p><p>11、<a href="http://www.samirchen.com/linux-cpu-performance/" target="_blank" rel="external">Linux环境下进程的CPU占用率</a></p><p>12、<a href="https://source.android.com/devices/tech/debug/ftrace?hl=zh-cn" target="_blank" rel="external">使用 ftrace</a></p><p>13、<a href="https://github.com/facebookincubator/profilo" target="_blank" rel="external">profilo-A library for performance traces from production</a></p><p>14、<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-ftrace/index.html" target="_blank" rel="external">ftrace 简介</a></p><p>15、<a href="https://android.googlesource.com/platform/frameworks/native/+/master/cmds/atrace/atrace.cpp" target="_blank" rel="external">atrace源码</a></p><p>16、<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06" target="_blank" rel="external">AndroidAdvanceWithGeektime<br>/ Chapter06</a></p><p>17、<a href="https://github.com/AndroidAdvanceWithGeektime/Chapter06-plus" target="_blank" rel="external">AndroidAdvanceWithGeektime<br>/ Chapter06-plus</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/Awesome-Android.png" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/01/26/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%A1%E9%A1%BF%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android布局优化（下）</title>
      <link>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/</link>
      <guid>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/</guid>
      <pubDate>Mon, 13 Jan 2020 14:59:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>本篇，为深入探索Android布局优化的下篇。这篇文章包含的主要内容如下所示：</p><ul><li>6、布局优化常规方案</li><li>7、布局优化的进阶方案</li><li>8、布局优化的常见问题</li></ul><p>下面，笔者将与大家一起进入进行布局优化的实操环节。</p><h3 id="六、布局优化常规方案"><a href="#六、布局优化常规方案" class="headerlink" title="六、布局优化常规方案"></a>六、布局优化常规方案</h3><p>布局优化的方法有很多，大部分主流的方案笔者已经在<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>里讲解过了。下面，我将介绍一些其它的优化方案。</p><h4 id="1、布局Inflate优化方案演进"><a href="#1、布局Inflate优化方案演进" class="headerlink" title="1、布局Inflate优化方案演进"></a>1、布局Inflate优化方案演进</h4><h5 id="1、代码动态创建View"><a href="#1、代码动态创建View" class="headerlink" title="1、代码动态创建View"></a>1、代码动态创建View</h5><p>使用Java代码动态添加控件的简单示例如下：</p><pre><code>Button button=new Button(this);        button.setBackgroundColor(Color.RED);button.setText(&quot;Hello World&quot;);ViewGroup viewGroup = (ViewGroup) LayoutInflater.from(this).inflate(R.layout.activity_main, null);viewGroup.addView(button);</code></pre><h5 id="2、替换MessageQueue来实现异步创建View"><a href="#2、替换MessageQueue来实现异步创建View" class="headerlink" title="2、替换MessageQueue来实现异步创建View"></a>2、替换MessageQueue来实现异步创建View</h5><p>在使用子线程创建视图控件的时候，我们可以把子线程Looper的MessageQueue替换成主线程的MessageQueue，在创建完需要的视图控件后记得将子线程Looper中的MessageQueue恢复为原来的。在<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>项目下的UiUtils的Ui优化工具类中，提供了相应的实现，代码如下所示：</p><pre><code> /** * 实现将子线程Looper中的MessageQueue替换为主线程中Looper的 * MessageQueue，这样就能够在子线程中异步创建UI。 * * 注意：需要在子线程中调用。 * * @param reset 是否将子线程中的MessageQueue重置为原来的，false则表示需要进行替换 * @return 替换是否成功 */public static boolean replaceLooperWithMainThreadQueue(boolean reset) {    if (CommonUtils.isMainThread()) {        return true;    } else {        // 1、获取子线程的ThreadLocal实例        ThreadLocal&lt;Looper&gt; threadLocal = ReflectUtils.reflect(Looper.class).field(&quot;sThreadLocal&quot;).get();        if (threadLocal == null) {            return false;        } else {            Looper looper = null;            if (!reset) {                Looper.prepare();                looper = Looper.myLooper();                // 2、通过调用MainLooper的getQueue方法区获取主线程Looper中的MessageQueue实例                Object queue = ReflectUtils.reflect(Looper.getMainLooper()).method(&quot;getQueue&quot;).get();                if (!(queue instanceof MessageQueue)) {                    return false;                }                // 3、将子线程中的MessageQueue字段的值设置为主线的MessageQueue实例                ReflectUtils.reflect(looper).field(&quot;mQueue&quot;, queue);            }            // 4、reset为false，表示需要将子线程Looper中的MessageQueue重置为原来的。            ReflectUtils.reflect(threadLocal).method(&quot;set&quot;, looper);            return true;        }    }}</code></pre><h5 id="3、AsynclayoutInflater异步创建View"><a href="#3、AsynclayoutInflater异步创建View" class="headerlink" title="3、AsynclayoutInflater异步创建View"></a>3、AsynclayoutInflater异步创建View</h5><p>在第三小节中，我们对Android的布局加载原理进行了深入地分析，从中我们得出了布局加载过程中的两个耗时点：</p><ul><li>1、布局文件读取慢：IO过程。</li><li>2、创建View慢：使用反射，比直接new的方式要慢3倍。布局嵌套层级越多，控件个数越多，反射的次数就会越频繁。</li></ul><p>很明显，我们无法从根本上去解决这两个问题，但是Google提供了一个从侧面解决的方案:使用AsyncLayoutInflater去异步加载对应的布局，它的特点如下：</p><ul><li>1、工作线程加载布局。</li><li>2、回调主线程。</li><li>3、节省主线程时间。</li></ul><p>接下来，我将详细地介绍AsynclayoutInflater的使用。</p><p>首先，在项目的build.gradle中进行配置：</p><pre><code>implementation &apos;com.android.support:asynclayoutinflater:28.0.0&apos;</code></pre><p>然后，在Activity中的onCreate方法中将setContentView注释：</p><pre><code>super.onCreate(savedInstanceState);// 内部分别使用了IO和反射的方式去加载布局解析器和创建对应的View// setContentView(R.layout.activity_main);</code></pre><p>接着，在super.onCreate方法前继续布局的异步加载：</p><pre><code>// 使用AsyncLayoutInflater进行布局的加载new AsyncLayoutInflater(MainActivity.this).inflate(R.layout.activity_main, null, new AsyncLayoutInflater.OnInflateFinishedListener() {        @Override        public void onInflateFinished(@NonNull View view, int i, @Nullable ViewGroup viewGroup) {            setContentView(view);            // findViewById、视图操作等    }});super.onCreate(savedInstanceState);</code></pre><p>接下来，我们来分析下AsyncLayoutInflater的实现原理与工作流程。</p><p>由于我们是使用new的方式创建的AsyncLayoutInflater，所以我们先来看看它的构造函数：</p><pre><code> public AsyncLayoutInflater(@NonNull Context context) {    // 1    this.mInflater = new AsyncLayoutInflater.BasicInflater(context);    // 2    this.mHandler = new Handler(this.mHandlerCallback);    // 3    this.mInflateThread = AsyncLayoutInflater.InflateThread.getInstance();}</code></pre><p>在注释1处，创建了一个BasicInflater，它内部的onCreateView并没有使用Factory做AppCompat控件兼容的处理：</p><pre><code>protected View onCreateView(String name, AttributeSet attrs) throws ClassNotFoundException {    String[] var3 = sClassPrefixList;    int var4 = var3.length;    for(int var5 = 0; var5 &lt; var4; ++var5) {        String prefix = var3[var5];        try {            View view = this.createView(name, prefix, attrs);            if (view != null) {                return view;            }        } catch (ClassNotFoundException var8) {        }    }    return super.onCreateView(name, attrs);}</code></pre><p>由前面的分析可知，在createView方法中仅仅是做了反射创建出对应View的处理。</p><p>接着，在注释2处，创建了一个全局的Handler对象，主要是用于将异步线程创建好的View实例及其相关信息回调到主线程。</p><p>最后，在注释3处，获取了一个用于异步加载View的线程实例。</p><p>接着，我们继续跟踪AsyncLayoutInflater实例的inflate方法：</p><pre><code>@UiThreadpublic void inflate(@LayoutRes int resid, @Nullable ViewGroup parent, @NonNull AsyncLayoutInflater.OnInflateFinishedListener callback) {    if (callback == null) {        throw new NullPointerException(&quot;callback argument may not be null!&quot;);    } else {        // 1        AsyncLayoutInflater.InflateRequest request = this.mInflateThread.obtainRequest();        request.inflater = this;        request.resid = resid;        request.parent = parent;        request.callback = callback;        this.mInflateThread.enqueue(request);    }}</code></pre><p>在注释1处，这里使用InflateRequest对象将我们传进来的三个参数进行了包装，并最终将这个InflateRequest对象加入了mInflateThread线程中的一个ArrayBlockingQueue中：</p><pre><code>public void enqueue(AsyncLayoutInflater.InflateRequest request) {    try {        this.mQueue.put(request);      } catch (InterruptedException var3) {        throw new RuntimeException(&quot;Failed to enqueue async inflate request&quot;, var3);    }}</code></pre><p>并且，在InflateThread这个静态内部类的静态代码块中调用了其自身实例的start方法以启动线程：</p><pre><code>static {    sInstance.start();}public void run() {    while(true) {        this.runInner();    }}public void runInner() {    AsyncLayoutInflater.InflateRequest request;    try {        // 1        request = (AsyncLayoutInflater.InflateRequest)this.mQueue.take();    } catch (InterruptedException var4) {        Log.w(&quot;AsyncLayoutInflater&quot;, var4);        return;    }    try {        // 2        request.view = request.inflater.mInflater.inflate(request.resid, request.parent, false);    } catch (RuntimeException var3) {        Log.w(&quot;AsyncLayoutInflater&quot;, &quot;Failed to inflate resource in the background! Retrying on the UI thread&quot;, var3);    }    // 3    Message.obtain(request.inflater.mHandler, 0, request).sendToTarget();}</code></pre><p>在run方法中，使用了死循环的方式去不断地调用runInner方法，在runInner方法中，首先在注释1处从ArrayBlockingQueue队列中获取一个InflateRequest对象，然后在注释2处将异步加载好的view对象赋值给了InflateRequest对象，最后，在注释3处，将请求作为消息发送给了Handler的handleMessage：</p><pre><code>private Callback mHandlerCallback = new Callback() {    public boolean handleMessage(Message msg) {        AsyncLayoutInflater.InflateRequest request = (AsyncLayoutInflater.InflateRequest)msg.obj;        // 1        if (request.view == null) {            request.view = AsyncLayoutInflater.this.mInflater.inflate(request.resid, request.parent, false);        }        request.callback.onInflateFinished(request.view, request.resid, request.parent);        AsyncLayoutInflater.this.mInflateThread.releaseRequest(request);        return true;    }};</code></pre><p>在handleMessage方法中，当异步加载得到的view为null时，此时在注释1处还做了一个fallback处理，直接在主线程进行view的加载，以此兼容某些异常情况，最后，就调用了回调接口的onInflateFinished方法将view的相关信息返回给Activity对象。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>由以上分析可知，AsyncLayoutInflater是通过侧面缓解的方式去缓解布局加载过程中的卡顿，但是它依然存在一些问题：</p><ul><li>1、不能设置LayoutInflater.Factory，通过自定义AsyncLayoutInflater的方式解决，由于它是一个final，所以需要将代码直接拷处进行修改。</li><li>2、因为是异步加载，所以需要注意在布局加载过程中不能有依赖于主线程的操作。</li></ul><p>由于AsyncLayoutInflater仅仅只能通过侧面缓解的方式去缓解布局加载的卡顿，因此，我们下面将介绍一种从根本上解决问题的方案。对于AsynclayoutInflater的改进措施，可以查看祁同伟同学封装之后的代码：</p><p><a href="https://www.jianshu.com/p/f0c0eda06ae4" target="_blank" rel="external">Android AsyncLayoutInflater 限制及改进</a></p><h5 id="4、使用X2C进行布局加载优化"><a href="#4、使用X2C进行布局加载优化" class="headerlink" title="4、使用X2C进行布局加载优化"></a>4、使用X2C进行布局加载优化</h5><p>由上分析可知，在布局加载的过程中有两个主要的耗时点，即IO操作和反射，而AsyncLayoutInflater仅仅是缓解，那么有什么方案能从根本上去解决这个问题呢？</p><h4 id="使用Java代码写布局？"><a href="#使用Java代码写布局？" class="headerlink" title="使用Java代码写布局？"></a>使用Java代码写布局？</h4><p>如果使用Java代码写布局，无疑从Xml文件进行IO操作的过程和反射获取View实例的过程都将被抹去。虽然这样从本质上解决了问题，但是也引入了一些新问题，如不便于开发，可维护性差等等。</p><p>那么，还有没有别的更好的方式呢？</p><p>答案就是X2C。</p><h4 id="X2C"><a href="#X2C" class="headerlink" title="X2C"></a>X2C</h4><p><a href="https://github.com/iReaderAndroid/X2C/blob/master/README_CN.md" target="_blank" rel="external">X2C项目地址</a></p><p>X2C框架保留了XML的优点，并解决了其IO操作和反射的性能问题。开发人员只需要正常写XML代码即可，在编译期，X2C会利用APT工具将XML代码翻译为Java代码。</p><p>接下来，我们来进行X2C的使用。</p><p>首先，在app的build.gradle文件添加如下依赖：</p><pre><code>annotationProcessor &apos;com.zhangyue.we:x2c-apt:1.1.2&apos;implementation &apos;com.zhangyue.we:x2c-lib:1.0.6&apos;</code></pre><p>然后，在对应的MainActivity类上方添加如下注解，让MainActivity知道我们使用的布局是activity_main：</p><pre><code>@Xml(layouts = &quot;activity_main&quot;)public class MainActivity extends AppCompatActivity implements OnFeedShowCallBack {</code></pre><p>接着，将onCreate方法中setContentView的原始方式改为X2C的设置方式：</p><pre><code>X2C.setContentView(MainActivity.this, R.layout.activity_main);</code></pre><p>最后，我们再Rebuild项目，会在build下的generated-&gt;source-&gt;apt-&gt;debug-&gt;com.zhangyue.we.x2c下自动生成X2C127_activity_main这个类：</p><pre><code>public class X2C127_activity_main implements IViewCreator {@Overridepublic View createView(Context context) {    return new com.zhangyue.we.x2c.layouts.X2C127_Activity_Main().createView(context);    }}</code></pre><p>在这个类中又继续调用了layout目录下的X2C127_Activity_Main实例的createView方法，如下所示：</p><pre><code>public class X2C127_Activity_Main implements IViewCreator {    @Override    public View createView(Context ctx) {        Resources res = ctx.getResources();        ConstraintLayout constraintLayout0 = new ConstraintLayout(ctx);        RecyclerView recyclerView1 = new RecyclerView(ctx);        ConstraintLayout.LayoutParams layoutParam1 = new ConstraintLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.MATCH_PARENT);        recyclerView1.setId(R.id.recycler_view);        recyclerView1.setLayoutParams(layoutParam1);        constraintLayout0.addView(recyclerView1);        return constraintLayout0;    }}</code></pre><p>从上可知，里面采用了new的方式创建了相应的控件，并设置了对应的信息。</p><p>接下来，我们回到X2C.setContentView(MainActivity.this, R.layout.activity_main)这个方法，看看它内部究竟做了什么处理：</p><pre><code>/** * 设置contentview，检测如果有对应的java文件，使用java文件，否则使用xml * * @param activity 上下文 * @param layoutId layout的资源id */public static void setContentView(Activity activity, int layoutId) {    if (activity == null) {        throw new IllegalArgumentException(&quot;Activity must not be null&quot;);    }    // 1    View view = getView(activity, layoutId);    if (view != null) {        activity.setContentView(view);    } else {        activity.setContentView(layoutId);    }}</code></pre><p>在注释1处，通过getView方法获取到了对应的view，我们继续跟踪进去：</p><pre><code>public static View getView(Context context, int layoutId) {    IViewCreator creator = sSparseArray.get(layoutId);    if (creator == null) {        try {            int group = generateGroupId(layoutId);            String layoutName = context.getResources().getResourceName(layoutId);            layoutName = layoutName.substring(layoutName.lastIndexOf(&quot;/&quot;) + 1);            String clzName = &quot;com.zhangyue.we.x2c.X2C&quot; + group + &quot;_&quot; + layoutName;            // 1            creator = (IViewCreator) context.getClassLoader().loadClass(clzName).newInstance();        } catch (Exception e) {            e.printStackTrace();        }        //如果creator为空，放一个默认进去，防止每次都调用反射方法耗时        if (creator == null) {            creator = new DefaultCreator();        }        sSparseArray.put(layoutId, creator);    }    // 2    return creator.createView(context);}</code></pre><p>可以看到，这里采用了一个sSparseArray集合去存储布局对应的视图创建对象creator，如果是首次创建creator的话，会在注释1处使用反射的方式去加载处对应的creator对象，然后将它放入sSparseArray集中，最后在注释2处调用了creator的createView方法去使用new的方式去创建对应的控件。</p><p>但是，X2C框架还存在一些问题：</p><ul><li>1、部分Java属性不支持。</li><li>2、失去了系统的兼容（AppCompat）</li></ul><p>对于第2个问题，我们需要修改X2C框架的源码，当发现是TextView等控件时，需要直接使用new的方式去创建一个AppCompatTextView等兼容类型的控件。于此同时，它还有如下两个小的点不支持，但是这个问题不大：</p><ul><li>merge标签 ,在编译期间无法确定xml的parent，所以无法支持。</li><li>系统style,在编译期间只能查到应用的style列表，无法查询系统style，所以只支持应用内style。</li></ul><h4 id="2、使用ConstraintLayout降低布局嵌套层级"><a href="#2、使用ConstraintLayout降低布局嵌套层级" class="headerlink" title="2、使用ConstraintLayout降低布局嵌套层级"></a>2、使用ConstraintLayout降低布局嵌套层级</h4><p>首先，对于Android视图绘制的原理，我们必须要有一定的了解，关于这块，大家可以参考下<a href="https://jsonchao.github.io/2018/10/28/Android%20View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/" target="_blank" rel="external">Android View的绘制流程</a>这篇文章。</p><p>对于视图绘制的性能瓶颈，大概有以下三点：</p><ul><li>1、测量、布局、绘制每个阶段的耗时。</li><li>2、自顶而下的遍历，当嵌套层级过多时，遍历耗时会比较明显。</li><li>3、无效的嵌套布局或不合理使用RelativeLayout可能会导致触发多次绘制。</li></ul><p>那么，如何减少布局的层级及复杂度呢？</p><p>基本上只要遵循以下两点即可：</p><ul><li>1、减少View树层级。</li><li>2、宽而浅，避免窄而深。</li></ul><p>为了提升布局的绘制速度，Google推出了ConstraintLayout，它的特点如下：</p><ul><li>1、实现几乎完全扁平化的布局。</li><li>2、构建复杂布局性能更高。</li><li>3、具有RelativeLayout和LinearLayout的特性。</li></ul><p>接下来，我们来简单使用一下ConstraintLayout来优化一下我们的布局。</p><p>首先，下面是我们的原始布局:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:id=&quot;@+id/ll_out&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;    android:padding=&quot;5dp&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;horizontal&quot;&gt;        &lt;com.facebook.drawee.view.SimpleDraweeView            android:id=&quot;@+id/iv_news&quot;            android:layout_width=&quot;80dp&quot;            android:layout_height=&quot;80dp&quot;            android:scaleType=&quot;fitXY&quot; /&gt;        &lt;TextView            android:id=&quot;@+id/tv_title&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:padding=&quot;10dp&quot;            android:textSize=&quot;20dp&quot; /&gt;    &lt;/LinearLayout&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_gravity=&quot;right&quot;        android:padding=&quot;3dp&quot;        android:text=&quot;来自NBA官网&quot;        android:textSize=&quot;14dp&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>可以看到,它具有三层嵌套结构,然后我们来使用ConstraintLayout来优化一下这个布局：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    android:id=&quot;@+id/ll_out&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:orientation=&quot;vertical&quot;    android:padding=&quot;5dp&quot;&gt;    &lt;com.facebook.drawee.view.SimpleDraweeView        android:id=&quot;@+id/iv_news&quot;        android:layout_width=&quot;80dp&quot;        android:layout_height=&quot;80dp&quot;        android:scaleType=&quot;fitXY&quot;        app:layout_constraintLeft_toLeftOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;    &lt;TextView        android:id=&quot;@+id/tv_title&quot;        android:layout_width=&quot;0dp&quot;        android:layout_height=&quot;wrap_content&quot;        android:paddingLeft=&quot;10dp&quot;        android:textSize=&quot;20dp&quot;        app:layout_constraintLeft_toRightOf=&quot;@id/iv_news&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toTopOf=&quot;@id/iv_news&quot; /&gt;    &lt;TextView        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot;        android:padding=&quot;3dp&quot;        android:text=&quot;来自NBA官网&quot;        android:textSize=&quot;14dp&quot;        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;        app:layout_constraintRight_toRightOf=&quot;parent&quot;        app:layout_constraintTop_toBottomOf=&quot;@id/iv_news&quot; /&gt;&lt;/android.support.constraint.ConstraintLayout&gt;</code></pre><p>经过ConstraintLayout之后，布局的嵌套层级变为了2级，如果布局比较复杂，比如有5，6，7层嵌套层级，使用Contraintlayout之后降低的层级会更加明显。对于其app下的一系列属性，其实都非常简单，这里就不多做介绍了。</p><p>除此之外，还有以下方式可以减少布局层级和复杂度：</p><ul><li>1、不嵌套使用RelativeLayout。</li><li>2、不在嵌套LinearLayout中使用weight。</li><li>3、使用merge标签，它能够减少一个层级，但只能用于根View。</li></ul><h4 id="3、过渡绘制优化"><a href="#3、过渡绘制优化" class="headerlink" title="3、过渡绘制优化"></a>3、过渡绘制优化</h4><p>在视图的绘制优化中，还有一个比较重要的优化点，就是避免过渡绘制，这个笔者已经在<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>一文的第四小节详细分析过了。最后这里补充一下自定义View中使用clipRect的一个实例。</p><p>首先，我们自定义了一个DroidCardsView，他可以存放多个叠加的卡片，onDraw方法的实现如下：</p><pre><code> protected void onDraw(Canvas canvas) {    super.onDraw(canvas);    // Don&apos;t draw anything until all the Asynctasks are done and all the DroidCards are ready.    if (mDroids.length &gt; 0 &amp;&amp; mDroidCards.size() == mDroids.length) {        // Loop over all the droids, except the last one.        int i;        for (i = 0; i &lt; mDroidCards.size() - 1; i++) {            mCardLeft = i * mCardSpacing;            // Draw the card. Only the parts of the card that lie within the bounds defined by            // the clipRect() get drawn.            drawDroidCard(canvas, mDroidCards.get(i), mCardLeft, 0);        }        // Draw the final card. This one doesn&apos;t get clipped.        drawDroidCard(canvas, mDroidCards.get(mDroidCards.size() - 1),                mCardLeft + mCardSpacing, 0);    }    // Invalidate the whole view. Doing this calls onDraw() if the view is visible.    invalidate();}</code></pre><p>从以上代码可知，这里是直接进行绘制的，此时显示的布局过渡绘制背景如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/pre_overdraw.jpeg" alt="image"></p><p>可以看到，图片的背景都叠加起来了，这个时候，我们需要在绘制的时候使用clipRect让系统去识别可绘制的区域，因此我们在自定义的DroidCardsView的onDraw方法去使用clipRect：</p><pre><code>protected void onDraw(Canvas canvas) {    super.onDraw(canvas);    // Don&apos;t draw anything until all the Asynctasks are done and all the DroidCards are ready.    if (mDroids.length &gt; 0 &amp;&amp; mDroidCards.size() == mDroids.length) {        // Loop over all the droids, except the last one.        int i;        for (i = 0; i &lt; mDroidCards.size() - 1; i++) {            mCardLeft = i * mCardSpacing;            // 1、clipRect方法和绘制前后成对使用canvas的save方法与restore方法。            canvas.save();            // 2、使用clipRect指定绘制区域，这里的mCardSpacing是指的相邻卡片最左边的间距，需要在动态创建DroidCardsView的时候传入。            canvas.clipRect(mCardLeft,0,mCardLeft+mCardSpacing,mDroidCards.get(i).getHeight());            // 3、Draw the card. Only the parts of the card that lie within the bounds defined by            // the clipRect() get drawn.            drawDroidCard(canvas, mDroidCards.get(i), mCardLeft, 0);            canvas.restore();        }        // Draw the final card. This one doesn&apos;t get clipped.        drawDroidCard(canvas, mDroidCards.get(mDroidCards.size() - 1),                mCardLeft + mCardSpacing, 0);    }    // Invalidate the whole view. Doing this calls onDraw() if the view is visible.    invalidate();}</code></pre><p>在注释1处，首先需要在clipRect方法和绘制前后成对使用canvas的save方法与restore方法用来对画布进行操作。接着，在注释2处，使用clipRect指定绘制区域，这里的mCardSpacing是指的相邻卡片最左边的间距，需要在动态创建DroidCardsView的时候传入。最后，在注释3处调用实际绘制卡片的方法。</p><p>使用clipRect优化过后的布局过渡绘制背景如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/after_overdraw.jpeg" alt="image"></p><p><strong>注意：</strong></p><p>我们还可以通过canvas.quickReject方法来判断是否没和某个矩形相交，以跳过非矩形区域的绘制操作。</p><p>当然，对视图的绘制优化还有其它的一些优化操作，比如：</p><ul><li>1、使用ViewStub、Merge，ViewStub是一种高效占位符，用于延迟初始化。</li><li>2、onDraw中避免创建大对象，进行耗时操作。</li><li>3、TextView的优化，比如利用它的drawableLeft属性。此外，也可以使用Android 9.0之后的 PrecomputedText，它将文件的measure与layout过程进行了异步化。但是需要注意，如果要显示的文本比较少，反而会造成不必要的Scheduling delay，建议文本字符大于200时才使用，并记得使用其兼容类PrecomputedTextCompat，它在9.0以上使用PrecomputedText进行优化，在5.0~9.0使用StaticLayout进行优化。具体调用代码如下所示：</li></ul><pre><code>Future&lt;PrecomputedTextCompat&gt; future = PrecomputedTextCompat.getTextFuture(                “text”, textView.getTextMetricsParamsCompat(), null)；textView.setTextFuture(future);</code></pre><p>到这里，笔者就将常规的布局优化讲解完了，是不是顿时感觉实力大增呢？</p><div align="center"><br><img src="http://image.diydoutu.com/12140371143798.png?imageView2/0/format/jpg/q/75" width="30%"><br></div><p>如果你此时内心已经YY到这种程度，那我只能说：</p><div align="center"><br><img src="http://image.diydoutu.com/12140564648444.gif?imageView2/0/format/gif/q/75" width="30%"><br></div><p>下面，笔者就来和大家一起来探索布局优化的进阶方案。</p><h3 id="七、布局优化的进阶方案"><a href="#七、布局优化的进阶方案" class="headerlink" title="七、布局优化的进阶方案"></a>七、布局优化的进阶方案</h3><h4 id="1、使用异步布局框架Litho"><a href="#1、使用异步布局框架Litho" class="headerlink" title="1、使用异步布局框架Litho"></a>1、使用异步布局框架Litho</h4><p>Litho是Facebook开源的一款在Android上高效建立UI的声明式框架，它具有以下特点：</p><ul><li>声明式：它使用了声明式的API来定义UI组件。</li><li>异步布局：它可以提前布局UI，而不会阻塞UI线程。</li><li>视图扁平化：它使用了Facebook开源的另一款布局引擎Yoga进行布局，以自动减少UI包含的ViewGroup数量。</li><li>细粒度的回收：可以回收文本或图形等任何组件，并可以在用户界面的任何位置重复使用。</li><li>内部不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。Litho实现了大量使用Drawable来渲染的基础组件，可以进一步使布局扁平化。</li></ul><h5 id="简单使用Litho"><a href="#简单使用Litho" class="headerlink" title="简单使用Litho"></a>简单使用Litho</h5><p>接下来，我们在项目里面来使用Litho。</p><p>1、首先，我们需要配置Litho的相关依赖，如下所示：</p><pre><code>// 项目下repositories {    jcenter()}// module下dependencies {    // ...    // Litho    implementation &apos;com.facebook.litho:litho-core:0.33.0&apos;    implementation &apos;com.facebook.litho:litho-widget:0.33.0&apos;    annotationProcessor &apos;com.facebook.litho:litho-processor:0.33.0&apos;    // SoLoader    implementation &apos;com.facebook.soloader:soloader:0.5.1&apos;    // For integration with Fresco    implementation &apos;com.facebook.litho:litho-fresco:0.33.0&apos;    // For testing    testImplementation &apos;com.facebook.litho:litho-testing:0.33.0&apos;    // Sections （options，用来声明去构建一个list）    implementation &apos;com.facebook.litho:litho-sections-core:0.33.0&apos;    implementation &apos;com.facebook.litho:litho-sections-widget:0.33.0&apos;    compileOnly &apos;com.facebook.litho:litho-sections-annotations:0.33.0&apos;    annotationProcessor &apos;com.facebook.litho:litho-sections-processor:0.33.0&apos;}</code></pre><p>2、然后，在Application下的onCreate方法中初始化SoLoader：</p><pre><code>@Overridepublic void onCreate() {    super.onCreate();    SoLoader.init(this, false);}</code></pre><p>从之前的介绍可知，我们知道Litho使用了Yoga进行布局，而Yoga包含有native依赖，在Soloader.init方法中对这些native依赖进行了加载。</p><p>3、最后，在Activity的onCreate方法中添加如下代码即可显示单个的文本视图：</p><pre><code> // 1、将Activity的Context对象保存到ComponentContext中，并同时初始化// 一个资源解析者实例ResourceResolver供其余组件使用。ComponentContext componentContext = new ComponentContext(this);// 2、Text内部使用建造者模式以实现组件属性的链式调用，下面设置的text、// TextColor等属性在Litho中被称为Prop，此概念引申字React。Text lithoText = Text.create(componentContext)        .text(&quot;Litho text&quot;)        .textSizeDip(64)        .textColor(ContextCompat.getColor(this, R.color.light_deep_red))            .build();// 3、设置一个LithoView去展示Text组件：LithoView.create内部新建了一个// LithoView实例，并用给定的Component（lithoText）进行初始化setContentView(LithoView.create(componentContext, lithoText));</code></pre><p>显示效果如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_text.png" alt="image"></p><p>在上面的示例中，我们仅仅是将Text这个子组件设置给了LithoView，后续为了实现更复杂的布局，我们需要使用带多个子组件的根组件去替换它。</p><h5 id="使用自定义Component"><a href="#使用自定义Component" class="headerlink" title="使用自定义Component"></a>使用自定义Component</h5><p>由上可知，在Litho中的视图单元叫做Component，即组件，它的设计理念来源于React组件化的思想。每个组件持有描述一个视图单元所必须的属性与状态，用于视图布局的计算工作。视图最终的绘制工作是由组件指定的绘制单元（View或Drawable）来完成的。接下来，我们使用Litho提供的自定义Component的功能，它能够让我们实现更复杂的Component，这里我们来实现一个类似ListView的列表。</p><p>首先，我们先来实现一个ListItem Component，它就如ListView的itemView一样。在下面的实战中，我们将会学习到所有的基础知识，这将会支撑你后续能实现更多更复杂的Component。</p><p>然后，在Litho中，我们需要先写一个Spec类去声明Component所对应的布局，在这里需要使用@LayoutSpec规范注解(除此之外，Litho还提供了另一种类型的组件规范：Mount Spec)。代码如下所示：</p><pre><code>@LayoutSpecpublic class ListItemSpec {    @OnCreateLayout    static Component onCreateLayout(ComponentContext context) {        // Column的作用类似于HTML中的&lt;div&gt;标签        return Column.create(context)                .paddingDip(YogaEdge.ALL, 16)                .backgroundColor(Color.WHITE)                .child(Text.create(context)                            .text(&quot;Litho Study&quot;)                            .textSizeSp(36)                         .textColor(Color.BLUE)                            .build())                .child(Text.create(context)                            .text(&quot;JsonChao&quot;)                            .textSizeSp(24)                         .textColor(Color.MAGENTA)                            .build())                .build();    }}</code></pre><p>然后，框架会使用APT技术去帮助生成对应的ListItem Component 类。最后，我们在Activity的onCreate中将上述第一个例子中的第二步改为如下：</p><pre><code> // 2、构建ListItem组件ListItem listItem = ListItem.create(componentContext).build();</code></pre><p>运行项目，显示界面如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_listitem.png" alt="image"></p><p><strong>那上述过程是如何创建与构建的呢？</strong></p><p>它看起来就像有一个LithoSpec的类名，并且在项目构建之后生成了一个与LithoSpec有着同样包名的Litho类，如下所示：</p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/litho_build_listitem.png?raw=true" alt="image"></p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/app_listitemspec.png?raw=true" alt="image"></p><p>类似于Litho这种类中的所有方法参数都会由Litho进行自动填充。此外，基于这些规格，将会有一些额外的方法由注解处理器自动生成，例如上述示例中Column或Row中的Text的TextSizeSp、backgroundColor等方法。(Row和Column分别对应着Flexox中的行和列，它们都实现了Litho中另一种特殊的组件Layout)</p><h5 id="补充：MountSpec规范"><a href="#补充：MountSpec规范" class="headerlink" title="补充：MountSpec规范"></a>补充：MountSpec规范</h5><p>MountSpec是用来生成可挂载类型组件的一种规范，它的作用是用来生成渲染具体的View或者Drawable的组件。同LayoutSpec类似，它必须使用@MountSpec注解来标注，并实现一个标注了@onCreateMountContent的方法。但是MountSpec的实现要比Layout更加地复杂，因为它拥有自己的生命周期，如下所示：</p><ul><li>@OnPrepare：准备阶段，用于进行一些初始化操作。</li><li>@OnMeasure：负责布局的计算工作。</li><li>@OnBoundsDefined：在布局计算完成之后、挂载视图之前做一些操作。</li><li>@OnCreateMountContent：如果没有可以复用的视图单元，则调用它去创建需要挂载的视图。</li><li>@OnMount：挂载视图，用于完成布局相关的设置。</li><li>@OnBind：绑定视图，用于完成数据和视图的绑定。</li><li>@OnUnBind：解绑视图，与@OnBind相对，主要用于重置视图的数据属性，避免出现数据复用的问题。</li><li>@OnUnmount：卸载视图，与@OnMount相对，主要用于重置视图的布局相关的属性，避免出现布局复用的问题。</li></ul><p>MountSpec的生命周期流转图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_mount_spec_lifecycle.png" alt="image"></p><p>在使用Litho完成了两个实例的开发之后，相信我们已经对Litho的布局方式已经有了一个感性的认知。那么，Litho到底是如何进行布局优化的呢？在布局优化中它所做的核心工作有哪些？</p><p>Litho在布局优化中所做的核心工作包括以下三点：</p><ul><li>1、异步布局化。</li><li>2、布局自动扁平化。</li><li>3、更细粒度地优化RecyclerView中组件的缓存与回收的方法。</li></ul><h5 id="1、异步布局化"><a href="#1、异步布局化" class="headerlink" title="1、异步布局化"></a>1、异步布局化</h5><p>在前文中，我们知道Android的布局加载过程通常会先后涉及到measure、layout、draw过程，并且它们都是在主线程执行的，如果方法执行过程中耗时太多，则主界面必然会产生卡顿现象。</p><p>还记得我们在前面介绍的PrecomputedText，它内部将measure与layout的过程放在了异步线程进行初始化，而Litho与PrecomputedText类似，也是将measre与layout的过程进行了异步化，核心原理就是利用CPU的闲置时间提前在异步线程中完成measure和layout的过程，仅在UI线程中完成绘制工作。</p><p><strong>那么Android为什么不自己实现异步布局呢？</strong></p><p>主要有以下两原因：</p><ul><li>1、因为View的属性是可变的，只要属性发生变化就可能导致布局变化，所以需要重新计算布局，那么提前异步去计算布局的意义就不大了。而Litho组件的属性是不可变的，因此它的布局计算结果也是不变的。</li><li>2、提前异步布局需要去提前创建好接下来用到的若干条目的视图，但是Android原生的View作为视图单元，不仅包含一个视图的所有属性，而且还负责视图的绘制工作。如果要在绘制前提前去计算布局，就需要预先去持有大量未展示的View实例，这将会大大增加App进程的内存占用。对于Litho的组件来说，它只是视图属性的一个集合，仅仅负责计算布局，绘制工作由指定的绘制单元来完成。因此在Litho中，提前创建好下面要用到的多个条目的组件，是不会有性能问题的。两者的绘制原理简图如下所示：</li></ul><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_sync.png" alt="image"></p><h5 id="2、布局自动扁平化"><a href="#2、布局自动扁平化" class="headerlink" title="2、布局自动扁平化"></a>2、布局自动扁平化</h5><p>经过之前的学习，我们了解到Litho采用了一套自有的布局引擎Yoga，它会在布局的过程中去检测出不必要的布局嵌套层级，并自动去减少多余的层级以实现布局的扁平化，这可以显著减少渲染时的递归调用，加快渲染速度。例如，在实现一个图片带多个文字的布局中，我们通常会至少有两个布局层级，当然，<strong>你也可以使用TextView的drawableStart方法 + 代码动态布局使用Spannable/Html.fromHtml(用来实现多种不同规格的文字) + lineSpaceExtra/lineSpacingMultiplier（用来调整多行文本的显示间距）</strong>来将布局层级降为一层，但是这种实现方式比较繁琐，而通过使用Litho，我们可以把降低布局嵌套层级的任务全部丢给布局引擎Yoga去处理。由前面可知，Litho是使用Flexbox来创建布局的，并最终生成带有层级结构的组件树。通过使用Yoga来进行布局计算，可以使用Flexbox的相对布局变成了只有一层嵌套的绝对布局。相比于ConstraintLayout，对于实现复杂布局的时候可读性会更好一些，因为ConstraintLayout此时会有过多的约束条件，这会导致可读性变差。此外，Litho自身还提供了许多挂载Drawable的基本视图组件，相比Viwe组件使用它们可以显著减少内存占用（通常会减少80%的内存占用）。Litho实现布局自动扁平化的原理图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_plan.png" alt="image"></p><h5 id="3、更细粒度地优化RecyclerView中组件的缓存与回收的方法"><a href="#3、更细粒度地优化RecyclerView中组件的缓存与回收的方法" class="headerlink" title="3、更细粒度地优化RecyclerView中组件的缓存与回收的方法"></a>3、更细粒度地优化RecyclerView中组件的缓存与回收的方法</h5><p>使用了RecyclerView与ListView这么久，我们明白它是以viewType为粒度来对一个组件集合统一进行缓存与回收的，并且，当viewType的类型越多，其对组件集合的缓存与回收的效果就会越差。相对于RecyclerView与ListView缓存与回收的粗粒度而言，Litho实现了更细粒度的回收机制，它是以Text、image、video等单个Component为粒度来作为其基准的，具体实现原理为在item回收前，会把LithoView中挂载的各个绘制单元进行解绑拆分出来，由Litho自己的缓存池去分类回收，然后在展示前由LithoView按照组件树的样式挂载组装各个绘制单元，这样就达到了细粒度复用的目的。毫无疑问，这不仅提高了其缓存的命中率与内存的使用率，也降低了提高了其滚动刷新的频率。更细粒度复用优化内存的原图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_recycler.png" alt="image"></p><p>由上图可以看出，滑出屏幕的itemType1会被拆分成一个个的视图单元。其中LithoView容器由Recycler缓存池回收，而其他视图单元则由Litho的缓存池分类回收，例如分类为Img缓存池、Text缓存池等等。</p><p>现在，我们对Litho已经比较了解了，它似乎很完美，但是任何事物都有其弊端，在学习一个新的事物时，我们不仅仅只去使用与了解它的优势，更应该对它的缺陷与弊端了如指掌。Litho在布局的过程中，使用了类似React的单向数据流设计，并且由于Litho是使用代码进行动态布局，这大大增加了布局的复杂度，而且，代码布局是无法实时预览的，这也增加了开发调试时的难度。</p><p>综上，对于某些性能性能要求高的场景，可以先使用Litho布局的方式去替换，特别是利用好RecyclerViewCollectionComponent与sections去充分提升RecylerView的性能。</p><p>现在，我们来使用RecyclerViewCollectionComponent与sections去创建一个可滚动的列表单元。</p><p>接下来，我们需要使用SectionsAPI，它可以将列表分为多个Section，然后编写GroupSectionSpec注解类来声明每个Section需要呈现的内容及其使用的数据。下面，我们创建一个ListSectoinSpec：</p><pre><code>// 1、可以理解为一个组合Sectoin规格@GroupSectionSpecpublic class ListSectionSpec {    @OnCreateChildren    static Children onCreateChildren(final SectionContext context) {        Children.Builder builder = Children.create();        for (int i = 0; i &lt; 20; i++) {            builder.child(                   // 单组件区域用来包含一个特定的组件                    SingleComponentSection.create(context)                    .key(String.valueOf(i))                    .component(ListItem.create(context).build())        };        return builder.build();    }}</code></pre><p>然后，我们将MainActivity onCreate方法中的步骤2替换为如下代码：</p><pre><code>// 2、使用RecyclerCollectionComponent去绘制list   RecyclerCollectionComponent recyclerCollectionComponent = RecyclerCollectionComponent.create(componentContext)           // 使下拉刷新实现           .disablePTR(true)           .section(ListSection.create(new SectionContext(componentContext)).build())           .build();</code></pre><p>最终的显示效果如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/recycle_section.png" alt="image"></p><p><strong>如果我们需要显示不同UI的ListItem该怎么办呢？</strong></p><p>这个时候我们需要去自定义Component的属性，即props，它是一种不可变属性（此外还有一种可变属性称为State，但是其变化是由组件内部进行控制的，例如输入框、Checkbox等都是由组件内部去感知用户的行为，并由此更新组件的State属性），你设置的这些属性将会改变Component的行为或表现。Props是Component Spec中方法的参数，并且使用@Prop注解。</p><p>下面，我们使用props将ListItemSpec的onCreateLayout修改为可自定义组件属性的方法，如下所示：</p><pre><code>@LayoutSpecpublic class ListItemSpec {    @OnCreateLayout    static Component onCreateLayout(ComponentContext context,                                @Prop int bacColor,                                @Prop String title,                                @Prop String subTitle,                                @Prop int textSize,                                @Prop int subTextSize) {        // Column的作用类似于HTML中的&lt;div&gt;标签        return Column.create(context)                .paddingDip(YogaEdge.ALL, 16)                .backgroundColor(bacColor)                .child(Text.create(context)                            .text(title)                         .textSizeSp(textSize)                         .textColor(Color.BLUE)                            .build())                .child(Text.create(context)                            .text(subTitle)                         .textSizeSp(subTextSize)                         .textColor(Color.MAGENTA)                            .build())                .build();    }}</code></pre><p>奇妙之处就发生在我们所定义的@Prop注解与注解处理器之间，注解处理器以一种智能的方对组件构建过程中所关联的属性生成了对应的方法。</p><p>接下来，我们再修改ListSectionSpec类，如下所示：</p><pre><code>@GroupSectionSpecpublic class ListSectionSpec {    @OnCreateChildren    static Children onCreateChildren(final SectionContext context) {        Children.Builder builder = Children.create();        for (int i = 0; i &lt; 20; i++) {            builder.child(                    SingleComponentSection.create(context)                    .key(String.valueOf(i))                    .component(ListItem.create(context)                            .bacColor(i % 2 == 0 ? Color.BLUE:Color.MAGENTA)                            .title(&quot;第&quot; + i + &quot;次练习&quot;)                         .subTitle(&quot;JsonChao&quot;)                            .textSize(36)                            .subTextSize(24)                            .build())            );        }        return builder.build();    }}</code></pre><p>最终的显示效果如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/litho_prop.png" alt="image"></p><p>除此之外，我们还可以有更多的方式去定义@Prop，如下所示：</p><pre><code>@Prop(optional = true, resType = ResType.DIMEN_OFFSET) int shadowRadius,</code></pre><p>上面定义了一个可选的Prop，传入的shadowRadius是支持dimen规格的，如px、dp、sp等等。</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>使用Litho，在布局性能上有很大的提升，但是开发成本太高，因为需要自己去实现很多的组件，并且其组件需要在编译时才能生成，不能够进行实时预览，但是可以把Litho封装成Flexbox布局的底层渲染引擎，以此实现上层的动态化，具体实现原理可参见<a href="https://tech.meituan.com/2019/09/19/litho-practice-in-dynamic-program-mtflexbox.html" target="_blank" rel="external">Litho在美团动态化方案MTFlexbox中的实践</a>。</p><h4 id="2、使用Flutter实现高性能的UI布局"><a href="#2、使用Flutter实现高性能的UI布局" class="headerlink" title="2、使用Flutter实现高性能的UI布局"></a>2、使用Flutter实现高性能的UI布局</h4><p>Flutter可以说是2019最火爆的框架之一了，它是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。对于Android来说，FLutter能够创作媲美原生的高性能应用，应用使用 Dart语言进行 开发。Flutter的架构类似于Android的层级架构，每一层都建立在前一层之上，其架构图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/flutter_acrchitecture.png" alt="image"></p><p>在Framework层中，Flutter通过在 widgets 层组合基础 widgets 来构建 Material 层，而 widgets 层本身则是通过对来自 Rendering 层的低层次对象组合而来。而在Engine层，Flutter集成了Skia引擎用于进行栅格化，并且使用了Dart虚拟机。</p><h5 id="那么Flutter的图形性能为何能够媲美原生应用呢？"><a href="#那么Flutter的图形性能为何能够媲美原生应用呢？" class="headerlink" title="那么Flutter的图形性能为何能够媲美原生应用呢？"></a>那么Flutter的图形性能为何能够媲美原生应用呢？</h5><p>接下来，我们以Flutter、原生Android、其它跨平台框架如RN来做比较，它们的图形绘制调用层级图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/flutter_performance_compare.png" alt="image"></p><p>可以看到，Flutter框架的代码完全取代了Java层的框架代码，所以只要当Flutter框架中Dart代码的效率可以媲美原生框架的Java代码的时候，那么总体的Flutter App的性能就能够媲美原生的APP。而反观其它流行的跨平台框架如RN，它首先需要调用自身的Js代码，然后再去调用Java层的代码，这里比原生和Flutter的App显然多出来一个步骤，所以它的性能肯定是不及原生的APP的。此外，Flutter App不同于原生、RN，它内部是直接包含了Skia渲染引擎的，只要Flutter SDK进行升级，Skia就能够升级，这样Skia的性能改进就能够同步到Flutter框架之中。而对于Android原生和RN来说，只能等到Android系统升级才能同步Skia的性能改进。</p><h5 id="而Flutter又是如何实现高性能UI布局的呢？"><a href="#而Flutter又是如何实现高性能UI布局的呢？" class="headerlink" title="而Flutter又是如何实现高性能UI布局的呢？"></a>而Flutter又是如何实现高性能UI布局的呢？</h5><p>接下来，我们来大致了解一下Flutter的UI绘制原理，它主要是通过VSYNC信号来使UI线程和GPU线程有条不紊的周期性的去渲染界面，其绘制原理图如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/flutter_ui_core.png" alt="image"></p><p>绘制步骤大致如下：</p><ul><li>1、首先 UI Runner 会执行 root isolate（可简单理解为Dart  VM的线程），它会告诉引擎层有帧要渲染，当需要渲染则会调用到Engine的ScheduleFrame()来注册VSYNC信号回调，一旦触发回调doFrame()，并当它执行完成后，便会移除回调方法，也就是说一次注册一次回调。</li><li>2、当需要再次绘制则需要重新调用到ScheduleFrame()方法，该方法的唯一重要参数regenerate_layer_tree决定在帧绘制过程是否需要重新生成layer tree，还是直接复用上一次的layer tree。</li><li>3、接着，执行的是UI线程绘制过程中最核心的WidgetsBinding的drawFrame()方法，然后会创建layer tree视图树。</li><li>4、然后 Layer Tree 会交给 GPU Task Runner 进行合成和栅格化。</li><li>5、最后，GPU Task Runner会利用Skia库结合GL或Vu’lkan将layer tree提供的信息转化为平台可执行的GPU指令。</li></ul><p>此外，Flutter 也采用了类似 Litho 的props属性不可变、Reat单向数据流的方案，用于将视图与数据分离。对于Flutter这一大前端领域的核心技术，笔者也是充满兴趣，后续会有计划对此进行深入研究，敬请期待。</p><h4 id="3、使用RenderThread-与-RenderScript"><a href="#3、使用RenderThread-与-RenderScript" class="headerlink" title="3、使用RenderThread 与 RenderScript"></a>3、使用RenderThread 与 RenderScript</h4><p>在Android 5.0之后，Android引进了RenderThread，它能够实现动画的异步渲染。但是目前支持RenderThread完全渲染的动画，只有两种，即ViewPropertyAnimator和CircularReveal（揭露动画）。对于CircularReveal使用比较简单且功能较为单一，就不多做过多的描述了。下面我简单说下ViewPropertyAnimator中如何去利用RenderThread。</p><h5 id="1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT-，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示："><a href="#1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT-，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示：" class="headerlink" title="1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT ，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示："></a>1、在ViewPropertyAnimator类系中，有一个ViewPropertyAnimatorRT ，它的主要作用就把动画交给RenderThread去处理。因此，我们需要先去创建对应view的ViewPropertyAnimatorRT，代码如下所示：</h5><pre><code> /** * 使用反射的方式去创建对应View的ViewPropertyAnimatorRT(非hide类) */private static Object createViewPropertyAnimatorRT(View view) {    try {                   Class&lt;?&gt; animRtClazz = Class.forName(&quot;android.view.ViewPropertyAnimatorRT&quot;);        Constructor&lt;?&gt; animRtConstructor = animRtClazz.getDeclaredConstructor(View.class);        animRtConstructor.setAccessible(true);        Object animRt = animRtConstructor.newInstance(view);                    return animRt;    } catch (Exception e) {                    Log.d(TAG, &quot;创建ViewPropertyAnimatorRT出错,错误信息:&quot; + e.toString());                   return null;    }}</code></pre><h5 id="2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示："><a href="#2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示：" class="headerlink" title="2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示："></a>2、接下来，我们需要将ViewPropertyAnimatorRT设置给ViewPropertyAnimator的mRTBackend字段，这样ViewPropertyAnimator才能利用它去将动画交给RenderThread处理，如下所示：</h5><pre><code>private static void setViewPropertyAnimatorRT(ViewPropertyAnimator animator, Object rt) {        try {        Class&lt;?&gt; animClazz = Class.forName(&quot;android.view.ViewPropertyAnimator&quot;);        Field animRtField = animClazz.getDeclaredField(&quot;mRTBackend&quot;);        animRtField.setAccessible(true);        animRtField.set(animator, rt);    } catch (Exception e) {        Log.d(TAG, &quot;设置ViewPropertyAnimatorRT出错,错误信息:&quot; + e.toString());    }}/** * 在animator.start()即执行动画开始之前配置的方法 */public static void onStartBeforeConfig(ViewPropertyAnimator animator, View view) {    Object rt = createViewPropertyAnimatorRT(view);    setViewPropertyAnimatorRT(animator, rt);}</code></pre><h5 id="3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示："><a href="#3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示：" class="headerlink" title="3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示："></a>3、最后，在开启动画之前将ViewPropertyAnimatorRT实例设置进去即可，如下所示：</h5><pre><code>ViewPropertyAnimator animator = v.animate().scaleY(2).setDuration(2000);AnimHelper.onStartBeforeConfig(animator, v);animator.start();</code></pre><p>现在，如果是做音视频或图像处理的工作，经常需要对图片进行高斯模糊、放大、锐化等操作，但是这里涉及大量的图片变换操作，例如缩放、裁剪、二值化以及降噪等。而图片的变换又涉及大量的计算任务，这个时候我们可以通过RenderScript去充分利用手机的GPU计算能力，以实现高效的图片处理。</p><p>而RenderScript的工作流程需要经历如下三个步骤：</p><ul><li>1、RenderScript运行时API：提供进行运算的API。</li><li>2、反射层：相当于NDK中的JNI胶水代码，它是一些由Android编译工具自动生成的类，对我们写的RenderScript代码进行包装，以使得安卓层能够和RenderScript进行交互。</li><li>3、安卓框架：通过调用反射层来访问RenderScript运行时。</li></ul><p>由于RenderScript主要是用于音视频、图像处理等细分领域，这里笔者就不继续深入扩展了，对于NDK、音视频领域的知识，笔者在今年会有一系列学习计划，目前大纲已经定制好了，如果有兴趣的朋友，可以了解下：<a href="https://github.com/JsonChao/Awesome-Android-NDK" target="_blank" rel="external">Awesome-Android-NDK</a>。</p><h3 id="八、布局优化的常见问题"><a href="#八、布局优化的常见问题" class="headerlink" title="八、布局优化的常见问题"></a>八、布局优化的常见问题</h3><h4 id="1、你在做布局优化的过程中用到了哪些工具？"><a href="#1、你在做布局优化的过程中用到了哪些工具？" class="headerlink" title="1、你在做布局优化的过程中用到了哪些工具？"></a>1、你在做布局优化的过程中用到了哪些工具？</h4><p>我在做布局优化的过程中，用到了很多的工具，但是每一个工具都有它不同的使用场景，不同的场景应该使用不同的工具。下面我从线上和线下两个角度来进行分析。</p><p>比如说，我要统计线上的FPS，我使用的就是Choreographer这个类，它具有以下特性：</p><ul><li>1、能够获取整体的帧率。</li><li>2、能够带到线上使用。</li><li>3、它获取的帧率几乎是实时的，能够满足我们的需求。</li></ul><p>同时，在线下，如果要去优化布局加载带来的时间消耗，那就需要检测每一个布局的耗时，对此我使用的是AOP的方式，它没有侵入性，同时也不需要别的开发同学进行接入，就可以方便地获取每一个布局加载的耗时。如果还要更细粒度地去检测每一个控件的加载耗时，那么就需要使用LayoutInflaterCompat.setFactory2这个方法去进行Hook。</p><p>此外，我还使用了LayoutInspector和Systrace这两个工具，Systrace可以很方便地看到每帧的具体耗时以及这一帧在布局当中它真正做了什么。而LayoutInspector可以很方便地看到每一个界面的布局层级，帮助我们对层级进行优化。</p><h4 id="2、布局为什么会导致卡顿，你又是如何优化的？"><a href="#2、布局为什么会导致卡顿，你又是如何优化的？" class="headerlink" title="2、布局为什么会导致卡顿，你又是如何优化的？"></a>2、布局为什么会导致卡顿，你又是如何优化的？</h4><p>分析完布局的加载流程之后，我们发现有如下四点可能会导致布局卡顿：</p><ul><li>1、首先，系统会将我们的Xml文件通过<strong>IO</strong>的方式映射的方式加载到我们的内存当中，而IO的过程可能会导致卡顿。</li><li>2、其次，布局加载的过程是一个反射的过程，而反射的过程也会可能会导致卡顿。</li><li>3、同时，这个布局的层级如果比较深，那么进行布局遍历的过程就会比较耗时。</li><li>4、最后，不合理的嵌套RelativeLayout布局也会导致重绘的次数过多。</li></ul><p>对此，我们的优化方式有如下几种：</p><ul><li>1、针对布局加载Xml文件的优化，我们使用了异步Inflate的方式，即AsyncLayoutInflater。它的核心原理是在子线程中对我们的Layout进行加载，而加载完成之后会将View通过Handler发送到主线程来使用。所以不会阻塞我们的主线程，加载的时间全部是在异步线程中进行消耗的。而这仅仅是一个从侧面缓解的思路。</li><li>2、后面，我们发现了一个从根源解决上述痛点的方式，即使用X2C框架。它的一个核心原理就是在开发过程我们还是使用的XML进行编写布局，但是在编译的时候它会使用APT的方式将XML布局转换为Java的方式进行布局，通过这样的方式去写布局，它有以下优点：1、它省去了使用IO的方式去加载XML布局的耗时过程。2、它是采用Java代码直接new的方式去创建控件对象，所以它也没有反射带来的性能损耗。这样就从根本上解决了布局加载过程中带来的问题。</li><li>3、然后，我们可以使用ConstraintLayout去减少我们界面布局的嵌套层级，如果原始布局层级越深，它能减少的层级就越多。而使用它也能避免嵌套RelativeLayout布局导致的重绘次数过多。</li><li>4、最后，我们可以使用AspectJ框架（即AOP）和LayoutInflaterCompat.setFactory2的方式分别去建立线下全局的布局加载速度和控件加载速度的监控体系。</li></ul><h4 id="3、做完布局优化有哪些成果产出？"><a href="#3、做完布局优化有哪些成果产出？" class="headerlink" title="3、做完布局优化有哪些成果产出？"></a>3、做完布局优化有哪些成果产出？</h4><ul><li>1、首先，我们建立了一个体系化的监控手段，这里的体系还指的是线上加线下的一个综合方案，针对线下，我们使用AOP或者ARTHook，可以很方便地获取到每一个布局的加载耗时以及每一个控件的加载耗时。针对线上，我们通过Choreographer.getInstance().postFrameCallback的方式收集到了FPS，这样我们可以知道用户在哪些界面出现了丢帧的情况。</li><li>2、然后，对于布局监控方面，我们设立了FPS、布局加载时间、布局层级等一系列指标。</li><li>3、最后，在每一个版本上线之前，我们都会对我们的核心路径进行一次Review，确保我们的FPS、布局加载时间、布局层级等达到一个合理的状态。</li></ul><h3 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h3><p>对于Android的布局优化，笔者以一种自顶向下，层层递进的方式和大家一起深入地去探索了Android中如何将布局优化做到极致，其中主要涉及以下八大主题：</p><ul><li>1、绘制原理：CPU\GPU、Android图形系统的整体架构、绘制线程、刷新机制。</li><li>2、屏幕适配：OLED 屏幕和 LCD 屏幕的区别、屏幕适配方案。</li><li>3、优化工具：使用Systrace来进行布局优化、利用Layout Inspector来查看视图层级结构、采用Choreographer来获取FPS以及自动化测量 UI 渲染性能的方式（gfxinfo、SurfaceFlinger等dumpsys命令）。</li><li>4、布局加载原理：布局加载源码分析、LayoutInflater.Factory分析。</li><li>5、获取界面布局耗时：使用AOP的方式去获取界面加载的耗时、利用LayoutInflaterCompat.setFactory2去监控每一个控件加载的耗时。</li><li>6、布局优化常规方案：使用AOP的方式去获取界面加载的耗时、利用LayoutInflaterCompat.setFactory2去监控每一个控件加载的耗时。</li><li>7、布局优化的进阶方案：使用异步布局框架Litho、使用Flutter实现高性能的UI布局、使用RenderThread实现动画的异步渲染与 利用RenderScript实现高效的图片处理。</li><li>8、布局优化的常见问题。</li></ul><p>可以看到，布局优化看似是Android性能优化中最简单的专项优化项，但是笔者却花费了整整三万字的篇幅才能比较完整地将其核心知识传授给大家。因此，不要小看每一个专项优化点，深入进去，必定满载而归。</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第五章 布局优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/80921" target="_blank" rel="external">极客时间之Android开发高手课 UI优化</a></p><p>3、<a href="http://mobile.zol.com.cn/680/6809348.html" target="_blank" rel="external">手机屏幕的前世今生 可能比你想的还精彩</a></p><p>4、<a href="https://www.zhihu.com/question/22263252" target="_blank" rel="external">OLED 和 LCD 什么区别？</a></p><p>5、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826034&amp;idx=1&amp;sn=5e86768d7abc1850b057941cdd003927&amp;chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&amp;scene=21#wechat_redirect" target="_blank" rel="external">Android 目前稳定高效的UI适配方案</a></p><p>6、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-smallestWidth 限定符适配方案</a></p><p>7、<a href="https://github.com/ladingwu/dimens_sw" target="_blank" rel="external">dimens_sw github</a></p><p>8、<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247484502&amp;idx=2&amp;sn=a60ea223de4171dd2022bc2c71e09351&amp;scene=21#wechat_redirect" target="_blank" rel="external">一种极低成本的Android屏幕适配方式</a></p><p>9、<a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-今日头条适配方案</a></p><p>10、<a href="https://juejin.im/post/5bce688e6fb9a05cf715d1c2#heading-0" target="_blank" rel="external">今日头条屏幕适配方案终极版正式发布!</a></p><p>11、<a href="https://www.jianshu.com/p/b492140a555f" target="_blank" rel="external">使用Systrace分析UI性能</a></p><p>12、<a href="https://gapid.dev/about/" target="_blank" rel="external">GAPID-Graphics API Debugger</a></p><p>13、<a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a></p><p>14、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 屏幕绘制机制及硬件加速</a></p><p>15、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 图形处理官方教程</a></p><p>16、<a href="https://zhuanlan.zhihu.com/p/20712354" target="_blank" rel="external">Vulkan - 高性能渲染</a></p><p>17、<a href="https://source.android.com/devices/graphics/arch-vulkan" target="_blank" rel="external">Android Vulkan Tutorial</a></p><p>18、<a href="https://developer.android.com/training/testing/performance#top_of_page" target="_blank" rel="external">Test UI performance-gfxinfo</a></p><p>19、<a href="https://www.jianshu.com/p/7477e381a7ea" target="_blank" rel="external">使用dumpsys gfxinfo 测UI性能（适用于Android6.0以后）</a></p><p>20、<a href="https://developer.android.com/reference/android/view/TextureView" target="_blank" rel="external">TextureView API</a></p><p>21、<a href="https://developer.android.com/reference/android/text/PrecomputedText" target="_blank" rel="external">PrecomputedText API</a></p><p>22、<a href="https://fblitho.com/docs/tutorial" target="_blank" rel="external">Litho Tutorial</a></p><p>23、<a href="https://tech.meituan.com/2019/03/14/litho-use-and-principle-analysis.html" target="_blank" rel="external">基本功 | Litho的使用及原理剖析</a></p><p>24、<a href="https://flutter.cn/docs/resources/technical-overview" target="_blank" rel="external">Flutter官方文档中文版</a></p><p>25、<a href="https://www.bilibili.com/video/av48772383/?spm_id_from=333.788.videocard.0" target="_blank" rel="external">[Google Flutter 团队出品] 深入了解 Flutter 的高性能图形渲染</a></p><p>26、<a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="external">Flutter渲染机制—UI线程</a></p><p>27、<a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489230&amp;idx=1&amp;sn=adc193e35903ab90a4c966059933a35a&amp;source=41#wechat_redirect" target="_blank" rel="external">RenderThread:异步渲染动画</a></p><p>28、<a href="https://developer.android.com/guide/topics/renderscript/compute" target="_blank" rel="external">RenderScript官方文档</a></p><p>29、<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">RenderScript :简单而快速的图像处理</a></p><p>30、<a href="https://www.jianshu.com/p/b72da42e1463" target="_blank" rel="external">RenderScript渲染利器</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8B%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>深入探索Android布局优化（上）</title>
      <link>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/</link>
      <guid>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/</guid>
      <pubDate>Mon, 13 Jan 2020 14:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>Android的绘制优化其实可以分为两个部分，即布局(UI)优化和卡顿优化，而布局优化的核心问题就是要解决因布局渲染性能不佳而导致应用卡顿的问题，所以它可以认为是卡顿优化的一个子集。对于Android开发来说，写布局可以说是一个比较简单的工作，但是如果想将写的每一个布局的渲染性能提升到比较好的程度，要付出的努力是要远远超过写布局所付出的。由于布局优化这一主题包含的内容太多，因此，笔者将它分为了上、下两篇，本篇，即为深入探索Android布局优化的上篇。本篇包含的主要内容如下所示：</p><ul><li>1、绘制原理</li><li>2、屏幕适配</li><li>3、优化工具</li><li>4、布局加载原理</li><li>5、获取界面布局耗时</li></ul><p>说到Android的布局绘制，那么我们就不得不先从布局的绘制原理开始说起。</p><h3 id="一、绘制原理"><a href="#一、绘制原理" class="headerlink" title="一、绘制原理"></a>一、绘制原理</h3><p>Android的绘制实现主要是借助CPU与GPU结合刷新机制共同完成的。</p><h4 id="1、CPU与GPU"><a href="#1、CPU与GPU" class="headerlink" title="1、CPU与GPU"></a>1、CPU与GPU</h4><ul><li>CPU负责计算显示内容，包括Measure、Layout、Record、Execute等操作。在UI绘制上的缺陷在于容易显示重复的视图组件，这样不仅带来重复的计算操作，而且会占用额外的GPU资源。</li><li>GPU负责栅格化（用于将UI元素绘制到屏幕上，即将UI组件拆分到不同的像素上显示）。</li></ul><p>这里举两个栗子来讲解一些CPU和GPU的作用：</p><ul><li>1、文字的显示首先经过CPU换算成纹理，然后再传给GPU进行渲染。</li><li>2、而图片的显示首先是经过CPU的计算，然后加载到内存当中，最后再传给GPU进行渲染。</li></ul><p>那么，软件绘制和硬件绘制有什么区别呢？我们先看看下图：</p><p><img src="https://raw.githubusercontent.com/yuegs/yuegs.github.io/master/images/android/render-process/diff-hw-soft.png" alt="image"></p><p>这里软件绘制使用的是Skia库（一款在低端设备如手机上呈现高质量的 2D 图形的 跨平台图形框架)进行绘制的，而硬件绘制本质上是使用的OpenGl ES接口去利用GPU进行绘制的。OpenGL是一种跨平台的图形API，它为2D/3D图形处理硬件指定了标准的软件接口。而OpenGL ES是用于嵌入式设备的，它是OpenGL规范的一种形式，也可称为其子集。</p><p>并且，由于OpenGl ES系统版本的限制，有很多 绘制API 都有相应的 Android API level 的限制，此外，在Android 7.0 把 OpenGL ES 升级到最新的 3.2 版本的时候，还添加了对Vulkan（一套适用于高性能 3D 图形的低开销、跨平台 API）的支持。Vulan作为下一代图形API以及OpenGL的继承者，它的优势在于大幅优化了CPU上图形驱动相关的性能。</p><h4 id="2、Android-图形系统的整体架构"><a href="#2、Android-图形系统的整体架构" class="headerlink" title="2、Android 图形系统的整体架构"></a>2、Android 图形系统的整体架构</h4><p>Android官方的架构图如下：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/graphic_arc.png" alt="image"></p><p>为了比较好的描述它们之间的作用，我们可以把应用程序图形渲染过程当作一次绘画过程，那么绘画过程中 Android 的各个图形组件的作用分别如下：</p><ul><li>画笔：Skia 或者 OpenGL。我们可以用 Skia去绘制 2D 图形，也可以用 OpenGL 去绘制 2D/3D 图形。</li><li>画纸：Surface。所有的元素都在 Surface 这张画纸上进行绘制和渲染。在 Android 中，Window 是 View 的容器，每个窗口都会关联一个 Surface。而 WindowManager 则负责管理这些窗口，并且把它们的数据传递给 SurfaceFlinger。</li><li>画板：Graphic Buffer。Graphic Buffer 缓冲用于应用程序图形的绘制，在 Android 4.1 之前使用的是双缓冲机制，而在 Android 4.1 之后使用的是三缓冲机制。</li><li>显示：SurfaceFlinger。它将 WindowManager 提供的所有 Surface，通过硬件合成器 Hardware Composer 合成并输出到显示屏。</li></ul><p>在了解完Android图形系统的整体架构之后，我们还需要了解下Android系统的显示原理，关于这块内容可以参考我之前写的<a href="https://jsonchao.github.io/2019/07/28/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E7%BB%98%E5%88%B6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">Android性能优化之绘制优化</a>的Android系统显示原理一节。</p><h4 id="3、RenderThread"><a href="#3、RenderThread" class="headerlink" title="3、RenderThread"></a>3、RenderThread</h4><p>在Android系统的显示过程中，虽然我们利用了GPU的图形高性能计算的能力，但是从计算Display到通过GPU绘制到Frame Buffer都在UI线程中完成，此时如果能让GPU在不同的线程中进行绘制渲染图形，那么绘制将会更加地流畅。</p><p>于是，在Android 5.0之后,引入了RenderNode和RenderThread的概念，它们的作用如下：</p><ul><li>RenderNode：进一步封装了Display和某些View的属性。</li><li>RenderThread：渲染线程，负责执行所有的OpenGl命令，其中的RenderNode保存有渲染帧的所有信息，能在主线程有耗时操作的前提下保证动画流畅。</li></ul><p>CPU将数据同步给GPU之后，通常不会阻塞等待RenderThread去利用GPU去渲染完视图，而是通知结束之后就返回。加入ReaderThread之后的整个显示调用流程图如下图所示：</p><p><img src="https://static001.geekbang.org/resource/image/7f/7d/7f349aefe7a081259218af30b9a9fc7d.png" alt="image"></p><p>在Android 6.0之后，其在adb shell dumpsys gxinfo命令中添加了更加详细的信息，在优化工具一节中我将详细分析下它的使用。</p><p>在Android 7.0之后，对HWUI进行了重构，它是用于2D硬件绘图并负责硬件加速的主要模块，其使用了OpenGl ES来进行GPU硬件绘图。此外，Android 7.0还支持了Vulkan，并且，Vulkan 1.1在Android 被引入。</p><h5 id="硬件加速存在哪些问题？"><a href="#硬件加速存在哪些问题？" class="headerlink" title="硬件加速存在哪些问题？"></a>硬件加速存在哪些问题？</h5><p>我们都知道，硬件加速的原理就是将CPU不擅长的图形计算转换成GPU专用指令。</p><ul><li>1、其中的OpenGl API调用和Graphic Buffer缓冲区至少会占用几MB以上的内存，<strong>内存消耗较大</strong>。</li><li>2、有些OpenGl的绘制API还没有支持，特别是比较低的Android系统版本，并且由于Android每一个版本都会对渲染模块进行一些重构，导致了在硬件加速绘制过程中会出现一些不可预知的Bug。如在Android 5.0~7.0机型上出现的libhwui.so崩溃问题，需要使用inline Hook、GOT Hook等native调试手段去进行分析定位，可能的原因是ReaderThread与UI线程的sync同步过程出现了差错，而这种情况一般都是有多个相同的视图绘制而导致的，比如View的复用、多个动画同时播放。</li></ul><h4 id="4、刷新机制"><a href="#4、刷新机制" class="headerlink" title="4、刷新机制"></a>4、刷新机制</h4><p>16ms发出VSync信号触发UI渲染，大多数的Android设备屏幕刷新频率为60HZ，如果16ms内不能完成渲染过程，则会产生掉帧现象。</p><h3 id="二、屏幕适配"><a href="#二、屏幕适配" class="headerlink" title="二、屏幕适配"></a>二、屏幕适配</h3><p>我们都知道，Android手机屏幕的差异化导致了严重的碎片化问题，并且屏幕材质也是用户比较关注的一个重要因素。</p><p>首先，我们来了解下主流Android屏幕材质，目前主要有两类：</p><ul><li>LCD（Liquid Crystal Display）：液晶显示器。</li><li>OLED（Organic Light-Emitting Diode ）:有机发光二极管。</li></ul><p>早在20世纪60年代，随着半导体集成电路的发展，美国人成功研发出了第一块液晶显示屏LCD，而现在大部分最新的高端机使用的都是OLED材质，这是因为相比于LCD屏幕，OLED屏幕在色彩、可弯曲程度、厚度和耗电等方面都有一定的优势。正因为如此，现在主流的全面屏、曲面屏与未来的柔性折叠屏，使用的几乎都是 OLED 材质。当前，好的材质，它的成本也必然会比较昂贵。</p><h4 id="1、OLED-屏幕和-LCD-屏幕的区别"><a href="#1、OLED-屏幕和-LCD-屏幕的区别" class="headerlink" title="1、OLED 屏幕和 LCD 屏幕的区别"></a>1、OLED 屏幕和 LCD 屏幕的区别</h4><p>如果要明白OLED 屏幕和LCD屏幕的区别，需要了解它们的运行原理，下面，我将分别进行讲解。</p><h5 id="屏幕的成像原理"><a href="#屏幕的成像原理" class="headerlink" title="屏幕的成像原理"></a>屏幕的成像原理</h5><p>屏幕由无数个点组成，并且，每个点由红绿蓝三个子像素组成，每个像素点通过调节红绿蓝子像素的颜色配比来显示不同的颜色，最终所有的像素点就会形成具体的画面。</p><h5 id="LCD背光源与OLED自发光"><a href="#LCD背光源与OLED自发光" class="headerlink" title="LCD背光源与OLED自发光"></a>LCD背光源与OLED自发光</h5><p>下面，我们来看下LCD和OLED的总体结构图，如下所示：</p><p><img src="https://pic4.zhimg.com/v2-5b2ed9a8a18793f9801183e327ecc364_b.jpg" alt="image"></p><p>LCD的发光原理主要在于背光层Back-light，它通常都会由大量的LED背光灯组成以用于显示白光，之后，为了显示出彩色，在其上面加了一层有颜色的薄膜，白色的背光穿透了有颜色的薄膜后就可以显示出彩色了。但是，为了实现调整红绿蓝光的比例，需要在背光层和颜色薄膜之间加入一个控制阀门，即液晶层liquid crystal，它可以通过改变电压的大小来控制开合的程度，开合大则光多，开合小则光少。</p><p>对于OLED来说，它不需要LCD屏幕的背光层和用于控制出光量的液晶层，它就像一个有着无数个小的彩色灯泡组成的屏幕，只需要给它通电就能发光。</p><h5 id="LCD的致命缺陷"><a href="#LCD的致命缺陷" class="headerlink" title="LCD的致命缺陷"></a>LCD的致命缺陷</h5><p>它的液晶层不能完全关合，如果LCD显示黑色，会有部分光穿过颜色层，所以LCD的黑色实际上是白色和黑色混合而成的灰色。而OLED不一样，OLED显示黑色的时候可以直接关闭区域的像素点。</p><p>此外，由于背光层的存在，所以LCD显示器的背光非常容易从屏幕与边框之间的缝隙泄漏出去，即会产生显示器漏光现象。</p><h5 id="OLED屏幕的优势"><a href="#OLED屏幕的优势" class="headerlink" title="OLED屏幕的优势"></a>OLED屏幕的优势</h5><ul><li>1、由于没有有背光层和液晶层的存在，所以它的<strong>厚度更薄，其弯曲程度可以达到180%</strong>。</li><li>2、对比度（白色比黑色的比值）更高，使其画面颜色越浓；相较于LCD来说，<strong>OLED是油画，色彩纯而细腻，而LCD是水彩笔画，色彩朦胧且淡</strong>。</li><li>3、OLED每个像素点都是独立的，所以OLED可以单独点亮某些像素点，即能实现<strong>单独点亮</strong>。而LCD只能控制整个背光层的开关。并且，由于OLED单独点亮的功能，使其<strong>耗电程度大大降低</strong>。</li><li>4、OLED的<strong>屏幕响应时间很快</strong>，不会造成画面残留以致造成视觉上的拖影现象。而LCD则会有严重的拖影现象。</li></ul><h5 id="OLED屏幕的劣势"><a href="#OLED屏幕的劣势" class="headerlink" title="OLED屏幕的劣势"></a>OLED屏幕的劣势</h5><ul><li>1、由于OLED是<strong>有机材料</strong>，导致其寿命是不如LCD的<br>有机材料的。并且，由于OLED单独点亮的功能，会使每个像素点工作的时间不一样，这样，在屏幕老化时就会导致色彩显示不均匀，即产生<strong>烧屏</strong>现象。</li><li>2、由于OLED就不能采取控制电压的方式去调整亮度，所以目前只能通过不断的开关开关开关去进行调光。</li><li>3、OLED的屏幕像素点排列方式不如LCD的紧凑，所以在分辨率相同的情况下，OLED的屏幕是不如LCD清楚的。即OLED的<strong>像素密度较低</strong>。</li></ul><h4 id="2、屏幕适配方案"><a href="#2、屏幕适配方案" class="headerlink" title="2、屏幕适配方案"></a>2、屏幕适配方案</h4><p>我们都知道，Android 的 系统碎片化、机型以及屏幕尺寸碎片化、屏幕分辨率碎片化非常地严重。所以，一个好的屏幕适配方案是很重要的。接下来，我将介绍目前主流的屏幕适配方案。</p><h5 id="1、最原始的Android适配方案：dp-自适应布局或weight比例布局"><a href="#1、最原始的Android适配方案：dp-自适应布局或weight比例布局" class="headerlink" title="1、最原始的Android适配方案：dp + 自适应布局或weight比例布局"></a>1、最原始的Android适配方案：dp + 自适应布局或weight比例布局</h5><p>首先，我们来回顾一下px、dp、dpi、ppi、density等概念：</p><ul><li>px：像素点，px = density * dp。</li><li>ppi：像素密度，每英寸所包含的像素数目，屏幕物理参数，不可调整，dpi没有人为调整时 = ppi。</li><li>dpi：像素密度，在系统软件上指定的单位尺寸的像素数量，可人为调整，dpi没有人为调整时 = ppi。</li><li>dp：density-independent pixels，即密度无关像素，基于屏幕物理分辨率的一个抽象的单位，以dp为尺寸单位的控件，在不同分辨率和尺寸的手机上代表了不同的真实像素，比如在分辨率较低的手机中，可能1dp = 1px,而在分辨率较高的手机中，可能1dp=2px，这样的话，一个64<em>64dp的控件，在不同的手机中就能表现出差不多的大小了，px = dp </em> （dpi / 160）。</li><li>denstiy：密度，屏幕上每平方英寸所包含的像素点个数，density = dpi / 160。</li></ul><p>通常情况下，我们只需要使用dp + 自适应布局（如鸿神的AutoLayout、ConstraintLayout等等）或weight比例布局即可基本解决碎片化问题，当然，这种方式也存在一些问题，比如dpi和ppi的差异所导致在同一分辨率手机上控件大小的不同。</p><h5 id="2、宽高限定符适配方案"><a href="#2、宽高限定符适配方案" class="headerlink" title="2、宽高限定符适配方案"></a>2、宽高限定符适配方案</h5><p>它就是穷举市面上所有的Android手机的宽高像素值，通过设立一个基准的分辨率，其他分辨率都根据这个基准分辨率来计算，在不同的尺寸文件夹内部，根据该尺寸编写对应的dimens文件，如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190420175718265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxNnlsZzA4,size_16,color_FFFFFF,t_70" alt="image"></p><p>比如以480x320为基准分辨率：</p><ul><li>宽度为320，将任何分辨率的宽度整分为320份，取值为x1-x320。</li><li>高度为480，将任何分辨率的高度整分为480份，取值为y1-y480。</li></ul><p>那么对于800*480的分辨率的dimens文件来说：</p><ul><li>x1=(480/320)*1=1.5px</li><li>x2=(480/320)*2=3px</li></ul><p><img src="http://img.jeepxie.net/upload/6/45/64555d6e993f2e28bee628c8cc52d171_thumb.png" alt="image"></p><p>此时，如果UI设计界面使用的就是基准分辨率，那么我们就可以按照设计稿上的尺寸填写相对应的dimens去引用，而当APP运行在不同分辨率的手机中时，系统会根据这些dimens去引用该分辨率对应的文件夹下面去寻找对应的值。但是这个方案由一个缺点，就是无法做到向下兼容去使用更小的dimens，比如说800x480的手机就一定要找到800x480的限定符，否则就只能用统一默认的dimens文件了。</p><h5 id="3、UI适配框架AndroidAutoLayout的适配方案"><a href="#3、UI适配框架AndroidAutoLayout的适配方案" class="headerlink" title="3、UI适配框架AndroidAutoLayout的适配方案"></a>3、UI适配框架AndroidAutoLayout的适配方案</h5><p>因宽高限定符方案的启发，鸿神出品了一款能使用UI适配更加开发高效和适配精准的项目。</p><p><a href="https://github.com/hongyangAndroid/AndroidAutoLayout" target="_blank" rel="external">项目地址</a></p><p>基本使用步骤如下：</p><p>第一步：在你的项目的AndroidManifest中注明你的设计稿的尺寸：</p><pre><code>&lt;meta-data android:name=&quot;design_width&quot; android:value=&quot;768&quot;&gt;&lt;/meta-data&gt;&lt;meta-data android:name=&quot;design_height&quot; android:value=&quot;1280&quot;&gt;&lt;/meta-data&gt;</code></pre><p>第二步：让你的Activity继承自AutoLayoutActivity。如果你不希望继承AutoLayoutActivity，可以在编写布局文件时，直接使用AutoLinearLayout、Auto<em>*</em>等适配布局即可。</p><p>接下来，直接在布局文件里面使用具体的像素值就可以了，因为在APP运行时，AndroidAutoLayout会帮助我们根据不同手机的具体尺寸按比例伸缩。</p><p>AndroidAutoLayout在宽高限定符适配的基础上，解决了其dimens不能向下兼容的问题，但是它在运行时会在onMeasure里面对dimens去做变换，所以对于自定义控件或者某些特定的控件需要进行单独适配；并且，整个UI的适配过程都是由框架完成的，以后想替换成别的UI适配方案成本会比较高，而且，不幸的是，项目已经停止维护了。</p><h5 id="4、smallestWidth适配方案（sw限定符适配）"><a href="#4、smallestWidth适配方案（sw限定符适配）" class="headerlink" title="4、smallestWidth适配方案（sw限定符适配）"></a>4、smallestWidth适配方案（sw限定符适配）</h5><p>smallestWidth即最小宽度，系统会根据当前设备屏幕的 最小宽度 来匹配 values-sw<n>dp。</n></p><p>我们都知道，移动设备都是允许屏幕可以旋转的，当屏幕旋转时，屏幕的高宽就会互换，加上 最小 这两个字，是因为这个方案是不区分屏幕方向的，它只会把屏幕的高度和宽度中值最小的一方认为是 最小宽度。</p><p>并且它跟宽高限定符适配原理上是一样，都是系统通过特定的规则来选择对应的文件。它与AndroidAutoLayout一样，同样解决了其dimens不能向下兼容的问题，如果该屏幕的最小宽度是360dp，但是项目中没有values-sw360dp文件夹的话，它就可能找到values-sw320dp这个文件夹，其尺寸规则命名如下图所示：</p><p><img src="https://i2.wp.com/5b0988e595225.cdn.sohucs.com/images/20180815/8abd457b9b8c40ab91dc58888aa8c6d9.png?zoom=2&amp;w" alt="image"></p><p>假如加入我们的设计稿的像素宽度是375，那么其对应的values-sw360dp和values-sw400dp宽度如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/ui_adpt_sw_1.png" alt="image"></p><p><img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/ui_adpt_sw_2.png?raw=true" alt="image"></p><p>smallestWidth的适配机制由系统保证，我们只需要针对这套规则生成对应的资源文件即可，即使对应的smallestWidth值没有找到完全对应的资源文件，它也能向下兼容，寻找最接近的资源文件。虽然多个dimens文件可能导致apk变大，但是其增加大小范围也只是在300kb-800kb这个区间，这还是可以接受的。这套方案唯一的变数就是选择需要适配哪些最小宽度限定符的文件，如果您生成的 values-sw<n>dp 与设备实际的 最小宽度 差别不大，那误差也就在能接受的范围内，如果差别很大，那效果就会很差。最后，总结一下这套方案的优缺点：</n></p><p><strong>优点：</strong></p><ul><li>1、稳定且无性能损耗。</li><li>2、可通过选择需要哪些最小宽度限定符文件去控制适配范围。</li><li>3、在自动生成values-sw<n>的插件基础下，学习成本较低。</n></li></ul><p>插件地址为<a href="https://github.com/ladingwu/dimens_sw" target="_blank" rel="external">自动生成values-sw<n>的项目代码</n></a>。生成需要的values-sw<n>dp文件夹的步骤如下：</n></p><ul><li>1、clone该项目到本地,以Android项目打开。</li><li>2、DimenTypes文件中写入你希望适配的sw尺寸，默认的这些尺寸能够覆盖几乎所有手机适配需求。</li><li>3、DimenGenerator文件中填写设计稿的尺寸(DESIGN_WIDTH是设计稿宽度，DESIGN_HEIGHT是设计稿高度)。</li><li>4、执行lib module中的DimenGenerator.main()方法，当前地址下会生成相应的适配文件,把相应的文件连带文件夹拷贝到正在开发的项目中。</li></ul><p><strong>缺点：</strong></p><ul><li>1、侵入性高，后续切换其他屏幕适配方案需修改大量 dimens 引用。</li><li>2、覆盖更多不同屏幕的机型需要生成更多的资源文件，使APK体积变大。</li><li>3、不能自动支持横竖屏切换时的适配，如要支持需使用 values-w<n>dp 或 屏幕方向限定符 再生成一套资源文件，又使APK体积变大。</n></li></ul><p><strong>如果想让屏幕宽度随着屏幕的旋转而做出改变该怎么办呢？</strong></p><p>此时根据 values-w<n>dp (去掉 sw 中的 s) 去生成一套资源文件即可。</n></p><p><strong>如果想区分屏幕的方向来做适配该怎么办呢？</strong></p><p>去根据 屏幕方向限定符 生成一套资源文件，后缀加上 -land 或 -port 即可，如：values-sw360dp-land (最小宽度 360 dp 横向)，values-sw400dp-port (最小宽度 720 dp 纵向)。</p><p><strong>注意：</strong></p><p>如果UI设计上明显更适合使用wrap_content,match_parent,layout_weight等,我们就要毫不犹豫的使用，毕竟，上述都是仅仅针对不得不使用固定宽高的情况，我相信基础的UI适配知识大部分开发者还是具备的。如果不具备的话，请看下方：</p><div align="center"><br><img src="http://image.diydoutu.com/12138865495338.gif?imageView2/0/format/gif/q/75" width="30%"><br></div><h5 id="5、今日头条适配方案"><a href="#5、今日头条适配方案" class="headerlink" title="5、今日头条适配方案"></a>5、今日头条适配方案</h5><p>它的原理是根据屏幕的宽度或高度动态调整每个设备的 density (每 dp 占当前设备屏幕多少像素)，通过修改density值的方式，强行把所有不同尺寸分辨率的手机的宽度dp值改成一个统一的值，这样就可以解决所有的适配问题。其对应的重要公式如下：</p><pre><code>当前设备屏幕总宽度（单位为像素）/  设计图总宽度（单位为 dp) = density</code></pre><p>今日头条适配方案默认项目中只能以高或宽中的一个作为基准来进行适配，并不像 AndroidAutoLayout 一样，高以高为基准，宽以宽为基准，来同时进行适配，为什么？</p><p>因为，现在中国大部分市面上的 Android 设备的屏幕高宽比都不一致，特别是现在的全面屏、刘海屏、弹性折叠屏，使这个问题更加严重，不同厂商推出的手机的屏幕高宽比都可能不一致。所以，我们只能以高或宽其中的一个作为基准进行适配，以此避免布局在高宽比不一致的屏幕上出现变形。</p><p>它有以下优势：</p><ul><li>1、使用成本低，操作简单，使用该方案后在页面布局时不需要额外的代码和操作。</li><li>2、侵入性低，和项目完全解耦，在项目布局时不会依赖哪怕一行该方案的代码，而且使用的还是 Android 官方的 API，意味着当你遇到什么问题无法解决，想切换为其他屏幕适配方案时，基本不需要更改之前的代码，整个切换过程几乎在瞬间完成，试错成本接近于 0。</li><li>3、可适配三方库的控件和系统的控件(不止是是 Activity 和 Fragment，Dialog、Toast 等所有系统控件都可以适配)，由于修改的 density 在整个项目中是全局的，所以只要一次修改，项目中的所有地方都会受益。</li><li>4、不会有任何性能的损耗。</li><li>5、不涉及私有API。</li></ul><p>它的缺点如下所示：</p><ul><li>1、适配范围不可控，只能一刀切的将整个项目进行适配，这种将所有控件都强行使用我们项目自身的设计图尺寸进行适配的方案会有问题：当某个系统控件或三方库控件的设计图尺寸和和我们项目自身的设计图尺寸差距越大时，该系统控件或三方库控件的适配效果就越差。比较好的解决方案就是按 Activity 为单位，取消当前 Activity 的适配效果，改用其他的适配方案。</li><li>2、对旧项目的UI适配兼容性不够。</li></ul><p><strong>注意：</strong></p><p>千万不要在此方案上使用smallestWidth适配方案中直接填写设计图上标注的 px 值的做法，这样会使项目强耦合于这个方案，后续切换其它方案都不得不将所有的 layout 文件都改一遍。</p><p>这里推荐一下JessYanCoding的<a href="https://github.com/JessYanCoding/AndroidAutoSize" target="_blank" rel="external">AndroidAutoSize</a>项目，用法如下：</p><p>1、首先在项目的build.gradle中添加该库的依赖：</p><pre><code>implementation &apos;me.jessyan:autosize:1.1.2&apos;</code></pre><p>2、接着 AndroidManifest 中填写全局设计图尺寸 (单位 dp)，如果使用副单位，则可以直接填写像素尺寸，不需要再将像素转化为 dp：</p><pre><code>&lt;manifest&gt;    &lt;application&gt;                    &lt;meta-data            android:name=&quot;design_width_in_dp&quot;            android:value=&quot;360&quot;/&gt;        &lt;meta-data            android:name=&quot;design_height_in_dp&quot;            android:value=&quot;640&quot;/&gt;               &lt;/application&gt;           &lt;/manifest&gt;</code></pre><p><strong>为什么只需在AndroidManifest.xml 中填写一下 meta-data 标签就可实现自动运行？</strong></p><p>在 App 启动时，系统会在 App 的主进程中自动实例化声明的 ContentProvider，并调用它的 onCreate 方法，执行时机比 Application#onCreate 还靠前，可以做一些初始化的工作，这个时候我们就可以利用它的 onCreate 方法在其中启动框架。如果项目使用了多进程，调用Application#onCreate 中调用下 ContentProvider#query 就能够使用 ContentProvider 在当前进程中进行实例化。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>上述介绍的所有方案并没有哪一个是十分完美的，但我们能清晰的认识到不同方案的优缺点，并将它们的优点相结合，这样才能应付更加复杂的开发需求，创造出最卓越的产品。比如SmallestWidth 限定符适配方案 主打的是稳定性，在运行过程中极少会出现安全隐患，适配范围也可控，不会产生其他未知的影响，而 今日头条适配方案 主打的是降低开发成本、提高开发效率，使用上更灵活，也能满足更多的扩展需求。所以，具体情况具体分析，到底选择哪一个屏幕适配方案还是需要去根据我们项目自身的需求去选择。</p><h3 id="三、优化工具"><a href="#三、优化工具" class="headerlink" title="三、优化工具"></a>三、优化工具</h3><h4 id="1、Systrace"><a href="#1、Systrace" class="headerlink" title="1、Systrace"></a>1、Systrace</h4><p>早在<a href="https://jsonchao.github.io/2019/11/10/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" target="_blank" rel="external">深入探索Android启动速度优化</a>一文中我们就了解过Systrace的使用、原理及它作为启动速度分析的用法。而它其实主要是用来分析绘制性能方面的问题。下面我就详细介绍下Systrace作为绘制优化工具有哪些必须关注的点。</p><h5 id="1、关注Frames"><a href="#1、关注Frames" class="headerlink" title="1、关注Frames"></a>1、关注Frames</h5><p>首先，先在左边栏选中我们当前的应用进程，在应用进程一栏下面有一栏Frames，我们可以看到有绿、黄、红三种不同的小圆圈，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/systrace_frames.png" alt="image"></p><p>图中每一个小圆圈代表着当前帧的状态，大致的对应关系如下：</p><ul><li>正常：绿色。</li><li>丢帧：黄色。</li><li>严重丢帧：红色。</li></ul><p>并且，选中其中某一帧，我们还可以在视图最下方的详情框看到该帧对应的相关的Alerts报警信息，以帮助我们去排查问题；此外，如果是大于等于Android 5.0的设备（即API Level21），创建帧的工作工作分为UI线程和render线程。而在Android 5.0之前的版本中，创建帧的所有工作都是在UI线程上完成的。接下来，我们看看该帧对应的详情图，如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/systrace_frame_detail.png" alt="image"></p><p>对应到此帧，我们发现这里可能有两个绘制问题：Bitmap过大、布局嵌套层级过多导致的measure和layout次数过多，这就需要我们去在项目中找到该帧对应的Bitmap进行相应的优化，针对布局嵌套层级过多的问题去选择更高效的布局方式，这块后面我们会详细介绍。</p><h5 id="2、关注Alerts栏"><a href="#2、关注Alerts栏" class="headerlink" title="2、关注Alerts栏"></a>2、关注Alerts栏</h5><p>此外，Systrace的显示界面还在在右边侧栏提供了一栏Alert框去显示出它所检测出所有可能有绘制性能问题的地方及对应的数量，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/systrace_alert.png" alt="image"></p><p>在这里，我们可以将Alert框看做是一个是待修复的Bug列表，通常一个区域的改进可以消除应用程序中的所有类中该类型的警报，所以，不要为这里的警报数量所担忧。</p><h4 id="2、Layout-Inspector"><a href="#2、Layout-Inspector" class="headerlink" title="2、Layout Inspector"></a>2、Layout Inspector</h4><p>Layout Inspector是AndroidStudio自带的工具，它的主要作用就是用来查看视图层级结构的。</p><p>具体的操作路径为：</p><pre><code>点击Tools工具栏 -&gt;第三栏的Layout Inspector -&gt; 选中当前的进程</code></pre><p>下面为操作之后打开的<a href="">Awesome-WanAndroid</a>首页图，如下所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/layout_inspect_overview.png" alt="image"></p><p>其中，最右侧的View Tree就是用来查看视图的层级结构的，非常方便，这是它最主要的功能，中间的是一个屏幕截图，最右边的是一个属性表格，比如我在截图中选中某一个TextView（Kotlin/入门及知识点一栏），在属性表格的text中就可以显示相关的信息，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/layout_inspect_pro_table.png" alt="image"></p><h4 id="3、Choreographer"><a href="#3、Choreographer" class="headerlink" title="3、Choreographer"></a>3、Choreographer</h4><p>Choreographer是用来获取FPS的，并且可以用于线上使用，具备实时性，但是仅能在Api 16之后使用，具体的调用代码如下：</p><pre><code>Choreographer.getInstance().postFrameCallback();</code></pre><p>使用Choreographer获取FPS的完整代码如下所示：</p><pre><code>private long mStartFrameTime = 0;private int mFrameCount = 0;/** * 单次计算FPS使用160毫秒 */private static final long MONITOR_INTERVAL = 160L; private static final long MONITOR_INTERVAL_NANOS = MONITOR_INTERVAL * 1000L * 1000L;/** * 设置计算fps的单位时间间隔1000ms,即fps/s */private static final long MAX_INTERVAL = 1000L; @TargetApi(Build.VERSION_CODES.JELLY_BEAN)private void getFPS() {    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.JELLY_BEAN) {        return;    }    Choreographer.getInstance().postFrameCallback(new Choreographer.FrameCallback() {        @Override        public void doFrame(long frameTimeNanos) {            if (mStartFrameTime == 0) {                mStartFrameTime = frameTimeNanos;            }            long interval = frameTimeNanos - mStartFrameTime;            if (interval &gt; MONITOR_INTERVAL_NANOS) {                double fps = (((double) (mFrameCount * 1000L * 1000L)) / interval) * MAX_INTERVAL;                // log输出fps                LogUtils.i(&quot;当前实时fps值为： &quot; + fps);                mFrameCount = 0;                mStartFrameTime = 0;            } else {                ++mFrameCount;            }            Choreographer.getInstance().postFrameCallback(this);        }    });}</code></pre><h4 id="4、Tracer-for-OpenGL-ES-与-GAPID（Graphics-API-Debugger）"><a href="#4、Tracer-for-OpenGL-ES-与-GAPID（Graphics-API-Debugger）" class="headerlink" title="4、Tracer for OpenGL ES 与 GAPID（Graphics API Debugger）"></a>4、Tracer for OpenGL ES 与 GAPID（Graphics API Debugger）</h4><p>Tracer for OpenGL ES 是 Android 4.1 新增加的工具，它可逐帧、逐函数的记录 App 使用 OpenGL ES 的绘制过程，并且，它可以记录每个 OpenGL 函数调用的消耗时间。当使用Systrace还找不到渲染问题时，就可以去尝试使用它。</p><p>而GAPID是 Android Studio 3.1 推出的工具，可以认为是Tracer for OpenGL ES的进化版，它不仅实现了跨平台，而且支持Vulkan与回放。由于它们主要是用于OpenGL相关开发的使用，这里我就不多介绍了。</p><h4 id="5、自动化测量-UI-渲染性能的方式"><a href="#5、自动化测量-UI-渲染性能的方式" class="headerlink" title="5、自动化测量 UI 渲染性能的方式"></a>5、自动化测量 UI 渲染性能的方式</h4><p>在自动化测试中，我们通常希望通过执行性能测试的自动化脚本来进行线下的自动化检测，那么，有哪些命令可以用于测量UI渲染的性能呢？</p><p>我们都知道，dumpsys是一款输出有关系统服务状态信息的Android工具，利用它我们可以获取当前设备的UI渲染性能信息，目前常用的有如下两种命令：</p><h5 id="1、gfxinfo"><a href="#1、gfxinfo" class="headerlink" title="1、gfxinfo"></a>1、gfxinfo</h5><p>gfxinfo的主要作用是输出各阶段发生的动画与帧相关的信息，命令格式如下：</p><pre><code>adb shell dumpsys gfxinfo &lt;PackageName&gt;</code></pre><p>这里我以<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>项目为例，输出其对应的gfxinfo信息如下所示：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys gfxinfo json.chao.com.wanandroidApplications Graphics Acceleration Info:Uptime: 549887348 Realtime: 549887348** Graphics info for pid 1722     [json.chao.com.wanandroid] **Stats since: 549356564232951nsTotal frames rendered: 5210Janky frames: 193 (3.70%)50th percentile: 5ms90th percentile: 9ms95th percentile: 13ms99th percentile: 34msNumber Missed Vsync: 31Number High input latency: 0Number Slow UI thread: 153Number Slow bitmap uploads: 6Number Slow issue draw commands: 51HISTOGRAM: 5ms=4254 6ms=131 7ms=144 8ms=87 9ms=80 10ms=83 11ms=108 12ms=57 13ms=29 14ms=17 15ms=17 16ms=14 17ms=20 18ms=15 19ms=15 20ms=17 21ms=9 22ms=14 23ms=8 24ms=9 25ms=4 26ms=5 27ms=4 28ms=4 29ms=1 30ms=2 31ms=4 32ms=3 34ms=6 36ms=5 38ms=7 40ms=8 42ms=0 44ms=3 46ms=3 48ms=5 53ms=2 57ms=0 61ms=3 65ms=0 69ms=1 73ms=1 77ms=0 81ms=0 85ms=0 89ms=1 93ms=1 97ms=0 101ms=0 105ms=0 109ms=0 113ms=1 117ms=0 121ms=0 125ms=0 129ms=0 133ms=0 150ms=2 200ms=0 250ms=2 300ms=1 350ms=1 400ms=0 450ms=1 500ms=0 550ms=1 600ms=0 650ms=0 700ms=0 750ms=0 800ms=0 850ms=0 900ms=0 950ms=0 1000ms=0 1050ms=0 1100ms=0 1150ms=0 1200ms=0 1250ms=0 1300ms=0 1350ms=0 1400ms=0 1450ms=0 1500ms=0 1550ms=0 1600ms=0 1650ms=0 1700ms=0 1750ms=0 1800ms=0 1850ms=0 1900ms=0 1950ms=0 2000ms=0 2050ms=0 2100ms=0 2150ms=0 2200ms=0 2250ms=0 2300ms=0 2350ms=0 2400ms=0 2450ms=0 2500ms=0 2550ms=0 2600ms=0 2650ms=0 2700ms=0 2750ms=0 2800ms=0 2850ms=0 2900ms=0 2950ms=0 3000ms=0 3050ms=0 3100ms=0 3150ms=0 3200ms=0 3250ms=0 3300ms=0 3350ms=0 3400ms=0 3450ms=0 3500ms=0 3550ms=0 3600ms=0 3650ms=0 3700ms=0 3750ms=0 3800ms=0 3850ms=0 3900ms=0 3950ms=0 4000ms=0 4050ms=0 4100ms=0 4150ms=0 4200ms=0 4250ms=0 4300ms=0 4350ms=0 4400ms=0 4450ms=0 4500ms=0 4550ms=0 4600ms=0 4650ms=0 4700ms=0 4750ms=0 4800ms=0 4850ms=0 4900ms=0 4950ms=0Caches:Current memory usage / total memory usage (bytes):TextureCache          5087048 / 59097600Layers total          0 (numLayers = 0)RenderBufferCache           0 /  4924800GradientCache           20480 /  1048576PathCache                   0 /  9849600TessellationCache           0 /  1048576TextDropShadowCache         0 /  4924800PatchCache                  0 /   131072FontRenderer A8        184219 /  1478656    A8   texture 0       184219 /  1478656FontRenderer RGBA           0 /        0FontRenderer total     184219 /  1478656Other:FboCache                    0 /        0Total memory usage:6586184 bytes, 6.28 MBPipeline=FrameBuilderProfile data in ms:    json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity/android.view.ViewRootImpl@4a2142e (visibility=8)    json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.ArticleDetailActivity/android.view.ViewRootImpl@4bccbcf (visibility=8)View hierarchy:json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity/android.view.ViewRootImpl@4a2142e151 views, 154.02 kB of display listsjson.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.ArticleDetailActivity/android.view.ViewRootImpl@4bccbcf19 views, 18.70 kB of display listsTotal ViewRootImpl: 2Total Views:        170Total DisplayList:  172.73 kB</code></pre><p>下面，我将对其中的关键信息进行分析。</p><p><strong>帧的聚合分析数据</strong></p><p>开始的一栏是统计的当前界面所有帧的聚合分析数据，主要作用是<strong>综合查看App的渲染性能以及帧的稳定性。</strong></p><ul><li>Graphics info for pid 1722     [json.chao.com.wanandroid] -&gt; 说明了当前提供的是Awesome-WanAndroid应用界面的帧信息，对应的进程id为1722。</li><li>Total frames rendered 5210 -&gt; 本次dump的数据搜集了5210帧的信息。</li><li>Janky frames: 193 (3.70%) -&gt; 5210帧中有193帧发生了Jank，即单帧耗时时间超过了16ms，卡顿的概率为3.70%。</li><li>50th percentile: 5ms -&gt; 所有帧耗时排序后，其中前50%最大的耗时帧的耗时为5ms。</li><li>90th percentile: 9ms -&gt; 同上，依次类推。</li><li>95th percentile: 13ms -&gt; 同上，依次类推。</li><li>99th percentile: 34ms -&gt; 同上，依次类推。</li><li>Number Missed Vsync: 31 -&gt; 垂直同步失败的帧数为31。</li><li>Number High input latency: 0 -&gt; 处理input耗时的帧数为0。</li><li>Number Slow UI thread: 153 -&gt; 因UI线程的工作而导致耗时的帧数为153。</li><li>Number Slow bitmap uploads: 6 -&gt; 因bitmap加载导致耗时的帧数为6。</li><li>Number Slow issue draw commands: 51 -&gt; 因绘制问题导致耗时的帧数为51。</li><li>HISTOGRAM: 5ms=4254 6ms=131 7ms=144 8ms=87… -&gt; 直方图数据列表，说明了耗时0~5ms的帧数为4254，耗时5~6ms的帧数为131，后续的数据依次类推即可。</li></ul><p>后续的log数据表明了不同组件的缓存占用信息，帧的建立路径信息以及总览信息等等，参考意义不大。</p><p>可以看到，上述的数据只能让我们总体感受到绘制性能的好坏，并不能去定位具体帧的问题，那么，还有更好的方式去获取具体帧的信息吗？</p><p><strong>添加framestats去获取最后120帧的详细信息</strong></p><p>该命令的格式如下：</p><pre><code>adb shell dumpsys gfxinfo &lt;PackageName&gt; framestats</code></pre><p>这里还是以Awesome-Android项目为例，输出项目标签页的帧详细信息：</p><pre><code>quchao@quchaodeMacBook-Pro ~ % adb shell dumpsys gfxinfo json.chao.com.wanandroid framestatsApplications Graphics Acceleration Info:Uptime: 603118462 Realtime: 603118462...Window: json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivityStats since: 603011709157414nsTotal frames rendered: 3295Janky frames: 117 (3.55%)50th percentile: 5ms90th percentile: 9ms95th percentile: 14ms99th percentile: 32msNumber Missed Vsync: 17Number High input latency: 3Number Slow UI thread: 97Number Slow bitmap uploads: 13Number Slow issue draw commands: 20HISTOGRAM: 5ms=2710 6ms=75 7ms=81 8ms=70...---PROFILEDATA---Flags,IntendedVsync,Vsync,OldestInputEvent,NewestInputEvent,HandleInputStart,AnimationStart,PerformTraversalsStart,DrawStart,SyncQueued,SyncStart,IssueDrawCommandsStart,SwapBuffers,FrameCompleted,DequeueBufferDuration,QueueBufferDuration,0,603111579233508,603111579233508,9223372036854775807,0,603111580203105,603111580207688,603111580417688,603111580651698,603111580981282,603111581033157,603111581263417,603111583942011,603111584638678,1590000,259000,0,603111595904553,603111595904553,9223372036854775807,0,603111596650344,603111596692428,603111596828678,603111597073261,603111597301386,603111597362376,603111597600292,603111600584667,603111601288261,1838000,278000,...,---PROFILEDATA---...</code></pre><p>这里我们只需关注其中的PROFILEDATA一栏，因为它表明了最近120帧每个帧的状态信息。</p><p>因为其中的数据是以csv格式显示的，我们将PROFILEDATA中的数据全部拷贝过来，然后放入一个txt文件中，接着，把.txt后缀改为.csv，使用WPS表格工具打开，如下图所示：</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/framestats_data.png" alt="image"></p><p>从上图中，我们看到输出的第一行是对应的输出数据列的格式，下面我将详细进行分析。</p><p><strong>Flags:</strong></p><ul><li>Flags为0则可计算得出该帧耗时：FrameCompleted - IntendedVsync。</li><li>Flags为非0则表示绘制时间超过16ms，为异常帧。</li></ul><p><strong>IntendedVsync：</strong></p><ul><li>帧的预期Vsync时刻，如果预期的Vsync时刻与现实的Vsync时刻不一致，则表明UI线程中有耗时工作导致其无法响应Vsync信号。</li></ul><p><strong>Vsync：</strong></p><ul><li>花费在Vsync监听器和帧绘制的时间，比如Choreographer frame回调、动画、View.getDrawingTime等待。</li><li>理解Vsync：Vsync避免了在屏幕刷新时，把数据从后台缓冲区复制到帧缓冲区所消耗的时间。</li></ul><p><strong>OldestInputEvent：</strong></p><ul><li>输入队列中最旧输入事件的时间戳，如果没有输入事件，则此列数据都为Long.MAX_VALUE。</li><li>通常用于framework层开发。</li></ul><p><strong>NewestInputEvent：</strong></p><ul><li>输入队列中最新输入时间的时间戳，如果没有输入事件，则此列数据都为0。</li><li>计算App大致的延迟添加时间：FrameCompleted - NewestInputEvent。</li><li>通常用于framework层开发。</li></ul><p><strong>HandleInputStart：</strong></p><ul><li>将输入事件分发给App对应的时间戳时刻。</li><li>用于测量App处理输入事件的时间：AnimationStart - HandleInputStart。当值大于2ms时，说明程序花费了很长的时间来处理输入事件，比如View.onTouchEvent等事件。注意在Activity切换或产生点击事件时此值一般都比较大，此时是可以接受的。</li></ul><p><strong>AnimationStart：</strong></p><ul><li>运行Choreographer（舞蹈编排者）注册动画的时间戳。</li><li>用来评估所有运行的所有动画器（ObjectAnimator、ViewPropertyAnimator、常用转换器）需要多长时间：AnimationStart - PerformTraversalsStart。当值大于2ms时，请查看此时是否执行的是自定义动画且动画是否有耗时操作。</li></ul><p><strong>PerformTraversalsStart：</strong></p><ul><li>执行布局递归遍历开始的时间戳。</li><li>用于获取measure、layout的时间：DrawStart - PerformTraversalsStart。（注意滚动或动画期间此值应接近于0）。</li></ul><p><strong>DrawStart：</strong></p><ul><li>draw阶段开始的时间戳，它记录了任何无效视图的DisplayList的起点。</li><li>用于获取视图数中所有无效视图调用View.draw方法所需的时间：SyncStart - DrawStart。</li><li>在此过程中，硬件加速模块中的DisplayList发挥了重要作用，Android系统仍然使用invalidate()调用draw()方法请求屏幕更新和渲染视图，但是对实际图形的处理方式有所不同。Android系统并没有立即执行绘图命令，而是将它们记录在DisplayList中，该列表包含视图层次结构绘图所需的所有信息。相对于软件渲染的另一个优化是，Android系统仅需要记录和更新DispalyList，以显示被invalidate() 标记为dirty的视图。只需重新发布先前记录的Displaylist，即可重新绘制尚未失效的视图。此时的硬件绘制模型主要包括三个过程：刷新视图层级、记录和更新DisplayList、绘制DisplayList。相对于软件绘制模型的刷新视图层级、然后直接去绘制视图层级的两个过程，虽然多了一个步骤，但是节省了很多不必要的绘制开销。</li></ul><p><strong>SyncQueued：</strong></p><ul><li>sync请求发送到RenderThread线程的时间戳。</li><li>获取sync就绪所花费的时间：SyncStart - SyncQueued。如果值大于0.1ms，则说明RenderThread正在忙于处理不同的帧。</li></ul><p><strong>SyncStart：</strong></p><ul><li>绘图的sync阶段开始的时间戳。</li><li>IssueDrawCommandsStart - SyncStart &gt; 0.4ms左右则表明有许多新的位图需要上传至GPU。</li></ul><p><strong>IssueDrawCommandsStart：</strong></p><ul><li>硬件渲染器开始GPU发出绘图命令的时间戳。</li><li>用于观察App此时绘制时消耗了多少GPU：FrameCompleted - IssueDrawCommandsStart。</li></ul><p><strong>SwapBuffers：</strong></p><ul><li>eglSwapBuffers被调用时的时间戳。</li><li>通常用于Framework层开发。</li></ul><p><strong>FrameCompleted：</strong></p><ul><li>当前帧完成绘制的时间戳。</li><li>获取当前帧绘制的总时间：FrameCompleted - IntendedVsync。</li></ul><p>综上，我们可以利用这些数据计算获取我们在自动化测试中想关注的因素，比如帧耗时、该帧调用View.draw方法所消耗的时间。framestats和帧耗时信息等一般2s收集一次，即一次120帧。为了精确控制收集数据的时间窗口，如将数据限制为特定的动画，可以重置计数器，重新聚合统计的信息，对应命令如下：</p><pre><code>adb shell dumpsys gfxinfo &lt;PackageName&gt; reset</code></pre><h5 id="2、SurfaceFlinger"><a href="#2、SurfaceFlinger" class="headerlink" title="2、SurfaceFlinger"></a>2、SurfaceFlinger</h5><p>我们都知道，在Android 4.1以后，系统使用了三级缓冲机制，即此时有三个Graphic Buffer，那么<strong>如何查看每个Graphic Buffer占用的内存呢？</strong></p><p>答案是使用SurfaceFlinger，命令如下所示：</p><pre><code>adb shell dumpsys SurfaceFlinger</code></pre><p>输出的结果非常多，因为包含很多系统应用和界面的相关信息，这里我们仅过滤出Awesome-WanAndroid应用对应的信息：</p><pre><code>+ Layer 0x7f5a92f000 (json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0)  layerStack=   0, z=    21050, pos=(0,0), size=(1080,2280), crop=(   0,   0,1080,2280), finalCrop=(   0,   0,  -1,  -1), isOpaque=1, invalidate=0, dataspace=(deprecated) sRGB Linear Full range, pixelformat=RGBA_8888 alpha=0.000, flags=0x00000002, tr=[1.00, 0.00][0.00, 1.00]  client=0x7f5dc23600  format= 1, activeBuffer=[1080x2280:1088,  1], queued-frames=0, mRefreshPending=0        mTexName=386 mCurrentTexture=0        mCurrentCrop=[0,0,0,0] mCurrentTransform=0        mAbandoned=0        - BufferQueue mMaxAcquiredBufferCount=1 mMaxDequeuedBufferCount=2          mDequeueBufferCannotBlock=0 mAsyncMode=0          default-size=[1080x2280] default-format=1 transform-hint=00 frame-counter=51        FIFO(0):        Slots:          // 序号           // 表明是否使用的状态 // 对象地址 // 当前负责第几帧 // 手机屏幕分辨率大小         &gt;[00:0x7f5e05a5c0] state=ACQUIRED 0x7f5b1ca580 frame=51 [1080x2280:1088,  1]          [02:0x7f5e05a860] state=FREE     0x7f5b1ca880 frame=49 [1080x2280:1088,  1]          [01:0x7f5e05a780] state=FREE     0x7f5b052a00 frame=50 [1080x2280:1088,  1]</code></pre><p>在Slots中，显示的是缓冲区相关的信息，可以看到，此时App使用的是00号缓冲区，即第一个缓冲区。</p><p>接着，在SurfaceFlinger命令输出log的最下方有一栏Allocated buffers，这这里可以使用当前缓冲区对应的对象地址去查询其占用的内存大小。具体对应到我们这里的是0x7f5b1ca580，匹配到的结果如下所示：</p><pre><code>0x7f5b052a00: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#00x7f5b1ca580: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#00x7f5b1ca880: 9690.00 KiB | 1080 (1088) x 2280 |    1 |        1 | 0x10000900 | json.chao.com.wanandroid/json.chao.com.wanandroid.ui.main.activity.MainActivity#0</code></pre><p>可以看到，这里每一个Graphic Buffer都占用了9MB多的内存，通常分辨率越大，单个Graphic Buffer占用的内存就越多，如1080 x 1920的手机屏幕，一般占用8160kb的内存大小。此外，如果应用使用了其它的Surface，如SurfaceView或TextureView（两者一般用在opengl进行图像处理或视频处理的过程中），这个值会更大。如果当App退到后台，系统就会将这部分内存回收。</p><p>了解了常用布局优化常用的工具与命令之后，我们就应该开始着手进行优化了，但在开始之前，我们还得对Android的布局加载原理有比较深入的了解。</p><div align="center"><br><img src="http://image.diydoutu.com/12139979399503.gif?imageView2/0/format/gif/q/75" width="30%"><br></div><h3 id="四、布局加载原理"><a href="#四、布局加载原理" class="headerlink" title="四、布局加载原理"></a>四、布局加载原理</h3><h4 id="1、为什么要了解Android布局加载原理？"><a href="#1、为什么要了解Android布局加载原理？" class="headerlink" title="1、为什么要了解Android布局加载原理？"></a>1、为什么要了解Android布局加载原理？</h4><p>知其然知其所以然，不仅要明白在平时开发过程中是怎样对布局API进行调用，还要知道它内部的实现原理是什么。明白具体的实现原理与流程之后，我们可能会发现更多可优化的点。</p><h4 id="2、布局加载源码分析"><a href="#2、布局加载源码分析" class="headerlink" title="2、布局加载源码分析"></a>2、布局加载源码分析</h4><p>我们都知道，Android的布局都是通过setContentView()这个方法进行设置的，那么它的内部肯定实现了布局的加载，接下来，我们就详细分析下它内部的实现原理与流程。</p><p>以<a href="https://github.com/JsonChao/Awesome-WanAndroid" target="_blank" rel="external">Awesome-WanAndroid</a>项目为例，我们在通用Activity基类的onCreate方法中进行了布局的设置：</p><pre><code>setContentView(getLayoutId());</code></pre><p>点进去，发现是调用了AppCompatActivity的setContentView方法：</p><pre><code>@Overridepublic void setContentView(@LayoutRes int layoutResID) {    getDelegate().setContentView(layoutResID);}</code></pre><p>这里的setContentView其实是AppCompatDelegate这个代理类的抽象方法：</p><pre><code> /** * Should be called instead of {@link Activity#setContentView(int)}} */public abstract void setContentView(@LayoutRes int resId);</code></pre><p>在这个抽象方法的左边，会有一个绿色的小圆圈，点击它就可以查看到对应的实现类与方法，这里的实现类是AppCompatDelegateImplV9，实现方法如下所示：</p><pre><code> @Overridepublic void setContentView(int resId) {    ensureSubDecor();    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);    contentParent.removeAllViews();    LayoutInflater.from(mContext).inflate(resId, contentParent);    mOriginalWindowCallback.onContentChanged();}</code></pre><p>setContentView方法中主要是获取到了content父布局，移除其内部所有视图之后并<strong>最终调用了LayoutInflater对象的inflate去加载对应的布局</strong>。接下来，我们关注inflate内部的实现：</p><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {    return inflate(resource, root, root != null);}</code></pre><p>这里只是调用了inflate另一个的重载方法：</p><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    if (DEBUG) {        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;                + Integer.toHexString(resource) + &quot;)&quot;);    }    // 1    final XmlResourceParser parser = res.getLayout(resource);    try {        // 2        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}</code></pre><p>在注释1处，通过Resources的getLayout方法获取到了一个XmlResourceParser对象，继续跟踪下getLayout方法：</p><pre><code>public XmlResourceParser getLayout(@LayoutRes int id) throws NotFoundException {    return loadXmlResourceParser(id, &quot;layout&quot;);}</code></pre><p>这里继续调用了loadXmlResourceParser方法，注意第二个参数传入的为layout，说明此时加载的是一个Xml资源布局解析器。我们继续跟踪loadXmlResourceParse方法：</p><pre><code>@NonNullXmlResourceParser loadXmlResourceParser(@AnyRes int id, @NonNull String type)        throws NotFoundException {    final TypedValue value = obtainTempTypedValue();    try {        final ResourcesImpl impl = mResourcesImpl;        impl.getValue(id, value, true);        if (value.type == TypedValue.TYPE_STRING) {            // 1            return impl.loadXmlResourceParser(value.string.toString(), id,                    value.assetCookie, type);        }        throw new NotFoundException(&quot;Resource ID #0x&quot; + Integer.toHexString(id)                + &quot; type #0x&quot; + Integer.toHexString(value.type) + &quot; is not valid&quot;);    } finally {        releaseTempTypedValue(value);    }}</code></pre><p>在注释1处，如果值类型为字符串的话，则调用了ResourcesImpl实例的loadXmlResourceParser方法。我们首先看看这个方法的注释：</p><pre><code>/** * Loads an XML parser for the specified file. * * @param file the path for the XML file to parse * @param id the resource identifier for the file * @param assetCookie the asset cookie for the file * @param type the type of resource (used for logging) * @return a parser for the specified XML file * @throws NotFoundException if the file could not be loaded */@NonNullXmlResourceParser loadXmlResourceParser(@NonNull String file, @AnyRes int id, int assetCookie,        @NonNull String type)        throws NotFoundException {        ...        final XmlBlock block = mAssets.openXmlBlockAsset(assetCookie, file);        ...        return block.newParser();        ...}</code></pre><p>注释的意思说明了这个方法是用于<strong>加载指定文件的Xml解析器</strong>，这里我们之间查看关键的mAssets.openXmlBlockAsset方法，这里的mAssets对象是AssetManager类型的，看看AssetManager实例的openXmlBlockAsset方法做了什么处理：</p><pre><code>/** * {@hide} * Retrieve a non-asset as a compiled XML file.  Not for use by * applications. *  * @param cookie Identifier of the package to be opened. * @param fileName Name of the asset to retrieve. *//*package*/ final XmlBlock openXmlBlockAsset(int cookie, String fileName)    throws IOException {    synchronized (this) {        if (!mOpen) {            throw new RuntimeException(&quot;Assetmanager has been closed&quot;);        }        // 1        long xmlBlock = openXmlAssetNative(cookie, fileName);        if (xmlBlock != 0) {            XmlBlock res = new XmlBlock(this, xmlBlock);            incRefsLocked(res.hashCode());            return res;        }    }    throw new FileNotFoundException(&quot;Asset XML file: &quot; + fileName);}</code></pre><p>可以看到，最终是调用了注释1处的openXmlAssetNative方法，这是定义在AssetManager中的一个Native方法：</p><pre><code>private native final long openXmlAssetNative(int cookie, String fileName);</code></pre><p>与此同时，我们可以猜到读取Xml文件肯定是通过IO流的方式进行的，而openXmlBlockAsset方法后抛出的IOException异常也验证了我们的想法。因为涉及到IO流的读取，所以这里是Android布局加载流程一个耗时点<br>，也有可能是我们后续优化的一个方向。</p><p>分析完Resources实例的getLayout方法的实现之后，我们继续跟踪inflate方法的注释2处：</p><pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    if (DEBUG) {        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;                + Integer.toHexString(resource) + &quot;)&quot;);    }    // 1    final XmlResourceParser parser = res.getLayout(resource);    try {        // 2        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}</code></pre><p>infalte的实现代码如下：</p><pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {    synchronized (mConstructorArgs) {        ...        try {            // Look for the root node.            int type;            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;                    type != XmlPullParser.END_DOCUMENT) {                // Empty            }            if (type != XmlPullParser.START_TAG) {                throw new InflateException(parser.getPositionDescription()                        + &quot;: No start tag found!&quot;);            }            final String name = parser.getName();            ...            // 1            if (TAG_MERGE.equals(name)) {                if (root == null || !attachToRoot) {                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;                            + &quot;ViewGroup root and attachToRoot=true&quot;);                }                rInflate(parser, root, inflaterContext, attrs, false);            } else {                // Temp is the root view that was found in the xml                // 2                final View temp = createViewFromTag(root, name, inflaterContext, attrs);                ...            }            ...        }        ...    }    ...}</code></pre><p>可以看到，infalte内部是通过XmlPull解析的方式对布局的每一个节点进行创建对应的视图的。首先，在注释1处会判断节点是否是merge标签，如果是，则对merge标签进行校验，如果merge节点不是当前布局的父节点，则抛出异常。然后，在注释2处，<strong>通过createViewFromTag方法去根据每一个标签创建对应的View视图</strong>。我们继续跟踪下createViewFromTag方法的实现：</p><pre><code>private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) {    return createViewFromTag(parent, name, context, attrs, false);} View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,        boolean ignoreThemeAttr) {    ...    try {        View view;        if (mFactory2 != null) {            view = mFactory2.onCreateView(parent, name, context, attrs);        } else if (mFactory != null) {            view = mFactory.onCreateView(name, context, attrs);        } else {            view = null;        }        if (view == null &amp;&amp; mPrivateFactory != null) {            view = mPrivateFactory.onCreateView(parent, name, context, attrs);        }        if (view == null) {            final Object lastContext = mConstructorArgs[0];            mConstructorArgs[0] = context;            try {                if (-1 == name.indexOf(&apos;.&apos;)) {                    view = onCreateView(parent, name, attrs);                } else {                    view = createView(name, null, attrs);                }            } finally {                mConstructorArgs[0] = lastContext;            }        }        return view;    }     ...}</code></pre><p>在createViewFromTag方法中，首先会判断mFactory2是否存在，存在就会使用mFactory2的onCreateView方法区创建视图，否则就会调用mFactory的onCreateView方法，接下来，如果此时的tag是一个Fragment，则会调用mPrivateFactory的onCreateView方法，否则的话，最终都会调用LayoutInflater实例的createView方法：</p><pre><code> public final View createView(String name, String prefix, AttributeSet attrs)        throws ClassNotFoundException, InflateException {   ...    try {        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);        if (constructor == null) {            // Class not found in the cache, see if it&apos;s real, and try to add it            // 1            clazz = mContext.getClassLoader().loadClass(                    prefix != null ? (prefix + name) : name).asSubclass(View.class);            if (mFilter != null &amp;&amp; clazz != null) {                boolean allowed = mFilter.onLoadClass(clazz);                if (!allowed) {                    failNotAllowed(name, prefix, attrs);                }            }            // 2            constructor = clazz.getConstructor(mConstructorSignature);            constructor.setAccessible(true);            sConstructorMap.put(name, constructor);        } else {            ...        }        ...        // 3        final View view = constructor.newInstance(args);        if (view instanceof ViewStub) {            // Use the same context when inflating ViewStub later.            final ViewStub viewStub = (ViewStub) view;            viewStub.setLayoutInflater(cloneInContext((Context) args[0]));        }        mConstructorArgs[0] = lastContext;        return view;    }    ...}</code></pre><p>LayoutInflater的createView方法中，首先，在注释1处，使用类加载器创建了对应的Class实例，然后在注释2处根据Class实例获取到了对应的构造器实例，并最终在注释3处通过构造器实例constructor的newInstance方法创建了对应的View对象。可以看到，在视图节点的创建过程中采用到了反射，我们都知道反射是比较耗性能的，过多的反射可能会导致布局加载过程变慢，这个点可能是后续优化的一个方向。</p><p>最后，我们来总结下Android中的布局加载流程：</p><ul><li>1、在setContentView方法中，会通过LayoutInflater的inflate方法去加载对应的布局。</li><li>2、inflate方法中首先会调用Resources的getLayout方法去通过IO的方式去加载对应的Xml布局解析器到内存中。</li><li>3、接着，会通过createViewFromTag根据每一个tag创建具体的View对象。</li><li>4、它内部主要是按优先顺序为Factory2和Factory的onCreatView、createView方法进行View的创建，而createView方法内部采用了构造器反射的方式实现。</li></ul><p>从以上分析可知，在Android的布局加载流程中，性能瓶颈主要存在两个地方：</p><ul><li>1、布局文件解析中的IO过程。</li><li>2、创建View对象时的反射过程。</li></ul><h4 id="3、LayoutInflater-Factory分析"><a href="#3、LayoutInflater-Factory分析" class="headerlink" title="3、LayoutInflater.Factory分析"></a>3、LayoutInflater.Factory分析</h4><p>在前面分析的View的创建过程中，我们明白系统会优先使用Factory2和Factory去创建对应的View，那么它们究竟是干什么的呢？</p><p>其实LayoutInflater.Factory是layoutInflater中创建View的一个Hook，Hook即挂钩，我们可以利用它在创建View的过程中加入一些日志或进行其它更高级的定制化处理：比如可以全局替换自定义的TextView等等。</p><p>接下来，我们查看下Factory2的实现：</p><pre><code> public interface Factory2 extends Factory {    /**     * Version of {@link #onCreateView(String, Context, AttributeSet)}     * that also supplies the parent that the view created view will be     * placed in.     *     * @param parent The parent that the created view will be placed     * in; &lt;em&gt;note that this may be null&lt;/em&gt;.     * @param name Tag name to be inflated.     * @param context The context the view is being created in.     * @param attrs Inflation attributes as specified in XML file.     *     * @return View Newly created view. Return null for the default     *         behavior.     */    public View onCreateView(View parent, String name, Context context, AttributeSet attrs);}</code></pre><p>可以看到，Factory2是直接继承于Factory,继续跟踪下Factory的源码：</p><pre><code> public interface Factory {    /**     * Hook you can supply that is called when inflating from a LayoutInflater.     * You can use this to customize the tag names available in your XML     * layout files.     *     * &lt;p&gt;     * Note that it is good practice to prefix these custom names with your     * package (i.e., com.coolcompany.apps) to avoid conflicts with system     * names.     *     * @param name Tag name to be inflated.     * @param context The context the view is being created in.     * @param attrs Inflation attributes as specified in XML file.     *     * @return View Newly created view. Return null for the default     *         behavior.     */    public View onCreateView(String name, Context context, AttributeSet attrs);}</code></pre><p>onCreateView方法中的第一个参数就是指的tag名字，比如TextView等等，我们还注意到Factory2比Factory的onCreateView方法多一个parent的参数，这是当前创建的View的父View。看来，Factory2比Factory功能要更强大一些。</p><p>最后，我们总结下Factory与Factory2的区别：</p><ul><li>1、Factory2继承与Factory。</li><li>2、Factory2比Factory的onCreateView方法多一个parent的参数，即当前创建View的父View。</li></ul><h3 id="五、获取界面布局耗时"><a href="#五、获取界面布局耗时" class="headerlink" title="五、获取界面布局耗时"></a>五、获取界面布局耗时</h3><h4 id="1、常规方式"><a href="#1、常规方式" class="headerlink" title="1、常规方式"></a>1、常规方式</h4><p>如果要获取每个界面的加载耗时，我们就必需在setContentView方法前后进行手动埋点。但是它有如下缺点：</p><ul><li>1、不够优雅。</li><li>2、代码有侵入性。</li></ul><h4 id="2、AOP"><a href="#2、AOP" class="headerlink" title="2、AOP"></a>2、AOP</h4><p>关于AOP的使用，我在<a href="">《深入探索Android启动速度优化》</a>一文的<strong>AOP(Aspect Oriented Programming)打点</strong>部分已经详细讲解过了，这里就不再赘述，还不了解的同学可以点击上面的链接先去学习下AOP的使用。</p><p>我们要使用AOP去获取界面布局的耗时，那么我们的切入点就是setContentView方法，声明一个@Aspect注解的PerformanceAop类，然后，我们就可以在里面实现对setContentView进行切面的方法，如下所示：</p><pre><code>@Around(&quot;execution(* android.app.Activity.setContentView(..))&quot;)public void getSetContentViewTime(ProceedingJoinPoint joinPoint) {    Signature signature = joinPoint.getSignature();    String name = signature.toShortString();    long time = System.currentTimeMillis();    try {        joinPoint.proceed();    } catch (Throwable throwable) {        throwable.printStackTrace();    }    LogHelper.i(name + &quot; cost &quot; + (System.currentTimeMillis() - time));}</code></pre><p>为了获取方法的耗时，我们必须使用@Around注解，这样第一个参数ProceedingJoinPoint就可以提供proceed方法去执行我们的setContentView方法，在此方法的前后就可以获取setContentView方法的耗时。后面的execution表明了在setContentView方法执行内部去调用我们写好的getSetContentViewTime方法，后面括号内的*是通配符，表示匹配任何Activity的setContentView方法，并且方法参数的个数和类型不做限定。</p><p>完成AOP获取界面布局耗时的方法之后，重装应用，打开几个Activity界面，就可以看到如下的界面布局加载耗时日志：</p><pre><code>2020-01-01 12:20:17.605 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 1742020-01-01 12:20:58.010 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 132020-01-01 12:21:27.058 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 442020-01-01 12:21:31.128 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 612020-01-01 12:23:09.805 12297-12297/json.chao.com.wanandroid I/WanAndroid-PEGASILOG: │ [PerformanceAop.java | 36 | getSetContentViewTime] AppCompatActivity.setContentView(..) cost 22</code></pre><p>可以看到，Awesome-WanAndroid项目里面各个界面的加载耗时一般都在几十毫秒作用，加载慢的界面可能会达到100多ms，当然，不同手机的配置不一样，但是，这足够让我们发现那些界面布局的加载比较慢。</p><h4 id="3、LayoutInflaterCompat-setFactory2"><a href="#3、LayoutInflaterCompat-setFactory2" class="headerlink" title="3、LayoutInflaterCompat.setFactory2"></a>3、LayoutInflaterCompat.setFactory2</h4><p>上面我们使用了AOP的方式监控了Activity的布局加载耗时，那么，如果我们需要监控每一个控件的加载耗时，该怎么实现呢？</p><p>答案是使用LayoutInflater.Factory2，我们在基类Activity的onCreate方法中直接使用LayoutInflaterCompat.setFactory2方法对Factory2的onCreateView方法进行重写，代码如下所示：</p><pre><code>@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    // 使用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件的加载耗时，    // 也可以做全局的自定义控件替换处理，比如：将TextView全局替换为自定义的TextView。    LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() {        @Override        public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {            if (TextUtils.equals(name, &quot;TextView&quot;)) {                // 生成自定义TextView            }            long time = System.currentTimeMillis();            // 1            View view = getDelegate().createView(parent, name, context, attrs);            LogHelper.i(name + &quot; cost &quot; + (System.currentTimeMillis() - time));            return view;        }        @Override        public View onCreateView(String name, Context context, AttributeSet attrs) {            return null;        }    });    // 2、setFactory2方法需在super.onCreate方法前调用，否则无效            super.onCreate(savedInstanceState);    setContentView(getLayoutId());    unBinder = ButterKnife.bind(this);    mActivity = this;    ActivityCollector.getInstance().addActivity(this);    onViewCreated();    initToolbar();    initEventAndData();}</code></pre><p>这样我们就实现了利用LayoutInflaterCompat.Factory2全局监控Activity界面每一个控件加载耗时的处理，后续我们可以将这些数据上传到我们自己的APM服务端，作为监控数据可以分析出哪些控件加载比较耗时。当然，这里我们也可以做全局的自定义控件替换处理，比如在上述代码中，我们可以将TextView全局替换为自定义的TextView。</p><p>然后，我们注意到这里我们使用getDelegate().createView方法来创建对应的View实例，跟踪进去发现这里的createView是一个抽象方法：</p><pre><code>public abstract View createView(@Nullable View parent, String name, @NonNull Context context,       @NonNull AttributeSet attrs);</code></pre><p>它对应的实现方法为AppCompatDelegateImplV9对象的createView方法，代码如下所示：</p><pre><code>@Overridepublic View createView(View parent, final String name, @NonNull Context context,        @NonNull AttributeSet attrs) {    ...    return mAppCompatViewInflater.createView(parent, name, context, attrs, inheritContext,            IS_PRE_LOLLIPOP, /* Only read android:theme pre-L (L+ handles this anyway) */            true, /* Read read app:theme as a fallback at all times for legacy reasons */            VectorEnabledTintResources.shouldBeUsed() /* Only tint wrap the context if enabled */    );}</code></pre><p>这里最终又调用了AppCompatViewInflater对象的createView方法：</p><pre><code> public final View createView(View parent, final String name, @NonNull Context context,        @NonNull AttributeSet attrs, boolean inheritContext,        boolean readAndroidTheme, boolean readAppTheme, boolean wrapContext) {    ...    // We need to &apos;inject&apos; our tint aware Views in place of the standard framework versions    switch (name) {        case &quot;TextView&quot;:            view = new AppCompatTextView(context, attrs);            break;        case &quot;ImageView&quot;:            view = new AppCompatImageView(context, attrs);            break;        case &quot;Button&quot;:            view = new AppCompatButton(context, attrs);            break;        case &quot;EditText&quot;:            view = new AppCompatEditText(context, attrs);            break;        case &quot;Spinner&quot;:            view = new AppCompatSpinner(context, attrs);            break;        case &quot;ImageButton&quot;:            view = new AppCompatImageButton(context, attrs);            break;        case &quot;CheckBox&quot;:            view = new AppCompatCheckBox(context, attrs);            break;        case &quot;RadioButton&quot;:            view = new AppCompatRadioButton(context, attrs);            break;        case &quot;CheckedTextView&quot;:            view = new AppCompatCheckedTextView(context, attrs);            break;        case &quot;AutoCompleteTextView&quot;:            view = new AppCompatAutoCompleteTextView(context, attrs);            break;        case &quot;MultiAutoCompleteTextView&quot;:            view = new AppCompatMultiAutoCompleteTextView(context, attrs);            break;        case &quot;RatingBar&quot;:            view = new AppCompatRatingBar(context, attrs);            break;        case &quot;SeekBar&quot;:            view = new AppCompatSeekBar(context, attrs);            break;    }    if (view == null &amp;&amp; originalContext != context) {        // If the original context does not equal our themed context, then we need to manually        // inflate it using the name so that android:theme takes effect.        view = createViewFromTag(context, name, attrs);    }    if (view != null) {        // If we have created a view, check its android:onClick        checkOnClickListener(view, attrs);    }    return view;}</code></pre><p>在AppCompatViewInflater对象的createView方法中系统根据不同的tag名字创建出了对应的AppCompat兼容控件。看到这里，我们明白了Android系统是使用了LayoutInflater的Factor2/Factory结合了AppCompat兼容类来进行高级版本控件的适配。</p><p>接下来，我们注意到注释1处，setFactory2方法需在super.onCreate方法前调用，否则无效，这是为什么呢？</p><p>这里可以先大胆猜测一下，可能是因为在super.onCreate()方法中就需要将Factory2实例存储到内存中。下面，我们就跟踪一下super.onCreate()的源码，看看是否如我们所假设的一样。AppCompatActivity的onCreate方法如下所示：</p><pre><code>@Overrideprotected void onCreate(@Nullable Bundle savedInstanceState) {    final AppCompatDelegate delegate = getDelegate();    delegate.installViewFactory();    delegate.onCreate(savedInstanceState);    if (delegate.applyDayNight() &amp;&amp; mThemeId != 0) {        // If DayNight has been applied, we need to re-apply the theme for        // the changes to take effect. On API 23+, we should bypass        // setTheme(), which will no-op if the theme ID is identical to the        // current theme ID.        if (Build.VERSION.SDK_INT &gt;= 23) {            onApplyThemeResource(getTheme(), mThemeId, false);        } else {            setTheme(mThemeId);        }    }    super.onCreate(savedInstanceState);}</code></pre><p>第一行的delegate实例的installViewFactory()方法就吸引了我们的注意，因为它包含了一个敏感的关键字“Factory“，这里我们继续跟踪进installViewFactory()方法：</p><pre><code>public abstract void installViewFactory();</code></pre><p>这里一个是抽象方法，点击左边绿色圆圈，可以看到这里具体的实现类为AppCompatDelegateImplV9，其实现的installViewFactory()方法如下所示：</p><pre><code>@Overridepublic void installViewFactory() {    LayoutInflater layoutInflater = LayoutInflater.from(mContext);    if (layoutInflater.getFactory() == null) {        LayoutInflaterCompat.setFactory2(layoutInflater, this);    } else {        if (!(layoutInflater.getFactory2() instanceof AppCompatDelegateImplV9)) {            Log.i(TAG, &quot;The Activity&apos;s LayoutInflater already has a Factory installed&quot;                    + &quot; so we can not install AppCompat&apos;s&quot;);        }    }}</code></pre><p>可以看到，如果我们在super.onCreate()方法前没有设置LayoutInflater的Factory2实例的话，这里就会设置一个默认的Factory2。最后，我们再来看下默认Factory2的onCreateView方法的实现：</p><pre><code>/** * From {@link LayoutInflater.Factory2}. */@Overridepublic final View onCreateView(View parent, String name, Context context, AttributeSet attrs) {    // 1、First let the Activity&apos;s Factory try and inflate the view    final View view = callActivityOnCreateView(parent, name, context, attrs);    if (view != null) {        return view;    }    // 2、If the Factory didn&apos;t handle it, let our createView() method try    return createView(parent, name, context, attrs);}</code></pre><p>在注释1处，我们首先会尝试让Activity的Facotry实例去加载对应的View实例，如果Factory不能够处理它，在注释2处，就会调用createView方法去创建对应的View，AppCompatDelegateImplV9类的createView方法的实现上面我们已经分析过了，此处就不再赘述了。</p><p>下篇，我们将进入布局优化的实战环节，敬请期待~</p><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr><p>1、<a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化 第五章 布局优化</a></p><p>2、<a href="https://time.geekbang.org/column/article/80921" target="_blank" rel="external">极客时间之Android开发高手课 UI优化</a></p><p>3、<a href="http://mobile.zol.com.cn/680/6809348.html" target="_blank" rel="external">手机屏幕的前世今生 可能比你想的还精彩</a></p><p>4、<a href="https://www.zhihu.com/question/22263252" target="_blank" rel="external">OLED 和 LCD 什么区别？</a></p><p>5、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826034&amp;idx=1&amp;sn=5e86768d7abc1850b057941cdd003927&amp;chksm=80b7b1acb7c038ba8912b9a09f7e0d41eef13ec0cea19462e47c4e4fe6a08ab760fec864c777&amp;scene=21#wechat_redirect" target="_blank" rel="external">Android 目前稳定高效的UI适配方案</a></p><p>6、<a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826381&amp;idx=1&amp;sn=5b71b7f1654b04a55fca25b0e90a4433&amp;chksm=80b7b213b7c03b0598f6014bfa2f7de12e1f32ca9f7b7fc49a2cf0f96440e4a7897d45c788fb&amp;scene=21#wechat_redirect" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-smallestWidth 限定符适配方案</a></p><p>7、<a href="https://github.com/ladingwu/dimens_sw" target="_blank" rel="external">dimens_sw github</a></p><p>8、<a href="https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;mid=2247484502&amp;idx=2&amp;sn=a60ea223de4171dd2022bc2c71e09351&amp;scene=21#wechat_redirect" target="_blank" rel="external">一种极低成本的Android屏幕适配方式</a></p><p>9、<a href="https://mp.weixin.qq.com/s/oSBUA7QKMWZURm1AHMyubA" target="_blank" rel="external">骚年你的屏幕适配方式该升级了!-今日头条适配方案</a></p><p>10、<a href="https://juejin.im/post/5bce688e6fb9a05cf715d1c2#heading-0" target="_blank" rel="external">今日头条屏幕适配方案终极版正式发布!</a></p><p>11、<a href="https://www.jianshu.com/p/b492140a555f" target="_blank" rel="external">使用Systrace分析UI性能</a></p><p>12、<a href="https://gapid.dev/about/" target="_blank" rel="external">GAPID-Graphics API Debugger</a></p><p>13、<a href="http://hukai.me/android-performance-render/" target="_blank" rel="external">Android性能优化之渲染篇</a></p><p>14、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 屏幕绘制机制及硬件加速</a></p><p>15、<a href="https://blog.csdn.net/qian520ao/article/details/81144167" target="_blank" rel="external">Android 图形处理官方教程</a></p><p>16、<a href="https://zhuanlan.zhihu.com/p/20712354" target="_blank" rel="external">Vulkan - 高性能渲染</a></p><p>17、<a href="https://source.android.com/devices/graphics/arch-vulkan" target="_blank" rel="external">Android Vulkan Tutorial</a></p><p>18、<a href="https://developer.android.com/training/testing/performance#top_of_page" target="_blank" rel="external">Test UI performance-gfxinfo</a></p><p>19、<a href="https://www.jianshu.com/p/7477e381a7ea" target="_blank" rel="external">使用dumpsys gfxinfo 测UI性能（适用于Android6.0以后）</a></p><p>20、<a href="https://developer.android.com/reference/android/view/TextureView" target="_blank" rel="external">TextureView API</a></p><p>21、<a href="https://developer.android.com/reference/android/text/PrecomputedText" target="_blank" rel="external">PrecomputedText API</a></p><p>22、<a href="https://fblitho.com/docs/tutorial" target="_blank" rel="external">Litho Tutorial</a></p><p>23、<a href="https://tech.meituan.com/2019/03/14/litho-use-and-principle-analysis.html" target="_blank" rel="external">基本功 | Litho的使用及原理剖析</a></p><p>24、<a href="https://flutter.cn/docs/resources/technical-overview" target="_blank" rel="external">Flutter官方文档中文版</a></p><p>25、<a href="https://www.bilibili.com/video/av48772383/?spm_id_from=333.788.videocard.0" target="_blank" rel="external">[Google Flutter 团队出品] 深入了解 Flutter 的高性能图形渲染</a></p><p>26、<a href="http://gityuan.com/2019/06/15/flutter_ui_draw/" target="_blank" rel="external">Flutter渲染机制—UI线程</a></p><p>27、<a href="https://mp.weixin.qq.com/s?__biz=MzUyMDAxMjQ3Ng==&amp;mid=2247489230&amp;idx=1&amp;sn=adc193e35903ab90a4c966059933a35a&amp;source=41#wechat_redirect" target="_blank" rel="external">RenderThread:异步渲染动画</a></p><p>28、<a href="https://developer.android.com/guide/topics/renderscript/compute" target="_blank" rel="external">RenderScript官方文档</a></p><p>29、<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2016/0504/4205.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="external">RenderScript :简单而快速的图像处理</a></p><p>30、<a href="https://www.jianshu.com/p/b72da42e1463" target="_blank" rel="external">RenderScript渲染利器</a></p><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2020/01/13/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%EF%BC%88%E4%B8%8A%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2019年终总结</title>
      <link>http://yoursite.com/2019/12/29/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <guid>http://yoursite.com/2019/12/29/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <pubDate>Sun, 29 Dec 2019 13:29:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>一转眼，一年很快就过去了，还记得一年前我写的<a href="https://jsonchao.github.io/2018/12/29/2018%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/" target="_blank" rel="external">2018年终总结</a>，当时定了比较完善的学习计划，到目前为止，由于今年换工作变动等等其它原因，使本年度实施的学习计划与2018年所制定的有一些差异，接下来，便开始回顾一下我的2019年主要做了哪些事情。</p><h3 id="二、回顾我的2019年"><a href="#二、回顾我的2019年" class="headerlink" title="二、回顾我的2019年"></a>二、回顾我的2019年</h3><h3 id="第一季度（1-3月）："><a href="#第一季度（1-3月）：" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目"><a href="#1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目" class="headerlink" title="1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目"></a>1、完成Android主流开源库源码分析系列博客，并完成Awesome-Third-Library-Source-Analysis开源项目</h4><p><a href="https://github.com/JsonChao/Awesome-Third-Library-Source-Analysis" target="_blank" rel="external">Awesome-Third-Library-Source-Analysis项目地址</a></p><p>众所周知，优秀源码的阅读与理解是最能提升自身功力的途径，如果想要成为一名优秀的Android工程师，那么Android优秀三方库源码的分析和理解则是必备技能。因此，为了将知识成体系地聚合起来，笔者创建了Awesome-Third-Library-Source-Analysis这个项目，为的就是让每一个Android工程师能够从以下七方面全方位地提升自己。</p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Third-Library-Source-Analysis/master/ScreenShots/Android_hot_third_source_analysis.png" alt="image"></p><p>这个项目目前已经全部完成，感兴趣的同学可以点击上方链接进行查看。</p><h4 id="2、Android核心源码"><a href="#2、Android核心源码" class="headerlink" title="2、Android核心源码"></a>2、Android核心源码</h4><p>主要基于《Android进阶解密》一书学习与Android应用开发紧密相关的Framework核心源码：</p><ul><li>Context家族</li><li>AMS</li><li>WMS</li><li>PMS</li><li>JNI原理</li></ul><h4 id="3、Android插件化知识相关"><a href="#3、Android插件化知识相关" class="headerlink" title="3、Android插件化知识相关"></a>3、Android插件化知识相关</h4><p>主要基于《Android进阶解密》一书学习和理解插件化知识，以此将FrameWork核心源码的相关知识融会贯通：</p><ul><li>JVM核心知识</li><li>Davilk/ART核心知识</li><li>类加载机制</li><li>热修复原理</li><li>插件化原理（基于VirtualAPK）</li></ul><h3 id="第二季度（4-6月）："><a href="#第二季度（4-6月）：" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、面试"><a href="#1、面试" class="headerlink" title="1、面试"></a>1、面试</h4><p>整个4月份则都是在反复地重复找工作、面试的这样的过程，期间也将Awesome-Android-Interview这个面试开源项目进行了进一步的总结与完善。</p><p><a href="https://github.com/JsonChao/Awesome-Android-Interview" target="_blank" rel="external">Awesome-Android-Interview项目地址</a></p><p>随着Android技术发展的成熟，Kotlin、大前端技术RN、Flutter、小程序等一下子就进入了我们的视野内，同时，Android自身的技术栈也正在不断扩展，比如前段时间Google推出的Jetpack。因此，Android开发者们越来越焦虑，越来越迷茫，每个人的时间和精力是有限的，我们到底该学什么才能有效地提高自身的竞争力呢?其实，首先我们应该优先深入学习工作中用到的技术，其次，关注这2年来Android最新的面试题所涉及的知识点，根据自身的实际情况有选择地进行针对性的学习和提升。</p><p>这里多说一句，其实找工作就是一个不断进行自我认知的一个过程，它能让你清晰地认识到自己哪方面存在着不足，哪一方面自己可能有一些优势，<strong>当你因此而找到自己的优势或感兴趣的方向时，坚持下去，肯定会有所收获。</strong></p><p>后面的5、6月份则都是在适应的过程中度过，因为以前都是在比较小的团队进行开发，所以一下转到大的开发团队后则有一些不适应。而且，团队内的外包人员占总人员比例是比较大的，大致为80%左右，这导致了许多应用代码或多或少都存在一些问题。因此，我们需要定制更多的流程与组件来检测甚至解决这些问题。</p><h4 id="2、开发效率提升"><a href="#2、开发效率提升" class="headerlink" title="2、开发效率提升"></a>2、开发效率提升</h4><p>主要基于 <strong>《Android群英传 神兵利器》</strong> 一书系统提升开发效率。（主要是换了Mac pro，QAQ~）</p><h3 id="第三季度（7-9月）："><a href="#第三季度（7-9月）：" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、系统学习Android源码设计模式"><a href="#1、系统学习Android源码设计模式" class="headerlink" title="1、系统学习Android源码设计模式"></a>1、系统学习Android源码设计模式</h4><p>主要基于 <strong>《HeadFirst设计模式》</strong> 与 <strong>《Android源码设计模式解析与实战》</strong> 两本书进一步加深对Android FrameWork层的的理解与思考。</p><h4 id="2、工作、学习效率提升"><a href="#2、工作、学习效率提升" class="headerlink" title="2、工作、学习效率提升"></a>2、工作、学习效率提升</h4><p>主要基于 <strong>《番茄工作法图解》</strong> 一书系统学习了番茄工作法的实施。</p><h4 id="3、算法基础学习"><a href="#3、算法基础学习" class="headerlink" title="3、算法基础学习"></a>3、算法基础学习</h4><p>主要基于 <strong>《漫画算法》</strong> 一书对算法中常见的数据结构与一些比较经典的算法实现进行了深入地了解。</p><h3 id="第四季度（10-12月）："><a href="#第四季度（10-12月）：" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、深入学习Android性能优化"><a href="#1、深入学习Android性能优化" class="headerlink" title="1、深入学习Android性能优化"></a>1、深入学习Android性能优化</h4><p>主要基于 <strong>极客时间之《Android开发高手课》</strong>、<strong><a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化</a></strong>、<strong>《移动性能实战》</strong> 和 <strong>《Android应用性能优化最佳实践》（已完成）</strong>、收藏的其它性能优化课程、文章对Android性能优化相关知识进行全面、系统、深入地学习。并且，因此我开源了Awesome-Android-Performance项目。</p><p><a href="https://github.com/JsonChao/Awesome-Android-Performance" target="_blank" rel="external">项目地址</a></p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/android-performance.png" alt="image"></p><blockquote><p>深入探索Android性能优化，从应用层、Framework层、Native层、ART/Dalvik以及Linux内核实现原理等各个层次深入挖掘各项性能优化技术~</p></blockquote><p>众所周知，性能优化是Android细分领域中最难且也是知识面涉及最深和最广的方向之一，但是如果你想要成为一名顶尖的Android工程师，性能优化细分领域则是非常好的实战与理论结合的场所。因此，为了将性能优化涉及的各个层面的知识成体系地糅合到一起，笔者创建了Awesome-Android-Performance这个项目，希望能带领读者从Android系统架构中的应用层、Framework层、Native层、ART/Dalvik以及Linux内核层这一大垂直领域去深入探索与挖掘性能优化的极致技术。</p><p>在写这篇年终总结之前，我刚刚完成了<a href="https://jsonchao.github.io/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/" target="_blank" rel="external">《深入探索Android内存优化》</a>这篇文章，这篇文章含金量比较高，建议对内存优化感兴趣的同学仔细阅读，必定有所收获。而且，内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。</p><h4 id="2、前端基础"><a href="#2、前端基础" class="headerlink" title="2、前端基础"></a>2、前端基础</h4><p>大前端是未来的趋势，技多不压身，因此，基于 <strong>《大前端入门指南 前端基础部分》</strong> 一书我对HTML、CSS、JavaScript的基础核心知识进行了学习。</p><h4 id="3、算法学习"><a href="#3、算法学习" class="headerlink" title="3、算法学习"></a>3、算法学习</h4><p>主要基于 <strong>《剑指Offer》（进行中）</strong> 一书系统学习算法面试的解题思路。</p><p>接下来，我对我的2020年制定了<strong>最核心的学习计划</strong>，所以会尽可能高标准地去实现好它。</p><h3 id="二、展望我的2020年"><a href="#二、展望我的2020年" class="headerlink" title="二、展望我的2020年"></a>二、展望我的2020年</h3><h3 id="第一季度（1-3月）：-1"><a href="#第一季度（1-3月）：-1" class="headerlink" title="第一季度（1-3月）："></a>第一季度（1-3月）：</h3><h4 id="1、继续深入学习Android性能优化"><a href="#1、继续深入学习Android性能优化" class="headerlink" title="1、继续深入学习Android性能优化"></a>1、继续深入学习Android性能优化</h4><p>主要基于 <strong>极客时间之《Android开发高手课》</strong>、<strong><a href="https://coding.imooc.com/class/308.html" target="_blank" rel="external">国内Top团队大牛带你玩转Android性能分析与优化</a></strong>、<strong>《移动性能实战》</strong> 和 <strong>《Android应用性能优化最佳实践》（已完成）</strong>、收藏的其它性能优化课程、文章对Android性能优化相关知识进行全面、系统、深入地学习。并且计划在3月底完成<a href="https://github.com/JsonChao/Awesome-Android-Performance" target="_blank" rel="external">Awesome-Android-Performance</a>项目。</p><h4 id="2、系统学习数据结构与算法"><a href="#2、系统学习数据结构与算法" class="headerlink" title="2、系统学习数据结构与算法"></a>2、系统学习数据结构与算法</h4><p>算法是比较难的东西，所以我将算法的学习全部放在了早上，详细的算法学习计划如下：</p><ul><li>1、全面了解<strong>数据结构与算法知识地图，建立算法知识框架</strong></li><li>2、300分钟搞定数据结构与算法，学习Google算法面试的精髓（每周六上午）</li><li>3、剑指Offer，系统学习算法面试的解题思路 13 - 68题（每天早上）</li><li>4、字节跳动leetcode 38道算法题（每天早上）</li><li>5、腾讯leetcode 11道高频算法题（每天早上）</li></ul><h3 id="第二季度（4-6月）：-1"><a href="#第二季度（4-6月）：-1" class="headerlink" title="第二季度（4-6月）："></a>第二季度（4-6月）：</h3><h4 id="1、Android-Framework层深入学习"><a href="#1、Android-Framework层深入学习" class="headerlink" title="1、Android Framework层深入学习"></a>1、Android Framework层深入学习</h4><p>主要基于 <strong><a href="https://coding.imooc.com/class/340.html" target="_blank" rel="external">剖析Framework面试 冲击Android高级职位</a></strong> 课程 将Framework的设计思想与实现细节、总体流程融合起来，追求真正的融会贯通。</p><h4 id="2、深入并系统学习热修复与插件化"><a href="#2、深入并系统学习热修复与插件化" class="headerlink" title="2、深入并系统学习热修复与插件化"></a>2、深入并系统学习热修复与插件化</h4><p>主要基于 <strong><a href="https://coding.imooc.com/class/106.html" target="_blank" rel="external">Android应用发展趋势必备武器 热修复与插件化</a></strong> 课程深入并系统地学习热修复与插件化技术。</p><h4 id="3、算法"><a href="#3、算法" class="headerlink" title="3、算法"></a>3、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录 &amp; 总结 &amp; 归纳</p><h3 id="第三季度（7-9月）：-1"><a href="#第三季度（7-9月）：-1" class="headerlink" title="第三季度（7-9月）："></a>第三季度（7-9月）：</h3><h4 id="1、继续Android-Framework层深入学习"><a href="#1、继续Android-Framework层深入学习" class="headerlink" title="1、继续Android Framework层深入学习"></a>1、继续Android Framework层深入学习</h4><p>主要基于 <strong>《深入理解Android内核设计思想》</strong> 一书将Framework的设计思想与实现细节、总体流程融合起来，追求真正的融会贯通。</p><h4 id="2、继续深入并系统学习热修复与插件化"><a href="#2、继续深入并系统学习热修复与插件化" class="headerlink" title="2、继续深入并系统学习热修复与插件化"></a>2、继续深入并系统学习热修复与插件化</h4><p>主要基于 <strong>《深入探索Android热修复技术原理》</strong>、<strong>《Android插件化开发指南》</strong> 两本书 深入并系统地学习热修复与插件化技术。</p><h4 id="3、算法-1"><a href="#3、算法-1" class="headerlink" title="3、算法"></a>3、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录 &amp; 总结 &amp; 归纳</p><h3 id="第四季度（10-12月）：-1"><a href="#第四季度（10-12月）：-1" class="headerlink" title="第四季度（10-12月）："></a>第四季度（10-12月）：</h3><h4 id="1、全面深入地掌握NDK技术"><a href="#1、全面深入地掌握NDK技术" class="headerlink" title="1、全面深入地掌握NDK技术"></a>1、全面深入地掌握NDK技术</h4><p>NDK技术是成为Android开发高手必须掌握的一个技能，因此，为了督促自身去深入学习NDK技术，我开源了Awesome-Android-NDK项目。</p><p><a href="https://github.com/JsonChao/Awesome-Android-NDK" target="_blank" rel="external">项目地址</a></p><p><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-NDK/master/ScreenShots/NDK%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E4%B9%8B%E8%B7%AF.png" alt="image"></p><blockquote><p>深入解码Android NDK技术、扎实C、C++、Shell、Linux基础，掌握JNI语法实现，熟悉Cmake、MakeFile的编译底层原理，全面解密顶级公司核心技术，搭乘着音视频与图像处理的5G快车，成长为最具核心竞争力的高级人才。</p></blockquote><h4 id="2、算法"><a href="#2、算法" class="headerlink" title="2、算法"></a>2、算法</h4><p>LetteCode 每日一题 ==&gt; 思考 &amp; 练习 &amp; 记录</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>成长的道路总会充满坎坷与荆棘，但是梦想与热情总是使我们充满力量，我相信，未来，会有更广阔的天空。</p><pre><code>心中有多少希望，未来就会有多精彩，愿你我都将充满力量地前行。</code></pre><h2 id="赞赏"><a href="#赞赏" class="headerlink" title="赞赏"></a>赞赏</h2><p>如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！</p><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width="20%"><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width="20%"><br></div><hr><h2 id="Contanct-Me"><a href="#Contanct-Me" class="headerlink" title="Contanct Me"></a>Contanct Me</h2><h3 id="●-微信："><a href="#●-微信：" class="headerlink" title="●  微信："></a>●  微信：</h3><blockquote><p>欢迎关注我的微信：<code>bcce5360</code>  </p></blockquote><h3 id="●-微信群："><a href="#●-微信群：" class="headerlink" title="●  微信群："></a>●  微信群：</h3><blockquote><p><strong>微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。</strong></p></blockquote><div align="center"><br><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_qrcode.jpg" width="35%"><br></div><h3 id="●-QQ群："><a href="#●-QQ群：" class="headerlink" title="●  QQ群："></a>●  QQ群：</h3><blockquote><p>2千人QQ群，<strong>Awesome-Android学习交流群，QQ群号：959936182</strong>， 欢迎大家加入~</p></blockquote><h3 id="About-me"><a href="#About-me" class="headerlink" title="About me"></a>About me</h3><ul><li><h4 id="Email-chao-qu521-gmail-com"><a href="#Email-chao-qu521-gmail-com" class="headerlink" title="Email: chao.qu521@gmail.com"></a>Email: <a href="">chao.qu521@gmail.com</a></h4></li><li><h4 id="Blog-https-jsonchao-github-io"><a href="#Blog-https-jsonchao-github-io" class="headerlink" title="Blog: https://jsonchao.github.io/"></a>Blog: <a href="https://jsonchao.github.io/" target="_blank" rel="external">https://jsonchao.github.io/</a></h4></li><li><h4 id="掘金-https-juejin-im-user-5a3ba9375188252bca050ade"><a href="#掘金-https-juejin-im-user-5a3ba9375188252bca050ade" class="headerlink" title="掘金: https://juejin.im/user/5a3ba9375188252bca050ade"></a>掘金: <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">https://juejin.im/user/5a3ba9375188252bca050ade</a></h4></li></ul><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/12/29/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
