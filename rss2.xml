<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Deep into Android</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Persist + Plan = Growing</description>
    <pubDate>Mon, 09 Jul 2018 15:40:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>深入Android单元测试（一）</title>
      <link>http://yoursite.com/2018/07/09/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/07/09/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/</guid>
      <pubDate>Mon, 09 Jul 2018 15:06:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>众所周知，一个好的项目需要不断地打造，而一些有效的测试则是加速这一过程的利器。本篇博文将带你了解并逐步深入Android单元测试。</p><h3 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h3><p>单元测试就是针对类中的某一个方法进行验证是否正确的过程，单元就是指独立的粒子，在Android和Java中大都是指方法。</p><h3 id="为什么要进行单元测试？"><a href="#为什么要进行单元测试？" class="headerlink" title="为什么要进行单元测试？"></a>为什么要进行单元测试？</h3><p>使用单元测试可以提高开发效率，当项目随着迭代越来越大时，每一次编译、运行、打包、调试需要耗费的时间会随之上升，因此，使用单元测试可以不需这一步骤就可以对单个方法进行功能或逻辑测试。<br>同时，为了能测试每一个细分功能模块，需要将其相关代码抽成相应的方法封装起来，这也在一定程度上改善了代码的设计。因为是单个方法的测试，所以能更快地定位到bug。</p><p>单元测试case需要对这段业务逻辑进行验证。在验证的过程中，开发人员可以深度了解业务流程，同时新人来了看一下项目单元测试就知道哪个逻辑跑了多少函数，需要注意哪些边界——是的，单元测试做的好和文档一样具备业务指导能力。</p><h3 id="Android测试的分类"><a href="#Android测试的分类" class="headerlink" title="Android测试的分类"></a>Android测试的分类</h3><p>Android测试主要分为三个方面：</p><pre><code>单元测试（Junit4、Mockito、PowerMockito、Robolectric）UI测试（Espresso、UI Automator）压力测试（Monkey）</code></pre><h3 id="一、单元测试之基础Junit4"><a href="#一、单元测试之基础Junit4" class="headerlink" title="一、单元测试之基础Junit4"></a>一、单元测试之基础Junit4</h3><h4 id="什么是Junit4？"><a href="#什么是Junit4？" class="headerlink" title="什么是Junit4？"></a>什么是Junit4？</h4><p>Junit4是事实上的Java标准测试库，并且它是JUnit框架有史以来的最大改进，其主要目标便是利用Java5的Annotation特性简化测试用例的编写。</p><h4 id="开始使用Junit4进行单元测试"><a href="#开始使用Junit4进行单元测试" class="headerlink" title="开始使用Junit4进行单元测试"></a>开始使用Junit4进行单元测试</h4><h5 id="1-Android-Studio已经自动集成了Junit4测试框架，如下"><a href="#1-Android-Studio已经自动集成了Junit4测试框架，如下" class="headerlink" title="1.Android Studio已经自动集成了Junit4测试框架，如下"></a>1.Android Studio已经自动集成了Junit4测试框架，如下</h5><pre><code>dependencies {    ...    testImplementation &apos;junit:junit:4.12&apos;}</code></pre><h5 id="2-Junit4框架使用时涉及到的重要注解如下"><a href="#2-Junit4框架使用时涉及到的重要注解如下" class="headerlink" title="2.Junit4框架使用时涉及到的重要注解如下"></a>2.Junit4框架使用时涉及到的重要注解如下</h5><pre><code>@Test 指明这是一个测试方法 (@Test注解可以接受2个参数，一个是预期错误expected，一个是超时时间timeout，格式如 @Test(expected = IndexOutOfBoundsException.class), @Test（timeout = 1000))@Before 在所有测试方法之前执行@After 在所有测试方法之后执行@BeforeClass 在该类的所有测试方法和@Before方法之前执行 （修饰的方法必须是静态的）@AfterClass 在该类的所有测试方法和@After方法之后执行（修饰的方法必须是静态的）@Ignore 忽略此单元测试</code></pre><p>此外，很多时候，因为某些原因（比如正式代码还没有实现等），我们可能想让JUnit忽略某些方法，让它在跑所有测试方法的时候不要跑这个测试方法。要达到这个目的也很简单，只需要在要被忽略的测试方法前面加上@Ignore就可以了</p><h5 id="3-主要的测试方法——断言"><a href="#3-主要的测试方法——断言" class="headerlink" title="3.主要的测试方法——断言"></a>3.主要的测试方法——断言</h5><pre><code>assertEquals(expected, actual) 判断2个值是否相等，相等则测试通过。assertEquals(expected, actual, tolerance) tolerance 偏差值</code></pre><p>注意：上面的每一个方法，都有一个重载的方法，可以加一个String类型的参数，表示如果验证失败的话，将用这个字符串作为失败的结果报告。</p><h5 id="4-自定义Junit-Rule——实现TestRule接口并重写apply方法"><a href="#4-自定义Junit-Rule——实现TestRule接口并重写apply方法" class="headerlink" title="4.自定义Junit Rule——实现TestRule接口并重写apply方法"></a>4.自定义Junit Rule——实现TestRule接口并重写apply方法</h5><pre><code>public class JsonChaoRule implements TestRule {    @Override    public Statement apply(final Statement base, final Description description) {        Statement repeatStatement =  new Statement() {            @Override            public void evaluate() throws Throwable {                    //测试前的初始化工作                    //执行测试方法                    base.evaluate();                    //测试后的释放资源等工作            }        };        return repeatStatement;    }}</code></pre><p>然后在想要的测试类中使用@Rule注解声明使用JsonChaoRule即可（注意被@Rule注解的变量必须是final的）：</p><pre><code>@Rulepublic final JsonChaoRule repeatRule = new JsonChaoRule();</code></pre><h5 id="5-开始上手，使用Junit4进行单元测试"><a href="#5-开始上手，使用Junit4进行单元测试" class="headerlink" title="5.开始上手，使用Junit4进行单元测试"></a>5.开始上手，使用Junit4进行单元测试</h5><pre><code>1.编写测试类。2.鼠标右键点击测试类，选择选择Go To-&gt;Test（或者使用快捷键Ctrl+Shift+T，此快捷键可以在方法和测试方法之间来回切换）在Test/java/项目测试文件夹/下自动生成测试模板。3.使用断言（assertEqual、assertEqualArrayEquals等等)进行单元测试。4.右键点击测试类，Run编写好的测试类。</code></pre><h5 id="6-使用Android-Studio自带的Gradle脚本自动化单元测试"><a href="#6-使用Android-Studio自带的Gradle脚本自动化单元测试" class="headerlink" title="6.使用Android Studio自带的Gradle脚本自动化单元测试"></a>6.使用Android Studio自带的Gradle脚本自动化单元测试</h5><p>点击Android Studio中的Gradle projects下的:app/Tasks/verification/test即可同时测试module下所有的测试类（案例），并在module下的build/reports/tests/下生成对应的index.html测试报告。</p><h5 id="7-对Junit4的总结："><a href="#7-对Junit4的总结：" class="headerlink" title="7.对Junit4的总结："></a>7.对Junit4的总结：</h5><pre><code>优点：速度快，支持代码覆盖率等代码质量的检测工具，缺点：无法单独对Android UI，一些类进行操作，与原生JAVA有一些差异。</code></pre><p>可能涉及到的额外的概念：</p><p>打桩方法：使方法简单快速地返回一个有效的结果。</p><p>测试驱动开发：编写测试，实现功能使测试通过，然后不断地使用这种方式实现功能的快速迭代开发。</p><h3 id="二、单元测试之基础Mockito"><a href="#二、单元测试之基础Mockito" class="headerlink" title="二、单元测试之基础Mockito"></a>二、单元测试之基础Mockito</h3><h4 id="什么是Mockito？"><a href="#什么是Mockito？" class="headerlink" title="什么是Mockito？"></a>什么是Mockito？</h4><p>Mockito 是美味的 Java 单元测试 Mock 框架，mock可以模拟各种各样的对象，从而代替真正的对象做出希望的响应。</p><h4 id="开始使用Mockito进行单元测试"><a href="#开始使用Mockito进行单元测试" class="headerlink" title="开始使用Mockito进行单元测试"></a>开始使用Mockito进行单元测试</h4><h5 id="1-在build-gradle里面添加Mcokito的依赖"><a href="#1-在build-gradle里面添加Mcokito的依赖" class="headerlink" title="1.在build.gradle里面添加Mcokito的依赖"></a>1.在build.gradle里面添加Mcokito的依赖</h5><pre><code>testImplementation &apos;org.mockito:mockito-core:2.7.1&apos;</code></pre><h5 id="2-使用mock-方法模拟对象"><a href="#2-使用mock-方法模拟对象" class="headerlink" title="2.使用mock()方法模拟对象"></a>2.使用mock()方法模拟对象</h5><pre><code>Person mPerson = mock(Person.class); </code></pre><h5 id="能量补充站（-vov-）"><a href="#能量补充站（-vov-）" class="headerlink" title="能量补充站（-vov-）"></a>能量补充站（-vov-）</h5><p>在JUnit框架下，case（带@Test注解的那个函数）也是个函数，直接调用这个函数就不是case，和case是无关的，两者并不会相互影响，可以直接调用以减少重复代码。单元测试不应该对某一个条件过度耦合，因此，需要用mock解除耦合，直接mock出网络请求得到的数据，单独验证页面对数据的响应。</p><h5 id="3-验证方法的调用，指定方法的返回值，或者执行特定的动作"><a href="#3-验证方法的调用，指定方法的返回值，或者执行特定的动作" class="headerlink" title="3.验证方法的调用，指定方法的返回值，或者执行特定的动作"></a>3.验证方法的调用，指定方法的返回值，或者执行特定的动作</h5><pre><code>when(iMathUtils.sum(1, 1)).thenReturn(2); doReturn(3).when(iMathUtils).sum(1,1);   //给方法设置桩可以设置多次，只会返回最后一次设置的值doReturn(2).when(iMathUtils).sum(1,1);//验证方法调用次数//方法调用1次Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)).thenReturn(true);//方法调用3次Mockito.when(mockValidator.verifyPassword(&quot;xiaochuang_is_handsome&quot;)， Mockito.times(3).thenReturn(true);//verify方法用于验证“模仿对象”的互动或验证发生的某些行为verify(mPerson, atLeast(2)).getAge();//参数匹配器,用于匹配特定的参数any()contains()argThat()when(mPerson.eat(any(String.class))).thenReturn(&quot;米饭&quot;);//除了mock()外，spy()也可以模拟对象，spy与mock的//唯一区别就是默认行为不一样：spy对象的方法默认调用//真实的逻辑，mock对象的方法默认什么都不做，或直接//返回默认值//如果要保留原来对象的功能，而仅仅修改一个或几个//方法的返回值，可以采用spy方法,无参构造的类初始//化也使用spy方法Person mPerson = spy(Person.class); //检查入参的mocks是否有任何未经验证的交互verifyNoMoreInteractions(iMathUtils);</code></pre><h5 id="4-使用Mockito后的思考"><a href="#4-使用Mockito后的思考" class="headerlink" title="4.使用Mockito后的思考"></a>4.使用Mockito后的思考</h5><p>简单的测试会使整体的代码更简单，更可读、更可维护。如果你不能把测试写的很简单，那么请在测试时重构你的代码。    </p><pre><code>优点：丰富强大的方式验证“模仿对象”的互动或验证发生的某些行为缺点：Mockito框架不支持mock匿名类、final类、static方法、private方法。</code></pre><p>虽然，static方法可以使用wrapper静态类的方式实现mockito的单元测试，但是，毕竟过于繁琐，因此，PowerMockito由此而来。</p><h3 id="三、拯救Mockito于水深火热的PowerMockito"><a href="#三、拯救Mockito于水深火热的PowerMockito" class="headerlink" title="三、拯救Mockito于水深火热的PowerMockito"></a>三、拯救Mockito于水深火热的PowerMockito</h3><h4 id="什么是PowerMockito？"><a href="#什么是PowerMockito？" class="headerlink" title="什么是PowerMockito？"></a>什么是PowerMockito？</h4><p>PowerMockito是一个扩展了Mockito的具有更强大功能的单元测试框架，它支持mock匿名类、final类、static方法、private方法</p><h4 id="开始PowerMockito之旅"><a href="#开始PowerMockito之旅" class="headerlink" title="开始PowerMockito之旅"></a>开始PowerMockito之旅</h4><h5 id="1-在build-gradle里面添加Mcokito的依赖-1"><a href="#1-在build-gradle里面添加Mcokito的依赖-1" class="headerlink" title="1.在build.gradle里面添加Mcokito的依赖"></a>1.在build.gradle里面添加Mcokito的依赖</h5><pre><code>testImplementation &apos;org.powermock:powermock-module-junit4:1.6.5&apos;testImplementation &apos;org.powermock:powermock-api-mockito:1.6.5&apos;</code></pre><h5 id="2-用PowerMockito来模拟对象"><a href="#2-用PowerMockito来模拟对象" class="headerlink" title="2.用PowerMockito来模拟对象"></a>2.用PowerMockito来模拟对象</h5><pre><code>//使用PowerMock须加注解@PrepareForTest和@RunWith(PowerMockRunner.class)（@PrepareForTest()里写的是对应方法所在的类    ，mockito支持的方法使用PowerMock的形式实现时，可以不加这两个注解）@PrepareForTest(T.class)@RunWith(PowerMockRunner.class)//mock含静态方法或字段的类    PowerMockito.mockStatic(Banana.class);//Powermock提供了一个Whitebox的class，可以方便的绕开权限限制，可以get/set private属性，实现注入。也可以调用private方法。也可以处理static的//属性/方法，根据不同需求选择不同参数的方法即可。//修改类里面静态字段的值Whitebox.setInternalState(Banana.class, &quot;COLOR&quot;, &quot;蓝色&quot;);//调用类中的真实方法PowerMockito.when(banana.getBananaInfo()).thenCallRealMethod();//验证私有方法是否被调用PowerMockito.verifyPrivate(banana, times(1)).invoke(&quot;flavor&quot;);//忽略调用私有方法PowerMockito.suppress(PowerMockito.method(Banana.class, &quot;flavor&quot;));//修改私有变量MemberModifier.field(Banana.class, &quot;fruit&quot;).set(banana, &quot;西瓜&quot;);//使用PowerMockito mock出来的对象可以直接调用final方法Banana banana = PowerMockito.mock(Banana.class);//whenNew 方法的意思是之后 new 这个对象时，返回某个被 Mock //的对象而不是让真的 new //新的对象。如果构造方法有参数，可以在withNoArguments方法中传入。PowerMockito.whenNew(Banana.class).withNoArguments().thenReturn(banana);</code></pre><h5 id="3-使用PowerMockRule来代替-RunWith-PowerMockRunner-class-的方式，需要多添加以下依赖："><a href="#3-使用PowerMockRule来代替-RunWith-PowerMockRunner-class-的方式，需要多添加以下依赖：" class="headerlink" title="3.使用PowerMockRule来代替@RunWith(PowerMockRunner.class)的方式，需要多添加以下依赖："></a>3.使用PowerMockRule来代替@RunWith(PowerMockRunner.class)的方式，需要多添加以下依赖：</h5><pre><code>testImplementation &quot;org.powermock:powermock-module-junit4-rule:1.7.4&quot;testImplementation &quot;org.powermock:powermock-classloading-xstream:1.7.4&quot;</code></pre><p>使用示例如下：</p><pre><code>@Rulepublic PowerMockRule mPowerMockRule = new PowerMockRule();</code></pre><h5 id="4-使用Parameterized来进行参数化测试："><a href="#4-使用Parameterized来进行参数化测试：" class="headerlink" title="4.使用Parameterized来进行参数化测试："></a>4.使用Parameterized来进行参数化测试：</h5><p>通过注解@Parameterized.parameters提供一系列数据给构造器中的构造参数或给被注解@Parameterized.parameter注解的public全局变量</p><pre><code>RunWith(Parameterized.class)public class ParameterizedTest {    private int num;    private boolean truth;    public ParameterizedTest(int num, boolean truth) {        this.num = num;        this.truth = truth;    }    //被此注解注解的方法将把返回的列表数据中的元素对应注入到测试类    //的构造函数ParameterizedTest(int num, boolean truth)中    @Parameterized.Parameters    public static Collection providerTruth() {        return Arrays.asList(new Object[][]{                {0, true},                {1, false},                {2, true},                {3, false},                {4, true},                {5, false}        });    }//    //也可不使用构造函数注入的方式，使用注解注入public变量的方式//    @Parameterized.Parameter//    public int num;//    //value = 1指定括号里的第二个Boolean值//    @Parameterized.Parameter(value = 1)//    public boolean truth;    @Test    public void printTest() {        Assert.assertEquals(truth, print(num));        System.out.println(num);    }    private boolean print(int num) {        return num % 2 == 0;    }}</code></pre><h3 id="四、能在Java单元测试里面执行Android代码的Robolectric"><a href="#四、能在Java单元测试里面执行Android代码的Robolectric" class="headerlink" title="四、能在Java单元测试里面执行Android代码的Robolectric"></a>四、能在Java单元测试里面执行Android代码的Robolectric</h3><h4 id="什么是Robolectric？"><a href="#什么是Robolectric？" class="headerlink" title="什么是Robolectric？"></a>什么是Robolectric？</h4><p>Robolectric通过一套能运行在JVM上的Android代码，解决了在Java单元测试中很难进行Android单元测试的痛点。</p><h4 id="进入Roboletric的领地"><a href="#进入Roboletric的领地" class="headerlink" title="进入Roboletric的领地"></a>进入Roboletric的领地</h4><h5 id="1-在build-gradle里面添加Robolectric的依赖"><a href="#1-在build-gradle里面添加Robolectric的依赖" class="headerlink" title="1.在build.gradle里面添加Robolectric的依赖"></a>1.在build.gradle里面添加Robolectric的依赖</h5><pre><code>//Robolectric核心testImplementation &quot;org.robolectric:robolectric:3.8&quot;//支持support-v4testImplementation &apos;org.robolectric:shadows-support-v4:3.4-rc2&apos;//支持Multidex功能testImplementation &quot;org.robolectric:shadows-multidex:3.+&quot; </code></pre><h5 id="2-Robolectric常用用法"><a href="#2-Robolectric常用用法" class="headerlink" title="2.Robolectric常用用法"></a>2.Robolectric常用用法</h5><p>首先给指定的测试类上面进行配置</p><pre><code>@RunWith(RobolectricTestRunner.class)//目前Robolectric最高支持sdk版本为23。@Config(constants = BuildConfig.class, sdk = 23)</code></pre><p>下面是一些常用用法</p><pre><code>//当Robolectric.setupActivity()方法返回的时候，//默认会调用Activity的onCreate()、onStart()、onResume()mTestActivity = Robolectric.setupActivity(TestActivity.class);//获取TestActivity对应的影子类，从而能获取其相应的动作或行为ShadowActivity shadowActivity = Shadows.shadowOf(mTestActivity);Intent intent = shadowActivity.getNextStartedActivity();//使用ShadowToast类获取展示toast时相应的动作或行为Toast latestToast = ShadowToast.getLatestToast();Assert.assertNull(latestToast);//直接通过ShadowToast简单工厂类获取Toast中的文本Assert.assertEquals(&quot;hahaha&quot;, ShadowToast.getTextOfLatestToast());//使用ShadowAlertDialog类获取展示AlertDialog时相应的//动作或行为（暂时只支持app包下的，不支持v7。。。）latestAlertDialog = ShadowAlertDialog.getLatestAlertDialog();AlertDialog latestAlertDialog = ShadowAlertDialog.getLatestAlertDialog();Assert.assertNull(latestAlertDialog);//使用RuntimeEnvironment.application可以获取到//Application，方便我们使用。比如访问资源文件。Application application = RuntimeEnvironment.application;String appName = application.getString(R.string.app_name);Assert.assertEquals(&quot;WanAndroid&quot;, appName);//也可以直接通过ShadowApplication获取applicationShadowApplication application = ShadowApplication.getInstance();Assert.assertNotNull(application.hasReceiverForIntent(intent));</code></pre><p>自定义Shadow类</p><pre><code>@Implements(Person.class)public class ShadowPerson {    @Implementation    public String getName() {        return &quot;AndroidUT&quot;;    }}@RunWith(RobolectricTestRunner.class)@Config(constants = BuildConfig.class,        sdk = 23,        shadows = {ShadowPerson.class})    Person person = new Person();    //实际上调用的是ShadowPerson的方法，输出JsonChao    Log.d(&quot;test&quot;, person.getName());    ShadowPerson shadowPerson = Shadow.extract(person);    //测试通过    Assert.assertEquals(&quot;JsonChao&quot;, shadowPerson.getName());}</code></pre><p>注意：<br>异步测试出现一些问题（比如改变一些编码习惯，比如回调函数不能写成匿名内部类对象，需要定义一个全局变量，并破坏其封装性，即提供一个get方法，供UT调用），解决方案使用Mockito来结合进行测试，将异步转为同步。</p><h5 id="3-Robolectric的优缺点"><a href="#3-Robolectric的优缺点" class="headerlink" title="3.Robolectric的优缺点"></a>3.Robolectric的优缺点</h5><pre><code>优点：支持大部分Android平台依赖类底层的引用与模拟。缺点：异步测试有些问题，需要结合一些框架来配合完成更多功能。</code></pre><h3 id="五、单元测试覆盖率报告生成值Jacoco"><a href="#五、单元测试覆盖率报告生成值Jacoco" class="headerlink" title="五、单元测试覆盖率报告生成值Jacoco"></a>五、单元测试覆盖率报告生成值Jacoco</h3><h4 id="什么是Jacoco"><a href="#什么是Jacoco" class="headerlink" title="什么是Jacoco"></a>什么是Jacoco</h4><p>Jacoco的全称为Java Code Coverage（Java代码覆盖率），可以生成java的单元测试代码覆盖率报告。</p><h4 id="加入Jacoco到你的单元测试大家族"><a href="#加入Jacoco到你的单元测试大家族" class="headerlink" title="加入Jacoco到你的单元测试大家族"></a>加入Jacoco到你的单元测试大家族</h4><p>在应用Module下加入jacoco.gradle自定义脚本，app.gradle apply from它，同步，即可看到在app的Task下生成了Report目录，Report目录<br>下生成了JacocoTestReport任务。</p><pre><code>apply plugin: &apos;jacoco&apos;jacoco {    toolVersion = &quot;0.7.7.201606060606&quot; //指定jacoco的版本    reportsDir = file(&quot;$buildDir/JacocoReport&quot;) //指定jacoco生成报告的文件夹}//依赖于testDebugUnitTest任务task jacocoTestReport(type: JacocoReport, dependsOn: &apos;testDebugUnitTest&apos;) {    group = &quot;reporting&quot; //指定task的分组    reports {        xml.enabled = true //开启xml报告        html.enabled = true //开启html报告    }    def debugTree = fileTree(dir: &quot;${buildDir}/intermediates/classes/debug&quot;,            includes: [&quot;**/*Presenter.*&quot;],            excludes: [&quot;*.*&quot;])//指定类文件夹、包含类的规则及排除类的规则，            //这里我们生成所有Presenter类的测试报告    def mainSrc = &quot;${project.projectDir}/src/main/java&quot; //指定源码目录    sourceDirectories = files([mainSrc])    classDirectories = files([debugTree])    executionData = files(&quot;${buildDir}/jacoco/testDebugUnitTest.exec&quot;)//指定报告数据的路径}</code></pre><p>在Gradle构建板块Gradle.projects下的app/Task/verification下，其中testDebugUnitTest构建任务会生成单元测试结果报告，包含xml及html格式，分别对应test-results和reports文件夹；jacocoTestReport任务会生成单元测试覆盖率报告，结果存放在jacoco和JacocoReport文件夹。</p><p><img src="https://s1.ax1x.com/2018/07/09/PnEv7j.png" alt="image"></p><p>生成的JacocoReport文件夹下的index.html即对应的单元测试覆盖率报告，用浏览器打开后，可以看到覆盖情况被不同的颜色标识出来，其中绿色表示代码被单元测试覆盖到，黄色表示部分覆盖，红色则表示完全没有覆盖到。</p><h3 id="六、单元测试的流程"><a href="#六、单元测试的流程" class="headerlink" title="六、单元测试的流程"></a>六、单元测试的流程</h3><p>要验证程序正确性，必然要给出所有可能的条件（极限编程），并验证其行为或结果，才算是100%覆盖条件。实际项目中，验证边界条件和一般条件就OK了。</p><p>在实际项目中，单元测试对象与页面是一对一的，并不建议跨页面，这样的单元测试藕合度太大，维护困难。<br>需要写完后，看覆盖率，找出单元测试中没有覆盖到的函数分支条件等，然后继续补充单元测试case列表，并在单元测试工程代码中补上case。<br>直到规划的页面中所有逻辑的重要分支、边界条件都被覆盖，该项目的单元测试结束。</p><h5 id="建议（-ovo-）"><a href="#建议（-ovo-）" class="headerlink" title="建议（-ovo-）~"></a>建议（-ovo-）~</h5><p>可以从公司项目小规模使用，形成自己的单元测试风格后，就可以跟大范围地推广了。</p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/07/09/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%EF%BC%88%E4%B8%80%E3%80%81%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>可能会改变你的话</title>
      <link>http://yoursite.com/2018/04/22/Some%20awesome%20tips/</link>
      <guid>http://yoursite.com/2018/04/22/Some%20awesome%20tips/</guid>
      <pubDate>Sun, 22 Apr 2018 13:17:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><pre><code>这是一篇记录平时读书遇到的一些让人觉得会改变自己的话。</code></pre><h4 id="Some-awesome-tips"><a href="#Some-awesome-tips" class="headerlink" title="Some awesome tips"></a>Some awesome tips</h4><pre><code>1.一个浪头打过来，最好的办法是迎上去了解个究竟，而不是漠视，或者干脆当事情没有发生。2.记住这个教训：别猜，去问！去查！3.隔一段时间重顾知识是记忆的关键方法。不要一次性学完一项知识就不管了，这样你无法真正的掌握。隔一段时间回顾一下，每次重复，你都会加深自己的理解，次数多了，你就会理解每个细节，成为真正的专家。4.对于一个技术通常我们需要抱有这样的疑问它是什么 一句话概括解决了什么问题 存在的意义怎样去使用它怎样解决了问题 内部的实现它的缺点是什么 多角度分析5.高效率的学习方法。理清楚概念很重要做好控制变量法多动手实践，与理论结合抓住重点，剔除干扰因素6.关于如何选择第三方库确定这个库是否是必需的这个库能否带来开发效率的提升，降低代码的维护成本这个库的学习成本如何 比如rxjava其实学习成本会相对高一些。这个库的质量如何，不要仅仅看star，更要看issue的处理情况。7.怎样练习算法题？每道算法题都先自己去实现，先写思路，然后自己去实现一遍，然后再看看答案，记住答案的思路，第二天再重新按照答案的思路实现一遍。8.&quot;另类&quot;的学习方法抄书的奥妙——那就是延缓阅读速度，不至遗漏每一个重要的细节：眼到，手到，心到，其实不仅书抄得，代码(优秀源码)也抄得。9.建议：建立逐字稿计算机网络相关的逐字稿计算机操作系统相关的逐字稿数据库相关的逐字稿设计模式相关的逐字稿数据结构与算法相关的逐字稿Java知识相关的逐字稿Kotlin知识相关的逐字稿Python知识相关的逐字稿React Native知识相关的逐字稿Flutter知识相关的逐字稿小程序知识相关的逐字稿JS知识相关的逐字稿Android知识相关的逐字稿与技术无关的逐字稿10.如何提升你的阅读能力？只字不差的反复阅读真正的获取知识，是通过阅读，深入思考与践行11.如何高效阅读一篇文章？由主题扩展为知识树尝试描述尝试记忆12.如何阅读源码？准备：Java设计模式(模板方法，单例，观察者，工厂方法，代理，策略，装饰者)，Java高级相关熟练掌握这个库先Google了解软件的整体架构设计搭建系统，把源码跑起来开始阅读：根据你对系统的理解，设计几个主要的测试案例，定义好输入，输出。(Debug一遍肯定是不行的，需要Debug很多遍)第一篇抛弃细节，抓住主要流程，第二篇，第三篇，再去看各个部分的细节。阅读的时候同时使用UML画出系统的类图。主要的测试案例明白了，丰富测试案例，考虑一些分支。这一步会非常非常地花费时间，但是你做完了，对系统的理解绝对有质的飞跃。13.想象一个来自未来的自己，他非常自信，非常成功，拥有你现在所希望的一切，他会对现在的你说些什么？他怎么说，你就怎么去做，10年之后，你就变成了他。14.重视实践，充分运用感性认知潜能，在项目中磨炼自己，才是正确的学习之道。在实践中，在某些关键动作上刻意练习，也会取得事半功倍的效果。15.我们需要从别人身上学习。从老师、领导、同事、下属甚至对手身上学习，是快速成长的重要手段。16.多多总结，多多分享，善莫大焉。17.解答别人的问题也是个人成长的重要手段。有时候，某个问题自己本来不太懂，但是在给别人讲解的时候却豁然开朗。所以，“诲人不倦”利人惠己。18.学习计划最好能结合工作计划，理论联系实际结合，快速学以致用。19.良好的用人方式应该如下：首选选择相信，在面临失败后，收缩信任度。查找失败的原因，提供改进意见，提升下属的能力。总是给下属机会，在恰当地时机给下属更高的挑战。 总之，苍天大树来自一颗小种子，要相信成长的力量。20.学习就是不断地刻意联系，刻意练习，就是有目的的练习，先规划好，再去练习。首先给自己定一个目标，目标可以有效的引导你学习，然后使用3F练习法：1： 专注（Focus），专注在眼前的任务上，在学习过程中保持专注，可以尝试使用番茄工作法。2：反馈（Feedback），意识到自己的不足，学习完之后进行反思，思考下自己哪些方面不足，为什么不足，3： 修正（Fix），改进自己的不足。不停的练习和思考可以改变大脑结构，大脑像肌肉一样，挑战越大，影响越大，学习更高效，并且也会产生突破性。21.写一篇博客的过程，其实就是对一件事情，学习、理解、思考、转化，最终输出成一篇博客的过程。22.深入浅出SQL给出的学习法则：如何快速记忆知识？将文字转换为图片（将文字嵌入图片效果比较好)，如果能转换为令人惊奇，有趣的情景模拟，那么可以让你的大脑意识到这是重要的东西，记忆效果会更好。1.慢慢来，理解越多，需要强记得就越少。2.勤做笔记，写下你的心得笔记。3.你的大脑会需要一段时间来消化新知识，如果之后再学别的知识，会使之前的记忆效果减弱，因此，在睡前看最重要的知识。4.喝水，多喝水。5.大声说出你想要记忆的知识，如果能与别人进行一问一答则效果更佳。6.当学习知识时，达到了漫不经心或过目即忘的状态，则应该让大脑好好休息。7.用心感受，让你的大脑知道这很重要，将学习的内容尽量以情景化+惊奇+幽默的形式展示出来。8.用学到的知识解决实际的难题（真实的情景演练）。23.想要学习新技术，想要提升自己，不是看见新技术就去学，沉下心来认真钻研才行，吃透它，不再为缓解焦虑而学习。24.业务代码一样很牛逼1.使用封装和抽象可以使业务代码更具扩展性。2.多和产品交流以便更好地理解和实现业务。3.日志记录好了问题定位效率可以提升10倍。25.在工作中学习、实战提升是效果最好的，其余时间可有目的去碎片化学习一整块知识，也可以快速构建牢固的知识体系。26.做更多：工作中熟悉多个业务代码，端到端（前后端）的业务代码，自学。做更好：1.提升项目稳定性，引进单元测试和UI测试。2.重构解耦项目。3.性能优化。4.设计模式去除重复代码。做练习：1.学习2.尝试3.教学27.一项新技术的出现，应该先去了解它，看它是否对自身的技术成长有比较大的帮助，有的话按优先级加入计划表28.重复记忆时间间隔：1小时、早上/晚上、1天、3天、7天、1个月、3个月形成长期记忆~29.学习一个新的知识点的流程：what、why、how、原理/源码、优缺点~注意”先主后从“原则，多实践加深理解。</code></pre><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/22/Some%20awesome%20tips/#disqus_thread</comments>
    </item>
    
    <item>
      <title>初识人工智能</title>
      <link>http://yoursite.com/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</link>
      <guid>http://yoursite.com/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/</guid>
      <pubDate>Sun, 18 Mar 2018 14:15:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><h3 id="AI-人工智能-的idea起源于20世纪50年代，在20世纪80年代时，ML-机器学习-开始变得流行起来，在大约2010年，DL-深度学习-在AI的推动下有了大的发展。下图是三者直接的关系图："><a href="#AI-人工智能-的idea起源于20世纪50年代，在20世纪80年代时，ML-机器学习-开始变得流行起来，在大约2010年，DL-深度学习-在AI的推动下有了大的发展。下图是三者直接的关系图：" class="headerlink" title="AI(人工智能)的idea起源于20世纪50年代，在20世纪80年代时，ML(机器学习)开始变得流行起来，在大约2010年，DL(深度学习)在AI的推动下有了大的发展。下图是三者直接的关系图："></a>AI(人工智能)的idea起源于20世纪50年代，在20世纪80年代时，ML(机器学习)开始变得流行起来，在大约2010年，DL(深度学习)在AI的推动下有了大的发展。下图是三者直接的关系图：</h3><p><img src="https://note.youdao.com/yws/public/resource/12ec8de4ff02f0af21b5ce1a93cbf9a9/xmlnote/A1389FE91E5D4696B23BEDBD955D115C/20679" alt="image"></p><h3 id="关于人工智能，我们所需要了解的"><a href="#关于人工智能，我们所需要了解的" class="headerlink" title="关于人工智能，我们所需要了解的"></a>关于人工智能，我们所需要了解的</h3><h5 id="what（人工智能是什么？）："><a href="#what（人工智能是什么？）：" class="headerlink" title="what（人工智能是什么？）："></a>what（人工智能是什么？）：</h5><p>人工智能（英语：Artificial Intelligence, AI）亦称机器智能，<br>是指由人制造出来的机器所表现出来的智能。通常人工智能是指通过<br>普通计算机程序的手段实现的类人智能技术。</p><h5 id="why（为什么要使用它-作用-？）："><a href="#why（为什么要使用它-作用-？）：" class="headerlink" title="why（为什么要使用它(作用)？）："></a>why（为什么要使用它(作用)？）：</h5><p>AI是一个制造智能机器的科学与工程，它的核心问题包括建构能够跟<br>人类似甚至超越的推理、知识、规划、学习、交流、感知、移动和操<br>作物体的能力等，以更好地实现某一领域的特定目标（例如搜索、逻<br>辑推演、创造力等等）。</p><h5 id="how（学习AI该从哪方面着手？）："><a href="#how（学习AI该从哪方面着手？）：" class="headerlink" title="how（学习AI该从哪方面着手？）："></a>how（学习AI该从哪方面着手？）：</h5><p>见下方。。</p><h3 id="AI的应用领域"><a href="#AI的应用领域" class="headerlink" title="AI的应用领域"></a>AI的应用领域</h3><h5 id="AI的应用领域很广泛，目前主要涉及到的领域如下："><a href="#AI的应用领域很广泛，目前主要涉及到的领域如下：" class="headerlink" title="AI的应用领域很广泛，目前主要涉及到的领域如下："></a>AI的应用领域很广泛，目前主要涉及到的领域如下：</h5><pre><code>智能控制机器人学自动化技术语言和图像理解遗传编程</code></pre><h5 id="涉及到的概念："><a href="#涉及到的概念：" class="headerlink" title="涉及到的概念："></a>涉及到的概念：</h5><h5 id="智能控制"><a href="#智能控制" class="headerlink" title="智能控制"></a>智能控制</h5><h5 id="what（它是什么？）："><a href="#what（它是什么？）：" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>智能控制是针对控制对象及其环境、控制目标和任务的不确定性<br>和复杂性而提出的一种控制技术。</p><h5 id="why（为什么要使用智能控制？）："><a href="#why（为什么要使用智能控制？）：" class="headerlink" title="why（为什么要使用智能控制？）："></a>why（为什么要使用智能控制？）：</h5><p>能够减小或消除被控对象的被控制量的控制偏差。</p><h5 id="how（有哪些人工智能控制方法？）："><a href="#how（有哪些人工智能控制方法？）：" class="headerlink" title="how（有哪些人工智能控制方法？）："></a>how（有哪些人工智能控制方法？）：</h5><p>类神经网络，模糊逻辑，机器学习，进化计算和遗传算法等等。</p><h5 id="机器人学"><a href="#机器人学" class="headerlink" title="机器人学"></a>机器人学</h5><h5 id="what（它是什么？）：-1"><a href="#what（它是什么？）：-1" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>是一项涵盖了机器人的设计、建造、运作、以及应用的跨领域科<br>技，就如同电脑系统之控制、感测回授、以及资讯处理。</p><h5 id="自动化技术"><a href="#自动化技术" class="headerlink" title="自动化技术"></a>自动化技术</h5><h5 id="what（它是什么？）：-2"><a href="#what（它是什么？）：-2" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>是一门综合性技术，它和控制论、信息论、系统工程、计算机技<br>术、电子学、液压气压技术、自动控制等都有着十分密切的关系，<br>而其中又以“控制理论”和“计算机技术”对自动化技术的影响最大。<br>一些过程已经被完全自动化。</p><h5 id="语言和图像理解"><a href="#语言和图像理解" class="headerlink" title="语言和图像理解"></a>语言和图像理解</h5><h5 id="what（它是什么？）：-3"><a href="#what（它是什么？）：-3" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>图像识别是对图像整体的语义内容进行类别判定，而语言识别是指<br>能够让计算机自动地识别语音中所携带信息的技术。</p><h5 id="遗传编程"><a href="#遗传编程" class="headerlink" title="遗传编程"></a>遗传编程</h5><h5 id="what（它是什么？）：-4"><a href="#what（它是什么？）：-4" class="headerlink" title="what（它是什么？）："></a>what（它是什么？）：</h5><p>是一种从生物演化过程得到灵感的自动化生成和选择计算机程序<br>来完成用户定义的任务的技术。</p><h5 id="AI的主要研究范畴如下："><a href="#AI的主要研究范畴如下：" class="headerlink" title="AI的主要研究范畴如下："></a>AI的主要研究范畴如下：</h5><pre><code>机器学习（Machine Learning）自然语言处理（NLP： Natural Language Processing）人工神经网络（Artificial Neural Network）数据挖掘（Data Mining）智能搜索（Intelligent Search）遗传算法</code></pre><h5 id="涉及到的概念：-1"><a href="#涉及到的概念：-1" class="headerlink" title="涉及到的概念："></a>涉及到的概念：</h5><h5 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h5><h5 id="what（他是什么？）"><a href="#what（他是什么？）" class="headerlink" title="what（他是什么？）"></a>what（他是什么？）</h5><p>机器学习可简单概括为“用数据解决问题”，即：数据 + 学习算法 =模型(映射或函数)<br>机器学习是人工智能的一个分支，近30多年已发展为一门多领域交叉<br>学科，机器学习理论主要是设计和分析一些让计算机可以自动“学习”<br>的算法。机器学习算法是一类从数据中自动分析获得规律，并利用规<br>律对未知数据进行预测的算法。</p><h5 id="why（为什么要学习机器学习？）"><a href="#why（为什么要学习机器学习？）" class="headerlink" title="why（为什么要学习机器学习？）"></a>why（为什么要学习机器学习？）</h5><p>就是因为机器学习算法的这种可预测性，能利用规律对未知数据进行<br>预测，从而会有比较广的应用范围，现如今，机器学习已广泛应用于<br>数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、<br>医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和<br>手写识别、战略游戏和机器人等领域。</p><h5 id="how（如何开始机器学习？）"><a href="#how（如何开始机器学习？）" class="headerlink" title="how（如何开始机器学习？）"></a>how（如何开始机器学习？）</h5><p>首先，我们需要了解机器学习分为哪几种。<br>监督学习：<br>从给定的训练数据集中学习出一个函数，当新的数据到来时，可以根据<br>这个函数预测结果。监督学习的训练集要求是包括输入和输出，也可以<br>说是特征和目标。训练集中的目标是由人标注的。常见的监督学习算法<br>包括回归分析和统计分类。<br>无监督学习：<br>与监督学习相比，训练集没有人为标注的结果。常见的无监督学习算法<br>有聚类。<br>半监督学习：<br>介于监督学习与无监督学习之间。<br>增强学习：<br>通过观察来学习做成如何的动作。每个动作都会对环境有所影响，学习<br>对象根据观察到的周围环境的反馈来做出判断。<br>选择了要学习的机器学习类别，具体的就是机器学习算法的学习了，此处<br>不再概述。</p><h5 id="进行机器学习的七步曲："><a href="#进行机器学习的七步曲：" class="headerlink" title="进行机器学习的七步曲："></a>进行机器学习的七步曲：</h5><pre><code>搜集数据准备数据选择模型训练模型评估模型参数微调预测</code></pre><h5 id="自然语言处理"><a href="#自然语言处理" class="headerlink" title="自然语言处理"></a>自然语言处理</h5><h5 id="what（它是什么？）"><a href="#what（它是什么？）" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>自然语言处理是人工智能和语言学领域的分支学科，它分为两部分，<br>自然语言生成系统和自然语言理解系统。自然语言生成系统把计算机<br>数据转化为自然语言。自然语言理解系统把自然语言转化为计算机程序<br>更易于处理的形式。</p><h5 id="why（为什么要使用自然语言处理？）"><a href="#why（为什么要使用自然语言处理？）" class="headerlink" title="why（为什么要使用自然语言处理？）"></a>why（为什么要使用自然语言处理？）</h5><p>就是为了使计算机生成和理解自然语言。</p><h5 id="how（自然语言的处理范畴？）"><a href="#how（自然语言的处理范畴？）" class="headerlink" title="how（自然语言的处理范畴？）"></a>how（自然语言的处理范畴？）</h5><p>自然语言的处理范畴比较广，主要有文本朗读、语音合成、语音识别、<br>文本分类、信息检索、信息抽取、问答系统、机器翻译、自动摘要等等。</p><h5 id="人工神经网络"><a href="#人工神经网络" class="headerlink" title="人工神经网络"></a>人工神经网络</h5><h5 id="what（它是什么？）-1"><a href="#what（它是什么？）-1" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>人工神经网络（英语：artificial neural network，缩写ANN），简称<br>神经网络（neural network，缩写NN）或类神经网络，在机器学习和认知<br>科学领域，是一种模仿生物神经网络（动物的中枢神经系统，特别是大脑）<br>的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。</p><h5 id="why（为什么要使用人工神经网络？）"><a href="#why（为什么要使用人工神经网络？）" class="headerlink" title="why（为什么要使用人工神经网络？）"></a>why（为什么要使用人工神经网络？）</h5><p>就是因为它对于函数进行估计或近似的这种能力，现在，已经被用于解决<br>各种各样的问题，例如机器视觉和语音识别。</p><h5 id="how（如何使用人工神经网络？）"><a href="#how（如何使用人工神经网络？）" class="headerlink" title="how（如何使用人工神经网络？）"></a>how（如何使用人工神经网络？）</h5><p>具体的学习请参照本文总结。</p><h5 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h5><h5 id="what（它是什么？）-2"><a href="#what（它是什么？）-2" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>数据挖掘（英语：data mining）是一个跨学科的计算机科学分支，它是<br>用人工智能、机器学习、统计学和数据库的交叉方法在相对较大型的数据<br>集中发现模式的计算过程。</p><h5 id="why（为什么要使用数据挖掘？）"><a href="#why（为什么要使用数据挖掘？）" class="headerlink" title="why（为什么要使用数据挖掘？）"></a>why（为什么要使用数据挖掘？）</h5><p>用于从大量数据中提取模式和知识。</p><h5 id="how（如何进行数据挖掘？）"><a href="#how（如何进行数据挖掘？）" class="headerlink" title="how（如何进行数据挖掘？）"></a>how（如何进行数据挖掘？）</h5><p>数据挖掘的方法类似于机器学习，包括监督式学习、非监督式学习、半监<br>督学习、增强学习。<br>监督式学习包括：分类、估计、预测。<br>非监督式学习包括：聚类，关联规则分析。</p><h5 id="智能搜索"><a href="#智能搜索" class="headerlink" title="智能搜索"></a>智能搜索</h5><h5 id="what（它是什么？）-3"><a href="#what（它是什么？）-3" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>智能搜索其实就是一些能提高搜索策略的搜索方式。比如：深度优先搜索、<br>迭代加深搜索（ID搜索）、启发式OR图搜索算法、AND-OR图启发式搜索、<br>约束满足搜索等等。</p><h5 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h5><h5 id="what（它是什么？）-4"><a href="#what（它是什么？）-4" class="headerlink" title="what（它是什么？）"></a>what（它是什么？）</h5><p>遗传算法（英语：genetic algorithm (GA)）是计算数学中用于解决最佳<br>化的搜索算法，是进化算法的一种。进化算法最初是借鉴了进化生物学中<br>的一些现象而发展起来的，这些现象包括遗传、突变、自然选择以及杂交等。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>关于AI，目前应用范围主要集中在机器学习、深度学习(用于学习机器学习的一种技术)、NLP、图像识别与处理这几个方面，请选择适合您的分支。</p><p>如果您对深度学习有兴趣，可以从<a href="http://mooc.study.163.com/smartSpec/detail/1001319001.htm" target="_blank" rel="external">吴恩达的深度学习课程</a>开始。同样的，如果对机器学习有兴趣，可以从<a href="https://developers.google.cn/machine-learning/crash-course/" target="_blank" rel="external">Google的机器学习速成课程</a>、<a href="https://www.coursera.org/learn/machine-learning" target="_blank" rel="external">吴恩达的机器学习课程</a>、<a href="https://zhuanlan.zhihu.com/tensorflowcn" target="_blank" rel="external">Google Cloud AI Adventure 中文版教程</a>、<a href="https://zhuanlan.zhihu.com/machine-learning-book?topic=%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0" target="_blank" rel="external">写给大家看的机器学习书</a>着手。</p><p>除此之外，这里还有一些关于AI的快速开发框架:最知名的如<a href="https://github.com/tensorflow/tensorflow" target="_blank" rel="external">TensorFlow</a>(使用数据流图形计算来扩展机器学习的框架)、<a href="https://github.com/BVLC/caffe" target="_blank" rel="external">caffe</a>(一个快速开放的深度学习框架)、<a href="https://github.com/keras-team/keras" target="_blank" rel="external">keras</a>(对人类的深度学习框架)、<br><a href="https://github.com/apache/incubator-mxnet" target="_blank" rel="external">MXNet</a>(MxNet是一个兼并效率和弹性的深度学习框架)、<a href="http://torch.ch/" target="_blank" rel="external">torch</a>(torch是一个广泛支持机器学习算法的科学计算框架)、<a href="https://github.com/Theano/Theano" target="_blank" rel="external">theano</a>(theano是一个允许你去高效地定义、优化、评估涉及多维数组的数学表达的python库)。</p><p>最热门的TensorFlow入门推荐-<a href="https://codelabs.developers.google.com/codelabs/tensorflow-for-poets/index.html#0" target="_blank" rel="external">Google的TensorFlow入门指南</a></p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/18/%E5%88%9D%E8%AF%86%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络（二、IP地址）</title>
      <link>http://yoursite.com/2018/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%E3%80%81IP%E5%9C%B0%E5%9D%80%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%E3%80%81IP%E5%9C%B0%E5%9D%80%EF%BC%89/</guid>
      <pubDate>Wed, 21 Feb 2018 11:20:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样。&quot;&gt;&lt;a href=&quot;
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://jsonchao.github.io/knowledgehierarchy/" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样。</h4><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h5 id="这是计算机网络的第二部分——IP地址。"><a href="#这是计算机网络的第二部分——IP地址。" class="headerlink" title="这是计算机网络的第二部分——IP地址。"></a>这是计算机网络的第二部分——IP地址。</h5><h5 id="what-IP地址是什么？"><a href="#what-IP地址是什么？" class="headerlink" title="what(IP地址是什么？)"></a>what(IP地址是什么？)</h5><p>IP地址全称为Internet ProtocolAddress，是分配给网络上使用IP的设备的标签。它由网络号(包括子网号)和机号组成，分为IPv4和IPv6两大类。</p><h5 id="why-为什么使用它？"><a href="#why-为什么使用它？" class="headerlink" title="why(为什么使用它？)"></a>why(为什么使用它？)</h5><p>给连接网络的每一台设备都贴上一个标签，以作区分。</p><h5 id="how-怎么使用它？"><a href="#how-怎么使用它？" class="headerlink" title="how(怎么使用它？)"></a>how(怎么使用它？)</h5><p>请看下文。。</p><h3 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h3><p>IP地址是唯一的，IPv4有2的32次方个地址。</p><h4 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h4><h5 id="按地址范围分："><a href="#按地址范围分：" class="headerlink" title="按地址范围分："></a>按地址范围分：</h5><p>A类地址(二进位)以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127255.255.255;</p><p>B类地址(二进位)以10开头，前两个字节作为网络号，地址范围为：128.0.0.0~91.255.255.255;</p><p>C地址(二进位)以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~23.255.255.255；</p><p>D类地址(二进位)以1110开头，地址范围是224.0.0.0~239.255.255.255；</p><p>E类地址(二进位)以1111开头，地址范围是240.0.0.0~255.255.255.255。</p><h5 id="注意：只有A-B-C有网络号和主机号之分。"><a href="#注意：只有A-B-C有网络号和主机号之分。" class="headerlink" title="注意：只有A,B,C有网络号和主机号之分。"></a>注意：只有A,B,C有网络号和主机号之分。</h5><h5 id="按功能分："><a href="#按功能分：" class="headerlink" title="按功能分："></a>按功能分：</h5><p>网络地址：网络地址的主机号全为0，它代表整个网络。</p><p>广播地址：通常称为直接广播地址，区分于受限广播地址。广播地址的主机号为1，与网络地址主机号相反。向某个网络的广播地址发送消息，该网络的所主机号都能接收到该消息。</p><p>组播地址：D类地址作为组播地址，负责一对多的通信。</p><p>保留地址：E类地址作为保留地址，供以后使用。</p><h5 id="其它特殊的地址："><a href="#其它特殊的地址：" class="headerlink" title="其它特殊的地址："></a>其它特殊的地址：</h5><h5 id="255-255-255-255："><a href="#255-255-255-255：" class="headerlink" title="255.255.255.255："></a>255.255.255.255：</h5><p>该地址指的是受限的广播地址，它只能用于本地网络。直接广播地址能通过某路由器，而受限的广播地址不能通过路由器。</p><h5 id="0-0-0-0"><a href="#0-0-0-0" class="headerlink" title="0.0.0.0:"></a>0.0.0.0:</h5><p>常用于寻找自己的IP地址。(以255.255.255.255为目的地址，向本地范围的服器发送IP请求分组)</p><h5 id="回环地址："><a href="#回环地址：" class="headerlink" title="回环地址："></a>回环地址：</h5><p>127.0.0.0/8被用作回环地址，即本地地址，用的最多的是127.0.0.1。</p><h5 id="A、B、C类私有地址："><a href="#A、B、C类私有地址：" class="headerlink" title="A、B、C类私有地址："></a>A、B、C类私有地址：</h5><p>也称为专用地址，不会再全球使用，只具有本地意义。</p><p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255。</p><p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255。</p><p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255。</p><h5 id="注意：IP地址后的-8、-12、-16代表网络号位数，后面的主机号为可变。"><a href="#注意：IP地址后的-8、-12、-16代表网络号位数，后面的主机号为可变。" class="headerlink" title="注意：IP地址后的/8、/12、/16代表网络号位数，后面的主机号为可变。"></a>注意：IP地址后的/8、/12、/16代表网络号位数，后面的主机号为可变。</h5><h3 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h3><p>IPv6的地址长度为2的128次方个地址。通常写作8组每组四个十六机制的形式。</p><p>2001:0DB8:0000:0000:0000:0000:1428:57ab</p><p>当有某组为0000时，可省略为<br>2001:0DB8::1428:57ab</p><p>同时每组前面有0时，可省略为<br>2001:DB8::1428:57ab</p><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%E3%80%81IP%E5%9C%B0%E5%9D%80%EF%BC%89/#disqus_thread</comments>
    </item>
    
    <item>
      <title>计算机网络（一、网络分层）</title>
      <link>http://yoursite.com/2018/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%EF%BC%89/</link>
      <guid>http://yoursite.com/2018/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%EF%BC%89/</guid>
      <pubDate>Tue, 13 Feb 2018 10:00:00 GMT</pubDate>
      <description>
      
        
        
          &lt;hr&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;h4 id=&quot;成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。&quot;&gt;&lt;a href=
        
      
      </description>
      
      <content:encoded><![CDATA[<hr><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>最近工作中发现计算机相关基础很薄弱，因此，从本篇博客开始，将会对计算机相关知识进行系统性的学习总结。众所周知，计算机网络的核心就是网络协议。</p><h5 id="what（计算机网络协议是什么？）"><a href="#what（计算机网络协议是什么？）" class="headerlink" title="what（计算机网络协议是什么？）"></a>what（计算机网络协议是什么？）</h5><p>网络协议是为计算机网络中进行数据交换而建立的规则、标准或者可认为是定的集合，它同世界各地的语言一样，品类繁多。但是，为了让使用不同协的网络群组进行通信，在1977年到1979年，Arpa公司推出了TCP/IP标准网络议，现如今，它已经成为了Internet中的“通用语言“（TCP/IP标准网络协议如世界标准交流语言英语的作用一样）。</p><h5 id="why（为什么要使用它？）"><a href="#why（为什么要使用它？）" class="headerlink" title="why（为什么要使用它？）"></a>why（为什么要使用它？）</h5><p>因为不同的用户的数据终端可能采取的字符集的不同的，两者需要通信，就须遵循一定的标准，这个标准就是网络协议。</p><h5 id="how（如何使用它？）"><a href="#how（如何使用它？）" class="headerlink" title="how（如何使用它？）"></a>how（如何使用它？）</h5><p>见下方。。</p><h4 id="网络协议分层"><a href="#网络协议分层" class="headerlink" title="网络协议分层"></a>网络协议分层</h4><p>1978年，国际标准化组织(ISO)推出了OSI/RM模型，OSI将网络协议分为7层模型，常见的网络协议分层还有TCP/IP四层模型、TCP/IP五层模型。如下图，依次为TCP/IP四层模型、TCP/IP五层模型、ISO七层模型。</p><p><img src="https://note.youdao.com/yws/public/resource/12ec8de4ff02f0af21b5ce1a93cbf9a9/xmlnote/9F7557F83C3D494A81CD205B13B25D80/19018" alt="image"></p><h5 id="1-物理层："><a href="#1-物理层：" class="headerlink" title="1.物理层："></a>1.物理层：</h5><h5 id="what："><a href="#what：" class="headerlink" title="what："></a>what：</h5><p>为传输数据所需的物理链路创建、维持、拆除，而提供具有机的，电子的，功能的和规范的特性。</p><h5 id="why："><a href="#why：" class="headerlink" title="why："></a>why：</h5><p>因为它能确保原始的数据可在各种物理媒体上传输。</p><h5 id="how："><a href="#how：" class="headerlink" title="how："></a>how：</h5><p>物理层映射的设备有多种，如中继器(放大器)、集线器、光纤等。</p><h5 id="涉及的概念："><a href="#涉及的概念：" class="headerlink" title="涉及的概念："></a>涉及的概念：</h5><h5 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h5><h5 id="what：-1"><a href="#what：-1" class="headerlink" title="what："></a>what：</h5><p>一种物理设备，用于放大、增强信号，频率转换及功率增强。</p><h5 id="why：-1"><a href="#why：-1" class="headerlink" title="why："></a>why：</h5><p>因为它能放大、增强信号，可以转换频率及增强功率，主要应用增强传输的信息强度，保证信息的到达率。</p><h5 id="how：-1"><a href="#how：-1" class="headerlink" title="how："></a>how：</h5><p>大部分中继器只有2种功能，AP功能(有线转无线)，中继功能。用请查看对应中继器的说明书。</p><h5 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h5><h5 id="what：-2"><a href="#what：-2" class="headerlink" title="what："></a>what：</h5><p>用于将多条以太网双绞线或光纤集合连接在同一段物理介质的备。</p><h5 id="why：-2"><a href="#why：-2" class="headerlink" title="why："></a>why：</h5><p>它是一种多端口的中继器，能够把收到的任何数字信号进行再生放大。</p><h5 id="how：-2"><a href="#how：-2" class="headerlink" title="how："></a>how：</h5><p>在集线器内，由于多条数据线路集合在同一物理介质下，因此，产生信号的碰撞，目前使用交换机取代了集线器。</p><h5 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a>2.数据链路层</h5><h5 id="what：-3"><a href="#what：-3" class="headerlink" title="what："></a>what：</h5><p>将来自网络层的数据可靠地传输到相邻节点的目标机网络层的性。</p><h5 id="why：-3"><a href="#why：-3" class="headerlink" title="why："></a>why：</h5><p>它能给网络层提供可靠的数据传输，将来自网络层的数据组合成，也就是帧(基本数据单位)。可用于物理地址寻址，流量控制、数据监测和发等等。</p><h5 id="how：-3"><a href="#how：-3" class="headerlink" title="how："></a>how：</h5><p>数据链路层映射的设备主要有2种，网桥和交换机。(遵循以太网议)</p><h5 id="涉及到的概念："><a href="#涉及到的概念：" class="headerlink" title="涉及到的概念："></a>涉及到的概念：</h5><h5 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h5><h5 id="what：-4"><a href="#what：-4" class="headerlink" title="what："></a>what：</h5><p>一种网络设备，它将网络的多个网段连接起来。</p><h5 id="why：-4"><a href="#why：-4" class="headerlink" title="why："></a>why：</h5><p>用于网络桥接。</p><h5 id="how：-4"><a href="#how：-4" class="headerlink" title="how："></a>how：</h5><p>使用请查看对应网桥的说明书。</p><h5 id="网络交换机"><a href="#网络交换机" class="headerlink" title="网络交换机"></a>网络交换机</h5><h5 id="what：-5"><a href="#what：-5" class="headerlink" title="what："></a>what：</h5><p>一种扩大网络的设备，能为子网提供更多的连接端口，以便连更多的电脑。</p><h5 id="why：-5"><a href="#why：-5" class="headerlink" title="why："></a>why：</h5><p>用于扩大网路信号，并且为子网提供更多的连接端口，从而能连更多的电脑。</p><h5 id="how：-5"><a href="#how：-5" class="headerlink" title="how："></a>how：</h5><p>网络交换机种类繁多，有2(传统)，3，4，7层交换机，使用请查看对应种类交换机的交互机说明书。</p><h5 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a>3.网络层</h5><h5 id="what：-6"><a href="#what：-6" class="headerlink" title="what："></a>what：</h5><p>它是一种实现路径选择、路由、逻辑寻址的特性。</p><h5 id="why：-6"><a href="#why：-6" class="headerlink" title="why："></a>why：</h5><p>实现两个端系统之间数据的透明传送(基本数据单位为IP数据报)。</p><h5 id="how：-6"><a href="#how：-6" class="headerlink" title="how："></a>how：</h5><p>网络层映射的设备主要为路由器。</p><h5 id="涉及到的概念：-1"><a href="#涉及到的概念：-1" class="headerlink" title="涉及到的概念："></a>涉及到的概念：</h5><h5 id="网络层协议-主要"><a href="#网络层协议-主要" class="headerlink" title="网络层协议(主要)"></a>网络层协议(主要)</h5><p>1.IP协议(Internet Protocol 因特网协议)。</p><p>2.ICMP协议(Internet Control Message Protocol 因特网控制报文协议)</p><p>3.ARP协议(Adrress Resolution Protocol 地址解析协议)</p><p>4.RARP协议(Reverse Adrress Resolution Protocol 逆地址解析协议)</p><h5 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h5><h5 id="what：-7"><a href="#what：-7" class="headerlink" title="what："></a>what：</h5><p>是一种电讯网络设备，提供路由和转发两种功能。</p><h5 id="why：-7"><a href="#why：-7" class="headerlink" title="why："></a>why：</h5><p>路由和转发功能可以为寻址提供一定的技术支持。</p><h5 id="how：-7"><a href="#how：-7" class="headerlink" title="how："></a>how：</h5><p>使用请查看对应种类的路由器。</p><p>路由：确定数据包从来源端到目的端的路由路径。</p><p>转发：将数据包从路由器输入端移送到指定的输出端。</p><h5 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4.传输层"></a>4.传输层</h5><h5 id="what：-8"><a href="#what：-8" class="headerlink" title="what："></a>what：</h5><p>它是一种将上层数据分段，提供端到端的可靠地或不可靠的传输的特性。</p><h5 id="why：-8"><a href="#why：-8" class="headerlink" title="why："></a>why：</h5><p>为数据提供可靠的传输，将数据传送到相应的端口。</p><h5 id="how：-8"><a href="#how：-8" class="headerlink" title="how："></a>how：</h5><p>使用TCP/UDP协议进行传输。</p><h5 id="涉及到的主要概念："><a href="#涉及到的主要概念：" class="headerlink" title="涉及到的主要概念："></a>涉及到的主要概念：</h5><h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><h5 id="what：-9"><a href="#what：-9" class="headerlink" title="what："></a>what：</h5><p>转发其它服务器通信数据的服务器。</p><h5 id="why：-9"><a href="#why：-9" class="headerlink" title="why："></a>why：</h5><p>因为它能提高通信的安全性。</p><h5 id="how：-9"><a href="#how：-9" class="headerlink" title="how："></a>how：</h5><p>与路由器相似，但不同于路由器的是，网关能在不同的协议之间传输数据，由器能在不同的网络之间传输数据。</p><h5 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5.会话层"></a>5.会话层</h5><h5 id="what：-10"><a href="#what：-10" class="headerlink" title="what："></a>what：</h5><p>用于管理主机之间的会话进程，负责建立，管理，终止进程之间的会话。<br>还利用在数据中插入校验点来实现数据的同步的特性。</p><h5 id="why：-10"><a href="#why：-10" class="headerlink" title="why："></a>why：</h5><p>它能建立、管理、终止进程之间的会话。</p><h5 id="how：-10"><a href="#how：-10" class="headerlink" title="how："></a>how：</h5><p>应用于解决网络会议中音频和视频流不同步的问题。解决网络视频中音频和频要合并或转换时要无缝连接的问题。</p><h5 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6.表示层"></a>6.表示层</h5><h5 id="what：-11"><a href="#what：-11" class="headerlink" title="what："></a>what：</h5><p>它是一个可以对上层数据或信息进行变换的特性。</p><h5 id="why：-11"><a href="#why：-11" class="headerlink" title="why："></a>why：</h5><p>保证一个主机的应用程序信息可以被另一个主机的应用程序理解。</p><h5 id="how：-11"><a href="#how：-11" class="headerlink" title="how："></a>how：</h5><p>具体对应为对数据进行加密、压缩、格式转换。</p><h5 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7.应用层"></a>7.应用层</h5><h5 id="what：-12"><a href="#what：-12" class="headerlink" title="what："></a>what：</h5><p>它是一个为操作系统或网络应用程序提供访问网络服务接口的特性。</p><h5 id="why：-12"><a href="#why：-12" class="headerlink" title="why："></a>why：</h5><p>为操作系统或网络应用程序提供访问网络服务的接口。</p><h5 id="how：-12"><a href="#how：-12" class="headerlink" title="how："></a>how：</h5><p>映射为各种应用层协议(如HTTP、DNS、SMTP、FTP、Telnet、POP3协议等等)。</p><h5 id="注意：会话层、表示层、应用层的数据传输基本单位为报文。"><a href="#注意：会话层、表示层、应用层的数据传输基本单位为报文。" class="headerlink" title="注意：会话层、表示层、应用层的数据传输基本单位为报文。"></a>注意：会话层、表示层、应用层的数据传输基本单位为报文。</h5><h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%EF%BC%89/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
