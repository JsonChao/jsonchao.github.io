<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Android主流三方库源码分析," />





  <link rel="alternate" href="/rss2.xml" title="Deep into Android" type="application/atom+xml" />






<meta name="description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。不知不觉，Android主流三方库源码分析系列已经来到最后关头了。这一次，笔者将会对Android中的事件总线框架EventBus源码进行详细地解析，一起来和大家揭开它背后的面纱。 一、简单示例1、首先，定义要传递的事件实体public class CollectEvent { ... } 2">
<meta name="keywords" content="Android主流三方库源码分析">
<meta property="og:type" content="article">
<meta property="og:title" content="Android主流三方库源码分析（九、深入理解EventBus源码）">
<meta property="og:url" content="http://yoursite.com/2019/01/28/Android主流三方库源码分析（九、深入理解EventBus源码）/index.html">
<meta property="og:site_name" content="Deep into Android">
<meta property="og:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。不知不觉，Android主流三方库源码分析系列已经来到最后关头了。这一次，笔者将会对Android中的事件总线框架EventBus源码进行详细地解析，一起来和大家揭开它背后的面纱。 一、简单示例1、首先，定义要传递的事件实体public class CollectEvent { ... } 2">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/2276275-c20610cdd44f4c5f.png?imageMogr2/auto-orient/">
<meta property="og:image" content="https://raw.githubusercontent.com/greenrobot/EventBus/master/EventBus-Publish-Subscribe.png">
<meta property="og:updated_time" content="2019-03-06T13:29:33.111Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android主流三方库源码分析（九、深入理解EventBus源码）">
<meta name="twitter:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。不知不觉，Android主流三方库源码分析系列已经来到最后关头了。这一次，笔者将会对Android中的事件总线框架EventBus源码进行详细地解析，一起来和大家揭开它背后的面纱。 一、简单示例1、首先，定义要传递的事件实体public class CollectEvent { ... } 2">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/2276275-c20610cdd44f4c5f.png?imageMogr2/auto-orient/">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '2JGM8QNUKR',
      apiKey: 'ad3d08277d479825f7ef759beadbce0d',
      indexName: 'dicovery',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/01/28/Android主流三方库源码分析（九、深入理解EventBus源码）/"/>





  <title>Android主流三方库源码分析（九、深入理解EventBus源码） | Deep into Android</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deep into Android</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/28/Android主流三方库源码分析（九、深入理解EventBus源码）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JsonChao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep into Android">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android主流三方库源码分析（九、深入理解EventBus源码）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-28T00:02:00+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/安卓主流三方库源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">安卓主流三方库源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/01/28/Android主流三方库源码分析（九、深入理解EventBus源码）/" class="leancloud_visitors" data-flag-title="Android主流三方库源码分析（九、深入理解EventBus源码）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>不知不觉，Android主流三方库源码分析系列已经来到最后关头了。这一次，笔者将会对Android中的事件总线框架EventBus源码进行详细地解析，一起来和大家揭开它背后的面纱。</p>
<h3 id="一、简单示例"><a href="#一、简单示例" class="headerlink" title="一、简单示例"></a>一、简单示例</h3><h4 id="1、首先，定义要传递的事件实体"><a href="#1、首先，定义要传递的事件实体" class="headerlink" title="1、首先，定义要传递的事件实体"></a>1、首先，定义要传递的事件实体</h4><pre><code>public class CollectEvent { ... }
</code></pre><h4 id="2、准备订阅者：声明并注解你的订阅方法"><a href="#2、准备订阅者：声明并注解你的订阅方法" class="headerlink" title="2、准备订阅者：声明并注解你的订阅方法"></a>2、准备订阅者：声明并注解你的订阅方法</h4><pre><code>@Subscribe(threadMode = ThreadMode.MAIN)
public void onMessageEvent(CollectEvent event) {
    LogHelper.d(&quot;OK&quot;);
}
</code></pre><h4 id="3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"><a href="#3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者" class="headerlink" title="3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"></a>3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者</h4><pre><code>@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}

@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}
</code></pre><h4 id="4、发送事件"><a href="#4、发送事件" class="headerlink" title="4、发送事件"></a>4、发送事件</h4><pre><code>EventBus.getDefault().post(new CollectEvent());
</code></pre><p>在正式讲解之前，笔者觉得需要对一些基础性的概念进行详细的讲解。众所周知，EventBus没出现之前，那时候的开发者一般是使用Android四大组件中的广播进行组件间的消息传递，那么我们<strong>为什么要使用事件总线机制来替代广播</strong>呢？主要是因为：</p>
<ul>
<li>广播：耗时、容易被捕获（不安全）。</li>
<li>事件总线：更节省资源、更高效，能将信息传递给原生以外的各种对象。</li>
</ul>
<p>那么，话又说回来了，<strong>事件总线又是什么呢？</strong></p>
<p>如下图所示，事件总线机制通过记录对象、使用观察者模式来通知对象各种事件。（当然，你也可以发送基本数据类型如 int，String 等作为一个事件）</p>
<p><img src="https://upload-images.jianshu.io/upload_images/2276275-c20610cdd44f4c5f.png?imageMogr2/auto-orient/" alt="image"></p>
<p>对于<strong>事件总线EventBus</strong>而言，它的<strong>优缺点</strong>又是如何？这里简单总结下：</p>
<ul>
<li>优点：开销小，代码更优雅、简洁，解耦发送者和接收者，可动态设置事件处理线程和优先级。</li>
<li>缺点：每个事件必须自定义一个事件类，增加了维护成本。</li>
</ul>
<p>EventBus是基于观察者模式扩展而来的，我们先了解一下观察者模式是什么？</p>
<p>观察者模式又可称为<strong>发布 - 订阅模式</strong>，它定义了对象间的一种1对多的依赖关系，每当这个对象的状态改变时，其它的对象都会接收到通知并被自动更新。</p>
<p>观察者模式有以下角色：</p>
<ul>
<li>抽象被观察者：将所有已注册的观察者对象保存在一个集合中。</li>
<li>具体被观察者：当内部状态发生变化时，将会通知所有已注册的观察者。</li>
<li>抽象观察者：定义了一个更新接口，当被观察者状态改变时更新自己。</li>
<li>具体被观察者：实现抽象观察者的更新接口。</li>
</ul>
<p>这里笔者给出一个简单的示例来让大家更深一步理解观察者模式的思想：</p>
<p>1、首先，创建抽象观察者</p>
<pre><code>public interface observer {

    public void update(String message);
}
</code></pre><p>2、接着，创建具体观察者</p>
<pre><code>public class WeXinUser implements observer {
    private String name;

    public WeXinUser(String name) {
        this.name = name;
    }

    @Override
    public void update(String message) {
        ...
    }
}
</code></pre><p>3、然后，创建抽象被观察者</p>
<pre><code>public interface observable {

    public void addWeXinUser(WeXinUser weXinUser);

    public void removeWeXinUser(WeXinUser weXinUser);

    public void notify(String message);
}
</code></pre><p>4、最后，创建具体被观察者</p>
<pre><code>public class Subscription implements observable {
    private List&lt;WeXinUser&gt; mUserList = new ArrayList();

    @Override
    public void addWeXinUser(WeXinUser weXinUser) {
        mUserList.add(weXinUser);
    }

    @Override
    public void removeWeXinUser(WeXinUser weXinUser) {
        mUserList.remove(weXinUser);
    }

    @Override
    public void notify(String message) {
        for(WeXinUser weXinUser : mUserList) {
            weXinUser.update(message);
        }
    }
}
</code></pre><p>在具体使用时，我们便可以这样使用，如下所示：</p>
<pre><code>Subscription subscription = new Subscription();

WeXinUser hongYang = new WeXinUser(&quot;HongYang&quot;);
WeXinUser rengYuGang = new WeXinUser(&quot;RengYuGang&quot;);
WeXinUser liuWangShu = new WeXinUser(&quot;LiuWangShu&quot;);

subscription.addWeiXinUser(hongYang);
subscription.addWeiXinUser(rengYuGang);
subscription.addWeiXinUser(liuWangShu);
subscription.notify(&quot;New article coming&quot;);
</code></pre><p>在这里，hongYang、rengYuGang、liuWangShu等大神都订阅了我的微信公众号，每当我的公众号发表文章时（subscription.notify())，他们就会接收到最新的文章信息（weXinUser.update()）。（ps：当然，这一切都是YY，事实是，我并没有微信公众号-0v0-）</p>
<p>当然，EventBus的观察者模式和一般的观察者模式不同，它使用了扩展的观察者模式对事件进行订阅和分发，其实这里的扩展就是指的使用了EventBus来作为中介者，抽离了许多职责，如下是它的官方原理图：</p>
<p><img src="https://raw.githubusercontent.com/greenrobot/EventBus/master/EventBus-Publish-Subscribe.png" alt="image"></p>
<p>在得知了EventBus的原理之后，我们注意到，每次我们在register之后，都必须进行一次unregister，这是为什么呢？</p>
<ul>
<li>因为register是强引用，它会让对象无法得到内存回收，导致内存泄露。所以必须在unregister方法中释放对象所占的内存。</li>
</ul>
<p>有些同学可能之前使用的是EventBus2.x的版本，那么它又与EventBus3.x的版本有哪些区别呢？</p>
<ul>
<li>1、EventBus2.x使用的是运行时注解，它采用了反射的方式对整个注册的类的所有方法进行扫描来完成注册，因而会对性能有一定影响。</li>
<li>2、EventBus3.x使用的是编译时注解，Java文件会编译成.class文件，再对class文件进行打包等一系列处理。在编译成.class文件时，EventBus会使用EventBusAnnotationProcessor注解处理器读取@Subscribe()注解并解析、处理其中的信息，然后生成Java类来保存所有订阅者的订阅信息。这样就创建出了对文件或类的索引关系，并将其编入到apk中。</li>
<li>3、从EventBus3.0开始使用了对象池缓存减少了创建对象的开销。</li>
</ul>
<p>除了EventBus，其实现在比较流行的事件总线还有RxBus，那么，它与EventBus相比又如何呢？</p>
<ul>
<li>1、RxJava的Observable有onError、onComplete等状态回调。</li>
<li>2、Rxjava使用组合而非嵌套的方式，避免了回调地狱。</li>
<li>3、Rxjava的线程调度设计的更加优秀，更简单易用。</li>
<li>4、Rxjava可使用多种操作符来进行链式调用来实现复杂的逻辑。</li>
<li>5、Rxjava的信息效率高于EventBus2.x，低于EventBus3.x。</li>
</ul>
<p>在了解了EventBus和RxBus的区别之后，那么，对待新项目的事件总线选型时，我们该如何考量？</p>
<p>很简单，如果项目中使用了RxJava，则使用RxBus，否则使用EventBus3.x。</p>
<p>接下来将按以下顺序来进行EventBus的源码分析：</p>
<ul>
<li>1、订阅者：EventBus.getDefault().register(this)；</li>
<li>2、发布者：EventBus.getDefault().post(new CollectEvent())；</li>
<li>3、订阅者：EventBus.getDefault().unregister(this)。</li>
</ul>
<p>下面，我们正式开始~</p>
<h3 id="二、EventBus-getDefault-register-this"><a href="#二、EventBus-getDefault-register-this" class="headerlink" title="二、EventBus.getDefault().register(this)"></a>二、EventBus.getDefault().register(this)</h3><p>首先，我们从获取EventBus实例的方法getDefault()开始分析：</p>
<pre><code>public static EventBus getDefault() {
    if (defaultInstance == null) {
        synchronized (EventBus.class) {
            if (defaultInstance == null) {
                defaultInstance = new EventBus();
            }
        }
    }
    return defaultInstance;
}
</code></pre><p>在getDefault()中使用了双重校验并加锁的单例模式来创建EventBus实例。</p>
<p>接着，我们看到EventBus的默认构造方法中做了什么:</p>
<pre><code>private static final EventBusBuilder DEFAULT_BUILDER = new EventBusBuilder();

public EventBus() {
    this(DEFAULT_BUILDER);
}
</code></pre><p>在EventBus的默认构造方法中又调用了它的另一个有参构造方法，将一个类型为EventBusBuilder的DEFAULT_BUILDER对象传递进去了。这里的EventBusBuilder很明显是一个EventBus的建造器，以便于EventBus能够添加自定义的参数和安装一个自定义的默认EventBus实例。</p>
<p>我们在看一下EventBusBuilder的构造方法：</p>
<pre><code>public class EventBusBuilder {

    ...

    EventBusBuilder() {
    }

    ...

}
</code></pre><p>EventBusBuilder的构造方法中什么也没有做，那我么继续查看EventBus的这个有参构造方法：</p>
<pre><code>private final Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;
private final Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;
private final Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;

EventBus(EventBusBuilder builder) {
    ...

    // 1
    subscriptionsByEventType = new HashMap&lt;&gt;();

    // 2
    typesBySubscriber = new HashMap&lt;&gt;();

    // 3
    stickyEvents = new ConcurrentHashMap&lt;&gt;();

    // 4
    mainThreadSupport = builder.getMainThreadSupport();
    mainThreadPoster = mainThreadSupport != null ? mainThreadSupport.createPoster(this) : null;
    backgroundPoster = new BackgroundPoster(this);
    asyncPoster = new AsyncPoster(this);

    ...

    // 5
    subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
            builder.strictMethodVerification, builder.ignoreGeneratedIndex);

    // 从builder取中一些列订阅相关信息进行赋值
    ...

    // 6
    executorService = builder.executorService;
}
</code></pre><p>在注释1处，创建了一个subscriptionsByEventType对象，可以看到它是一个类型为HashMap的subscriptionsByEventType对象，并且其key为 Event 类型，value为 Subscription链表。这里的Subscription是一个订阅信息对象，它里面保存了两个重要的字段，一个是类型为 Object 的 subscriber，该字段即为注册的对象（在 Android 中时通常是 Activity对象）；另一个是 类型为SubscriberMethod 的 subscriberMethod，它就是被@Subscribe注解的那个订阅方法，里面保存了一个重要的字段eventType，它是 Class&lt;?&gt; 类型的，代表了 Event 的类型。在注释2处，新建了一个类型为 Map 的typesBySubscriber对象，它的key为subscriber对象，value为subscriber对象中所有的 Event 类型链表，日常使用中仅用于判断某个对象是否注册过。在注释3处新建了一个类型为ConcurrentHashMap的stickyEvents对象，它是专用于粘性事件处理的一个字段，key为事件的Class对象，value为当前的事件。可能有的同学不了解sticky event，这里解释下：</p>
<ul>
<li>我们都知道普通事件是先注册，然后发送事件才能收到；而粘性事件，在发送事件之后再订阅该事件也能收到。并且，粘性事件会保存在内存中，每次进入都会去内存中查找获取最新的粘性事件，除非你手动解除注册。</li>
</ul>
<p>在注释4处，新建了三个不同类型的事件发送器，这里总结下：</p>
<ul>
<li>mainThreadPoster：主线程事件发送器，通过它的mainThreadPoster.enqueue(subscription, event)方法可以将订阅信息和对应的事件进行入队，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。</li>
<li>backgroundPoster：后台事件发送器，通过它的enqueue() 将方法加入到后台的一个队列，最后通过线程池去执行，注意，它在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。</li>
<li>asyncPoster：实现逻辑类似于backgroundPoster，不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，asyncPoster则是异步运行的，可以同时接收多个任务。</li>
</ul>
<p>我们在回到注释5这行代码，这里新建了一个subscriberMethodFinder对象，这是从EventBus中抽离出的订阅方法查询的一个对象，在优秀的源码中，我们经常能看到组合优于继承的这种实现思想。在注释6处，从builder中取出了一个默认的线程池对象，它由Executors的newCachedThreadPool()方法创建，它是一个有则用、无则创建、无数量上限的线程池。</p>
<p>分析完这些核心的字段之后，后面的讲解就比较轻松了，接着我们查看EventBus的regist()方法：</p>
<pre><code>public void register(Object subscriber) {
    Class&lt;?&gt; subscriberClass = subscriber.getClass();

    // 1
    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    synchronized (this) {
        for (SubscriberMethod subscriberMethod : subscriberMethods) {
            // 2
            subscribe(subscriber, subscriberMethod);
        }
    }
}
</code></pre><p>在注释1处，根据当前注册类获取 subscriberMethods这个订阅方法列表 。在注释2处，使用了增强for循环令subsciber对象 对 subscriberMethods 中每个 SubscriberMethod 进行订阅。</p>
<p>接着我们查看SubscriberMethodFinder的findSubscriberMethods()方法：</p>
<pre><code>List&lt;SubscriberMethod&gt; findSubscriberMethods(Class&lt;?&gt; subscriberClass) {
    // 1
    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) {
        return subscriberMethods;
    }

    // 2
    if (ignoreGeneratedIndex) {
        subscriberMethods = findUsingReflection(subscriberClass);
    } else {
        subscriberMethods = findUsingInfo(subscriberClass);
    }
    if (subscriberMethods.isEmpty()) {
        throw new EventBusException(&quot;Subscriber &quot; + subscriberClass
                + &quot; and its super classes have no public methods with the @Subscribe annotation&quot;);
    } else {
        METHOD_CACHE.put(subscriberClass, subscriberMethods);
        return subscriberMethods;
    }
}
</code></pre><p>在注释1处，如果缓存中有subscriberClass对象对应 的订阅方法列表，则直接返回。注释2处，先详细说说这个ignoreGeneratedIndex字段， 它用来判断是否使用生成的 APT 代码去优化寻找接收事件的过程，如果开启了的话，那么将会通过 subscriberInfoIndexes 来快速得到接收事件方法的相关信息。如果我们没有在项目中接入 EventBus 的 APT，那么可以将 ignoreGeneratedIndex 字段设为 false 以提高性能。这里ignoreGeneratedIndex 默认为false，所以会执行findUsingInfo()方法，后面生成 subscriberMethods 成功的话会加入到缓存中，失败的话会 抛出异常。</p>
<p>接着我们查看SubscriberMethodFinder的findUsingInfo()方法：</p>
<pre><code>private List&lt;SubscriberMethod&gt; findUsingInfo(Class&lt;?&gt; subscriberClass) {
    // 1
    FindState findState = prepareFindState();
    findState.initForSubscriber(subscriberClass);
    // 2
    while (findState.clazz != null) {
        findState.subscriberInfo = getSubscriberInfo(findState);
        if (findState.subscriberInfo != null) {
            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();
            for (SubscriberMethod subscriberMethod: array) {
                if (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) {
                    findState.subscriberMethods.add(subscriberMethod);
                }
            }
        } else {
             // 3
             findUsingReflectionInSingleClass(findState);
        }
        findState.moveToSuperclass();
    }
    // 4
    return getMethodsAndRelease(findState);
}
</code></pre><p>在注释1处，调用了SubscriberMethodFinder的prepareFindState()方法创建了一个新的 FindState 类，我们来看看这个方法：</p>
<pre><code>private static final FindState[] FIND_STATE_POOL = new FindState[POOL_SIZE];
private FindState prepareFindState() {
    // 1
    synchronized(FIND_STATE_POOL) {
        for (int i = 0; i &lt; POOL_SIZE; i++) {
            FindState state = FIND_STATE_POOL[i];
            if (state != null) {
                FIND_STATE_POOL[i] = null;
                return state;
            }
        }
    }
    // 2
    return new FindState();
}
</code></pre><p>在注释1处，会先从 FIND_STATE_POOL 即 FindState 池中取出可用的 FindState（这里的POOL_SIZE为4），如果没有的话，则通过注释2处的代码直接新建 一个新的 FindState 对象。</p>
<p>接着我们来分析下FindState这个类：</p>
<pre><code>static class FindState {
    ....
    void initForSubscriber(Class&lt;?&gt; subscriberClass) {
        this.subscriberClass = clazz = subscriberClass;
        skipSuperClasses = false;
        subscriberInfo = null;
    }
    ...
}
</code></pre><p>它是 SubscriberMethodFinder 的内部类，这个方法主要做一个初始化、回收对象等工作。</p>
<p>我们接着回到SubscriberMethodFinder的注释2处的SubscriberMethodFinder()方法：</p>
<pre><code>private SubscriberInfo getSubscriberInfo(FindState findState) {
    if (findState.subscriberInfo != null &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != null) {
        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();
        if (findState.clazz == superclassInfo.getSubscriberClass()) {
            return superclassInfo;
        }
    }
    if (subscriberInfoIndexes != null) {
        for (SubscriberInfoIndex index: subscriberInfoIndexes) {
            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);
            if (info != null) {
                return info;
            }
        }
    }
    return null;
}
</code></pre><p>在前面初始化的时候，findState的subscriberInfo和subscriberInfoIndexes 这两个字段为空，所以这里直接返回 null。</p>
<p>接着我们查看注释3处的findUsingReflectionInSingleClass()方法：</p>
<pre><code>private void findUsingReflectionInSingleClass(FindState findState) {
    Method[] methods;
    try {
        // This is faster than getMethods, especially when subscribers are fat classes like Activities
        methods = findState.clazz.getDeclaredMethods();
    } catch (Throwable th) {
        methods = findState.clazz.getMethods();
        findState.skipSuperClasses = true;
    }
    for (Method method: methods) {
        int modifiers = method.getModifiers();
        if ((modifiers &amp; Modifier.PUBLIC) != 0 &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == 0) {
            Class&lt;?&gt; [] parameterTypes = method.getParameterTypes();
            if (parameterTypes.length == 1) {
                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);
                if (subscribeAnnotation != null) {
                    // 重点
                    Class&lt;?&gt; eventType = parameterTypes[0];
                    if (findState.checkAdd(method, eventType)) {
                        ThreadMode threadMode = subscribeAnnotation.threadMode();
                        findState.subscriberMethods.add(new SubscriberMethod(method, eventType, threadMode, subscribeAnnotation.priority(),  subscribeAnnotation.sticky()));
                    }
                }
            } else if (strictMethodVerification &amp;&amp;     method.isAnnotationPresent(Subscribe.class)) {
            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
            throw new EventBusException(&quot;@Subscribe method &quot; + methodName + &quot;must have exactly 1 parameter but has &quot; + parameterTypes.length);
            }
        } else if (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) {
            String methodName = method.getDeclaringClass().getName() + &quot;.&quot; + method.getName();
            throw new EventBusException(methodName + &quot; is a illegal @Subscribe method: must be public, non-static, and non-abstract&quot;);
        }
    }
}
</code></pre><p>这个方法很长，大概做的事情是：</p>
<ul>
<li>1、通过反射的方式获取订阅者类中的所有声明方法，然后在这些方法里面寻找以 @Subscribe作为注解的方法进行处理。</li>
<li>2、在经过经过一轮检查，看看 findState.subscriberMethods是否存在，如果没有，将方法名，threadMode，优先级，是否为 sticky 方法等信息封装到 SubscriberMethod 对象中，最后添加到 subscriberMethods 列表中。</li>
</ul>
<p>最后，我们继续查看注释4处的getMethodsAndRelease()方法：</p>
<pre><code>private List&lt;SubscriberMethod&gt; getMethodsAndRelease(FindState findState) {
    // 1
    List&lt;SubscriberMethod&gt; subscriberMethods = new ArrayList&lt;&gt;(findState.subscriberMethods);
    // 2
    findState.recycle();
    // 3
    synchronized(FIND_STATE_POOL) {
        for (int i = 0; i &lt; POOL_SIZE; i++) {
            if (FIND_STATE_POOL[i] == null) {
                FIND_STATE_POOL[i] = findState;
                break;
            }
        }
    }
    // 4
    return subscriberMethods;
}
</code></pre><p>在这里，首先在注释1处，从findState中取出了保存的subscriberMethods。在注释2处，将findState里的保存的所有对象进行回收。在注释3处，把findState存储在 FindState 池中方便下一次使用，以提高性能。最后，在注释4处，返回subscriberMethods。接着，在EventBus的 register() 方法的最后会调用 subscribe 方法：</p>
<pre><code>public void register(Object subscriber) {
    Class&lt;?&gt; subscriberClass = subscriber.getClass();
    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
    synchronized (this) {
        for (SubscriberMethod subscriberMethod : subscriberMethods) {
            subscribe(subscriber, subscriberMethod);
        }
    }
}
</code></pre><p>我们继续看看这个subscribe()方法做的事情：</p>
<pre><code>private void subscribe(Object subscriber, SubscriberMethod subscriberMethod) {
    Class&lt;?&gt; eventType = subscriberMethod.eventType;
    Subscription newSubscription = new Subscription(subscriber, subscriberMethod);

    // 1
    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);
    if (subscriptions == null) {
        subscriptions = new CopyOnWriteArrayList &lt;&gt; ();
        subscriptionsByEventType.put(eventType, subscriptions);
    } else {
        if (subscriptions.contains(newSubscription)) {
            throw new EventBusException(&quot;Subscriber &quot; + subscriber.getClass() + &quot; already registered to event &quot; + eventType);
        }
    }
    int size = subscriptions.size();

    // 2
    for (int i = 0; i &lt;= size; i++) {
        if (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) {
            subscriptions.add(i, newSubscription);
            break;
        }
    }

    // 3
    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);
    if (subscribedEvents == null) {
        subscribedEvents = new ArrayList&lt;&gt;();
        typesBySubscriber.put(subscriber, subscribedEvents);
    }
    subscribedEvents.add(eventType);
    // 4
    if (subscriberMethod.sticky) {
        if (eventInheritance) {
            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();
            for (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) {
                Class&lt;?&gt; candidateEventType = entry.getKey();
                if(eventType.isAssignableFrom(candidateEventType)) {
                Object stickyEvent = entry.getValue();
                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);
                }
            }
        } else {
            Object stickyEvent = stickyEvents.get(eventType);
            checkPostStickyEventToSubscription(newSubscription, stickyEvent);
        }
    }
}
</code></pre><p>首先，在注释1处，会根据 subscriberMethod的eventType，在 subscriptionsByEventType 去查找一个 CopyOnWriteArrayList ，如果没有则创建一个新的 CopyOnWriteArrayList，然后将这个 CopyOnWriteArrayList 放入 subscriptionsByEventType 中。在注释2处，添加 newSubscription对象，它是一个 Subscription 类，里面包含着 subscriber 和 subscriberMethod 等信息，并且这里有一个优先级的判断，说明它是按照优先级添加的。优先级越高，会插到在当前 List 靠前面的位置。在注释3处，对typesBySubscriber 进行添加，这主要是在EventBus的isRegister()方法中去使用的，目的是用来判断这个 Subscriber对象 是否已被注册过。最后，在注释4处，会判断是否是 sticky事件。如果是sticky事件的话，会调用 checkPostStickyEventToSubscription() 方法。</p>
<p>我们接着查看这个checkPostStickyEventToSubscription()方法：</p>
<pre><code>private void checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent) {
    if (stickyEvent != null) {
        postToSubscription(newSubscription, stickyEvent, isMainThread());
    }
}
</code></pre><p>可以看到最终是调用了postToSubscription()这个方法来进行粘性事件的发送，对于粘性事件的处理，我们最后再分析，接下来我们看看事件是如何post的。</p>
<h3 id="三、EventBus-getDefault-post-new-CollectEvent"><a href="#三、EventBus-getDefault-post-new-CollectEvent" class="headerlink" title="三、EventBus.getDefault().post(new CollectEvent())"></a>三、EventBus.getDefault().post(new CollectEvent())</h3><pre><code>public void post(Object event) {
    // 1
    PostingThreadState postingState = currentPostingThreadState.get();
    List &lt;Object&gt; eventQueue = postingState.eventQueue;
    eventQueue.add(event);
    // 2
    if (!postingState.isPosting) {
        postingState.isMainThread = isMainThread();
        postingState.isPosting = true;
        if (postingState.canceled) {
            throw new EventBusException(&quot;Internal error. Abort state was not reset&quot;);
        }
        try {
            while (!eventQueue.isEmpty()) {
                postSingleEvent(eventQueue.remove(0), postingState);
            }
        } finally {
            postingState.isPosting = false;
            postingState.isMainThread = false;
        }
    }
}
</code></pre><p>注释1处，这里的currentPostingThreadState 是一个 ThreadLocal 类型的对象，里面存储了 PostingThreadState，而 PostingThreadState 中包含了一个 eventQueue 和其他一些标志位，相关的源码如下：</p>
<pre><code>private final ThreadLocal &lt;PostingThreadState&gt; currentPostingThreadState = new ThreadLocal &lt;PostingThreadState&gt; () {
@Override
protected PostingThreadState initialValue() {
    return new PostingThreadState();
}
};

final static class PostingThreadState {
    final List &lt;Object&gt; eventQueue = new ArrayList&lt;&gt;();
    boolean isPosting;
    boolean isMainThread;
    Subscription subscription;
    Object event;
    boolean canceled;
}
</code></pre><p>接着把传入的 event，保存到了当前线程中的一个变量 PostingThreadState 的 eventQueue 中。在注释2处，最后调用了 postSingleEvent() 方法，我们继续查看这个方法：</p>
<pre><code>private void postSingleEvent(Object event, PostingThreadState postingState) throws Error {
    Class&lt;?&gt; eventClass = event.getClass();
    boolean subscriptionFound = false;
    // 1
    if (eventInheritance) {
        // 2
        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);
        int countTypes = eventTypes.size();
        for (int h = 0; h &lt; countTypes; h++) {
            Class&lt;?&gt; clazz = eventTypes.get(h);
            subscriptionFound |=
            // 3
            postSingleEventForEventType(event, postingState, clazz);
        }
    } else {
        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);
    }
    if (!subscriptionFound) {
        ...
    }
}
</code></pre><p>首先，在注释1处，首先取出 Event 的 class 类型，接着会对 eventInheritance 标志位 判断，它默认为true，如果设为 true 的话，它会在发射事件的时候判断是否需要发射父类事件，设为 false，能够提高一些性能。接着，在注释2处，会调用lookupAllEventTypes() 方法，它的作用就是取出 Event 及其父类和接口的 class 列表，当然重复取的话会影响性能，所以它也做了一个 eventTypesCache 的缓存，这样就不用重复调用 getSuperclass() 方法。最后，在注释3处会调用postSingleEventForEventType()方法，我们看下这个方法：</p>
<pre><code>private boolean postSingleEventForEventType(Object event, PostingThreadState postingState, Class &lt;?&gt; eventClass) {
    CopyOnWriteArrayList &lt;Subscription&gt; subscriptions;
    synchronized(this) {
        subscriptions = subscriptionsByEventType.get(eventClass);
    }
    if (subscriptions != null &amp;&amp; !subscriptions.isEmpty()) {
        for (Subscription subscription: subscriptions) {
            postingState.event = event;
            postingState.subscription = subscription;
            boolean aborted = false;
            try {
                postToSubscription(subscription, event, postingState.isMainThread);
                aborted = postingState.canceled;
            } finally {
                postingState.event = null;
                postingState.subscription = null;
                postingState.canceled = false;
            }
            if (aborted) {
                break;
            }
        }
        return true;
    }
    return false;
}
</code></pre><p>可以看到，这里直接根据 Event 类型从 subscriptionsByEventType 中取出对应的 subscriptions对象，最后调用了 postToSubscription() 方法。</p>
<p>这个时候我们在看看这个postToSubscription()方法：</p>
<pre><code>private void postToSubscription(Subscription subscription, Object event, boolean isMainThread) {
    switch (subscription.subscriberMethod.threadMode) {
        case POSTING:
            invokeSubscriber(subscription, event);
            break;
        case MAIN:
            if (isMainThread) {
                invokeSubscriber(subscription, event);
            } else {
                mainThreadPoster.enqueue(subscription, event);
            }
            break;
        case MAIN_ORDERED:
            if (mainThreadPoster != null) {
                mainThreadPoster.enqueue(subscription, event);
            } else {
                invokeSubscriber(subscription, event);
            }
            break;
        case BACKGROUND:
            if (isMainThread) {
                backgroundPoster.enqueue(subscription, event);
            } else {
                invokeSubscriber(subscription, event);
            }
            break;
        case ASYNC:
            asyncPoster.enqueue(subscription, event);
            break;
        default:
            throw new IllegalStateException(&quot;Unknow thread mode: &quot; + subscription.subscriberMethod.threadMode);
    }
}
</code></pre><p>从上面可以看出，这里通过threadMode 来判断在哪个线程中去执行方法：</p>
<ul>
<li>1、POSTING：执行 invokeSubscriber() 方法，内部直接采用反射调用。</li>
<li>2、MAIN：首先去判断当前是否在 UI 线程，如果是的话则直接反射调用，否则调用mainThreadPoster的enqueue()方法，即把当前的方法加入到队列之中，然后通过 handler 去发送一个消息，在 handler 的 handleMessage 中去执行方法。</li>
<li>3、MAIN_ORDERED：与MAIN类型，不过是确保是顺序执行的。</li>
<li>4、BACKGROUND：判断当前是否在 UI 线程，如果不是的话直接反射调用，是的话通过backgroundPoster的enqueue()方法 将方法加入到后台的一个队列，最后通过线程池去执行。注意，backgroundPoster在 Executor的execute()方法 上添加了 synchronized关键字 并设立 了控制标记flag，保证任一时间只且仅能有一个任务会被线程池执行。</li>
<li>5、ASYNC：逻辑实现类似于BACKGROUND，将任务加入到后台的一个队列，最终由Eventbus 中的一个线程池去调用，这里的线程池与 BACKGROUND 逻辑中的线程池用的是同一个，即使用Executors的newCachedThreadPool()方法创建的线程池，它是一个有则用、无则创建、无数量上限的线程池。不同于backgroundPoster的保证任一时间只且仅能有一个任务会被线程池执行的特性，这里asyncPoster则是异步运行的，可以同时接收多个任务。</li>
</ul>
<p>分析完EventBus的post()方法值，我们接着看看它的unregister()。</p>
<h3 id="四、EventBus-getDefault-unregister-this"><a href="#四、EventBus-getDefault-unregister-this" class="headerlink" title="四、EventBus.getDefault().unregister(this)"></a>四、EventBus.getDefault().unregister(this)</h3><p>它的核心源码如下所示：</p>
<pre><code>public synchronized void unregister(Object subscriber) {
    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);
    if (subscribedTypes != null) {
        for (Class&lt;?&gt; eventType : subscribedTypes) {
            //1
            unsubscribeByEventType(subscriber, eventType);
        }
        // 2
        typesBySubscriber.remove(subscriber);
    }
}
</code></pre><p>首先，在注释1处，unsubscribeByEventType() 方法中对 subscriptionsByEventType 移除了该 subscriber 的所有订阅信息。最后，在注释2处，移除了注册对象和其对应的所有 Event 事件链表。</p>
<p>最后，我们在来分析下EventBus中对粘性事件的处理。</p>
<h3 id="五、EventBus-getDefault-postSticky-new-CollectEvent"><a href="#五、EventBus-getDefault-postSticky-new-CollectEvent" class="headerlink" title="五、EventBus.getDefault.postSticky(new CollectEvent())"></a>五、EventBus.getDefault.postSticky(new CollectEvent())</h3><p>如果想要发射 sticky 事件需要通过 EventBus的postSticky() 方法，内部源码如下所示：</p>
<pre><code>public void postSticky(Object event) {
    synchronized (stickyEvents) {
        // 1
        stickyEvents.put(event.getClass(), event);
    }
    // 2
    post(event);
}
</code></pre><p>在注释1处，先将该事件放入 stickyEvents 中，接着在注释2处使用post()发送事件。前面我们在分析register()方法的最后部分时，其中有关粘性事件的源码如下：</p>
<pre><code>if (subscriberMethod.sticky) {
    Object stickyEvent = stickyEvents.get(eventType);
    if (stickyEvent != null) {
        postToSubscription(newSubscription, stickyEvent, isMainThread());
    }
}
</code></pre><p>可以看到，在这里会判断当前事件是否是 sticky 事件，如果 是，则从 stickyEvents 中拿出该事件并执行 postToSubscription() 方法。</p>
<p>至此，EventBus源码分析完毕。</p>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>EventBus 的源码在Android主流三方库源码分析系列中可以说是除了ButterKnife之外，算是比较简单的了。但是，它其中的一些思想和设计是值得借鉴的。比如它使用 FindState 复用池来复用 FindState 对象，在各处使用了 synchronized 关键字进行代码块同步的一些优化操作。其中上面分析了这个多，EventBus最核心的逻辑就是利用了 subscriptionsByEventType 这个重要的列表，将订阅对象，即接收事件的方法存储在这个列表，发布事件的时候在列表中查询出相对应的方法并执行。至此，Android主流三方库源码分析系列到此完结~</p>
<pre><code>结束即开始，未来的路还有很长。
</code></pre><h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr>
<p>1、EventBus V3.1.1 源码</p>
<p>2、Android进阶之光</p>
<p>3、Android组件化架构</p>
<p>3、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650243033&amp;idx=1&amp;sn=28709941e6f8821c6f5dd3fa047b1393&amp;chksm=88638eb6bf1407a034ba2184cac9e31c24f43e3ac395b1b23b18243f64220c244f2edc7dc22a&amp;scene=38#wechat_redirect" target="_blank" rel="external">EventBus设计之禅</a></p>
<p>4、<a href="https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&amp;mid=2650242621&amp;idx=1&amp;sn=cc9c31aba5ff33b20fb9fecc3b0404b2&amp;chksm=88638f52bf14064453fc09e6e53798ac5a1299d84df490b15764f9a85292732879eb4a1c0665&amp;scene=38#wechat_redirect" target="_blank" rel="external">从源码入手来学习EventBus 3事件总线机制</a></p>
<h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="JsonChao Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android主流三方库源码分析/" rel="tag"># Android主流三方库源码分析</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/20/Android主流三方库源码分析（八、深入理解Dagger2源码）/" rel="next" title="Android主流三方库源码分析（八、深入理解Dagger2源码）">
                <i class="fa fa-chevron-left"></i> Android主流三方库源码分析（八、深入理解Dagger2源码）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/18/Android系统启动流程之init进程启动/" rel="prev" title="Android系统启动流程之init进程启动">
                Android系统启动流程之init进程启动 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="JsonChao" />
            
              <p class="site-author-name" itemprop="name">JsonChao</p>
              <p class="site-description motion-element" itemprop="description">Persist + Plan = Growing</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JsonChao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://mail.google.com/mail/u/0/#inbox" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" title="JueJin">
                      
                        <i class="fa fa-fw fa-globe"></i>JueJin</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Manito Link
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wanandroid.com/" title="WanAndroid" target="_blank">WanAndroid</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://hencoder.com/" title="HenCoder" target="_blank">HenCoder</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://stormzhang.com/" title="stromzhang" target="_blank">stromzhang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.hensen.site/" title="Hensen" target="_blank">Hensen</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://liuwangshu.cn/" title="刘望舒" target="_blank">刘望舒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhuanlan.zhihu.com/baron/" title="张磊" target="_blank">张磊</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kymjs.com/" title="张涛" target="_blank">张涛</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.piasy.com/" title="Piasy" target="_blank">Piasy</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.lmj.wiki/" title="ANLY" target="_blank">ANLY</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://glanwang.com/" title="Glan" target="_blank">Glan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://huangjunbin.com/" title="黄俊彬" target="_blank">黄俊彬</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://droidyue.com/" title="技术小黑屋" target="_blank">技术小黑屋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://gityuan.com/" title="gityuan" target="_blank">gityuan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.gcssloop.com/#blog" title="gcsslop" target="_blank">gcsslop</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><span class="nav-number">1.0.1.</span> <span class="nav-text">成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一、简单示例"><span class="nav-number">1.1.</span> <span class="nav-text">一、简单示例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1、首先，定义要传递的事件实体"><span class="nav-number">1.1.1.</span> <span class="nav-text">1、首先，定义要传递的事件实体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2、准备订阅者：声明并注解你的订阅方法"><span class="nav-number">1.1.2.</span> <span class="nav-text">2、准备订阅者：声明并注解你的订阅方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者"><span class="nav-number">1.1.3.</span> <span class="nav-text">3、在2中，也就是订阅中所在的类中，注册和解注册你的订阅者</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4、发送事件"><span class="nav-number">1.1.4.</span> <span class="nav-text">4、发送事件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、EventBus-getDefault-register-this"><span class="nav-number">1.2.</span> <span class="nav-text">二、EventBus.getDefault().register(this)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、EventBus-getDefault-post-new-CollectEvent"><span class="nav-number">1.3.</span> <span class="nav-text">三、EventBus.getDefault().post(new CollectEvent())</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、EventBus-getDefault-unregister-this"><span class="nav-number">1.4.</span> <span class="nav-text">四、EventBus.getDefault().unregister(this)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、EventBus-getDefault-postSticky-new-CollectEvent"><span class="nav-number">1.5.</span> <span class="nav-text">五、EventBus.getDefault.postSticky(new CollectEvent())</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六、总结"><span class="nav-number">1.6.</span> <span class="nav-text">六、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#参考链接："><span class="nav-number">1.6.0.1.</span> <span class="nav-text">参考链接：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><span class="nav-number">1.6.1.</span> <span class="nav-text">很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。"><span class="nav-number">1.6.2.</span> <span class="nav-text">希望我们能成为朋友，在 Github、掘金上一起分享知识。</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JsonChao</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>







        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  
    

    
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2155025"></script>
      <!-- UY END -->
    
  





  










   
   
     
   
   
  
     
</div>
<!-- City版安装代码已完成 -->
   
 

   
     
   
  
       <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
       <script type="text/javascript">
          (function(d, s) {
              var j, e = d.getElementsByTagName(s)[0];
              if (typeof LivereTower === 'function') { return; }
              j = d.createElement(s);
              j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
              j.async = true;
              e.parentNode.insertBefore(j, e);
          })(document, 'script');
       </script>
       <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
       <!-- UY END -->
   
 
  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("2wtHdVd6zid7kU6YQKIqsHU5-gzGzoHsz", "eLibBRhSAsSoX1JbTMJH6ka3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
