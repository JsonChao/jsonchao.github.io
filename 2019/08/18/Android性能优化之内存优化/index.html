<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="性能优化," />





  <link rel="alternate" href="/rss2.xml" title="Deep into Android" type="application/atom+xml" />






<meta name="description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。本篇，笔者将带领大家一起来系统地学习Android中的内存优化。 可能有不少读者都知道，在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面">
<meta name="keywords" content="性能优化">
<meta property="og:type" content="article">
<meta property="og:title" content="Android性能优化之内存优化">
<meta property="og:url" content="http://yoursite.com/2019/08/18/Android性能优化之内存优化/index.html">
<meta property="og:site_name" content="Deep into Android">
<meta property="og:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。本篇，笔者将带领大家一起来系统地学习Android中的内存优化。 可能有不少读者都知道，在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://www.jcodecraeer.com/uploads/20150920/1442716389944246.jpg">
<meta property="og:updated_time" content="2019-08-18T14:11:46.766Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android性能优化之内存优化">
<meta name="twitter:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。本篇，笔者将带领大家一起来系统地学习Android中的内存优化。 可能有不少读者都知道，在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面">
<meta name="twitter:image" content="http://www.jcodecraeer.com/uploads/20150920/1442716389944246.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '2JGM8QNUKR',
      apiKey: 'ad3d08277d479825f7ef759beadbce0d',
      indexName: 'dicovery',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/08/18/Android性能优化之内存优化/"/>





  <title>Android性能优化之内存优化 | Deep into Android</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deep into Android</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/18/Android性能优化之内存优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JsonChao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep into Android">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android性能优化之内存优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T22:12:00+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/08/18/Android性能优化之内存优化/" class="leancloud_visitors" data-flag-title="Android性能优化之内存优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>内存优化可以说是性能优化中最重要的优化点之一，可以说，如果你没有掌握系统的内存优化方案，就不能说你对Android的性能优化有过多的研究与探索。本篇，笔者将带领大家一起来系统地学习Android中的内存优化。</p>
<p>可能有不少读者都知道，在内存管理上，JVM拥有垃圾内存回收的机制，自身会在虚拟机层面自动分配和释放内存，因此不需要像使用C/C++一样在代码中分配和释放某一块内存。Android系统的内存管理类似于JVM，通过new关键字来为对象分配内存，内存的释放由GC来回收。并且Android系统在内存管理上有一个Generational Heap Memory模型，当内存达到某一个阈值时，系统会根据不同的规则自动释放可以释放的内存。即便有了内存管理机制，但是，如果不合理地使用内存，也会造成一系列的性能问题，比如内存泄漏、内存抖动、短时间内分配大量的内存对象等等。下面，我就先谈谈Android的内存管理机制。</p>
<h3 id="一、Android内存管理机制"><a href="#一、Android内存管理机制" class="headerlink" title="一、Android内存管理机制"></a>一、Android内存管理机制</h3><p>我们都知道，应用程序的内存分配和垃圾回收都是由Android虚拟机完成的，在Android 5.0以下，使用的是Dalvik虚拟机，5.0及以上，则使用的是ART虚拟机。</p>
<h4 id="1-1、Java对象生命周期"><a href="#1-1、Java对象生命周期" class="headerlink" title="1.1、Java对象生命周期"></a>1.1、Java对象生命周期</h4><p>Java代码编译后生成的字节码.class文件从从文件系统中加载到虚拟机之后，便有了JVM上的Java对象，Java对象在JVM上运行有7个阶段，如下：</p>
<ul>
<li>Created</li>
<li>InUse</li>
<li>Invisible</li>
<li>Unreachable</li>
<li>Collected</li>
<li>Finalized</li>
<li>Deallocated</li>
</ul>
<h5 id="1、Created（创建）"><a href="#1、Created（创建）" class="headerlink" title="1、Created（创建）"></a>1、Created（创建）</h5><p>Java对象的创建分为如下几步：</p>
<ul>
<li>1、为对象分配存储空间。</li>
<li>2、构造对象。</li>
<li>3、从超类到子类对static成员进行初始化，类的static成员的初始化在ClassLoader加载该类时进行。</li>
<li>4、超类成员变量按顺序初始化，递归调用超类的构造方法。</li>
<li>5、子类成员变量按顺序初始化，一旦对象被创建，子类构造方法就调用该对象并为某些变量赋值。</li>
</ul>
<h5 id="2、InUse（应用）"><a href="#2、InUse（应用）" class="headerlink" title="2、InUse（应用）"></a>2、InUse（应用）</h5><p>此时对象至少被一个强引用持有。</p>
<h5 id="3、Invisible（不可见）"><a href="#3、Invisible（不可见）" class="headerlink" title="3、Invisible（不可见）"></a>3、Invisible（不可见）</h5><p>当一个对象处于不可见阶段时，说明程序本身不再持有该对象的任何强引用，虽然该对象仍然是存在的。简单的例子就是程序的执行已经超出了该对象的作用域了。但是，该对象仍可能被虚拟机下的某些已装载的静态变量线程或JNI等强引用持有，这些特殊的强引用称为“GC Root”。被这些GC Root强引用的对象会导致该对象的内存泄漏，因而无法被GC回收。</p>
<h5 id="4、Unreachable（不可达）"><a href="#4、Unreachable（不可达）" class="headerlink" title="4、Unreachable（不可达）"></a>4、Unreachable（不可达）</h5><p>该对象不再被任何强引用持有。</p>
<h5 id="5、Collected（收集）"><a href="#5、Collected（收集）" class="headerlink" title="5、Collected（收集）"></a>5、Collected（收集）</h5><p>当GC已经对该对象的内存空间重新分配做好准备时，对象进入收集阶段，如果该对象重写了finalize()方法，则执行它。</p>
<h5 id="6、Finalized（终结）"><a href="#6、Finalized（终结）" class="headerlink" title="6、Finalized（终结）"></a>6、Finalized（终结）</h5><p>等待垃圾回收器回收该对象空间。</p>
<h5 id="7、Deallocated（对象空间重新分配）"><a href="#7、Deallocated（对象空间重新分配）" class="headerlink" title="7、Deallocated（对象空间重新分配）"></a>7、Deallocated（对象空间重新分配）</h5><p>GC对该对象所占用的内存空间进行回收或者再分配，则该对象彻底消失。</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ul>
<li>1、不需要使用该对象时，及时置空。</li>
<li>2、访问本地变量优于访问类中的变量。</li>
</ul>
<h4 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h4><p>在Android系统中，堆实际上就是一块匿名共享内存。Android虚拟机仅仅只是把它封装成一个mSpace，由底层C库来管理，并且仍然使用libc提供的函数malloc和free来分配和释放内存。</p>
<p>大多数静态数据会被映射到一个共享的进程中。常见的静态数据包括Dalvik Code、app resources、so文件等等。</p>
<p>在大多数情况下，Android通过显示分配共享内存区域（如ashmem或者gralloc）来实现动态RAM区域能够在不同进程之间共享的机制。例如，Window Surface在App和Screen Compositor之间使用共享的内存，Cursor Buffers在Content Provider和Clients之间共享内存。</p>
<p>上面说过，对于Android Runtime有两种虚拟机，Dalvik和ART，它们分配的内存区域块是不同的：</p>
<h5 id="Dalvik"><a href="#Dalvik" class="headerlink" title="Dalvik"></a>Dalvik</h5><ul>
<li>Linear Alloc</li>
<li>Zygote Space</li>
<li>Alloc Space</li>
</ul>
<h5 id="ART"><a href="#ART" class="headerlink" title="ART"></a>ART</h5><ul>
<li>Non Moving Space</li>
<li>Zygote Space</li>
<li>Alloc Space</li>
<li>Image Space</li>
<li>Large Obj Space</li>
</ul>
<p>不管是Dlavik还是ART，运行时堆都分为LinearAlloc（类似于ART的Non Moving Space）、Zygote Space和Alloc Space。Dalvik中的Linear Alloc是一个线性内存空间，是一个只读区域，主要用来存储虚拟机中的类，因为类加载后只需要读的属性，并且不会改变它。把这些只读属性以及在整个进程的生命周期都不能结束的永久数据放到线性分配器中管理，能很好地减少堆混乱和GC扫描，提升内存管理的性能。Zygote Space在Zygote进程和应用程序进程之间共享，Allocation Space则是每个进程独占。Android系统的第一个虚拟机由Zygote进程创建并且只有一个Zygote Space。但是当Zygote进程在fork第一个应用程序进程之前，会将已经使用的那部分堆内存划分为一部分，还没有使用的堆内存划分为另一部分，也就是Allocation Space。但无论是应用程序进程，还是Zygote进程，当他们需要分配对象时，都是在各自的Allocation Space堆上进行。</p>
<p>当在ART运行时，还有另外两个区块，即ImageSpace和Large Object Space。</p>
<ul>
<li>Image Space：存放一些预加载类，类似于Dalvik中的Linear Alloc。与Zygote Space一样，在Zygote进程和应用程序进程之间共享。 </li>
<li>Large Object Space：离散地址的集合，分配一些大对象，用于提高GC的管理效率和整体性能。</li>
</ul>
<p>注意：Image Space的对象只创建一次，而Zygote Space的对象需要在系统每次启动时，根据运行情况都重新创建一遍。</p>
<h4 id="1-3、内存回收机制"><a href="#1-3、内存回收机制" class="headerlink" title="1.3、内存回收机制"></a>1.3、内存回收机制</h4><p>在Android的高级系统版本中，针对Heap空间有一个Generational Heap Memory的模型，其中将整个内存分为三个区域：</p>
<ul>
<li>Young Generation（年轻代）</li>
<li>Old Generation（年老代）</li>
<li>Permanent Generation（持久代）</li>
</ul>
<p>模型示意图如下所示：</p>
<p><img src="http://www.jcodecraeer.com/uploads/20150920/1442716389944246.jpg" alt="image"></p>
<h5 id="1、Young-Generation"><a href="#1、Young-Generation" class="headerlink" title="1、Young Generation"></a>1、Young Generation</h5><p>由一个Eden区和两个Survivor区组成，程序中生成的大部分新的对象都在Eden区中，当Eden区满时，还存活的对象将被复制到其中一个Survivor区，当次Survivor区满时，此区存活的对象又被复制到另一个Survivor区，当这个Survivor区也满时，会将其中存活的对象复制到年老代。</p>
<h5 id="2、Old-Generation"><a href="#2、Old-Generation" class="headerlink" title="2、Old Generation"></a>2、Old Generation</h5><p>一般情况下，年老代中的对象生命周期都比较长。</p>
<h5 id="3、Permanent-Generation"><a href="#3、Permanent-Generation" class="headerlink" title="3、Permanent Generation"></a>3、Permanent Generation</h5><p>用于存放静态的类和方法，持久代对垃圾回收没有显著影响。</p>
<h5 id="总结：内存对象的处理过程如下："><a href="#总结：内存对象的处理过程如下：" class="headerlink" title="总结：内存对象的处理过程如下："></a>总结：内存对象的处理过程如下：</h5><ul>
<li>1、对象创建后在Eden区。</li>
<li>2、执行GC后，如果对象仍然存活，则复制到S0区。</li>
<li>3、当S0区满时，该区域存活对象将复制到S1区，然后S0清空，接下来S0和S1角色互换。</li>
<li>4、当第3步达到一定次数（系统版本不同会有差异）后，存活对象将被复制到Old Generation。</li>
<li>5、当这个对象在Old Generation区域停留的时间达到一定程度时，它会被移动到Old Generation，最后累积一定时间再移动到Permanent Generation区域。</li>
</ul>
<p>系统在Young Generation、Old Generation上采用不同的回收机制。每一个Generation的内存区域都有固定的大小。随着新的对象陆续被分配到此区域，当对象总的大小临近这一级别内存区域的阈值时，会触发GC操作，以便腾出空间来存放其他新的对象。</p>
<p>执行GC占用的时间与Generation和Generation中的对象数量有关：</p>
<ul>
<li>Young Generation &lt; Old Generation &lt; Permanent Generation</li>
<li>Gener中的对象数量与执行时间成正比。</li>
</ul>
<h5 id="4、Young-Generation-GC"><a href="#4、Young-Generation-GC" class="headerlink" title="4、Young Generation GC"></a>4、Young Generation GC</h5><p>由于其对象存活时间短，因此基于Copying算法（扫描出存活的对象，并复制到一块新的完全未使用的控件中）来回收。新生代采用空闲指针的方式来控制GC触发，指针保持最后一个分配的对象在Young Generation区间的位置，当有新的对象要分配内存时，用于检查空间是否足够，不够就触发GC。</p>
<h5 id="5、Old-Generation-GC"><a href="#5、Old-Generation-GC" class="headerlink" title="5、Old Generation GC"></a>5、Old Generation GC</h5><p>由于其对象存活时间较长，比较稳定，因此采用Mark（标记）算法（扫描出存活的对象，然后再回收未被标记的对象，回收后对空出的空间要么合并，要么标记出来便于下次分配，以减少内存碎片带来的效率损耗）来回收。</p>
<h3 id="1-4、GC类型"><a href="#1-4、GC类型" class="headerlink" title="1.4、GC类型"></a>1.4、GC类型</h3><p>在Android系统中，GC有三种类型：</p>
<ul>
<li>kGcCauseForAlloc：分配内存不够引起的GC，会Stop World。由于是并发GC，其它线程都会停止，直到GC完成。</li>
<li>kGcCauseBackground：内存达到一定阈值触发的GC，由于是一个后台GC，所以不会引起Stop World。</li>
<li>kGcCauseExplicit：显示调用时进行的GC，当ART打开这个选项时，使用System.gc时会进行GC。</li>
</ul>
<p>接下来，我们来学会如何分析Android虚拟机中的GC日志，日志如下：</p>
<pre><code>D/dalvikvm(7030)：GC_CONCURRENT freed 1049K, 60% free 2341K/9351K, external 3502K/6261K, paused 3ms 3ms
</code></pre><p>GC_CONCURRENT是当前GC时的类型，GC日志中有以下几种类型：</p>
<ul>
<li>GC_CONCURRENT：当应用程序中的Heap内存占用上升时，避免Heap内存满了而触发的GC。</li>
<li>GC_FOR_MALLOC：这是由于Concurrent GC没有及时执行完，而应用又需要分配更多的内存，这时不得不停下来进行Malloc GC。</li>
<li>GC_EXTERNAL_ALLOC：这是为external分配的内存执行的GC。</li>
<li>GC_HPROF_DUMP_HEAP：创建一个HPROF profile的时候执行。</li>
<li>GC_EXPLICIT：显示调用了System.GC()。（尽量避免）</li>
</ul>
<p>再回到上面打印的日志:</p>
<ul>
<li>freed 1049k 表明在这次GC中回收了多少内存。</li>
<li>60% free 2341k/6261K 表明回收后60%的Heap可用，存活的对象大小为2341kb，heap大小是9351kb。</li>
<li>external 3502/6261K 是Native Memory的数据。存放Bitmap Pixel Data（位图数据）或者堆以外内存（NIO Direct Buffer）之类的。第一个值说明在Native Memory中已分配3502kb内存，第二个值是一个浮动的GC阈值，当分配内存达到这个值时，会触发一次GC。</li>
<li>paused 3ms 3ms 表明GC的暂停时间，如果是Concurrent GC，会看到两个时间，一个开始，一个结束，且时间很短，如如果是其他类型的GC，很可能只会看到一个时间，且这个时间是相对比较长的。并且，越大的Heap Size在GC时导致暂停的时间越长。</li>
</ul>
<p>注意：在ART模式下，多了一个Large Object Space，这部分内存并不是分配在堆上，但还是属于应用程序的内存空间。</p>
<p>在Dalvik虚拟机下，GC的操作都是并发的，也就意味着每次触发GC都会导致其它线程暂停工作（包括UI线程）。而在ART模式下，GC时不像Dalvik仅有一种回收算法，ART在不同的情况下会选择不同的回收算法，比如Alloc内存不够时会采用非并发GC，但在Alloc后，发现内存达到一定阈值时又会触发并发GC。所以在ART模式下，并不是所有的GC都是非并发的。</p>
<p>总体来看，在GC方面，与Dalvik相比，ART更为高效，不仅仅是GC的效率，大大地缩短了Pause时间，而且在内存分配上对大内存分配单独的区域，还能有算法在后台做内存整理，减少内存碎片。因此，在ART虚拟机下，可以避免较多的类似GC导致的卡顿问题。</p>
<h3 id="二、优化内存的意义"><a href="#二、优化内存的意义" class="headerlink" title="二、优化内存的意义"></a>二、优化内存的意义</h3><ul>
<li>减少OOM，提高应用稳定性。</li>
<li>减少卡顿，提高应用流畅度。</li>
<li>减少内存占用，提高应用后台运行时的存活率。</li>
<li>减少异常发生和代码逻辑隐患。</li>
</ul>
<p>注意：出现OOM是因为内存溢出导致，这种情况不一定会发生在相同的代码，也不一定是出现OOM的代码使用内存有问题，而是刚好执行到这段代码。</p>
<h3 id="三、避免内存泄漏"><a href="#三、避免内存泄漏" class="headerlink" title="三、避免内存泄漏"></a>三、避免内存泄漏</h3><h4 id="3-1-内存泄漏定义"><a href="#3-1-内存泄漏定义" class="headerlink" title="3.1 内存泄漏定义"></a>3.1 内存泄漏定义</h4><p>Android系统虚拟机的垃圾回收是通过虚拟机GC机制来实现的。GC会选择一些还存活的对象作为内存遍历的根节点GC Roots，通过对GC Roots的可达性来判断是否需要回收。内存泄漏就是在当前应用周期内不再使用的对象被GC Roots引用，导致不能回收，使实际可使用内存变小。</p>
<h4 id="3-2-使用MAT来查找内存泄漏"><a href="#3-2-使用MAT来查找内存泄漏" class="headerlink" title="3.2 使用MAT来查找内存泄漏"></a>3.2 使用MAT来查找内存泄漏</h4><p>MAT工具可以帮助开发者定位导致内存泄漏的对象，以及发现大的内存对象，然后解决内存泄漏并通过优化内存对象，达到减少内存消耗的目的。</p>
<h5 id="3-2-1-使用步骤"><a href="#3-2-1-使用步骤" class="headerlink" title="3.2.1 使用步骤"></a>3.2.1 使用步骤</h5><p>1、在<a href="https://eclipse.org/mat/downloads.php下载MAT客户端。" target="_blank" rel="external">https://eclipse.org/mat/downloads.php下载MAT客户端。</a></p>
<p>2、从Android Studio进入Profile的Memory视图，选择需要分析的应用进程，对应用进行怀疑有内存问题的操作，结束操作后，主动GC几次，最后export dump文件。</p>
<p>3、因为Android Studio保存的是Android Dalvik/ART格式的.hprof文件，所以需要转换成J2SE HPROF格式才能被MAT识别和分析。Android SDK自带了一个转换工具在SDK的platform-tools下，其中转换语句为：</p>
<pre><code>./hprof-conv file.hprof converted.hprof
</code></pre><p>4、通过MAT打开转换后的HPROF文件。</p>
<h5 id="3-2-2-MAT视图"><a href="#3-2-2-MAT视图" class="headerlink" title="3.2.2 MAT视图"></a>3.2.2 MAT视图</h5><p>在MAT窗口上，OverView是一个总体概览，显示总体的内存消耗情况和疑似问题。MAT提供了多种分析维度，其中Histogram、Dominator Tree、Top Consumers和Leak Suspects的分析维度不同。下面分别介绍下：</p>
<p>1、Histogram</p>
<p>列出内存中的所有实例类型对象和其个数以及大小，并在顶部的regex区域支持正则表达式查找。</p>
<p>2、Dominator Tree</p>
<p>列出最大的对象及其依赖存活的Object。相比Histogram，能更方便地看出引用关系。</p>
<p>3、Top Consumers</p>
<p>通过图像列出最大的Object。</p>
<p>4、Leak Suspects</p>
<p>通过MAT自动分析内存泄漏的原因和泄漏的一份总体报告。</p>
<p>分析内存最常用的是Histogram和Dominator Tree两个视图，视图中一共有四列：</p>
<ul>
<li>Class Name：类名。</li>
<li>Objects：对象实例个数。</li>
<li>Shallow Heap：对象自身占用的内存大小，不包括它引用的对象。非数组的常规对象的Shallow Heap Size由其成员变量的数量和类型决定，数组的Shallow Heap Size由数组元素的类型（对象类型、基本类型）和数组长度决定。真正的内存都在堆上，看起来是一堆原生的byte[]、char[]、int[]，对象本身的内存都很小。因此Shallow Heap对分析内存泄漏意义不是很大。</li>
<li>Retained Heap：是当前对象大小与当前对象可直接或间接引用到的对象的大小总和，包括被递归释放的。即：Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存大小。</li>
</ul>
<h5 id="3-2-3-查找内存泄漏具体位置"><a href="#3-2-3-查找内存泄漏具体位置" class="headerlink" title="3.2.3 查找内存泄漏具体位置"></a>3.2.3 查找内存泄漏具体位置</h5><p>常规方式：</p>
<ul>
<li>按照包名类型分类进行实例筛选或直接使用顶部Regex选取特定实例。</li>
<li>右击选中被怀疑的实例对象，选择Merge Shortest Paths to GC Root-&gt;exclude all phantom/weak/soft etc references。(显示GC Roots最短路径的强引用)</li>
<li>分析引用链或通过代码逻辑找出原因。 </li>
</ul>
<p>还有一种更快速的方法就是对比泄漏前后的HPROF数据：</p>
<ul>
<li>在两个HPROF文件中，把Histogram或者Dominator Tree增加到Compare Basket。</li>
<li>在Compare Basket中单击 ! ，生成对比结果视图。这样就可以对比相同的对象在不同阶段的对象实例个数和内存占用大小，如明显只需要一个实例的对象，或者不应该增加的对象实例个数却增加了，说明发生了内存泄漏，就需要去代码中定位具体的原因并解决。</li>
</ul>
<p>注意：如果目标不太明确，可以直接定位当RetainedHeap最大的Object，通过Select incoming references查看引用链，定位到可疑的对象，然后通过Path to GC Roots分析引用链。</p>
<p>此外，我们知道，当Hash集合中过多的对象返回相同的Hash值时，会严重影响性能，这时可以用Map Collision Ratio查找导致Hash集合的碰撞率较高的罪魁祸首。</p>
<p>在本人平时的项目开发中，一般会使用如下两种方式来快速对指定页面进行内存泄漏的检测：</p>
<ul>
<li><p>1、shell命令+LeakCanary+MAT：运行程序，所有功能跑一遍，确保没有改出问题，完全退出程序，手动触发GC，然后使用adb shell dumpsys meminfo packagename -d命令查看退出界面后Objects下的Views和Activities数目是否为0，如果不是则通过LeakCanary检查可能存在内存泄露的地方，最后通过MAT分析，如此反复，改善满意为止。</p>
</li>
<li><p>2、Profile MEMORY：运行程序，对每一个页面进行内存分析检查。首先，反复打开关闭页面5次，然后收到GC（点击Profile MEMORY左上角的垃圾桶图标），如果此时total内存还没有恢复到之前的数值，则可能发生了内存泄露。此时，再点击Profile MEMORY左上角的垃圾桶图标旁的heap dump按钮查看当前的内存堆栈情况，选择按包名查找，找到当前测试的Activity，如果引用了多个实例，则表明发生了内存泄露。</p>
</li>
</ul>
<h4 id="3-3-常见内存泄漏场景"><a href="#3-3-常见内存泄漏场景" class="headerlink" title="3.3 常见内存泄漏场景"></a>3.3 常见内存泄漏场景</h4><h5 id="1、资源性对象未关闭"><a href="#1、资源性对象未关闭" class="headerlink" title="1、资源性对象未关闭"></a>1、资源性对象未关闭</h5><p>对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后在置为null。</p>
<h5 id="2、注册对象未注销"><a href="#2、注册对象未注销" class="headerlink" title="2、注册对象未注销"></a>2、注册对象未注销</h5><h5 id="3、类的静态变量持有大数据对象"><a href="#3、类的静态变量持有大数据对象" class="headerlink" title="3、类的静态变量持有大数据对象"></a>3、类的静态变量持有大数据对象</h5><h5 id="4、非静态内部类的静态实例"><a href="#4、非静态内部类的静态实例" class="headerlink" title="4、非静态内部类的静态实例"></a>4、非静态内部类的静态实例</h5><p>该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。</p>
<p>解决方案：</p>
<p>将内部类设为静态内部类或将内部类抽取来作为一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。</p>
<h5 id="5、Handler临时性内存泄漏"><a href="#5、Handler临时性内存泄漏" class="headerlink" title="5、Handler临时性内存泄漏"></a>5、Handler临时性内存泄漏</h5><p>Message发出之后存储在MessageQueue中，在Message中存在一个target，它是Handler的一个引用，Message在Queue中存在的时间过长，就会导致Handler无法被回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。并且消息队列是在一个Looper线程中不断地轮询处理消息，当这个Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中的Message持有Handler实例的引用，Handler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。</p>
<p>解决方案：</p>
<ul>
<li>1、使用一个静态Handler内部类，然后对Handler持有的对象（一般是Activity）使用弱引用，这样在回收时，也可以回收Handler持有的对象。</li>
<li>2、在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。</li>
</ul>
<p>注意：AsyncTask内部也是Handler机制，同样存在内存泄漏风险，当其一般是临时性的。</p>
<h5 id="6、容器中的对象没清理造成的内存泄漏"><a href="#6、容器中的对象没清理造成的内存泄漏" class="headerlink" title="6、容器中的对象没清理造成的内存泄漏"></a>6、容器中的对象没清理造成的内存泄漏</h5><h5 id="7、WebView"><a href="#7、WebView" class="headerlink" title="7、WebView"></a>7、WebView</h5><p>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。</p>
<p>解决方案：</p>
<p>为WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。</p>
<h4 id="3-4-内存泄漏监控"><a href="#3-4-内存泄漏监控" class="headerlink" title="3.4 内存泄漏监控"></a>3.4 内存泄漏监控</h4><p>一般使用LeakCanary进行内存泄漏的监控即可，具体使用和原理分析请参见我之前的文章<a href="https://jsonchao.github.io/2019/01/06/Android主流三方库源码分析（六、深入理解Leakcanary源码）/" target="_blank" rel="external">Android主流三方库源码分析（六、深入理解Leakcanary源码）</a>。</p>
<p>除了基本使用外，我们还可以自定义处理结果，首先，继承DisplayLeakService实现一个自定义的监控处理Service，代码如下：</p>
<pre><code>public class LeakCnaryService extends DisplayLeakServcie {

    private final String TAG = “LeakCanaryService”；

    @Override
    protected void afterDefaultHandling(HeapDump heapDump， AnalysisResult result， String leakInfo) {
        ...
    }
}
</code></pre><p>重写afterDefaultHanding方法，在其中处理需要的数据，三个参数的定义如下：</p>
<ul>
<li>heapDump：堆内存文件，可以拿到完成的hprof文件，以使用MAT分析。</li>
<li>result：监控到的内存状态，如是否泄漏等。</li>
<li>leakInfo：leak trace详细信息，除了内存泄漏对象，还有设备信息。</li>
</ul>
<p>然后在install时，使用自定义的LeakCanaryService即可，代码如下：</p>
<pre><code>public class BaseApplication extends Application {

    @Override
    public void onCreate() {
        super.onCreate();
        mRefWatcher = LeakCanary.install(this, LeakCanaryService.calss, AndroidExcludedRefs.createAppDefaults().build());
    }

    ...

}
</code></pre><p>经过这样的处理，就可以在LeakCanaryService中实现自己的处理方式，如丰富的提示信息，把数据保存在本地、上传到服务器进行分析。</p>
<p>注意：LeakCanaryService需要在AndroidManifest中注册。</p>
<h3 id="四、优化内存空间"><a href="#四、优化内存空间" class="headerlink" title="四、优化内存空间"></a>四、优化内存空间</h3><h4 id="4-1-对象引用"><a href="#4-1-对象引用" class="headerlink" title="4.1 对象引用"></a>4.1 对象引用</h4><p>从Java 1.2版本开始引入了三种对象引用方式：SoftReference、WeakReference和PhantomReference三个引用类，引用类的主要功能就是能够引用但仍可以被垃圾回收器回收的对象。在引入引用类之前，只能使用Strong Reference，如果没有指定对象引用类型，默认是强引用。</p>
<h5 id="1、强引用"><a href="#1、强引用" class="headerlink" title="1、强引用"></a>1、强引用</h5><p>如果一个对象具有强引用，GC就绝对不会回收它。当内存空间不足时，JVM会抛出OOM错误。</p>
<h5 id="2、软引用"><a href="#2、软引用" class="headerlink" title="2、软引用"></a>2、软引用</h5><p>如果一个对象只具有软引用，则内存空间足够，GC时就不会回收它；如果内存不足，就会回收这些对象的内存。可用来实现内存敏感的高速缓存。</p>
<p>软引用可以和一个ReferenceQueue（引用队列）联合使用，如果软引用引用的对象被垃圾回收器回收，JVM会把这个软引用加入与之关联的引用队列中。</p>
<h5 id="3、弱引用"><a href="#3、弱引用" class="headerlink" title="3、弱引用"></a>3、弱引用</h5><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>注意：可能需要运行多次GC，才能找到并释放弱引用对象。</p>
<h5 id="4、虚引用"><a href="#4、虚引用" class="headerlink" title="4、虚引用"></a>4、虚引用</h5><p>只能用于跟踪即将对被引用对象进行的收集。虚拟机必须与ReferenceQueue类联合使用。因为它能够充当通知机制。</p>
<h4 id="4-2-减少不必要的内存开销"><a href="#4-2-减少不必要的内存开销" class="headerlink" title="4.2 减少不必要的内存开销"></a>4.2 减少不必要的内存开销</h4><h5 id="1、AutoBoxing"><a href="#1、AutoBoxing" class="headerlink" title="1、AutoBoxing"></a>1、AutoBoxing</h5><p>自动装箱的核心就是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。如int只占4字节，而Integer对象有16字节，特别是HashMap这类容器，进行增、删、改、查操作时，都会产生大量的自动装箱操作。</p>
<p>检测方式：使用TraceView查看耗时，如果发现调用了大量的integer.value，就说明发生了AutoBoxing。</p>
<h5 id="2、内存复用"><a href="#2、内存复用" class="headerlink" title="2、内存复用"></a>2、内存复用</h5><ul>
<li>资源复用：通用的字符串、颜色定义、简单页面布局的复用。</li>
<li>视图复用：可以使用ViewHolder实现ConvertView复用。</li>
<li>对象池：显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间。</li>
<li>Bitmap对象的复用：使用inBitmap属性可以告知Bitmap解码器尝试使用已经存在的内存区域，新解码的bitmap会尝试使用之前那张bitmap在heap中占据的pixel data内存区域。</li>
</ul>
<h4 id="4-3-使用最优的数据类型的"><a href="#4-3-使用最优的数据类型的" class="headerlink" title="4.3 使用最优的数据类型的"></a>4.3 使用最优的数据类型的</h4><h5 id="1、HashMap与ArrayMap"><a href="#1、HashMap与ArrayMap" class="headerlink" title="1、HashMap与ArrayMap"></a>1、HashMap与ArrayMap</h5><p>HashMap是一个散列链表，向HashMap中put元素时，先根据key的HashCode重新计算hash值，根据hash值得到这个元素在数组中的位置，如果数组该位置上已经存放有其它元素了，那么这个位置上的元素将以链表的形式存放，新加入的放在链头，最后加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。也就是说，向HashMap插入一个对象前，会给一个通向Hash阵列的索引，在索引的位置中，保存了这个Key对象的值。这意味着需要考虑的一个最大问题是冲突，当多个对象散列于阵列相同位置时，就会有散列冲突的问题。因此，HashMap会配置一个大的数组来减少潜在的冲突，并且会有其他逻辑防止链接算法和一些冲突的发生。</p>
<p>ArrayMap提供了和HashMap一样的功能，但避免了过多的内存开销，方法是使用两个小数组，而不是一个大数组。并且ArrayMap在内存上是连续不间断的。</p>
<p>总体来说，在ArrayMap中执行插入或者删除操作时，从性能角度上看，比HashMap还要更差一些，但如果只涉及很小的对象数，比如1000以下，就不需要担心这个问题了。因为此时ArrayMap不会分配过大的数组。</p>
<h5 id="2、枚举类型"><a href="#2、枚举类型" class="headerlink" title="2、枚举类型"></a>2、枚举类型</h5><p>使用枚举类型的dex size是普通常量定义的dex size的13倍以上，同时，运行时的内存分配，一个enum值的声明会消耗至少20bytes。</p>
<p>枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：IntDef和StringDef，用来提供编译期的类型检查。</p>
<p>注意：使用IntDef和StringDef需要在Gradle配置中引入相应的依赖包：</p>
<pre><code>compile &apos;com.android.support:support-annotations:22.0.0&apos;
</code></pre><h5 id="3、LruCache"><a href="#3、LruCache" class="headerlink" title="3、LruCache"></a>3、LruCache</h5><p>最近最少使用缓存，使用强引用保存需要缓存的对象，它内部维护了一个由LinkedHashMap组成的双向列表，不支持线程安全，LruCache对它进行了封装，添加了线程安全操作。当其中的一个值被访问时，它被放到队列的尾部，当缓存将满时，队列头部的值（最近最少被访问的）被丢弃，之后可以被GC回收。</p>
<p>除了普通的get/set方法之外，还有sizeOf方法，它用来返回每个缓存对象的大小。此外，还有entryRemoved方法，当一个缓存对象被丢弃时调用的方法，当第一个参数为true：表明环处对象是为了腾出空间而被清理时。否则，表明缓存对象的entry被remove移除或者被put覆盖时。</p>
<p>注意：分配LruCache大小时应考虑应用剩余内存有多大。</p>
<h5 id="4、图片内存优化"><a href="#4、图片内存优化" class="headerlink" title="4、图片内存优化"></a>4、图片内存优化</h5><p>在Android默认情况下，当图片文件解码成位图时，会被处理成32bit/像素。红色、绿色、蓝色和透明通道各8bit，即使是没有透明通道的图片，如JEPG隔世是没有透明通道的，但然后会处理成32bit位图，这样分配的32bit中的8bit透明通道数据是没有任何用处的，这完全没有必要，并且在这些图片被屏幕渲染之前，它们首先要被作为纹理传送到GPU，这意味着每一张图片会同时占用CPU内存和GPU内存。</p>
<p>减少内存开销常用方式如下：</p>
<ul>
<li>1、设置位图的规格：当显示小图片或对图片质量要求不高时可以考虑使用RGB_565，用户头像或圆角图片一般可以尝试ARGB_4444。通过设置inPreferredConfig参数来实现不同的位图规格，代码如下所示：</li>
</ul>
<pre><code>BitmapFactory.Options options = new BitmapFactory.Options();
options.inPreferredConfig = Bitmap.Config.RGB_565;
BitmapFactory.decodeStream(is, null, options);
</code></pre><ul>
<li>2、inSampleSize：位图功能对象中的inSampleSize属性实现了位图的缩放功能，代码如下所示：</li>
</ul>
<pre><code>BitampFactory.Options options = new BitmapFactory.Options();
// 设置为4就是1/4大小的图片。因此，图片大小总会比原始图片小一倍以上。
options.inSampleSize = 4;
BitmapFactory.decodeSream(is, null, options);
</code></pre><ul>
<li>3、inScaled，inDensity和inTargetDensity实现更细的缩放图片：当inScaled设置为true时，系统会按照现有的密度来划分目标密度，代码如下所示：</li>
</ul>
<pre><code>BitampFactory.Options options = new BitampFactory.Options();
options.inScaled = true;
options.inDensity = srcWidth;
options.inTargetDensity = dstWidth;
BitmapFactory.decodeStream(is, null, options);
</code></pre><p>上述三种方案的缺点：使用了过多的算法，导致图片显示过程需要更多的时间开销，如果图片很多的话，就影响到图片的显示效果。最好的方案是结合这两个方法，达到最佳的性能结合，首先使用inSampleSize处理图片，转换为接近目标的2次幂，然后用inDensity和inTargetDensity生成最终想要的准确大小，因为inSampleSize会减少像素的数量，而基于输出密码的需要对像素重新过滤。但获取资源图片的大小，需要设置位图对象的inJustDecodeBounds值为true，然后继续解码图片文件，这样才能生产图片的宽高数据，并允许继续优化图片。总体的代码如下所示：</p>
<pre><code>BitmapFactory.Options options = new BitampFactory.Options();
options.inJustDecodeBounds = true;
BitmapFactory.decodeStream(is, null, options);
options.inScaled = true;
options.inDensity = options.outWidth;
options.inSampleSize = 4;
Options.inTargetDensity = desWith * options.inSampleSize;
options.inJustDecodeBounds = false;
BitmapFactory.decodeStream(is, null, options);
</code></pre><h5 id="4、inBitmap"><a href="#4、inBitmap" class="headerlink" title="4、inBitmap"></a>4、inBitmap</h5><p>可以结合LruCache来实现，在LruCache移除超出cache size的图片时，暂时缓存Bitamp到一个软引用集合，需要创建新的Bitamp时，可以从这个软用用集合中找到最适合重用的Bitmap，来重用它的内存区域。</p>
<p>注意：新申请的Bitmap与旧的Bitmap必须有相同的解码格式，并且在Android 4.4之前，只能重用相同大小的Bitamp的内存区域，而Android 4.4之后可以重用任何bitmap的内存区域。</p>
<h3 id="五、图片管理模块设计与实现"><a href="#五、图片管理模块设计与实现" class="headerlink" title="五、图片管理模块设计与实现"></a>五、图片管理模块设计与实现</h3><p>在设计一个模块时，需要考虑以下几点：</p>
<ul>
<li>1、单一职责</li>
<li>2、避免不同功能之间的耦合</li>
<li>3、接口隔离</li>
</ul>
<p>在编写代码前先画好UML图，确定每一个对象、方法、接口的功能，首先尽量做到功能单一原则，在这个基础上，再明确模块与模块的直接关系，最后使用代码实现。</p>
<h4 id="5-1-实现异步加载功能"><a href="#5-1-实现异步加载功能" class="headerlink" title="5.1 实现异步加载功能"></a>5.1 实现异步加载功能</h4><h5 id="1-实现网络图片显示"><a href="#1-实现网络图片显示" class="headerlink" title="1.实现网络图片显示"></a>1.实现网络图片显示</h5><p>ImageLoader是实现图片加载的基类，其中ImageLoader有一个内部类BitmapLoadTask是继承AsyncTask的异步下载管理类，负责图片的下载和刷新，MiniImageLoader是ImageLoader的子类，维护类一个ImageLoader的单例，并且实现了基类的网络加载功能，因为具体的下载在应用中有不同的下载引擎，抽象成接口便于替换。代码如下所示：</p>
<pre><code>public abstract class ImageLoader {
    private boolean mExitTasksEarly = false;   //是否提前结束
    protected boolean mPauseWork = false;
    private final Object mPauseWorkLock = new   Object();

    protected ImageLoader() {

    }

    public void loadImage(String url, ImageView imageView) {
        if (url == null) {
            return;
        }

        BitmapDrawable bitmapDrawable = null;
        if (bitmapDrawable != null) {
            imageView.setImageDrawable(bitmapDrawable);
        } else {
            final BitmapLoadTask task = new BitmapLoadTask(url, imageView);
            task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
        }
    }

    private class BitmapLoadTask extends AsyncTask&lt;Void, Void, Bitmap&gt; {

        private String mUrl;
        private final WeakReference&lt;ImageView&gt; imageViewWeakReference;

        public BitmapLoadTask(String url, ImageView imageView) {
            mUrl = url;
            imageViewWeakReference = new WeakReference&lt;ImageView&gt;(imageView);
        }

        @Override
        protected Bitmap doInBackground(Void... params) {
            Bitmap bitmap = null;
            BitmapDrawable drawable = null;

            synchronized (mPauseWorkLock) {
                while (mPauseWork &amp;&amp; !isCancelled()) {
                    try {
                        mPauseWorkLock.wait();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }

            if (bitmap == null
                    &amp;&amp; !isCancelled()
                    &amp;&amp; imageViewWeakReference.get() != null
                    &amp;&amp; !mExitTasksEarly) {
                bitmap = downLoadBitmap(mUrl);
            }
            return bitmap;
        }

        @Override
        protected void onPostExecute(Bitmap bitmap) {
            if (isCancelled() || mExitTasksEarly) {
                bitmap = null;
            }

            ImageView imageView = imageViewWeakReference.get();
            if (bitmap != null &amp;&amp; imageView != null) {
                setImageBitmap(imageView, bitmap);
            }
        }

        @Override
        protected void onCancelled(Bitmap bitmap) {
            super.onCancelled(bitmap);
            synchronized (mPauseWorkLock) {
                mPauseWorkLock.notifyAll();
            }
        }
    }

    public void setPauseWork(boolean pauseWork) {
        synchronized (mPauseWorkLock) {
            mPauseWork = pauseWork;
            if (!mPauseWork) {
                mPauseWorkLock.notifyAll();
            }
        }
    }

    public void setExitTasksEarly(boolean exitTasksEarly) {
        mExitTasksEarly = exitTasksEarly;
        setPauseWork(false);
    }

    private void setImageBitmap(ImageView imageView, Bitmap bitmap) {
        imageView.setImageBitmap(bitmap);
    }

    protected abstract Bitmap downLoadBitmap(String    mUrl);
}
</code></pre><p>setPauseWork方法是图片加载线程控制接口，pauseWork控制图片模块的暂停和继续工作，一般在listView等控件中，滑动时停止加载图片，保证滑动流畅。另外，具体的图片下载和解码是和业务强相关的，因此在ImageLoader中不做具体的实现，只是定义类一个抽象方法。</p>
<p>MiniImageLoader是一个单例，保证一个应用只维护一个ImageLoader，减少对象开销，并管理应用中所有的图片加载。MiniImageLoader代码如下所示：</p>
<pre><code>public class MiniImageLoader extends ImageLoader {

    private volatile static MiniImageLoader sMiniImageLoader = null;

    private ImageCache mImageCache = null;

    public static MiniImageLoader getInstance() {
        if (null == sMiniImageLoader) {
            synchronized (MiniImageLoader.class) {
                MiniImageLoader tmp = sMiniImageLoader;
                if (tmp == null) {
                    tmp = new MiniImageLoader();
                }
                sMiniImageLoader = tmp;
            }
        }
        return sMiniImageLoader;
    }

    public MiniImageLoader() {
        mImageCache = new ImageCache();
    }

    @Override
    protected Bitmap downLoadBitmap(String mUrl) {
        HttpURLConnection urlConnection = null;
        InputStream in = null;
        try {
            final URL url = new URL(mUrl);
            urlConnection = (HttpURLConnection) url.openConnection();
            in = urlConnection.getInputStream();
            Bitmap bitmap = decodeSampledBitmapFromStream(in, null);
            return bitmap;

        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (urlConnection != null) {
                urlConnection.disconnect();
                urlConnection = null;
            }

            if (in != null) {
                try {
                    in.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        return null;
    }

    public Bitmap decodeSampledBitmapFromStream(InputStream is, BitmapFactory.Options options) {
        return BitmapFactory.decodeStream(is, null, options);
    }
}
</code></pre><p>其中，volatile保证了对象从主内存加载。并且，上面的try …cache层级太多，Java中有一个Closeable接口，该接口标识类一个可关闭的对象，因此可以写如下的工具类：</p>
<pre><code>public class CloseUtils {

    public static void closeQuietly(Closeable closeable) {
        if (null != closeable) {
            try {
                closeable.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
</code></pre><p>改造后如下所示：</p>
<pre><code>finally {
    if  (urlConnection != null) {
        urlConnection.disconnect();    
    }
    CloseUtil.closeQuietly(in);
}
</code></pre><p>同时，为了使ListView在滑动过程中更流畅，在滑动时暂停图片加载，减少系统开销，代码如下所示：</p>
<pre><code>listView.setOnScrollListener(new AbsListView.OnScrollListener() {

    @Override
    public void onScrollStateChanged(AbsListView absListView, int scrollState) {
        if (scorllState == AbsListView.OnScrollListener.SCROLL_STAE_FLING) {
            MiniImageLoader.getInstance().setPauseWork(true);
        } else {
            MiniImageLoader.getInstance().setPauseWork(false);
        }
    }
}
</code></pre><h5 id="2-单个图片内存优化"><a href="#2-单个图片内存优化" class="headerlink" title="2 单个图片内存优化"></a>2 单个图片内存优化</h5><p>这里使用一个BitmapConfig类来实现参数的配置，代码如下所示:</p>
<pre><code>public class BitmapConfig {

    private int mWidth, mHeight;
    private Bitmap.Config mPreferred;

    public BitmapConfig(int width, int height) {
        this.mWidth = width;
        this.mHeight = height;
        this.mPreferred = Bitmap.Config.RGB_565;
    }

    public BitmapConfig(int width, int height, Bitmap.Config preferred) {
        this.mWidth = width;
        this.mHeight = height;
        this.mPreferred = preferred;
    }

    public BitmapFactory.Options getBitmapOptions() {
        return getBitmapOptions(null);
    }

    // 精确计算，需要图片is流现解码，再计算宽高比
    public BitmapFactory.Options getBitmapOptions(InputStream is) {
        final BitmapFactory.Options options = new BitmapFactory.Options();
        options.inPreferredConfig = Bitmap.Config.RGB_565;
        if (is != null) {
            options.inJustDecodeBounds = true;
            BitmapFactory.decodeStream(is, null, options);
            options.inSampleSize = calculateInSampleSize(options, mWidth, mHeight);
        }
        options.inJustDecodeBounds = false;
        return options;
    }

    private static int calculateInSampleSize(BitmapFactory.Options    options, int mWidth, int mHeight) {
        final int height = options.outHeight;
        final int width = options.outWidth;
        int inSampleSize = 1;
        if (height &gt; mHeight || width &gt; mWidth) {
            final int halfHeight = height / 2;
            final int halfWidth = width / 2;
            while ((halfHeight / inSampleSize) &gt; mHeight
                    &amp;&amp; (halfWidth / inSampleSize) &gt; mWidth) {
                inSampleSize *= 2;
            }
        }

        return inSampleSize;
    }
}
</code></pre><p>然后，调用MiniImageLoader的downLoadBitmap方法，增加获取BitmapFactory.Options的步骤：</p>
<pre><code>final URL url = new URL(urlString);
urlConnection = (HttpURLConnection) url.openConnection();
in = urlConnection.getInputStream();
final BitmapFactory.Options options =    mConfig.getBitmapOptions(in);
in.close();
urlConnection.disconnect();
urlConnection = (HttpURLConnection)    url.openConnection();
in = urlConnection.getInputStream();
Bitmap bitmap = decodeSampledBitmapFromStream(in,    options);
</code></pre><p>优化后仍存在一些问题：</p>
<ul>
<li>1.相同的图片，每次都要重新加载；</li>
<li>2.整体内存开销不可控，虽然减少了单个图片开销，但是在片非常多的情况下，没有合理管理机制仍然对性能有严重影的。</li>
</ul>
<p>为了解决这两个问题，就需要有内存池的设计理念，通过内存池控制整体图片内存，不重新加载和解码已经显示过的图片。</p>
<h4 id="5-2-实现三级缓存"><a href="#5-2-实现三级缓存" class="headerlink" title="5.2 实现三级缓存"></a>5.2 实现三级缓存</h4><p>内存–本地–网络</p>
<h5 id="1、内存缓存"><a href="#1、内存缓存" class="headerlink" title="1、内存缓存"></a>1、内存缓存</h5><p>使用软引用和弱引用（SoftReference or WeakReference）来实现内存池是以前的常用做法，但是现在不建议。从API 9起（Android 2.3）开始，Android系统垃圾回收器更倾向于回收持有软引用和弱引用的对象，所以不是很靠谱，从Android 3.0开始（API 11）开始，图片的数据无法用一种可遇见的方式将其释放，这就存在潜在的内存溢出风险。<br>使用LruCache来实现内存管理是一种可靠的方式，它的主要算法原理是把最近使用的对象用强引用来存储在LinkedHashMap中，并且把最近最少使用的对象在缓存值达到预设定值之前从内存中移除。使用LruCache实现一个图片的内存缓存的代码如下所示：</p>
<pre><code>public class MemoryCache {

    private final int DEFAULT_MEM_CACHE_SIZE = 1024 * 12;
    private LruCache&lt;String, Bitmap&gt; mMemoryCache;
    private final String TAG = &quot;MemoryCache&quot;;
    public MemoryCache(float sizePer) {
        init(sizePer);
    }

    private void init(float sizePer) {
        int cacheSize = DEFAULT_MEM_CACHE_SIZE;
        if (sizePer &gt; 0) {
            cacheSize = Math.round(sizePer * Runtime.getRuntime().maxMemory() / 1024);
        }

        mMemoryCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {
            @Override
            protected int sizeOf(String key, Bitmap value) {
                final int bitmapSize = getBitmapSize(value) / 1024;
                return bitmapSize == 0 ? 1 : bitmapSize;
            }

            @Override
            protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) {
               super.entryRemoved(evicted, key, oldValue, newValue);
            }
        };
    }

    @TargetApi(Build.VERSION_CODES.KITKAT)
    public int getBitmapSize(Bitmap bitmap) {
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
            return bitmap.getAllocationByteCount();
        }
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB_MR1) {
            return bitmap.getByteCount();
        }

        return bitmap.getRowBytes() * bitmap.getHeight();
    }

    public Bitmap getBitmap(String url) {
        Bitmap bitmap = null;
        if (mMemoryCache != null) {
            bitmap = mMemoryCache.get(url);
        }
        if (bitmap != null) {
            Log.d(TAG, &quot;Memory cache exiet&quot;);
        }

        return bitmap;
    }

    public void addBitmapToCache(String url, Bitmap bitmap) {
        if (url == null || bitmap == null) {
            return;
        }

        mMemoryCache.put(url, bitmap);
    }

    public void clearCache() {
        if (mMemoryCache != null) {
            mMemoryCache.evictAll();
        }
    }
}
</code></pre><p>上述代码中cacheSize百分比占比多少合适？可以基于以下几点来考虑：</p>
<ul>
<li>1.应用中内存的占用情况，除了图片以外，是否还有大内存的数据需要缓存到内存。</li>
<li>2.在应用中大部分情况要同时显示多少张图片，优先保证最大图片的显示数量的缓存支持。</li>
<li>3.Bitmap的规格，计算出一张图片占用的内存大小。</li>
<li>4.图片访问的频率。</li>
</ul>
<p>在应用中，如果有一些图片的访问频率要比其它的大一些，或者必须一直显示出来，就需要一直保持在内存中，这种情况可以使用多个LruCache对象来管理多组Bitmap，对Bitmap进行分级，不同级别的Bitmap放到不同的LruCache中。</p>
<h5 id="2、bitmap内存复用"><a href="#2、bitmap内存复用" class="headerlink" title="2、bitmap内存复用"></a>2、bitmap内存复用</h5><p>从Android3.0开始Bitmap支持内存复用，也就是BitmapFactoy.Options.inBitmap属性，如果这个属性被设置有效的目标用对象，decode方法就在加载内容时重用已经存在的bitmap，这意味着Bitmap的内存被重新利用，这可以减少内存的分配回收，提高图片的性能。代码如下所示：</p>
<pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
        mReusableBitmaps = Collections.synchronizedSet(newHashSet&lt;SoftReference&lt;Bitmap&gt;&gt;());
}
</code></pre><p>因为inBitmap属性在Android3.0以后才支持，在entryRemoved方法中加入软引用集合，作为复用的源对象，之前是直接删除，代码如下所示：</p>
<pre><code>if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
    mReusableBitmaps.add(new SoftReference&lt;Bitmap&gt;(oldValue));
}
</code></pre><p>同样在3.0以上判断，需要分配一个新的bitmap对象时，首先检查是否有可复用的bitmap对象：</p>
<pre><code>public static Bitmap decodeSampledBitmapFromStream(InputStream is, BitmapFactory.Options options, ImageCache cache) {
     if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
         addInBitmapOptions(options, cache);
     }
     return BitmapFactory.decodeStream(is, null, options);
 }

@TargetApi(Build.VERSION_CODES.HONEYCOMB)
private static void addInBitmapOptions(BitmapFactory.Options options, ImageCache cache) {
     options.inMutable = true;
     if (cache != null) {
         Bitmap inBitmap = cache.getBitmapFromReusableSet(options);
         if (inBitmap != null) {
             options.inBitmap = inBitmap;
         }
     }

 }
</code></pre><p>接着，我们使用cache.getBitmapForResubleSet方法查找一个合适的bitmap赋值给inBitmap。代码如下所示：</p>
<pre><code>// 获取inBitmap,实现内存复用
public Bitmap getBitmapFromReusableSet(BitmapFactory.Options options) {
    Bitmap bitmap = null;

    if (mReusableBitmaps != null &amp;&amp; !mReusableBitmaps.isEmpty()) {
        final Iterator&lt;SoftReference&lt;Bitmap&gt;&gt; iterator = mReusableBitmaps.iterator();
        Bitmap item;

        while (iterator.hasNext()) {
            item = iterator.next().get();

            if (null != item &amp;&amp; item.isMutable()) {
                if (canUseForInBitmap(item, options)) {

                    Log.v(&quot;TEST&quot;, &quot;canUseForInBitmap!!!!&quot;);

                    bitmap = item;

                    // Remove from reusable set so it can&apos;t be used again
                    iterator.remove();
                    break;
                }
            } else {
                // Remove from the set if the reference has been cleared.
                iterator.remove();
            }
        }
    }

    return bitmap;
}
</code></pre><p>上述方法从软引用集合中查找规格可利用的Bitamp作为内存复用对象，因为使用inBitmap有一些限制，在Android 4.4之前，只支持同等大小的位图。因此使用了canUseForInBitmap方法来判断该Bitmap是否可以复用，代码如下所示：</p>
<pre><code>@TargetApi(Build.VERSION_CODES.KITKAT)
private static boolean canUseForInBitmap(
        Bitmap candidate, BitmapFactory.Options targetOptions) {

    if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.KITKAT) {
        return candidate.getWidth() == targetOptions.outWidth
                &amp;&amp; candidate.getHeight() == targetOptions.outHeight
                &amp;&amp; targetOptions.inSampleSize == 1;
    }
    int width = targetOptions.outWidth / targetOptions.inSampleSize;
    int height = targetOptions.outHeight / targetOptions.inSampleSize;

    int byteCount = width * height * getBytesPerPixel(candidate.getConfig());

    return byteCount &lt;= candidate.getAllocationByteCount();
}
</code></pre><h5 id="3、磁盘缓存"><a href="#3、磁盘缓存" class="headerlink" title="3、磁盘缓存"></a>3、磁盘缓存</h5><p>由于磁盘读取时间是不可预知的，所以图片的解码和文件读取都应该在后台进程中完成。DisLruCache是Android提供的一个管理磁盘缓存的类。</p>
<ul>
<li>1、首先调用DiskLruCache的open方法进行初始化，代码如下：</li>
</ul>
<pre><code>public static DiskLruCache open(File directory, int appVersion, int valueCou9nt, long maxSize)
</code></pre><p>directory一般建议缓存到SD卡上。appVersion发生变化时，会自动删除前一个版本的数据。valueCount是指Key与Value的对应关系，一般情况下是1对1的关系。maxSize是缓存图片的最大缓存数据大小。初始化DiskLruCache的代码如下所示：</p>
<pre><code>private void init(final long cacheSize,final File cacheFile) {
    new Thread(new Runnable() {
        @Override
        public void run() {
            synchronized (mDiskCacheLock) {
                if(!cacheFile.exists()){
                    cacheFile.mkdir();
                }
                MLog.d(TAG,&quot;Init DiskLruCache cache path:&quot; + cacheFile.getPath() + &quot;\r\n&quot; + &quot;Disk Size:&quot; + cacheSize);
                try {
                    mDiskLruCache = DiskLruCache.open(cacheFile, MiniImageLoaderConfig.VESION_IMAGELOADER, 1, cacheSize);
                    mDiskCacheStarting = false;
                    // Finished initialization
                    mDiskCacheLock.notifyAll(); 
                    // Wake any waiting threads
                }catch(IOException e){
                    MLog.e(TAG,&quot;Init err:&quot; + e.getMessage());
                }
            }
        }
    }).start();
}
</code></pre><p>如果在初始化前就要操作写或者读会导致失败，所以在整个DiskCache中使用的Object的wait/notifyAll机制来避免同步问题。</p>
<ul>
<li>2、写入DiskLruCache</li>
</ul>
<p>首先，获取Editor实例，它需要传入一个key来获取参数，Key必须与图片有唯一对应关系，但由于URL中的字符可能会带来文件名不支持的字符类型，所以取URL的MD4值作为文件名，实现Key与图片的对应关系，通过URL获取MD5值的代码如下所示:</p>
<pre><code>private String hashKeyForDisk(String key) {
    String cacheKey;
    try {
        final MessageDigest mDigest = MessageDigest.getInstance(&quot;MD5&quot;);
        mDigest.update(key.getBytes());
        cacheKey = bytesToHexString(mDigest.digest());
    } catch (NoSuchAlgorithmException e) {
        cacheKey = String.valueOf(key.hashCode());
    }
    return cacheKey;
}
private String bytesToHexString(byte[] bytes) {
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; bytes.length; i++) {
        String hex = Integer.toHexString(0xFF &amp; bytes[i]);
        if (hex.length() == 1) {
            sb.append(&apos;0&apos;);
        }
        sb.append(hex);
    }
    return sb.toString();
}
</code></pre><p>然后，写入需要保存的图片数据，图片数据写入本地缓存的整体代码如下所示：</p>
<pre><code> public void saveToDisk(String imageUrl, InputStream in) {
    // add to disk cache
    synchronized (mDiskCacheLock) {
        try {
            while (mDiskCacheStarting) {
                try {
                    mDiskCacheLock.wait();
                } catch (InterruptedException e) {}
            }
            String key = hashKeyForDisk(imageUrl);
            MLog.d(TAG,&quot;saveToDisk get key:&quot; + key);
            DiskLruCache.Editor editor = mDiskLruCache.edit(key);
            if (in != null &amp;&amp; editor != null) {
                // 当 valueCount指定为1时，index传0即可
                OutputStream outputStream = editor.newOutputStream(0);
                MLog.d(TAG, &quot;saveToDisk&quot;);
                if (FileUtil.copyStream(in,outputStream)) {
                    MLog.d(TAG, &quot;saveToDisk commit start&quot;);
                    editor.commit();
                    MLog.d(TAG, &quot;saveToDisk commit over&quot;);
                } else {
                    editor.abort();
                    MLog.e(TAG, &quot;saveToDisk commit abort&quot;);
                }
            }
            mDiskLruCache.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}
</code></pre><p>接着，读取图片缓存，通过DiskLruCache的get方法实现，代码如下所示：</p>
<pre><code>public Bitmap  getBitmapFromDiskCache(String imageUrl,BitmapConfig bitmapconfig) {
    synchronized (mDiskCacheLock) {
        // Wait while disk cache is started from background thread
        while (mDiskCacheStarting) {
            try {
                mDiskCacheLock.wait();
            } catch (InterruptedException e) {}
        }
        if (mDiskLruCache != null) {
            try {

                String key = hashKeyForDisk(imageUrl);
                MLog.d(TAG,&quot;getBitmapFromDiskCache get key:&quot; + key);
                DiskLruCache.Snapshot snapShot = mDiskLruCache.get(key);
                if(null == snapShot){
                    return null;
                }
                InputStream is = snapShot.getInputStream(0);
                if(is != null){
                    final BitmapFactory.Options options = bitmapconfig.getBitmapOptions();
                    return BitmapUtil.decodeSampledBitmapFromStream(is, options);
                }else{
                    MLog.e(TAG,&quot;is not exist&quot;);
                }
            }catch (IOException e){
                MLog.e(TAG,&quot;getBitmapFromDiskCache ERROR&quot;);
            }
        }
    }
    return null;
}
</code></pre><p>最后，要注意读取并解码Bitmap数据和保存图片数据都是有一定耗时的IO操作。所以这些方法都是在ImageLoader中的doInBackground方法中调用，代码如下所示：</p>
<pre><code>@Override
protected Bitmap doInBackground(Void... params) {

    Bitmap bitmap = null;
    synchronized (mPauseWorkLock) {
        while (mPauseWork &amp;&amp; !isCancelled()) {
            try {
                mPauseWorkLock.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    if (bitmap == null &amp;&amp; !isCancelled()
            &amp;&amp; imageViewReference.get() != null &amp;&amp; !mExitTasksEarly) {
        bitmap = getmImageCache().getBitmapFromDisk(mUrl, mBitmapConfig);
    }

    if (bitmap == null &amp;&amp; !isCancelled()
            &amp;&amp; imageViewReference.get() != null &amp;&amp; !mExitTasksEarly) {
        bitmap = downLoadBitmap(mUrl, mBitmapConfig);
    }
    if (bitmap != null) {
        getmImageCache().addToCache(mUrl, bitmap);
    }

    return bitmap;
}
</code></pre><h4 id="5-3-图片加载三方库"><a href="#5-3-图片加载三方库" class="headerlink" title="5.3 图片加载三方库"></a>5.3 图片加载三方库</h4><p>目前使用最广泛的有Picasso、Glide和Fresco。Glide和Picasso比较相似，但是Glide相对于Picasso来说，功能更多，内部实现更复杂，对Glide有兴趣的同学可以阅读这篇文章<a href="https://jsonchao.github.io/2018/12/16/Android主流三方库源码分析（三、深入理解Glide源码）" target="_blank" rel="external">Android主流三方库源码分析（三、深入理解Glide源码）</a>。Fresco最大的亮点在与它的内存管理，特别实在低端机和Android 5.0以下的机器上的优势更加明显，而使用Fresco将很好地解决图片占用内存大的问题。因为，Fresco会将图片放到一个特别的内存区域，当图片不再显示时，占用的内存会自动释放。以下总结以下其优点：</p>
<ul>
<li>1、内存管理。</li>
<li>2、渐进式呈现：先呈现大致的图片轮廓，然后随着图片下载的继续，呈现逐渐清晰的图片。</li>
<li>3、支持更多的图片格式:如Gif和Webp。</li>
<li>4、图像加载策略丰富：其中的Image Pipeline可以为同一个图片指定不同的远程路径，比如先显示已经存在本地缓存中的图片，等高清图下载完成之后在显示高清图集。</li>
</ul>
<p>缺点：</p>
<ul>
<li>安装包过大，所以对图片加载和显示要求不是比较高的情况下建议使用Glide。</li>
</ul>
<h4 id="六、内存优化"><a href="#六、内存优化" class="headerlink" title="六、内存优化"></a>六、内存优化</h4><p>对于内存泄漏，其本质可理解为无法回收无用的对象。这里我总结了我在项目中遇到的一些常见的内存泄漏案例（包含解决方案）和常见的内存优化技术。</p>
<h5 id="6-1、常见的内存泄漏案例-完善3-3小节）："><a href="#6-1、常见的内存泄漏案例-完善3-3小节）：" class="headerlink" title="6.1、常见的内存泄漏案例(完善3.3小节）："></a>6.1、常见的内存泄漏案例(完善3.3小节）：</h5><ul>
<li>1、单例造成的内存泄漏（使用Application的Context）</li>
<li>2、非静态内部类创建静态实例造成的内存泄漏（将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，就使用Application的Context）</li>
<li>3、Handler造成的内存泄漏（将Handler类独立出来或者使用静态内部类）</li>
<li>4、线程造成的内存泄漏（将AsyncTask和Runnable类独立出来或者使用静态内部类）</li>
<li>5、BraodcastReceiver、Bitmap等资源未关闭造成的内存泄漏（应该在Activity销毁时及时关闭或者注销）</li>
<li>6、使用ListView时造成的内存泄漏（在构造Adapter时，使用缓存的convertView）</li>
<li>7、集合容器中的内存泄露（在退出程序之前，将集合里的东西clear，然后置为null，再退出程序）</li>
<li>8、WebView造成的泄露（为WebView另外开启一个进程，通过AIDL与主线程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，从而达到内存的完整释放）</li>
</ul>
<h5 id="6-2、常见的内存优化点："><a href="#6-2、常见的内存优化点：" class="headerlink" title="6.2、常见的内存优化点："></a>6.2、常见的内存优化点：</h5><p>1、只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。</p>
<p>2、图片优化：</p>
<ul>
<li>颜色模式：RGB_8888-&gt;RGB_565</li>
<li>降低图片大小</li>
<li>降低采样率</li>
</ul>
<p>3、在App退到后台内存紧张即将被Kill掉时选择重写onTrimMemory()方法去释放掉图片缓存、静态缓存来自保。</p>
<p>4、item被回收不可见时释放掉对图片的引用：</p>
<ul>
<li>ListView：因此每次item被回收后再次利用都会重新绑定数据，只需在ImageView onDetachFromWindow的时候释放掉图片引用即可。</li>
<li>RecyclerView：因为被回收不可见时第一选择是放进mCacheView中，这里item被复用并不会只需bindViewHolder来重新绑定数据，只有被回收进mRecyclePool中后拿出来复用才会重新绑定数据，因此重写Recycler.Adapter中的onViewRecycled()方法来使item被回收进RecyclePool的时候去释放图片引用。</li>
</ul>
<p>5、集合优化：Android提供了一系列优化过后的数据集合工具类，如SparseArray、SparseBooleanArray、LongSparseArray，使用这些API可以让我们的程序更加高效。HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。</p>
<p>6、避免创作不必要的对象：字符串拼接使用StringBuffer，StringBuilder。</p>
<p>7、onDraw方法里面不要执行对象的创建。</p>
<p>8、使用static final 优化成员变量。</p>
<p>9、使用增强型for循环语法。</p>
<p>10、在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。</p>
<p>11、适当采用软引用和弱引用。</p>
<p>12、采用内存缓存和磁盘缓存。</p>
<p>13、尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。</p>
<h3 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h3><p>对于内存优化，一般都是通过使用MAT等工具来进行检查和使用LeakCanary等内存泄漏监控工具来进行监控，以此来发现问题，再分析问题原因，解决发现的问题或者对当前的实现逻辑进行优化，优化完后在进行检查，直到达到预定的性能指标。下一篇，将会深入分析一下Android系统的存储优化相关技术，尽请期待~</p>
<h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr>
<p>1、Android应用性能优化最佳实践</p>
<p>2、<a href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ?" target="_blank" rel="external">必知必会 | Android 性能优化的方面方面都在这儿</a></p>
<h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="JsonChao Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/性能优化/" rel="tag"># 性能优化</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/28/Android性能优化之绘制优化/" rel="next" title="Android性能优化之绘制优化">
                <i class="fa fa-chevron-left"></i> Android性能优化之绘制优化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/11/10/深入探索Android启动速度优化/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="JsonChao" />
            
              <p class="site-author-name" itemprop="name">JsonChao</p>
              <p class="site-description motion-element" itemprop="description">Persist + Plan = Growing</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JsonChao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://mail.google.com/mail/u/0/#inbox" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" title="JueJin">
                      
                        <i class="fa fa-fw fa-globe"></i>JueJin</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Manito Link
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wanandroid.com/" title="WanAndroid" target="_blank">WanAndroid</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://hencoder.com/" title="HenCoder" target="_blank">HenCoder</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://stormzhang.com/" title="stromzhang" target="_blank">stromzhang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.hensen.site/" title="Hensen" target="_blank">Hensen</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://liuwangshu.cn/" title="刘望舒" target="_blank">刘望舒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhuanlan.zhihu.com/baron/" title="张磊" target="_blank">张磊</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kymjs.com/" title="张涛" target="_blank">张涛</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.piasy.com/" title="Piasy" target="_blank">Piasy</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.lmj.wiki/" title="ANLY" target="_blank">ANLY</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://glanwang.com/" title="Glan" target="_blank">Glan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://huangjunbin.com/" title="黄俊彬" target="_blank">黄俊彬</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://droidyue.com/" title="技术小黑屋" target="_blank">技术小黑屋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://gityuan.com/" title="gityuan" target="_blank">gityuan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.gcssloop.com/#blog" title="gcsslop" target="_blank">gcsslop</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><span class="nav-number">1.0.1.</span> <span class="nav-text">成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一、Android内存管理机制"><span class="nav-number">1.1.</span> <span class="nav-text">一、Android内存管理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1、Java对象生命周期"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1、Java对象生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Created（创建）"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1、Created（创建）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、InUse（应用）"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2、InUse（应用）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Invisible（不可见）"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">3、Invisible（不可见）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Unreachable（不可达）"><span class="nav-number">1.1.1.4.</span> <span class="nav-text">4、Unreachable（不可达）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、Collected（收集）"><span class="nav-number">1.1.1.5.</span> <span class="nav-text">5、Collected（收集）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、Finalized（终结）"><span class="nav-number">1.1.1.6.</span> <span class="nav-text">6、Finalized（终结）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、Deallocated（对象空间重新分配）"><span class="nav-number">1.1.1.7.</span> <span class="nav-text">7、Deallocated（对象空间重新分配）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意："><span class="nav-number">1.1.1.8.</span> <span class="nav-text">注意：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-内存分配"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Dalvik"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Dalvik</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ART"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">ART</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3、内存回收机制"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3、内存回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Young-Generation"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1、Young Generation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Old-Generation"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">2、Old Generation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Permanent-Generation"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">3、Permanent Generation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#总结：内存对象的处理过程如下："><span class="nav-number">1.1.3.4.</span> <span class="nav-text">总结：内存对象的处理过程如下：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、Young-Generation-GC"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">4、Young Generation GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、Old-Generation-GC"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">5、Old Generation GC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4、GC类型"><span class="nav-number">1.2.</span> <span class="nav-text">1.4、GC类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、优化内存的意义"><span class="nav-number">1.3.</span> <span class="nav-text">二、优化内存的意义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、避免内存泄漏"><span class="nav-number">1.4.</span> <span class="nav-text">三、避免内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-内存泄漏定义"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 内存泄漏定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-使用MAT来查找内存泄漏"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.2 使用MAT来查找内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-1-使用步骤"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">3.2.1 使用步骤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-2-MAT视图"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">3.2.2 MAT视图</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-查找内存泄漏具体位置"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">3.2.3 查找内存泄漏具体位置</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-常见内存泄漏场景"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.3 常见内存泄漏场景</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、资源性对象未关闭"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">1、资源性对象未关闭</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、注册对象未注销"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">2、注册对象未注销</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、类的静态变量持有大数据对象"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">3、类的静态变量持有大数据对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、非静态内部类的静态实例"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">4、非静态内部类的静态实例</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、Handler临时性内存泄漏"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">5、Handler临时性内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、容器中的对象没清理造成的内存泄漏"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">6、容器中的对象没清理造成的内存泄漏</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、WebView"><span class="nav-number">1.4.3.7.</span> <span class="nav-text">7、WebView</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-内存泄漏监控"><span class="nav-number">1.4.4.</span> <span class="nav-text">3.4 内存泄漏监控</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#四、优化内存空间"><span class="nav-number">1.5.</span> <span class="nav-text">四、优化内存空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-对象引用"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1 对象引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、强引用"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">1、强引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、软引用"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">2、软引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、弱引用"><span class="nav-number">1.5.1.3.</span> <span class="nav-text">3、弱引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、虚引用"><span class="nav-number">1.5.1.4.</span> <span class="nav-text">4、虚引用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-减少不必要的内存开销"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2 减少不必要的内存开销</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、AutoBoxing"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">1、AutoBoxing</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、内存复用"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">2、内存复用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-使用最优的数据类型的"><span class="nav-number">1.5.3.</span> <span class="nav-text">4.3 使用最优的数据类型的</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、HashMap与ArrayMap"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">1、HashMap与ArrayMap</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、枚举类型"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">2、枚举类型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、LruCache"><span class="nav-number">1.5.3.3.</span> <span class="nav-text">3、LruCache</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、图片内存优化"><span class="nav-number">1.5.3.4.</span> <span class="nav-text">4、图片内存优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、inBitmap"><span class="nav-number">1.5.3.5.</span> <span class="nav-text">4、inBitmap</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五、图片管理模块设计与实现"><span class="nav-number">1.6.</span> <span class="nav-text">五、图片管理模块设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-实现异步加载功能"><span class="nav-number">1.6.1.</span> <span class="nav-text">5.1 实现异步加载功能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-实现网络图片显示"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">1.实现网络图片显示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-单个图片内存优化"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">2 单个图片内存优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-实现三级缓存"><span class="nav-number">1.6.2.</span> <span class="nav-text">5.2 实现三级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、内存缓存"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">1、内存缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、bitmap内存复用"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">2、bitmap内存复用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、磁盘缓存"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">3、磁盘缓存</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-图片加载三方库"><span class="nav-number">1.6.3.</span> <span class="nav-text">5.3 图片加载三方库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、内存优化"><span class="nav-number">1.6.4.</span> <span class="nav-text">六、内存优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1、常见的内存泄漏案例-完善3-3小节）："><span class="nav-number">1.6.4.1.</span> <span class="nav-text">6.1、常见的内存泄漏案例(完善3.3小节）：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2、常见的内存优化点："><span class="nav-number">1.6.4.2.</span> <span class="nav-text">6.2、常见的内存优化点：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#七、总结"><span class="nav-number">1.7.</span> <span class="nav-text">七、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#参考链接："><span class="nav-number">1.7.0.1.</span> <span class="nav-text">参考链接：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><span class="nav-number">1.7.1.</span> <span class="nav-text">很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。"><span class="nav-number">1.7.2.</span> <span class="nav-text">希望我们能成为朋友，在 Github、掘金上一起分享知识。</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JsonChao</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>







        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  
    

    
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2155025"></script>
      <!-- UY END -->
    
  





  










   
   
     
   
   
  
     
</div>
<!-- City版安装代码已完成 -->
   
 

   
     
   
  
       <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
       <script type="text/javascript">
          (function(d, s) {
              var j, e = d.getElementsByTagName(s)[0];
              if (typeof LivereTower === 'function') { return; }
              j = d.createElement(s);
              j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
              j.async = true;
              e.parentNode.insertBefore(j, e);
          })(document, 'script');
       </script>
       <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
       <!-- UY END -->
   
 
  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("2wtHdVd6zid7kU6YQKIqsHU5-gzGzoHsz", "eLibBRhSAsSoX1JbTMJH6ka3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
