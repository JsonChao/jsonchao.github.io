<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="性能优化," />





  <link rel="alternate" href="/rss2.xml" title="Deep into Android" type="application/atom+xml" />






<meta name="description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。我们都知道，造成绘制不流畅最大的罪魁祸首就是卡顿，而卡顿的主要场景有很多，按场景可以分成4类：UI绘制、应用启动、页面跳转、事件响应，其中又可细分为如下： UI 绘制 刷新  启动 安装启动 冷启动 热启动  跳转 页面间跳转 前后台切换  响应 按键 系统事件 滑动  造成其根本原因可以分为">
<meta name="keywords" content="性能优化">
<meta property="og:type" content="article">
<meta property="og:title" content="Android性能优化之绘制优化">
<meta property="og:url" content="http://yoursite.com/2019/07/28/Android性能优化之绘制优化/index.html">
<meta property="og:site_name" content="Deep into Android">
<meta property="og:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。我们都知道，造成绘制不流畅最大的罪魁祸首就是卡顿，而卡顿的主要场景有很多，按场景可以分成4类：UI绘制、应用启动、页面跳转、事件响应，其中又可细分为如下： UI 绘制 刷新  启动 安装启动 冷启动 热启动  跳转 页面间跳转 前后台切换  响应 按键 系统事件 滑动  造成其根本原因可以分为">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-07-28T10:08:02.403Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android性能优化之绘制优化">
<meta name="twitter:description" content="前言成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。我们都知道，造成绘制不流畅最大的罪魁祸首就是卡顿，而卡顿的主要场景有很多，按场景可以分成4类：UI绘制、应用启动、页面跳转、事件响应，其中又可细分为如下： UI 绘制 刷新  启动 安装启动 冷启动 热启动  跳转 页面间跳转 前后台切换  响应 按键 系统事件 滑动  造成其根本原因可以分为">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '2JGM8QNUKR',
      apiKey: 'ad3d08277d479825f7ef759beadbce0d',
      indexName: 'dicovery',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/07/28/Android性能优化之绘制优化/"/>





  <title>Android性能优化之绘制优化 | Deep into Android</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Deep into Android</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/28/Android性能优化之绘制优化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JsonChao">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Deep into Android">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Android性能优化之绘制优化</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-28T18:07:00+08:00">
                2019-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2019/07/28/Android性能优化之绘制优化/" class="leancloud_visitors" data-flag-title="Android性能优化之绘制优化">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><a href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。" class="headerlink" title="成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。"></a>成为一名优秀的Android开发，需要一份完备的<a href="https://github.com/JsonChao/Awesome-Android-Exercise" target="_blank" rel="external">知识体系</a>，在这里，让我们一起成长为自己所想的那样~。</h4><p>我们都知道，造成绘制不流畅最大的罪魁祸首就是卡顿，而卡顿的主要场景有很多，按场景可以分成4类：UI绘制、应用启动、页面跳转、事件响应，其中又可细分为如下：</p>
<h5 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h5><ul>
<li>绘制</li>
<li>刷新</li>
</ul>
<h5 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h5><ul>
<li>安装启动</li>
<li>冷启动</li>
<li>热启动</li>
</ul>
<h5 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h5><ul>
<li>页面间跳转</li>
<li>前后台切换</li>
</ul>
<h5 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h5><ul>
<li>按键</li>
<li>系统事件</li>
<li>滑动</li>
</ul>
<p>造成其根本原因可以分为两大类：</p>
<h5 id="界面绘制"><a href="#界面绘制" class="headerlink" title="界面绘制"></a>界面绘制</h5><ul>
<li>绘制层级深</li>
<li>页面复杂</li>
<li>刷新不合理</li>
</ul>
<h5 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h5><ul>
<li>数据处理在UI线程</li>
<li>占用CPU高，导致主线程拿不到时间片</li>
<li>内存增加导致GC频繁，从而引起卡顿</li>
</ul>
<h3 id="一、Android系统显示原理"><a href="#一、Android系统显示原理" class="headerlink" title="一、Android系统显示原理"></a>一、Android系统显示原理</h3><p>Android的显示过程可以简单概括为：Android应用程序把经过测量、布局、绘制后的surface缓存数据、通过SurfaceFlinger把数据渲染到显示屏幕上，通过Android的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕。</p>
<h4 id="1-1、绘制原理"><a href="#1-1、绘制原理" class="headerlink" title="1.1、绘制原理"></a>1.1、绘制原理</h4><h5 id="1、应用层"><a href="#1、应用层" class="headerlink" title="1、应用层"></a>1、应用层</h5><p>在Android的每个View都会经过Measure和Layout来确定当前需要绘制的View所在的大小和位置，通过绘制到surface，在Android系统中整体的绘制源码是在ViewRootImpl类的performTraversals()方法，通过这个方法可以看出Measure和Layout都是递归来获取View的大小和位置，并且以深度作为优先级。显然，层级越深，元素越多，耗时就越长。</p>
<p>对于绘制，Android支持两种绘制方式：</p>
<ul>
<li>软件绘制（CPU）</li>
<li>硬件绘制（GPU）</li>
</ul>
<p>硬件加速从Android 3.0开始支持，它在UI显示和绘制效率方面远高于软件绘制。但它的局限如下：</p>
<ul>
<li>耗电：GPU功耗高于CPU。</li>
<li>兼容性：不兼容某些接口和函数。</li>
<li>内存大：使用OpenGL的接口需要占用内存8MB。</li>
</ul>
<h5 id="2、系统层"><a href="#2、系统层" class="headerlink" title="2、系统层"></a>2、系统层</h5><p>将数据渲染到屏幕上是通过系统级进程中的SurfaceFlinger服务来实现的，它的主要工作流程如下：</p>
<ul>
<li>1、响应客户端事件，创建Layer与客户端的Surface建立连接。</li>
<li>2、接收客户端数据和属性，修改Layer属性，如尺寸、颜色、透明度等。</li>
<li>3、将创建的Layer内容刷新到屏幕上。</li>
<li>4、维持Layer的序列，并对Layer最终输出做出裁剪计算。</li>
</ul>
<p>其中，SurfaceFlinger系统进程和应用进程使用了匿名共享内存SharedClient，并且，每一个应用和SurfaceFlinger之间都会创建一个SharedClient，并且，每个SharedClient中，最多可以创建31个SharedBufferStack，每一个SharedBufferStack对应一个Surface，即一个window。（其中包含了两个（小于4.1版本）或者三个（4.1及以上版本）缓冲区）</p>
<p>因此，从上可知，一个Android应用程序最多可以包含31个窗口。最后，显示的整体流程如下：</p>
<ul>
<li>应用层绘制到缓冲区</li>
<li>SurfaceFlinger把缓冲区数据渲染到屏幕，其中使用了Android匿名共享内存SharedClient缓存需要显示的数据来达到目的。</li>
</ul>
<p>绘制的过程首先是CPU准备数据，通过Driver层把数据交给CPU渲染，其中CPU主要负责Measure、Layout、Record、Execute的数据计算工作，GPU负责Rasterization（栅格化）、渲染。因为图形API不允许CPU直接和GPU通信，所以要通过一个图形驱动的中间层来进行连接。图形驱动里面维护了一个队列，CPU把display list（待显示的数据列表）添加到队列中，GPU从这个队列中取出数据进行绘制，最终才在显示屏上显示出来。</p>
<p>Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅的画面所需的60FPS。</p>
<h4 id="1-2-刷新机制"><a href="#1-2-刷新机制" class="headerlink" title="1.2 刷新机制"></a>1.2 刷新机制</h4><p>4.1版本的Project Butter对Android Display系统进行了重构，引入了三个核心元素：VSYNC（Vertical Synchronization）、Triple Buffer、Choreographer。其中作为Project Buffer核心的VSYNC，即垂直同步可认为是一种定时中断。而Choreographer起调度的作用，将绘制工作统一到VSYNC的某个时间点上，使应用的绘制工作有序。</p>
<h5 id="为什么要推出Project-Butter？"><a href="#为什么要推出Project-Butter？" class="headerlink" title="为什么要推出Project Butter？"></a>为什么要推出Project Butter？</h5><p>解决刷新不同步的问题。</p>
<h5 id="为什么要使用双缓冲技术？"><a href="#为什么要使用双缓冲技术？" class="headerlink" title="为什么要使用双缓冲技术？"></a>为什么要使用双缓冲技术？</h5><p>在Linux上通常使用Framebuffer来做显示输出，当用户进程更新Framebuffer中的数据后，显示驱动会把FrameBuffer中每个像素点的值更新到屏幕，但是如果上一帧数据还没显示完，Framebuffer中的数据又更新了，就会带来残影的问题，用户会觉得有闪烁感，所以采用了双缓冲技术。</p>
<h5 id="双缓冲的含义？"><a href="#双缓冲的含义？" class="headerlink" title="双缓冲的含义？"></a>双缓冲的含义？</h5><p>双缓冲意味着要使用两个缓冲区（在上文提及的SharedBufferStack中），其中一个称为Front Buffer，另一个称为Back Buffer。UI总是先在Back Buffer中绘制，然后再和Front Buffer交换，渲染到显示设备中。即只有当另一个buffer的数据准备好后，通过io_ctl来通知显示设备切换Buffer。</p>
<h5 id="Choreographer的作用是什么？"><a href="#Choreographer的作用是什么？" class="headerlink" title="Choreographer的作用是什么？"></a>Choreographer的作用是什么？</h5><p>当收到VSYNC信号时，调用用户设置的回调函数。回调类型的优先级从高到低为CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL。</p>
<h5 id="当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？"><a href="#当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？" class="headerlink" title="当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？"></a>当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？</h5><p>因为只有两个Buffer；所以4.1版本后，出现了第三个缓冲区：Triple Buffer。它利用CPU/GPU的空闲等待时间提前准备好数据，并不一定会使用。</p>
<p><strong>注意</strong>：除非必要，大部分情况下只是用到双缓冲。而且，缓冲区并不是越多越好，要做到平衡到最佳效果。</p>
<h5 id="Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？"><a href="#Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？" class="headerlink" title="Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？"></a>Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？</h5><p>因为VSync 中断处理的线程优先级一定要最高，否则即使接收到VSync中断，不能及时处理，也是徒劳无功。</p>
<h4 id="1-3、卡顿的根本原因"><a href="#1-3、卡顿的根本原因" class="headerlink" title="1.3、卡顿的根本原因"></a>1.3、卡顿的根本原因</h4><ul>
<li>绘制任务太重、绘制一帧内容耗时太长。</li>
<li>主线程太忙，导致VSync信号来时还没有准备好数据导致丢帧。</li>
</ul>
<h3 id="二、性能分析工具"><a href="#二、性能分析工具" class="headerlink" title="二、性能分析工具"></a>二、性能分析工具</h3><p>Android常用的性能优化工具一般有如下几种：</p>
<ul>
<li>Hierarchy View：查看Layout层次</li>
<li>Android Studio自带的Profile工具</li>
<li>静态代码检查工具Lint</li>
<li>TraceView</li>
<li>Systrace</li>
</ul>
<h4 id="2-1、卡顿检测工具Profile-GPU-Rendering"><a href="#2-1、卡顿检测工具Profile-GPU-Rendering" class="headerlink" title="2.1、卡顿检测工具Profile GPU Rendering"></a>2.1、卡顿检测工具Profile GPU Rendering</h4><p>它是Android手机上自带的一个辅助工具，打开Profile GPU Rendering后可以看到实时刷新的彩色图，其中每一根竖线表示一帧，由多个颜色组成，不同颜色的解释如下：</p>
<ul>
<li>每一条柱状图都由红、黄、蓝、紫组成，分别对应每一帧在不同阶段的实际耗时。</li>
<li>蓝色：测量绘制的时间，需要多长时间去创建和更新DisplayList。在蓝色的线很高时，有可能是因为需要重新绘制，或者自定义视图的onDraw函数处理事情太多。</li>
<li>红色：Android进行2D渲染Display List的执行的时间。当红色的线非常高时，可能是由于重新提交了视图导致的。</li>
<li>橙色：处理时间或CPU告诉GPU渲染一帧的地方，如果柱状图很高，就意味着GPU太繁忙了。</li>
<li>紫色：将资源转移到渲染线程的时间。（4.0版本以上提供）</li>
</ul>
<p>并且，从Android M开始变成了渲染八步骤：</p>
<h5 id="1、橙色-Swap-Buffers"><a href="#1、橙色-Swap-Buffers" class="headerlink" title="1、橙色-Swap Buffers"></a>1、橙色-Swap Buffers</h5><p>表示GPU处理任务的时间。</p>
<h5 id="2、红色-Command-Issue"><a href="#2、红色-Command-Issue" class="headerlink" title="2、红色-Command Issue"></a>2、红色-Command Issue</h5><p>进行2D渲染显示列表的时间，越高表示需要绘制的视图越多。</p>
<h5 id="3、浅蓝-Sync-amp-Upload"><a href="#3、浅蓝-Sync-amp-Upload" class="headerlink" title="3、浅蓝-Sync&amp;Upload"></a>3、浅蓝-Sync&amp;Upload</h5><p>准备有待绘制的图片所耗费的时间，越高表示图片数量越多或图片越大。</p>
<h5 id="4、深蓝-Draw"><a href="#4、深蓝-Draw" class="headerlink" title="4、深蓝-Draw"></a>4、深蓝-Draw</h5><p>测量和绘制视图所需的时间，越高表示视图越多或onDraw方法有耗时操作。</p>
<h5 id="5、一级绿-Measure-Layout"><a href="#5、一级绿-Measure-Layout" class="headerlink" title="5、一级绿-Measure/Layout"></a>5、一级绿-Measure/Layout</h5><p>onMeasure与onLayout所花费的时间。</p>
<h5 id="6、二级绿-Animation"><a href="#6、二级绿-Animation" class="headerlink" title="6、二级绿-Animation"></a>6、二级绿-Animation</h5><p>执行动画所需要花费的时间。越高表示使用了非官方动画工具或执行中有读写操作。</p>
<h5 id="7、三级绿-Input-Handling"><a href="#7、三级绿-Input-Handling" class="headerlink" title="7、三级绿-Input Handling"></a>7、三级绿-Input Handling</h5><p>系统处理输入事件所耗费的时间。</p>
<h5 id="8、四级绿-Misc-Time-Vsync-Delay"><a href="#8、四级绿-Misc-Time-Vsync-Delay" class="headerlink" title="8、四级绿-Misc Time/Vsync Delay"></a>8、四级绿-Misc Time/Vsync Delay</h5><p>主线程执行了太多任务，导致UI渲染跟不上vSync的信号而出现掉帧。</p>
<p>此外，可通过如下adb命令将具体的耗时输出到日志中来分析：</p>
<pre><code>adb shell dumpsys gfxinfo com.**.** 
</code></pre><h4 id="2-2、TraceView"><a href="#2-2、TraceView" class="headerlink" title="2.2、TraceView"></a>2.2、TraceView</h4><p>它主要用来分析函数的调用过程，可以对Android的应用程序以及Framework层代码进行性能分析。</p>
<p>使用TraceView查看耗时，主要关注Calls + Recur Calls / Total和（该方法调用次数+递归次数）和Cpu Time / Call（该方法耗时）这两个值，然后优化这些方法的逻辑和调用次数，减少耗时。</p>
<p><strong>注意</strong>：RealTime（实际时长）的实际执行时间要比CPU Time要长，因为它包括了CPU的上下文切换、阻塞、GC等。</p>
<h5 id="2-3、Systrace-UI性能分析"><a href="#2-3、Systrace-UI性能分析" class="headerlink" title="2.3、Systrace UI性能分析"></a>2.3、Systrace UI性能分析</h5><p>Systrace是Android 4.1及以上版本提供的性能数据采样和分析工具，它的作用有：</p>
<ul>
<li>收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务、View系统等）的运行信息，这样可以更直观地分析系统瓶颈，改进性能。</li>
<li>跟踪系统的I/0操作、内核工作队列、CPU负载等，在UI显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡等问题上。</li>
</ul>
<p><strong>注意：Systrace是以系统的角度返回一些信息，并不能定位到具体耗时的方法，建议使用TraceView。</strong></p>
<h5 id="1、Systrace使用方法"><a href="#1、Systrace使用方法" class="headerlink" title="1、Systrace使用方法"></a>1、Systrace使用方法</h5><p>使用事项如下：</p>
<ul>
<li>支持4.1版本及以上。</li>
<li>4.3以前的系统版本需要打开Setting&gt;Developer options&gt;Monitoring&gt;Enable traces。</li>
</ul>
<p>一般我们使用命令行来得到输出的html表单，在4.3版本及以上可以省略设置跟踪类别标签来获取默认值。命令如下：</p>
<pre><code>cd android-sdk/platform-tools/systrace
python systrace.py --time=10 -o mynewtrace.html sched gfx view wm
</code></pre><p>其中，常用的几个参数命令如下：</p>
<ul>
<li>-o <file>：保存的文件名。</file></li>
<li>-t N, –time=N：多少秒内的数据，默认为5s，以当前时间点往后倒N秒时间。</li>
</ul>
<p>其余标签用法请<a href="http://developer.android.com/intl/zh-cn/tools/help/systrace.html" target="_blank" rel="external">参见此处</a>。</p>
<p>此外，我们可以使用代码插桩的方式，在Android 4.3及以上版本可以使用Trace类的Trace.beginSection()与Trace.endSection()方法来进行追踪。其中需要注意：</p>
<ul>
<li>保证beginSection和endSection的调用次数要匹配。</li>
<li>Trace的begin与end必须在同一线程中执行。</li>
</ul>
<h5 id="2、分析Systrace报告"><a href="#2、分析Systrace报告" class="headerlink" title="2、分析Systrace报告"></a>2、分析Systrace报告</h5><p>使用Chrome打开文件后，其中和UI绘制关系最密切的是Alerts和Frame两个数据：</p>
<ul>
<li>Alerts：标记了性能有问题的点，单击该点可以查看详细信息，右侧的Alerts框还可以看到每个类型的Alerts的数量。</li>
<li>Frame：每个应用都有一行专门显示frame，每一帧就显示为一个绿色的圆圈。当显示为黄色或者红色时，它的渲染时间超过了16.6ms。</li>
</ul>
<p>这里，列出Systrace有用的快捷键：</p>
<ul>
<li>W：放大</li>
<li>S：缩小</li>
<li>A：左移</li>
<li>D：右移</li>
</ul>
<h4 id="三、布局优化"><a href="#三、布局优化" class="headerlink" title="三、布局优化"></a>三、布局优化</h4><h5 id="3-1、布局优化方法"><a href="#3-1、布局优化方法" class="headerlink" title="3.1、布局优化方法"></a>3.1、布局优化方法</h5><h5 id="1、减少层级"><a href="#1、减少层级" class="headerlink" title="1、减少层级"></a>1、减少层级</h5><ul>
<li>合理使用RelativeLayout和LinearLayout。</li>
<li>合理使用Merge。</li>
</ul>
<p>RelativeLayout也存在性能低的问题，原因是RelativeLayout会对子View做两次测量。但如果在LinearLayout中有weight属性，也需要进行两次测量，因为没有更多的依赖关系，所以仍然会比RelativeLayout的效率高。</p>
<p><strong>注意：由于Android的碎片化程度很高，所以使用RelativeLayout能使构建的布局适应性更强。</strong></p>
<p>merge的原理：在Android布局的源码中，如果是Merge标签，那么直接将其中的子元素添加到Merge标签Parent中。</p>
<p>注意：</p>
<ul>
<li>Merge只能用在布局XML文件的根元素。</li>
<li>使用merge来加载一个布局时，必须指定一个ViewGroup作为其父元素，并且要设置加载的attachToRoot参数为true。</li>
<li>不能在ViewStub中使用Merge标签。原因就是ViewStub的inflate方法中根本没有attachToRoot的设置。</li>
</ul>
<h5 id="2、提供显示速度"><a href="#2、提供显示速度" class="headerlink" title="2、提供显示速度"></a>2、提供显示速度</h5><p>ViewStub是一个轻量级的View，它是一个看不见的，并且不占布局位置，占用资源非常小的视图对象。可以为ViewStub指定一个布局，加载布局时，只有ViewStub会被初始化，然后当ViewStub被设置为可见时，或是调用了ViewStub.inflate()时，ViewStub所指向的布局会被加载和实例化，然后ViewStub的布局属性都会传给它指向的布局。</p>
<p>注意：</p>
<ul>
<li>ViewStub只能加载一次，之后ViewStub对象会被置为空。所以它不适用于需要按需显示隐藏的情况。</li>
<li>ViewStub只能用来加载一个布局文件，而不是某个具体的View。</li>
<li>ViewStub中不能嵌套Merge标签。</li>
</ul>
<h5 id="3、布局复用"><a href="#3、布局复用" class="headerlink" title="3、布局复用"></a>3、布局复用</h5><p>Android的布局复用可以通过<include>标签来实现。</include></p>
<p>一些优化总结：</p>
<ul>
<li>使用<viewstub>标签加载一些不常用的布局。</viewstub></li>
<li>尽可能少用wrap_content，wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content。</li>
<li>使用TextView替换RL、LL。</li>
<li>使用低端机进行优化，以发现性能瓶颈。</li>
<li>使用TextView的行间距替换多行文本：lineSpacingExtra/lineSpacingMultiplier。</li>
<li>使用Spannable/Html.fromHtml替换多种不同规格文字。</li>
<li>尽可能使用LinearLayout自带的分割线。</li>
<li>使用Space添加间距。</li>
<li>多利用lint + alibaba规约修复问题点。</li>
<li>嵌套层级过多可以考虑使用约束布局。</li>
</ul>
<h4 id="四、避免过度绘制"><a href="#四、避免过度绘制" class="headerlink" title="四、避免过度绘制"></a>四、避免过度绘制</h4><p>导致过度绘制的主要原因是：</p>
<ul>
<li>XML布局：控件有重叠且都有设置背景。</li>
<li>View自绘：View.OnDraw里面同一个区域被绘制多次。</li>
</ul>
<h5 id="4-1、过度绘制检测工具"><a href="#4-1、过度绘制检测工具" class="headerlink" title="4.1、过度绘制检测工具"></a>4.1、过度绘制检测工具</h5><p>打开手机开发者选项中的Show GPU Overdraw选项，会有不同的颜色来表示过度绘制次数，依次是无、蓝、绿、淡红、深红，分别对应0-4次过度绘制。</p>
<h5 id="4-2、如何避免过度绘制"><a href="#4-2、如何避免过度绘制" class="headerlink" title="4.2、如何避免过度绘制"></a>4.2、如何避免过度绘制</h5><h5 id="1、布局上的优化"><a href="#1、布局上的优化" class="headerlink" title="1、布局上的优化"></a>1、布局上的优化</h5><ul>
<li>移除XML中非必需的背景，或根据条件设置。</li>
<li>有选择性地移除窗口背景：getWindow().setBackgroundDrawable(null)。</li>
<li>按需显示占位背景图片。</li>
</ul>
<p>比如：在获取Avatar的图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到时，才设置对应的Background占位图片。</p>
<h5 id="2、自定义View优化"><a href="#2、自定义View优化" class="headerlink" title="2、自定义View优化"></a>2、自定义View优化</h5><p>通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制。并且，它还可以节约CPU和GPU资源，在clipRect区域之外的绘制指令都不会被执行。</p>
<p>在绘制一个单元之前，首先判断该单元的区域是否在Canvas的剪切域内。若不在，直接返回，避免CPU和GPU的计算和渲染工作。</p>
<h4 id="五、启动优化"><a href="#五、启动优化" class="headerlink" title="五、启动优化"></a>五、启动优化</h4><h5 id="5-1、应用启动流程"><a href="#5-1、应用启动流程" class="headerlink" title="5.1、应用启动流程"></a>5.1、应用启动流程</h5><p>应用的启动流程即为从点击图标到用户可操作的全部过程。它的意义就是为了避免用户一安装应用就卸载。</p>
<p>启动分为两种类型：</p>
<ul>
<li>冷启动：系统会重新创建一个新的进程分配给它。</li>
<li>热启动：因为会从已有的进程中启动，所以它不会再创建和初识Application。</li>
</ul>
<p>具体又可分为如下过程：</p>
<h5 id="冷启动前"><a href="#冷启动前" class="headerlink" title="冷启动前"></a>冷启动前</h5><ul>
<li>1、点击相应应用图标。</li>
<li>2、App启动之后立即展示一个空白的Window（预览窗口显示）。</li>
<li>3、创建App进程。</li>
</ul>
<h5 id="冷启动后"><a href="#冷启动后" class="headerlink" title="冷启动后"></a>冷启动后</h5><ul>
<li>1、创建App对象。</li>
<li>2、启动Main Thread。</li>
<li>3、创建启动的Activity对象，闪屏显示。</li>
<li>4、创建启动的MainActivity对象，主页显示。</li>
<li>5、其它工作。</li>
</ul>
<h5 id="5-2、启动耗时监测"><a href="#5-2、启动耗时监测" class="headerlink" title="5.2、启动耗时监测"></a>5.2、启动耗时监测</h5><h5 id="1、adb-shell-am"><a href="#1、adb-shell-am" class="headerlink" title="1、adb shell am"></a>1、adb shell am</h5><p>使用adb shell获取应用真实的启动时间：</p>
<pre><code>adb shell am start -W [packageName]/[packageName.AppstartActivity]
</code></pre><p>执行后会得到三个时间：ThisTime、TotalTime和WaitTime，一般查看得到的TotalTime，即应用的启动时间，包括创建进程+Application初始化+Activity初始化到界面显示。</p>
<h5 id="2、代码打点"><a href="#2、代码打点" class="headerlink" title="2、代码打点"></a>2、代码打点</h5><p>可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：</p>
<ul>
<li>在上传数据到服务器时建议根据用户ID的尾号来抽样上报。</li>
<li>在项目中核心基类的关键回调函数和核心方法中加入打点。</li>
</ul>
<p>代码如下：</p>
<pre><code>/**
* 耗时监视器对象，记录整个过程的耗时情况，可以用在很多需要统计的地方，比如Activity的启动耗时和Fragment的启动耗时。
*/
public class TimeMonitor {

    private final String TAG = TimeMonitor.class.getSimpleName();
    private int mMonitorId = -1;

    // 保存一个耗时统计模块的各种耗时，tag对应某一个阶段的时间
    private HashMap&lt;String, Long&gt; mTimeTag = new HashMap&lt;&gt;();
    private long mStartTime = 0;

    public TimeMonitor(int mMonitorId) {
        Log.d(TAG, &quot;init TimeMonitor id: &quot; + mMonitorId);
        this.mMonitorId = mMonitorId;
    }

    public int getMonitorId() {
        return mMonitorId;
    }

    public void startMonitor() {
        // 每次重新启动都把前面的数据清除，避免统计错误的数据
        if (mTimeTag.size() &gt; 0) {
        mTimeTag.clear();
        }
        mStartTime = System.currentTimeMillis();
    }

    /**
    * 每打一次点，记录某个tag的耗时
    */
    public void recordingTimeTag(String tag) {
        // 若保存过相同的tag，先清除
        if (mTimeTag.get(tag) != null) {
            mTimeTag.remove(tag);
        }
        long time = System.currentTimeMillis() - mStartTime;
        Log.d(TAG, tag + &quot;: &quot; + time);
        mTimeTag.put(tag, time);
    }

    public void end(String tag, boolean writeLog) {
        recordingTimeTag(tag);
        end(writeLog);
    }

    public void end(boolean writeLog) {
        if (writeLog) {
            //写入到本地文件
        }
    }

    public HashMap&lt;String, Long&gt; getTimeTags() {
        return mTimeTag;
    }
}
</code></pre><p>为了使代码更好管理，定义一个打点配置类：</p>
<pre><code>/**
* 打点配置类，用于统计各阶段的耗时，便于代码的维护和管理。
*/
public final class TimeMonitorConfig {

    // 应用启动耗时
    public static final int TIME_MONITOR_ID_APPLICATION_START = 1;
}
</code></pre><p>因为，耗时统计可能会在多个模块和类中需要打点，所以需要一个单例类来管理各个耗时统计的数据：</p>
<pre><code>/**
* 采用单例管理各个耗时统计的数据。
*/
public class TimeMonitorManager {

    private static TimeMonitorManager mTimeMonitorManager = null;
private HashMap&lt;Integer, TimeMonitor&gt; mTimeMonitorMap = null;

    public synchronized static TimeMonitorManager getInstance() {
        if (mTimeMonitorManager == null) {
            mTimeMonitorManager = new TimeMonitorManager();
        }
        return mTimeMonitorManager;
    }

    public TimeMonitorManager() {
        this.mTimeMonitorMap = new HashMap&lt;Integer, TimeMonitor&gt;();
    }

    /**
     * 初始化打点模块
    */
    public void resetTimeMonitor(int id) {
        if (mTimeMonitorMap.get(id) != null) {
            mTimeMonitorMap.remove(id);
        }
        getTimeMonitor(id);
    }

    /**
    * 获取打点器
    */
    public TimeMonitor getTimeMonitor(int id) {
        TimeMonitor monitor = mTimeMonitorMap.get(id);
        if (monitor == null) {
            monitor = new TimeMonitor(id);
            mTimeMonitorMap.put(id, monitor);
        }
        return monitor;
    }
}
</code></pre><p>主要在以下几个方面需要打点：</p>
<ul>
<li>应用程序的生命周期节点。</li>
<li>启动时需要初始化的重要方法，如数据库初始化，读取本地的一些数据。</li>
<li>其他耗时的一些算法。</li>
</ul>
<p>例如，启动时在Application和第一个Activity加入打点统计：</p>
<p><strong>Application：</strong></p>
<pre><code>@Override
protected void attachBaseContext(Context base) {
    super.attachBaseContext(base);
    TimeMonitorManager.getInstance().resetTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START);
}

@Override
public void onCreate() {
    super.onCreate();
    SoLoader.init(this, /* native exopackage */ false);
    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;Application-onCreate&quot;);
}
</code></pre><p><strong>第一个Activity：</strong></p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;SplashActivity-onCreate&quot;);
    super.onCreate(savedInstanceState);

    initData();

    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).recordingTimeTag(&quot;SplashActivity-onCreate-Over&quot;);
}

@Override
protected void onStart() {
    super.onStart();
    TimeMonitorManager.getInstance().getTimeMonitor(TimeMonitorConfig.TIME_MONITOR_ID_APPLICATION_START).end(&quot;SplashActivity-onStart&quot;, false);
}
</code></pre><h5 id="5-3-启动速度分析工具"><a href="#5-3-启动速度分析工具" class="headerlink" title="5.3 启动速度分析工具"></a>5.3 启动速度分析工具</h5><p>目标：力求获取准确的数据评估。</p>
<h5 id="1、TraceView"><a href="#1、TraceView" class="headerlink" title="1、TraceView"></a>1、TraceView</h5><p>性能损耗太大，得出的结果并不真实</p>
<h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h5><p>主要做热点分析，得到两种数据：</p>
<ul>
<li>单次执行最耗时的方法。</li>
<li>执行次数最多的方法。</li>
</ul>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><ul>
<li>1、代码中添加：Debug.startMethodTracing()、检测方法、Debug.stopMethodTracing()。</li>
<li>2、打开Profile-&gt;CPU-&gt;点击Record-&gt;点击Stop-&gt;查看Profile下方Top Down/Bottom Up找出耗时的热点方法。</li>
</ul>
<h5 id="2、Systrace-函数插桩"><a href="#2、Systrace-函数插桩" class="headerlink" title="2、Systrace+函数插桩"></a>2、Systrace+函数插桩</h5><h5 id="Systrace原理"><a href="#Systrace原理" class="headerlink" title="Systrace原理"></a>Systrace原理</h5><p>在系统的一些关键链路（如SystemServcie、虚拟机、Binder驱动）插入一些信息（Label），<br>通过Label的开始和结束来确定某个核心过程的执行时间，然后把这些Label信息收集起来得到系统关键路径的运行时间信息，<br>最后得到整个系统的运行性能信息。Android Framework里面一些重要的模块都插入了label信息(Java层通过android.os.Trace类完成，<br>native层通过ATrace宏完成），用户App中可以添加自定义的Lable。</p>
<h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul>
<li>系统版本越高，Android Framework中添加的系统可用Label就越多，能够支持和分析的系统模块也就越多。</li>
<li>必须手动缩小范围，会帮助你加速收敛问题的分析过程，进而快速地定位和解决问题。</li>
</ul>
<h5 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h5><h5 id="1、命令行"><a href="#1、命令行" class="headerlink" title="1、命令行"></a>1、命令行</h5><p>systrace.py -t 10 sched gfx view wm am app webview -a <package-name></package-name></p>
<h5 id="2、代码插桩"><a href="#2、代码插桩" class="headerlink" title="2、代码插桩"></a>2、代码插桩</h5><p>定义Trace静态工厂类i，o封装Trace.begainSection(),Trace.endSection()。</p>
<p>分析App的冷启动过程：在Application类的attachBaseContext调用<code>Trace.beginSection(&quot;Boot Procedure&quot;)</code>，然后在App首页的onWindowFoucusChanged方法<br>或者你认为别的合适的启动结束点调用<code>Trace.endSection</code>就可以到启动过程的信息。</p>
<p>手动开启App自定义Label的Trace功能：通过反射设置setAppTracingAllowed方法为true。</p>
<h5 id="5-4、启动优化方案"><a href="#5-4、启动优化方案" class="headerlink" title="5.4、启动优化方案"></a>5.4、启动优化方案</h5><h5 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h5><h5 id="1、点击图标很久都不响应"><a href="#1、点击图标很久都不响应" class="headerlink" title="1、点击图标很久都不响应"></a>1、点击图标很久都不响应</h5><p>预览窗口被禁用或设置为透明</p>
<h5 id="2、首页显示太慢"><a href="#2、首页显示太慢" class="headerlink" title="2、首页显示太慢"></a>2、首页显示太慢</h5><p>初始化任务太多</p>
<h5 id="3、首页显示后无法操作"><a href="#3、首页显示后无法操作" class="headerlink" title="3、首页显示后无法操作"></a>3、首页显示后无法操作</h5><p>太多任务初始化异步/延迟</p>
<h5 id="优化区域"><a href="#优化区域" class="headerlink" title="优化区域"></a>优化区域</h5><p>Application、Activity创建以及回调等过程</p>
<h5 id="通常手段"><a href="#通常手段" class="headerlink" title="通常手段"></a>通常手段</h5><ul>
<li>利用主题背景防止出现白屏</li>
<li>减少Application的onCreate中所要做的事情</li>
<li>一些不重要的SDK延迟或者异步加载</li>
<li>多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作</li>
<li>部分将要使用到的类异步加载（IntentService）</li>
<li>针对multidex专门做优化（5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了，无需优化）</li>
</ul>
<h5 id="具体优化步骤如下所示："><a href="#具体优化步骤如下所示：" class="headerlink" title="具体优化步骤如下所示："></a>具体优化步骤如下所示：</h5><h5 id="1、主题切换"><a href="#1、主题切换" class="headerlink" title="1、主题切换"></a>1、主题切换</h5><p>使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list）,在启动后，在Activity的onCreate()方法前再setTheme(R.style.AppTheme)</p>
<ul>
<li>优点：简单</li>
<li>缺点：<br>治标不治本，表面上产生一种快的感觉。</li>
</ul>
<p>对于中低端机，总的闪屏时间会更长，建议只在Android6.0/7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验。</p>
<h5 id="2、避免过重的App初始化"><a href="#2、避免过重的App初始化" class="headerlink" title="2、避免过重的App初始化"></a>2、避免过重的App初始化</h5><p>获取所有应用activity堆栈信息</p>
<pre><code>adb shell dumpsys activity
</code></pre><p>adb获取自己的应用activity堆栈信息</p>
<pre><code>adb shell dumpsys activity | grep com.xxx.xxx.xx
</code></pre><p>使用adb命令启动一个Activity</p>
<pre><code>adb shell am start com.growingwiththeweb.example/.MainActivity
</code></pre><p>adb命令统计启动时间</p>
<pre><code>adb shell am start -W com.growingwiththeweb.example/.SplashActivity
</code></pre><ul>
<li>1、分步初始化（优先级高的放前面）</li>
<li>2、异步初始化（如出现主线程要使用时还没初始化则在此次使用前初始化）</li>
<li>3、延迟初始化（利用闪屏页的停留时间进行部分初始化）</li>
</ul>
<h5 id="3、Multidex预加载优化"><a href="#3、Multidex预加载优化" class="headerlink" title="3、Multidex预加载优化"></a>3、Multidex预加载优化</h5><ul>
<li>1、启动时单独开一个进程进行Multidex的第一次加载，即Dex提取和Dexopt操作。</li>
<li>2、此时，主进程在后台等待，优化进程执行完毕后通知主进程继续执行，此时执行到Multidex时，则已经发现提取优化好了Dex，直接执行。</li>
</ul>
<p><strong>注意：判断只有在主进程及SDK 5.0以下才进行Multidex的预加载。</strong></p>
<h5 id="4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）"><a href="#4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）" class="headerlink" title="4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）"></a>4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）</h5><h5 id="5、业务层面优化"><a href="#5、业务层面优化" class="headerlink" title="5、业务层面优化"></a>5、业务层面优化</h5><h4 id="六、合理的刷新机制"><a href="#六、合理的刷新机制" class="headerlink" title="六、合理的刷新机制"></a>六、合理的刷新机制</h4><h5 id="6-1-减少刷新次数"><a href="#6-1-减少刷新次数" class="headerlink" title="6.1 减少刷新次数"></a>6.1 减少刷新次数</h5><ul>
<li>控制刷新频率</li>
<li>避免没有必要的刷新</li>
</ul>
<h5 id="6-2-避免后台线程的影响"><a href="#6-2-避免后台线程的影响" class="headerlink" title="6.2 避免后台线程的影响"></a>6.2 避免后台线程的影响</h5><p>如通过监听ListView的onScrollStateChanged事件，在滚动时暂停图片下载线程工作，结束后再开始，可以提高ListView的滚动平滑度。</p>
<h5 id="6-3-缩小刷新区域"><a href="#6-3-缩小刷新区域" class="headerlink" title="6.3 缩小刷新区域"></a>6.3 缩小刷新区域</h5><p>如自定义View一般采用invalidate方法刷新，可以用以下重载方法刷新要刷新的区域：</p>
<ul>
<li>invalidate(Rect dirty);</li>
<li>invalidate(int left, int top, int right, int bottom);</li>
</ul>
<h4 id="七、提升动画性能"><a href="#七、提升动画性能" class="headerlink" title="七、提升动画性能"></a>七、提升动画性能</h4><p>提升动画性能主要从以下三个纬度着手：</p>
<ul>
<li>流畅度：控制每一帧动画在16m内完成。</li>
<li>内存：避免内存泄漏，减小内存开销。</li>
<li>耗电：减小运算量，优化算法，减小CPU占用。</li>
</ul>
<h5 id="7-1-帧动画"><a href="#7-1-帧动画" class="headerlink" title="7.1 帧动画"></a>7.1 帧动画</h5><p>消耗资源最多，效果最差，能不用就不用。</p>
<h5 id="7-2-补间动画"><a href="#7-2-补间动画" class="headerlink" title="7.2 补间动画"></a>7.2 补间动画</h5><p>使用补间动画实现导致View重绘非常频繁，更新DisplayList的次数过多，且有以下缺点：</p>
<ul>
<li>只能用于View对象。</li>
<li>只有4种动画操作。</li>
<li>只是改变View的显示效果，但是不会真正改变View的属性。</li>
</ul>
<h5 id="7-3-属性动画"><a href="#7-3-属性动画" class="headerlink" title="7.3 属性动画"></a>7.3 属性动画</h5><p>相比于补间动画，属性动画重绘明显会少很多，应优先使用。</p>
<h5 id="7-4-硬件加速"><a href="#7-4-硬件加速" class="headerlink" title="7.4 硬件加速"></a>7.4 硬件加速</h5><h5 id="1、硬件加速原理"><a href="#1、硬件加速原理" class="headerlink" title="1、硬件加速原理"></a>1、硬件加速原理</h5><p>核心类：DisplayList，每一个View对应一个。</p>
<p>在打开硬件渲染后绘制View时，其中执行绘制的draw()方法会把所有绘制命令记录到一个新的显示列表（DisplayList），这个显示列表包含了输出的View层级的绘制代码，但并不是加入到显示列表就立刻执行，当这个ViewTree的DisplayList全都记录完毕后，由OpenGLRender负责将Root View中的DisplayList渲染到屏幕上。而invalidate()方法只是在显示列表中记录和更新显示层级，去标记不需要绘制的View。</p>
<h5 id="2、硬件加速控制级别"><a href="#2、硬件加速控制级别" class="headerlink" title="2、硬件加速控制级别"></a>2、硬件加速控制级别</h5><p>如果应用程序中只使用了标准View或者Drawable，就可以为整个系统打开硬件加速的全局设置。</p>
<h5 id="3、在动画上使用硬件加速"><a href="#3、在动画上使用硬件加速" class="headerlink" title="3、在动画上使用硬件加速"></a>3、在动画上使用硬件加速</h5><p>硬件纹理操作对一个View进行动画绘制，如果不调用invalidate()方法，就可以减少对View自身频繁的重绘。同时Android 3.0的属性动画也减小了重绘，当View通过硬件层返回时，最终所有的层叠画面显示到屏幕，View的属性同时被处理好，因此只要设置这些属性，就可以明显提高绘制的效率，它们不需要View重绘，设置属性后，View会自动刷新。因此，属性动画中绘制的递归次数比补间动画少很多。</p>
<p>在Android 3.0前，使用View的绘制缓冲或Canvas.saveLayer()函数对离屏缓冲进行渲染。Android 3.0后则使用View,.setLayerType(type, paint)方法代替，type可以为以下三种Layer类型之一：</p>
<ul>
<li>LAYER_TYPE_NONE：普通渲染方式，不会返回一个离屏的缓冲，默认值。</li>
<li>LAYER_TYPE_HARDWARE：如果这个应用使用了硬件加速，这个View将会在硬件中渲染为硬件纹理。</li>
<li>LAYER_TYPE_SOFTWARE：此View通过软件渲染为一个Bitmap。</li>
</ul>
<h5 id="设计一个动画的流程如下："><a href="#设计一个动画的流程如下：" class="headerlink" title="设计一个动画的流程如下："></a>设计一个动画的流程如下：</h5><p>1、将要执行动画的View的LayerType设置为LAYER_TYPE_HARDWARE。</p>
<p>2、计算动画View的属性等信息，更新View的属性。</p>
<p>3、若动画结束，将LayerType设置为NONE。</p>
<h5 id="硬件加速需要注意的问题："><a href="#硬件加速需要注意的问题：" class="headerlink" title="硬件加速需要注意的问题："></a>硬件加速需要注意的问题：</h5><ul>
<li>在软件渲染时，可以使用重用Bitmap的方法来节省内存，但是如果开起来硬件加速，这个方案就不起作用。</li>
<li>开启硬件加速的View在前台运行时，需要耗费额外的内存，加速的UI切换到后台时，产生的额外内存有可能不释放。</li>
<li>当UI中存在过渡绘制时，硬件加速会比较容易发问题。</li>
</ul>
<h4 id="八、卡顿监控方案与实现"><a href="#八、卡顿监控方案与实现" class="headerlink" title="八、卡顿监控方案与实现"></a>八、卡顿监控方案与实现</h4><p>目前比较流行的方案都是利用了Looper中的Printer来实现监控。</p>
<h5 id="8-1-监控原理"><a href="#8-1-监控原理" class="headerlink" title="8.1 监控原理"></a>8.1 监控原理</h5><p>利用主线程的消息队列处理机制，通过自定义Printer，然后在Printer中获取到两次被调用的时间差，这个时间差就是执行时间。如果该时间超过阈值（如1000ms）时，主线程卡顿发生，并抛出各种有用信息，供开发者分析。（此外，也可以在UI线程以外开启一个异步线程，定时向UI线程发送一个任务，并记下发送时间。任务的内容是将执行时间同步到发送线程，如果UI线程被阻塞，那么发送过去的任务不能被准时执行。但此方法会增加系统开销，不可取）</p>
<h5 id="可抓取的信息"><a href="#可抓取的信息" class="headerlink" title="可抓取的信息"></a>可抓取的信息</h5><ul>
<li>基础信息：系统版本、机型、进程名、应用版本号、磁盘空间、UID等。</li>
<li>耗时信息：卡顿开始和结束时间。</li>
<li>CPU信息：CPU的信息、整体CPU使用率和本进程CPU使用率（可粗略判断是当前应用消耗CPU资源太多导致的卡顿，还是其他原因）等。</li>
<li>堆栈信息。</li>
</ul>
<h5 id="注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。"><a href="#注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。" class="headerlink" title="注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。"></a>注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。</h5><h4 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h4><p>至此，这里我们分析一下绘制优化应经历的几个过程：</p>
<ul>
<li>1、发现问题：除使用时感知的卡顿外，还应通过卡段监控工具来发现整体的耗时情况，或打开开发者选项的一些辅助工具来发现问题。</li>
<li>2、分析问题：可以使用Systrace和TraceView来分析耗时，使用Hierarhy Viewer来分析页面层级。</li>
<li>3、寻求原因：深入探索导致问题的根本原因。</li>
<li>4、解决问题。</li>
</ul>
<p>应用之所以会出现卡顿，除了绘制方面的问题，还有一个影响因素就是内存，不合理地使用内存不仅会导致卡顿，还会对耗电和应用的稳定性造成很大影响，下一篇文章，笔者将对Android中的内存优化进行全面的讲解，若读者觉得哪里有写的不好的地方或有误的地方希望多多进行批评指正，愿我们共同进步和成长！</p>
<h5 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h5><hr>
<p>1、Android应用性能优化最佳实践</p>
<p>2、<a href="https://mp.weixin.qq.com/s/QVOYF2nfoWMCbM5YsxQgRQ?" target="_blank" rel="external">必知必会 | Android 性能优化的方面方面都在这儿</a></p>
<h4 id="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><a href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。" class="headerlink" title="很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"></a>很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</h4><h4 id="希望我们能成为朋友，在-Github、掘金上一起分享知识。"><a href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。" class="headerlink" title="希望我们能成为朋友，在 Github、掘金上一起分享知识。"></a>希望我们能成为朋友，在 <a href="https://github.com/JsonChao" target="_blank" rel="external">Github</a>、<a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" rel="external">掘金</a>上一起分享知识。</h4>
      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.png" alt="JsonChao Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/性能优化/" rel="tag"># 性能优化</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/12/Android开发工程师高效成长指南/" rel="next" title="Android开发工程师高效成长指南">
                <i class="fa fa-chevron-left"></i> Android开发工程师高效成长指南
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="JsonChao" />
            
              <p class="site-author-name" itemprop="name">JsonChao</p>
              <p class="site-description motion-element" itemprop="description">Persist + Plan = Growing</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/rss2.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/JsonChao" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-globe"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://mail.google.com/mail/u/0/#inbox" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-globe"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/5a3ba9375188252bca050ade" target="_blank" title="JueJin">
                      
                        <i class="fa fa-fw fa-globe"></i>JueJin</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Manito Link
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://wanandroid.com/" title="WanAndroid" target="_blank">WanAndroid</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://hencoder.com/" title="HenCoder" target="_blank">HenCoder</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.trinea.cn/" title="Trinea" target="_blank">Trinea</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://stormzhang.com/" title="stromzhang" target="_blank">stromzhang</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.hensen.site/" title="Hensen" target="_blank">Hensen</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://liuwangshu.cn/" title="刘望舒" target="_blank">刘望舒</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhuanlan.zhihu.com/baron/" title="张磊" target="_blank">张磊</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://kymjs.com/" title="张涛" target="_blank">张涛</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://blog.piasy.com/" title="Piasy" target="_blank">Piasy</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.lmj.wiki/" title="ANLY" target="_blank">ANLY</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://glanwang.com/" title="Glan" target="_blank">Glan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://huangjunbin.com/" title="黄俊彬" target="_blank">黄俊彬</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://droidyue.com/" title="技术小黑屋" target="_blank">技术小黑屋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://gityuan.com/" title="gityuan" target="_blank">gityuan</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.gcssloop.com/#blog" title="gcsslop" target="_blank">gcsslop</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样-。"><span class="nav-number">1.0.1.</span> <span class="nav-text">成为一名优秀的Android开发，需要一份完备的知识体系，在这里，让我们一起成长为自己所想的那样~。</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#UI"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">UI</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#启动"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">启动</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#跳转"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">跳转</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#响应"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#界面绘制"><span class="nav-number">1.0.1.5.</span> <span class="nav-text">界面绘制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据处理"><span class="nav-number">1.0.1.6.</span> <span class="nav-text">数据处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一、Android系统显示原理"><span class="nav-number">1.1.</span> <span class="nav-text">一、Android系统显示原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1、绘制原理"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1、绘制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、应用层"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">1、应用层</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、系统层"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2、系统层</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-刷新机制"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2 刷新机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要推出Project-Butter？"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">为什么要推出Project Butter？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么要使用双缓冲技术？"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">为什么要使用双缓冲技术？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双缓冲的含义？"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">双缓冲的含义？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Choreographer的作用是什么？"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">Choreographer的作用是什么？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？"><span class="nav-number">1.1.2.5.</span> <span class="nav-text">当第一帧数据没有及时处理时，为什么CPU不能在第二个16ms处即VSync到来就开始工作呢？</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？"><span class="nav-number">1.1.2.6.</span> <span class="nav-text">Google做了这么多的优化，为什么实际开发中应用还存在卡顿现象？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3、卡顿的根本原因"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3、卡顿的根本原因</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、性能分析工具"><span class="nav-number">1.2.</span> <span class="nav-text">二、性能分析工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1、卡顿检测工具Profile-GPU-Rendering"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1、卡顿检测工具Profile GPU Rendering</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1、橙色-Swap-Buffers"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">1、橙色-Swap Buffers</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、红色-Command-Issue"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">2、红色-Command Issue</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、浅蓝-Sync-amp-Upload"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">3、浅蓝-Sync&Upload</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、深蓝-Draw"><span class="nav-number">1.2.1.4.</span> <span class="nav-text">4、深蓝-Draw</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、一级绿-Measure-Layout"><span class="nav-number">1.2.1.5.</span> <span class="nav-text">5、一级绿-Measure/Layout</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6、二级绿-Animation"><span class="nav-number">1.2.1.6.</span> <span class="nav-text">6、二级绿-Animation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7、三级绿-Input-Handling"><span class="nav-number">1.2.1.7.</span> <span class="nav-text">7、三级绿-Input Handling</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#8、四级绿-Misc-Time-Vsync-Delay"><span class="nav-number">1.2.1.8.</span> <span class="nav-text">8、四级绿-Misc Time/Vsync Delay</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2、TraceView"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2、TraceView</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3、Systrace-UI性能分析"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.3、Systrace UI性能分析</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、Systrace使用方法"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">1、Systrace使用方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、分析Systrace报告"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">2、分析Systrace报告</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、布局优化"><span class="nav-number">1.2.3.</span> <span class="nav-text">三、布局优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-1、布局优化方法"><span class="nav-number">1.2.3.1.</span> <span class="nav-text">3.1、布局优化方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、减少层级"><span class="nav-number">1.2.3.2.</span> <span class="nav-text">1、减少层级</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、提供显示速度"><span class="nav-number">1.2.3.3.</span> <span class="nav-text">2、提供显示速度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、布局复用"><span class="nav-number">1.2.3.4.</span> <span class="nav-text">3、布局复用</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、避免过度绘制"><span class="nav-number">1.2.4.</span> <span class="nav-text">四、避免过度绘制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1、过度绘制检测工具"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">4.1、过度绘制检测工具</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2、如何避免过度绘制"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">4.2、如何避免过度绘制</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、布局上的优化"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">1、布局上的优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、自定义View优化"><span class="nav-number">1.2.4.4.</span> <span class="nav-text">2、自定义View优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五、启动优化"><span class="nav-number">1.2.5.</span> <span class="nav-text">五、启动优化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-1、应用启动流程"><span class="nav-number">1.2.5.1.</span> <span class="nav-text">5.1、应用启动流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#冷启动前"><span class="nav-number">1.2.5.2.</span> <span class="nav-text">冷启动前</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#冷启动后"><span class="nav-number">1.2.5.3.</span> <span class="nav-text">冷启动后</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-2、启动耗时监测"><span class="nav-number">1.2.5.4.</span> <span class="nav-text">5.2、启动耗时监测</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、adb-shell-am"><span class="nav-number">1.2.5.5.</span> <span class="nav-text">1、adb shell am</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、代码打点"><span class="nav-number">1.2.5.6.</span> <span class="nav-text">2、代码打点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-3-启动速度分析工具"><span class="nav-number">1.2.5.7.</span> <span class="nav-text">5.3 启动速度分析工具</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、TraceView"><span class="nav-number">1.2.5.8.</span> <span class="nav-text">1、TraceView</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#作用："><span class="nav-number">1.2.5.9.</span> <span class="nav-text">作用：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用："><span class="nav-number">1.2.5.10.</span> <span class="nav-text">使用：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、Systrace-函数插桩"><span class="nav-number">1.2.5.11.</span> <span class="nav-text">2、Systrace+函数插桩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Systrace原理"><span class="nav-number">1.2.5.12.</span> <span class="nav-text">Systrace原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#特性"><span class="nav-number">1.2.5.13.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#使用方式："><span class="nav-number">1.2.5.14.</span> <span class="nav-text">使用方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、命令行"><span class="nav-number">1.2.5.15.</span> <span class="nav-text">1、命令行</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、代码插桩"><span class="nav-number">1.2.5.16.</span> <span class="nav-text">2、代码插桩</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-4、启动优化方案"><span class="nav-number">1.2.5.17.</span> <span class="nav-text">5.4、启动优化方案</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#常见问题"><span class="nav-number">1.2.5.18.</span> <span class="nav-text">常见问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、点击图标很久都不响应"><span class="nav-number">1.2.5.19.</span> <span class="nav-text">1、点击图标很久都不响应</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、首页显示太慢"><span class="nav-number">1.2.5.20.</span> <span class="nav-text">2、首页显示太慢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、首页显示后无法操作"><span class="nav-number">1.2.5.21.</span> <span class="nav-text">3、首页显示后无法操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#优化区域"><span class="nav-number">1.2.5.22.</span> <span class="nav-text">优化区域</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#通常手段"><span class="nav-number">1.2.5.23.</span> <span class="nav-text">通常手段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#具体优化步骤如下所示："><span class="nav-number">1.2.5.24.</span> <span class="nav-text">具体优化步骤如下所示：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、主题切换"><span class="nav-number">1.2.5.25.</span> <span class="nav-text">1、主题切换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、避免过重的App初始化"><span class="nav-number">1.2.5.26.</span> <span class="nav-text">2、避免过重的App初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、Multidex预加载优化"><span class="nav-number">1.2.5.27.</span> <span class="nav-text">3、Multidex预加载优化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）"><span class="nav-number">1.2.5.28.</span> <span class="nav-text">4、闪屏页和主页绘制优化（即布局优化和过渡绘制优化）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5、业务层面优化"><span class="nav-number">1.2.5.29.</span> <span class="nav-text">5、业务层面优化</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#六、合理的刷新机制"><span class="nav-number">1.2.6.</span> <span class="nav-text">六、合理的刷新机制</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#6-1-减少刷新次数"><span class="nav-number">1.2.6.1.</span> <span class="nav-text">6.1 减少刷新次数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-2-避免后台线程的影响"><span class="nav-number">1.2.6.2.</span> <span class="nav-text">6.2 避免后台线程的影响</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-3-缩小刷新区域"><span class="nav-number">1.2.6.3.</span> <span class="nav-text">6.3 缩小刷新区域</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#七、提升动画性能"><span class="nav-number">1.2.7.</span> <span class="nav-text">七、提升动画性能</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-帧动画"><span class="nav-number">1.2.7.1.</span> <span class="nav-text">7.1 帧动画</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-补间动画"><span class="nav-number">1.2.7.2.</span> <span class="nav-text">7.2 补间动画</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-属性动画"><span class="nav-number">1.2.7.3.</span> <span class="nav-text">7.3 属性动画</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-硬件加速"><span class="nav-number">1.2.7.4.</span> <span class="nav-text">7.4 硬件加速</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1、硬件加速原理"><span class="nav-number">1.2.7.5.</span> <span class="nav-text">1、硬件加速原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2、硬件加速控制级别"><span class="nav-number">1.2.7.6.</span> <span class="nav-text">2、硬件加速控制级别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3、在动画上使用硬件加速"><span class="nav-number">1.2.7.7.</span> <span class="nav-text">3、在动画上使用硬件加速</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#设计一个动画的流程如下："><span class="nav-number">1.2.7.8.</span> <span class="nav-text">设计一个动画的流程如下：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#硬件加速需要注意的问题："><span class="nav-number">1.2.7.9.</span> <span class="nav-text">硬件加速需要注意的问题：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#八、卡顿监控方案与实现"><span class="nav-number">1.2.8.</span> <span class="nav-text">八、卡顿监控方案与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#8-1-监控原理"><span class="nav-number">1.2.8.1.</span> <span class="nav-text">8.1 监控原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#可抓取的信息"><span class="nav-number">1.2.8.2.</span> <span class="nav-text">可抓取的信息</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。"><span class="nav-number">1.2.8.3.</span> <span class="nav-text">注意：这里的信息建议抽样上报或者可以先将其保存到本地，在合适的时机以及达到一定的量时，再压缩上报到服务器，供开发者分析。具体监控代码实现可以参考BlockCanary开源项目的代码。</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#九、总结"><span class="nav-number">1.2.9.</span> <span class="nav-text">九、总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#参考链接："><span class="nav-number">1.2.9.1.</span> <span class="nav-text">参考链接：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。"><span class="nav-number">1.2.10.</span> <span class="nav-text">很感谢您阅读这篇文章，希望您能将它分享给您的朋友或技术群，这对我意义重大。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#希望我们能成为朋友，在-Github、掘金上一起分享知识。"><span class="nav-number">1.2.11.</span> <span class="nav-text">希望我们能成为朋友，在 Github、掘金上一起分享知识。</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JsonChao</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>







        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  
    

    
      <!-- UY BEGIN -->
      <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2155025"></script>
      <!-- UY END -->
    
  





  










   
   
     
   
   
  
     
</div>
<!-- City版安装代码已完成 -->
   
 

   
     
   
  
       <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzg1Mi8xMDQwNQ==">
       <script type="text/javascript">
          (function(d, s) {
              var j, e = d.getElementsByTagName(s)[0];
              if (typeof LivereTower === 'function') { return; }
              j = d.createElement(s);
              j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
              j.async = true;
              e.parentNode.insertBefore(j, e);
          })(document, 'script');
       </script>
       <noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
       <!-- UY END -->
   
 
  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("2wtHdVd6zid7kU6YQKIqsHU5-gzGzoHsz", "eLibBRhSAsSoX1JbTMJH6ka3");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
